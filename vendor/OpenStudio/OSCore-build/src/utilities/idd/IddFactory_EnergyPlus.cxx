/**********************************************************************
*  Copyright (c) 2008-2016, Alliance for Sustainable Energy.
*  All rights reserved.
*
*  This library is free software; you can redistribute it and/or
*  modify it under the terms of the GNU Lesser General Public
*  License as published by the Free Software Foundation; either
*  version 2.1 of the License, or (at your option) any later version.
*
*  This library is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*  Lesser General Public License for more details.
*
*  You should have received a copy of the GNU Lesser General Public
*  License along with this library; if not, write to the Free Software
*  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
**********************************************************************/

#include <utilities/idd/IddFactory.hxx>
#include <utilities/idd/IddEnums.hxx>

#include <utilities/core/Assert.hpp>
#include <utilities/core/Compare.hpp>

#include <QMutexLocker>

namespace openstudio {

IddObject createLeadInputIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Lead Input;\n";

    IddObjectType objType(IddObjectType::LeadInput);
    OptionalIddObject oObj = IddObject::load("Lead Input",
                                             "",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::LeadInput);
  return object;
}

IddObject createEndLeadInputIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "End Lead Input;\n";

    IddObjectType objType(IddObjectType::EndLeadInput);
    OptionalIddObject oObj = IddObject::load("End Lead Input",
                                             "",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EndLeadInput);
  return object;
}

IddObject createSimulationDataIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Simulation Data;\n";

    IddObjectType objType(IddObjectType::SimulationData);
    OptionalIddObject oObj = IddObject::load("Simulation Data",
                                             "",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SimulationData);
  return object;
}

IddObject createEndSimulationDataIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "End Simulation Data;\n";

    IddObjectType objType(IddObjectType::EndSimulationData);
    OptionalIddObject oObj = IddObject::load("End Simulation Data",
                                             "",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EndSimulationData);
  return object;
}

IddObject createVersionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Version,\n";
    ss << "\\memo Specifies the EnergyPlus version of the IDF file.\n";
    ss << "\\unique-object\n";
    ss << "\\format singleLine\n";
    ss << "\\min-fields 1\n";
    ss << "A1 ; \\field Version Identifier\n";
    ss << "\\default 8.4\n";

    IddObjectType objType(IddObjectType::Version);
    OptionalIddObject oObj = IddObject::load("Version",
                                             "Simulation Parameters",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Version);
  return object;
}

IddObject createSimulationControlIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SimulationControl,\n";
    ss << "\\unique-object\n";
    ss << "\\memo Note that the following 3 fields are related to the Sizing:Zone, Sizing:System,\n";
    ss << "\\memo and Sizing:Plant objects.  Having these fields set to Yes but no corresponding\n";
    ss << "\\memo Sizing object will not cause the sizing to be done. However, having any of these\n";
    ss << "\\memo fields set to No, the corresponding Sizing object is ignored.\n";
    ss << "\\memo Note also, if you want to do system sizing, you must also do zone sizing in the same\n";
    ss << "\\memo run or an error will result.\n";
    ss << "\\min-fields 5\n";
    ss << "A1, \\field Do Zone Sizing Calculation\n";
    ss << "\\note If Yes, Zone sizing is accomplished from corresponding Sizing:Zone objects\n";
    ss << "\\note and autosize fields.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A2, \\field Do System Sizing Calculation\n";
    ss << "\\note If Yes, System sizing is accomplished from corresponding Sizing:System objects\n";
    ss << "\\note and autosize fields.\n";
    ss << "\\note If Yes, Zone sizing (previous field) must also be Yes.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A3, \\field Do Plant Sizing Calculation\n";
    ss << "\\note If Yes, Plant sizing is accomplished from corresponding Sizing:Plant objects\n";
    ss << "\\note and autosize fields.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A4, \\field Run Simulation for Sizing Periods\n";
    ss << "\\note If Yes, SizingPeriod:* objects are executed and results from those may be displayed..\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "A5, \\field Run Simulation for Weather File Run Periods\n";
    ss << "\\note If Yes, RunPeriod:* objects are executed and results from those may be displayed..\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "A6, \\field Do HVAC Sizing Simulation for Sizing Periods\n";
    ss << "\\note If Yes, SizingPeriod:* objects are exectuted additional times for advanced sizing.\n";
    ss << "\\note Currently limited to use with coincident plant sizing, see Sizing:Plant object\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N1; \\field Maximum Number of HVAC Sizing Simulation Passes\n";
    ss << "\\note the entire set of SizingPeriod:* objects may be repeated to fine tune size results\n";
    ss << "\\note this input sets a limit on the number of passes that the sizing algorithms can repeate the set\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";

    IddObjectType objType(IddObjectType::SimulationControl);
    OptionalIddObject oObj = IddObject::load("SimulationControl",
                                             "Simulation Parameters",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SimulationControl);
  return object;
}

IddObject createBuildingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Building,\n";
    ss << "\\memo Describes parameters that are used during the simulation\n";
    ss << "\\memo of the building. There are necessary correlations between the entries for\n";
    ss << "\\memo this object and some entries in the Site:WeatherStation and\n";
    ss << "\\memo Site:HeightVariation objects, specifically the Terrain field.\n";
    ss << "\\unique-object\n";
    ss << "\\required-object\n";
    ss << "\\min-fields 8\n";
    ss << "A1 , \\field Name\n";
    ss << "\\retaincase\n";
    ss << "\\default NONE\n";
    ss << "N1 , \\field North Axis\n";
    ss << "\\note degrees from true North\n";
    ss << "\\units deg\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "A2 , \\field Terrain\n";
    ss << "\\note  Country=FlatOpenCountry | Suburbs=CountryTownsSuburbs | City=CityCenter | Ocean=body of water (5km) | Urban=Urban-Industrial-Forest\n";
    ss << "\\type choice\n";
    ss << "\\key Country\n";
    ss << "\\key Suburbs\n";
    ss << "\\key City\n";
    ss << "\\key Ocean\n";
    ss << "\\key Urban\n";
    ss << "\\default Suburbs\n";
    ss << "N2 , \\field Loads Convergence Tolerance Value\n";
    ss << "\\note Loads Convergence Tolerance Value is a fraction of load\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum .5\n";
    ss << "\\default .04\n";
    ss << "N3 , \\field Temperature Convergence Tolerance Value\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum .5\n";
    ss << "\\default .4\n";
    ss << "A3 , \\field Solar Distribution\n";
    ss << "\\note  MinimalShadowing | FullExterior | FullInteriorAndExterior | FullExteriorWithReflections | FullInteriorAndExteriorWithReflections\n";
    ss << "\\type choice\n";
    ss << "\\key MinimalShadowing\n";
    ss << "\\key FullExterior\n";
    ss << "\\key FullInteriorAndExterior\n";
    ss << "\\key FullExteriorWithReflections\n";
    ss << "\\key FullInteriorAndExteriorWithReflections\n";
    ss << "\\default FullExterior\n";
    ss << "N4 , \\field Maximum Number of Warmup Days\n";
    ss << "\\note EnergyPlus will only use as many warmup days as needed to reach convergence tolerance.\n";
    ss << "\\note This field's value should NOT be set less than 25.\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 25\n";
    ss << "N5 ; \\field Minimum Number of Warmup Days\n";
    ss << "\\note The minimum number of warmup days that produce enough temperature and flux history\n";
    ss << "\\note to start EnergyPlus simulation for all reference buildings was suggested to be 6.\n";
    ss << "\\note When this field is greater than the maximum warmup days defined previous field\n";
    ss << "\\note the maximum number of warmup days will be reset to the minimum value entered here.\n";
    ss << "\\note Warmup days will be set to be the value you entered when it is less than the default 6.\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 6\n";

    IddObjectType objType(IddObjectType::Building);
    OptionalIddObject oObj = IddObject::load("Building",
                                             "Simulation Parameters",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Building);
  return object;
}

IddObject createShadowCalculationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ShadowCalculation,\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 2\n";
    ss << "\\memo This object is used to control details of the solar, shading, and daylighting models\n";
    ss << "A1 , \\field Calculation Method\n";
    ss << "\\note choose calculation method. note that TimestepFrequency is only needed for certain cases\n";
    ss << "\\note and can increase execution time significantly.\n";
    ss << "\\type choice\n";
    ss << "\\key AverageOverDaysInFrequency\n";
    ss << "\\key TimestepFrequency\n";
    ss << "\\default AverageOverDaysInFrequency\n";
    ss << "N1 , \\field Calculation Frequency\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 20\n";
    ss << "\\note enter number of days\n";
    ss << "\\note this field is only used if the previous field is set to AverageOverDaysInFrequency\n";
    ss << "\\note 0=Use Default Periodic Calculation|<else> calculate every <value> day\n";
    ss << "\\note only really applicable to RunPeriods\n";
    ss << "\\note warning issued if >31\n";
    ss << "N2 , \\field Maximum Figures in Shadow Overlap Calculations\n";
    ss << "\\note Number of allowable figures in shadow overlap calculations\n";
    ss << "\\type integer\n";
    ss << "\\minimum 200\n";
    ss << "\\default 15000\n";
    ss << "A2 , \\field Polygon Clipping Algorithm\n";
    ss << "\\note Advanced Feature.  Internal default is SutherlandHodgman\n";
    ss << "\\note Refer to InputOutput Reference and Engineering Reference for more information\n";
    ss << "\\type choice\n";
    ss << "\\key ConvexWeilerAtherton\n";
    ss << "\\key SutherlandHodgman\n";
    ss << "A3 ; \\field Sky Diffuse Modeling Algorithm\n";
    ss << "\\note Advanced Feature.  Internal default is SimpleSkyDiffuseModeling\n";
    ss << "\\note If you have shading elements that change transmittance over the\n";
    ss << "\\note year, you may wish to choose the detailed method.\n";
    ss << "\\note Refer to InputOutput Reference and Engineering Reference for more information\n";
    ss << "\\type choice\n";
    ss << "\\key SimpleSkyDiffuseModeling\n";
    ss << "\\key DetailedSkyDiffuseModeling\n";

    IddObjectType objType(IddObjectType::ShadowCalculation);
    OptionalIddObject oObj = IddObject::load("ShadowCalculation",
                                             "Simulation Parameters",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ShadowCalculation);
  return object;
}

IddObject createSurfaceConvectionAlgorithm_InsideIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceConvectionAlgorithm:Inside,\n";
    ss << "\\memo Default indoor surface heat transfer convection algorithm to be used for all zones\n";
    ss << "\\unique-object\n";
    ss << "\\format singleLine\n";
    ss << "\\min-fields 1\n";
    ss << "A1 ; \\field Algorithm\n";
    ss << "\\type choice\n";
    ss << "\\key Simple\n";
    ss << "\\key TARP\n";
    ss << "\\key CeilingDiffuser\n";
    ss << "\\key AdaptiveConvectionAlgorithm\n";
    ss << "\\default TARP\n";
    ss << "\\note Simple = constant value natural convection (ASHRAE)\n";
    ss << "\\note TARP = variable natural convection based on temperature difference (ASHRAE, Walton)\n";
    ss << "\\note CeilingDiffuser = ACH-based forced and mixed convection correlations\n";
    ss << "\\note  for ceiling diffuser configuration with simple natural convection limit\n";
    ss << "\\note AdaptiveConvectionAlgorithm = dynamic selection of convection models based on conditions\n";

    IddObjectType objType(IddObjectType::SurfaceConvectionAlgorithm_Inside);
    OptionalIddObject oObj = IddObject::load("SurfaceConvectionAlgorithm:Inside",
                                             "Simulation Parameters",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceConvectionAlgorithm_Inside);
  return object;
}

IddObject createSurfaceConvectionAlgorithm_OutsideIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceConvectionAlgorithm:Outside,\n";
    ss << "\\memo Default outside surface heat transfer convection algorithm to be used for all zones\n";
    ss << "\\unique-object\n";
    ss << "\\format singleLine\n";
    ss << "\\min-fields 1\n";
    ss << "A1 ; \\field Algorithm\n";
    ss << "\\type choice\n";
    ss << "\\key SimpleCombined\n";
    ss << "\\key TARP\n";
    ss << "\\key MoWiTT\n";
    ss << "\\key DOE-2\n";
    ss << "\\key AdaptiveConvectionAlgorithm\n";
    ss << "\\default DOE-2\n";
    ss << "\\note SimpleCombined = Combined radiation and convection coefficient using simple ASHRAE model\n";
    ss << "\\note TARP = correlation from models developed by ASHRAE, Walton, and Sparrow et. al.\n";
    ss << "\\note MoWiTT = correlation from measurements by Klems and Yazdanian for smooth surfaces\n";
    ss << "\\note DOE-2 = correlation from measurements by Klems and Yazdanian for rough surfaces\n";
    ss << "\\note AdaptiveConvectionAlgorithm = dynamic selection of correlations based on conditions\n";

    IddObjectType objType(IddObjectType::SurfaceConvectionAlgorithm_Outside);
    OptionalIddObject oObj = IddObject::load("SurfaceConvectionAlgorithm:Outside",
                                             "Simulation Parameters",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceConvectionAlgorithm_Outside);
  return object;
}

IddObject createHeatBalanceAlgorithmIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HeatBalanceAlgorithm,\n";
    ss << "\\memo Determines which Heat Balance Algorithm will be used ie.\n";
    ss << "\\memo CTF (Conduction Transfer Functions),\n";
    ss << "\\memo EMPD (Effective Moisture Penetration Depth with Conduction Transfer Functions).\n";
    ss << "\\memo Advanced/Research Usage: CondFD (Conduction Finite Difference)\n";
    ss << "\\memo Advanced/Research Usage: ConductionFiniteDifferenceSimplified\n";
    ss << "\\memo Advanced/Research Usage: HAMT (Combined Heat And Moisture Finite Element)\n";
    ss << "\\unique-object\n";
    ss << "\\format singleLine\n";
    ss << "A1 , \\field Algorithm\n";
    ss << "\\type choice\n";
    ss << "\\key ConductionTransferFunction\n";
    ss << "\\key MoisturePenetrationDepthConductionTransferFunction\n";
    ss << "\\key ConductionFiniteDifference\n";
    ss << "\\key CombinedHeatAndMoistureFiniteElement\n";
    ss << "\\default ConductionTransferFunction\n";
    ss << "N1 , \\field Surface Temperature Upper Limit\n";
    ss << "\\type real\n";
    ss << "\\minimum 200\n";
    ss << "\\default 200\n";
    ss << "\\units C\n";
    ss << "N2 , \\field Minimum Surface Convection Heat Transfer Coefficient Value\n";
    ss << "\\units W/m2-K\n";
    ss << "\\default 0.1\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3 ; \\field Maximum Surface Convection Heat Transfer Coefficient Value\n";
    ss << "\\units W/m2-K\n";
    ss << "\\default 1000\n";
    ss << "\\minimum 1.0\n";

    IddObjectType objType(IddObjectType::HeatBalanceAlgorithm);
    OptionalIddObject oObj = IddObject::load("HeatBalanceAlgorithm",
                                             "Simulation Parameters",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HeatBalanceAlgorithm);
  return object;
}

IddObject createHeatBalanceSettings_ConductionFiniteDifferenceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HeatBalanceSettings:ConductionFiniteDifference,\n";
    ss << "\\memo Determines settings for the Conduction Finite Difference\n";
    ss << "\\memo algorithm for surface heat transfer modeling.\n";
    ss << "\\unique-object\n";
    ss << "A1 , \\field Difference Scheme\n";
    ss << "\\type choice\n";
    ss << "\\key CrankNicholsonSecondOrder\n";
    ss << "\\key FullyImplicitFirstOrder\n";
    ss << "\\default FullyImplicitFirstOrder\n";
    ss << "N1 , \\field Space Discretization Constant\n";
    ss << "\\note increase or decrease number of nodes\n";
    ss << "\\type real\n";
    ss << "\\default 3\n";
    ss << "N2 , \\field Relaxation Factor\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum 0.01\n";
    ss << "\\maximum 1.0\n";
    ss << "N3 ; \\field Inside Face Surface Temperature Convergence Criteria\n";
    ss << "\\type real\n";
    ss << "\\default 0.002\n";
    ss << "\\minimum 1.0E-7\n";
    ss << "\\maximum 0.01\n";

    IddObjectType objType(IddObjectType::HeatBalanceSettings_ConductionFiniteDifference);
    OptionalIddObject oObj = IddObject::load("HeatBalanceSettings:ConductionFiniteDifference",
                                             "Simulation Parameters",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HeatBalanceSettings_ConductionFiniteDifference);
  return object;
}

IddObject createZoneAirHeatBalanceAlgorithmIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneAirHeatBalanceAlgorithm,\n";
    ss << "\\memo Determines which algorithm will be used to solve the zone air heat balance.\n";
    ss << "\\unique-object\n";
    ss << "\\format singleLine\n";
    ss << "A1 ; \\field Algorithm\n";
    ss << "\\type choice\n";
    ss << "\\key ThirdOrderBackwardDifference\n";
    ss << "\\key AnalyticalSolution\n";
    ss << "\\key EulerMethod\n";
    ss << "\\default ThirdOrderBackwardDifference\n";

    IddObjectType objType(IddObjectType::ZoneAirHeatBalanceAlgorithm);
    OptionalIddObject oObj = IddObject::load("ZoneAirHeatBalanceAlgorithm",
                                             "Simulation Parameters",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneAirHeatBalanceAlgorithm);
  return object;
}

IddObject createZoneAirContaminantBalanceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneAirContaminantBalance,\n";
    ss << "\\memo Determines which contaminant concentration will be simulates.\n";
    ss << "\\unique-object\n";
    ss << "\\format singleLine\n";
    ss << "A1 , \\field Carbon Dioxide Concentration\n";
    ss << "\\note If Yes, CO2 simulation will be performed.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A2 , \\field Outdoor Carbon Dioxide Schedule Name\n";
    ss << "\\note Schedule values should be in parts per million (ppm)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Generic Contaminant Concentration\n";
    ss << "\\note If Yes, generic contaminant simulation will be performed.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A4 ; \\field Outdoor Generic Contaminant Schedule Name\n";
    ss << "\\note Schedule values should be generic contaminant concentration in parts per\n";
    ss << "\\note million (ppm)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::ZoneAirContaminantBalance);
    OptionalIddObject oObj = IddObject::load("ZoneAirContaminantBalance",
                                             "Simulation Parameters",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneAirContaminantBalance);
  return object;
}

IddObject createZoneAirMassFlowConservationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneAirMassFlowConservation,\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 3\n";
    ss << "A1,  \\field Adjust Zone Mixing For Zone Air Mass Flow Balance\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A2,  \\field Infiltration Balancing Method\n";
    ss << "\\type choice\n";
    ss << "\\key AddInfiltrationFlow\n";
    ss << "\\key AdjustInfiltrationFlow\n";
    ss << "\\key None\n";
    ss << "\\default AddInfiltrationFlow\n";
    ss << "A3;  \\field Infiltration Balancing Zones\n";
    ss << "\\type choice\n";
    ss << "\\key MixingSourceZonesOnly\n";
    ss << "\\key AllZones\n";
    ss << "\\default MixingSourceZonesOnly\n";

    IddObjectType objType(IddObjectType::ZoneAirMassFlowConservation);
    OptionalIddObject oObj = IddObject::load("ZoneAirMassFlowConservation",
                                             "Simulation Parameters",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneAirMassFlowConservation);
  return object;
}

IddObject createZoneCapacitanceMultiplier_ResearchSpecialIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneCapacitanceMultiplier:ResearchSpecial,\n";
    ss << "\\unique-object\n";
    ss << "\\format singleLine\n";
    ss << "\\memo Multiplier altering the relative capacitance of the air compared to an empty zone\n";
    ss << "\\min-fields 4\n";
    ss << "N1 , \\field Temperature Capacity Multiplier\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Used to alter the capacitance of zone air with respect to heat or temperature\n";
    ss << "N2 , \\field Humidity Capacity Multiplier\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Used to alter the capacitance of zone air with respect to moisture or humidity ratio\n";
    ss << "N3 , \\field Carbon Dioxide Capacity Multiplier\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Used to alter the capacitance of zone air with respect to zone air carbon dioxide concentration\n";
    ss << "N4 ; \\field Generic Contaminant Capacity Multiplier\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Used to alter the capacitance of zone air with respect to zone air generic contaminant concentration\n";

    IddObjectType objType(IddObjectType::ZoneCapacitanceMultiplier_ResearchSpecial);
    OptionalIddObject oObj = IddObject::load("ZoneCapacitanceMultiplier:ResearchSpecial",
                                             "Simulation Parameters",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneCapacitanceMultiplier_ResearchSpecial);
  return object;
}

IddObject createTimestepIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Timestep,\n";
    ss << "\\memo Specifies the \"basic\" timestep for the simulation. The\n";
    ss << "\\memo value entered here is also known as the Zone Timestep.  This is used in\n";
    ss << "\\memo the Zone Heat Balance Model calculation as the driving timestep for heat\n";
    ss << "\\memo transfer and load calculations.\n";
    ss << "\\unique-object\n";
    ss << "\\format singleLine\n";
    ss << "\\min-fields 1\n";
    ss << "N1 ; \\field Number of Timesteps per Hour\n";
    ss << "\\note Number in hour: normal validity 4 to 60: 6 suggested\n";
    ss << "\\note Must be evenly divisible into 60\n";
    ss << "\\note Allowable values include 1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, and 60\n";
    ss << "\\note Normal 6 is minimum as lower values may cause inaccuracies\n";
    ss << "\\note A minimum value of 20 is suggested for both ConductionFiniteDifference\n";
    ss << "\\note and CombinedHeatAndMoistureFiniteElement surface heat balance algorithms\n";
    ss << "\\note A minimum of 12 is suggested for simulations involving a Vegetated Roof (Material:RoofVegetation).\n";
    ss << "\\default 6\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 60\n";

    IddObjectType objType(IddObjectType::Timestep);
    OptionalIddObject oObj = IddObject::load("Timestep",
                                             "Simulation Parameters",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Timestep);
  return object;
}

IddObject createConvergenceLimitsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ConvergenceLimits,\n";
    ss << "\\memo Specifies limits on HVAC system simulation timesteps and iterations.\n";
    ss << "\\memo This item is an advanced feature that should be used only with caution.\n";
    ss << "\\unique-object\n";
    ss << "N1 , \\field Minimum System Timestep\n";
    ss << "\\units minutes\n";
    ss << "\\type integer\n";
    ss << "\\note 0 sets the minimum to the zone timestep (ref: Timestep)\n";
    ss << "\\note 1 is normal (ratchet down to 1 minute)\n";
    ss << "\\note setting greater than zone timestep (in minutes) will effectively set to zone timestep\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 60\n";
    ss << "N2 , \\field Maximum HVAC Iterations\n";
    ss << "\\type integer\n";
    ss << "\\default 20\n";
    ss << "\\minimum 1\n";
    ss << "N3 , \\field Minimum Plant Iterations\n";
    ss << "\\note Controls the minimum number of plant system solver iterations within a single HVAC iteration\n";
    ss << "\\note Larger values will increase runtime but might improve solution accuracy for complicated plant systems\n";
    ss << "\\note Complex plants include: several interconnected loops, heat recovery, thermal load following generators, etc.\n";
    ss << "\\type integer\n";
    ss << "\\default 2\n";
    ss << "\\minimum 1\n";
    ss << "N4 ; \\field Maximum Plant Iterations\n";
    ss << "\\note Controls the maximum number of plant system solver iterations within a single HVAC iteration\n";
    ss << "\\note Smaller values might decrease runtime but could decrease solution accuracy for complicated plant systems\n";
    ss << "\\type integer\n";
    ss << "\\default 8\n";
    ss << "\\minimum 2\n";

    IddObjectType objType(IddObjectType::ConvergenceLimits);
    OptionalIddObject oObj = IddObject::load("ConvergenceLimits",
                                             "Simulation Parameters",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ConvergenceLimits);
  return object;
}

IddObject createProgramControlIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ProgramControl,\n";
    ss << "\\memo used to support various efforts in time reduction for simulation including threading\n";
    ss << "\\memo This object is currently disabled\n";
    ss << "N1 ; \\field Number of Threads Allowed\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\note This is currently used only in the Interior Radiant Exchange module -- view factors on # surfaces\n";
    ss << "\\note if value is 0, then maximum number allowed will be used.\n";

    IddObjectType objType(IddObjectType::ProgramControl);
    OptionalIddObject oObj = IddObject::load("ProgramControl",
                                             "Simulation Parameters",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ProgramControl);
  return object;
}

IddObject createCompliance_BuildingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Compliance:Building,\n";
    ss << "\\memo Building level inputs related to compliance to building standards, building codes, and beyond energy code programs.\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 1\n";
    ss << "N1;  \\field Building Rotation for Appendix G\n";
    ss << "\\note Additional degrees of rotation to be used with the requirement in ASHRAE Standard 90.1 Appendix G\n";
    ss << "\\note that states that the baseline building should be rotated in four directions.\n";
    ss << "\\units deg\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::Compliance_Building);
    OptionalIddObject oObj = IddObject::load("Compliance:Building",
                                             "Compliance Objects",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Compliance_Building);
  return object;
}

IddObject createSite_LocationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Site:Location,\n";
    ss << "\\memo Specifies the building's location. Only one location is allowed.\n";
    ss << "\\memo Weather data file location, if it exists, will override this object.\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 5\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type  alpha\n";
    ss << "N1 , \\field Latitude\n";
    ss << "\\units deg\n";
    ss << "\\minimum -90.0\n";
    ss << "\\maximum +90.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note + is North, - is South, degree minutes represented in decimal (i.e. 30 minutes is .5)\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Longitude\n";
    ss << "\\units deg\n";
    ss << "\\minimum -180.0\n";
    ss << "\\maximum +180.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note - is West, + is East, degree minutes represented in decimal (i.e. 30 minutes is .5)\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Time Zone\n";
    ss << "\\note basic these limits on the WorldTimeZone Map (2003)\n";
    ss << "\\units hr\n";
    ss << "\\minimum -12.0\n";
    ss << "\\maximum +14.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note  Time relative to GMT. Decimal hours.\n";
    ss << "\\type real\n";
    ss << "N4 ; \\field Elevation\n";
    ss << "\\units m\n";
    ss << "\\minimum -300.0\n";
    ss << "\\maximum< 8900.0\n";
    ss << "\\default 0.0\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::Site_Location);
    OptionalIddObject oObj = IddObject::load("Site:Location",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Site_Location);
  return object;
}

IddObject createSizingPeriod_DesignDayIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SizingPeriod:DesignDay,\n";
    ss << "\\memo The design day object creates the parameters for the program to create\n";
    ss << "\\memo the 24 hour weather profile that can be used for sizing as well as\n";
    ss << "\\memo running to test the other simulation parameters. Parameters in this\n";
    ss << "\\memo include a date (month and day), a day type (which uses the appropriate\n";
    ss << "\\memo schedules for either sizing or simple tests), min/max temperatures,\n";
    ss << "\\memo wind speeds, and solar radiation values.\n";
    ss << "A1, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference RunPeriodsAndDesignDays\n";
    ss << "N1,  \\field Month\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "\\type integer\n";
    ss << "N2,  \\field Day of Month\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "\\type integer\n";
    ss << "\\note must be valid for Month field\n";
    ss << "A2,  \\field Day Type\n";
    ss << "\\required-field\n";
    ss << "\\note Day Type selects the schedules appropriate for this design day\n";
    ss << "\\type choice\n";
    ss << "\\key Sunday\n";
    ss << "\\key Monday\n";
    ss << "\\key Tuesday\n";
    ss << "\\key Wednesday\n";
    ss << "\\key Thursday\n";
    ss << "\\key Friday\n";
    ss << "\\key Saturday\n";
    ss << "\\key Holiday\n";
    ss << "\\key SummerDesignDay\n";
    ss << "\\key WinterDesignDay\n";
    ss << "\\key CustomDay1\n";
    ss << "\\key CustomDay2\n";
    ss << "N3,  \\field Maximum Dry-Bulb Temperature\n";
    ss << "\\note This field is required when field \"Dry-Bulb Temperature Range Modifier Type\"\n";
    ss << "\\note is not \"TemperatureProfileSchedule\".\n";
    ss << "\\units C\n";
    ss << "\\minimum -90\n";
    ss << "\\maximum 70\n";
    ss << "\\type real\n";
    ss << "N4,  \\field Daily Dry-Bulb Temperature Range\n";
    ss << "\\note Must still produce appropriate maximum dry-bulb (within range)\n";
    ss << "\\note This field is not needed if Dry-Bulb Temperature Range Modifier Type\n";
    ss << "\\note is \"delta\".\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\type real\n";
    ss << "A3,  \\field Dry-Bulb Temperature Range Modifier Type\n";
    ss << "\\note Type of modifier to the dry-bulb temperature calculated for the timestep\n";
    ss << "\\type choice\n";
    ss << "\\key MultiplierSchedule\n";
    ss << "\\key DifferenceSchedule\n";
    ss << "\\key TemperatureProfileSchedule\n";
    ss << "\\key DefaultMultipliers\n";
    ss << "\\default DefaultMultipliers\n";
    ss << "A4,  \\field Dry-Bulb Temperature Range Modifier Day Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "\\note Only used when previous field is \"MultiplierSchedule\", \"DifferenceSchedule\" or\n";
    ss << "\\note   \"TemperatureProfileSchedule\".\n";
    ss << "\\note For type \"MultiplierSchedule\"  the hour/time interval values should specify\n";
    ss << "\\note   the fraction (0-1) of the dry-bulb temperature range to be subtracted\n";
    ss << "\\note   from the maximum dry-bulb temperature for each timestep in the day\n";
    ss << "\\note For type \"DifferenceSchedule\" the values should specify a number to be subtracted\n";
    ss << "\\note   from the maximum dry-bulb temperature for each timestep in the day.\n";
    ss << "\\note Note that numbers in the difference schedule cannot be negative as that\n";
    ss << "\\note   would result in a higher maximum than the maximum previously specified.\n";
    ss << "\\note For type \"TemperatureProfileSchedule\" the values should specify the actual dry-bulb\n";
    ss << "\\note   temperature for each timestep in the day.\n";
    ss << "A5,  \\field Humidity Condition Type\n";
    ss << "\\note values/schedules indicated here and in subsequent fields create the humidity\n";
    ss << "\\note values in the 24 hour design day conditions profile.\n";
    ss << "\\type choice\n";
    ss << "\\key WetBulb\n";
    ss << "\\key DewPoint\n";
    ss << "\\key HumidityRatio\n";
    ss << "\\key Enthalpy\n";
    ss << "\\key RelativeHumiditySchedule\n";
    ss << "\\key WetBulbProfileMultiplierSchedule\n";
    ss << "\\key WetBulbProfileDifferenceSchedule\n";
    ss << "\\key WetBulbProfileDefaultMultipliers\n";
    ss << "\\default WetBulb\n";
    ss << "N5,  \\field Wetbulb or DewPoint at Maximum Dry-Bulb\n";
    ss << "\\note Wetbulb or dewpoint temperature coincident with the maximum temperature.\n";
    ss << "\\note Required only if field Humidity Condition Type is \"Wetbulb\", \"Dewpoint\",\n";
    ss << "\\note \"WetBulbProfileMultiplierSchedule\", \"WetBulbProfileDifferenceSchedule\",\n";
    ss << "\\note or \"WetBulbProfileDefaultMultipliers\"\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "A6,  \\field Humidity Condition Day Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "\\note Only used when Humidity Condition Type is \"RelativeHumiditySchedule\",\n";
    ss << "\\note  \"WetBulbProfileMultiplierSchedule\", or \"WetBulbProfileDifferenceSchedule\"\n";
    ss << "\\note For type \"RelativeHumiditySchedule\", the hour/time interval values should specify\n";
    ss << "\\note   relative humidity (percent) from 0.0 to 100.0.\n";
    ss << "\\note For type \"WetBulbProfileMultiplierSchedule\" the hour/time interval values should specify\n";
    ss << "\\note   the fraction (0-1) of the wet-bulb temperature range to be subtracted from the\n";
    ss << "\\note   maximum wet-bulb temperature for each timestep in the day (units = Fraction)\n";
    ss << "\\note For type \"WetBulbProfileDifferenceSchedule\" the values should specify a number to be subtracted\n";
    ss << "\\note   from the maximum wet-bulb temperature for each timestep in the day. (units = deltaC)\n";
    ss << "N6,  \\field Humidity Ratio at Maximum Dry-Bulb\n";
    ss << "\\note Humidity ratio coincident with the maximum temperature (constant humidity ratio throughout day).\n";
    ss << "\\note Required only if field Humidity Condition Type is \"HumidityRatio\".\n";
    ss << "\\type real\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "N7,  \\field Enthalpy at Maximum Dry-Bulb  !will require units transition.\n";
    ss << "\\note Enthalpy coincident with the maximum temperature.\n";
    ss << "\\note Required only if field Humidity Condition Type is \"Enthalpy\".\n";
    ss << "\\type real\n";
    ss << "\\units J/kg\n";
    ss << "N8,  \\field Daily Wet-Bulb Temperature Range\n";
    ss << "\\units deltaC\n";
    ss << "\\note Required only if Humidity Condition Type = \"WetbulbProfileMultiplierSchedule\" or\n";
    ss << "\\note \"WetBulbProfileDefaultMultipliers\"\n";
    ss << "N9,  \\field Barometric Pressure\n";
    ss << "\\note This field's value is also checked against the calculated \"standard barometric pressure\"\n";
    ss << "\\note for the location.  If out of range (>10%) or blank, then is replaced by standard value.\n";
    ss << "\\units Pa\n";
    ss << "\\minimum 31000\n";
    ss << "\\maximum 120000\n";
    ss << "\\type real\n";
    ss << "\\ip-units inHg\n";
    ss << "N10, \\field Wind Speed\n";
    ss << "\\required-field\n";
    ss << "\\units m/s\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 40\n";
    ss << "\\ip-units miles/hr\n";
    ss << "\\type real\n";
    ss << "N11, \\field Wind Direction\n";
    ss << "\\required-field\n";
    ss << "\\units deg\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 360\n";
    ss << "\\note North=0.0 East=90.0\n";
    ss << "\\note 0 and 360 are the same direction.\n";
    ss << "\\type real\n";
    ss << "A7,  \\field Rain Indicator\n";
    ss << "\\note Yes is raining (all day), No is not raining\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A8,  \\field Snow Indicator\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note Yes is Snow on Ground, No is no Snow on Ground\n";
    ss << "A9,  \\field Daylight Saving Time Indicator\n";
    ss << "\\note Yes -- use schedules modified for Daylight Saving Time Schedules.\n";
    ss << "\\note No - do not use schedules modified for Daylight Saving Time Schedules\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A10, \\field Solar Model Indicator\n";
    ss << "\\type choice\n";
    ss << "\\key ASHRAEClearSky\n";
    ss << "\\key ZhangHuang\n";
    ss << "\\key Schedule\n";
    ss << "\\key ASHRAETau\n";
    ss << "\\default ASHRAEClearSky\n";
    ss << "A11, \\field Beam Solar Day Schedule Name\n";
    ss << "\\note if Solar Model Indicator = Schedule, then beam schedule name (for day)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A12, \\field Diffuse Solar Day Schedule Name\n";
    ss << "\\note if Solar Model Indicator = Schedule, then diffuse schedule name (for day)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "N12, \\field ASHRAE Clear Sky Optical Depth for Beam Irradiance (taub)\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Required if Solar Model Indicator = ASHRAETau\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.2\n";
    ss << "\\default 0\n";
    ss << "N13, \\field ASHRAE Clear Sky Optical Depth for Diffuse Irradiance (taud)\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Required if Solar Model Indicator = ASHRAETau\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 3\n";
    ss << "\\default 0\n";
    ss << "N14; \\field Sky Clearness\n";
    ss << "\\note Used if Sky Model Indicator = ASHRAEClearSky or ZhangHuang\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.2\n";
    ss << "\\default 0.0\n";
    ss << "\\note 0.0 is totally unclear, 1.0 is totally clear\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::SizingPeriod_DesignDay);
    OptionalIddObject oObj = IddObject::load("SizingPeriod:DesignDay",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SizingPeriod_DesignDay);
  return object;
}

IddObject createSizingPeriod_WeatherFileDaysIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SizingPeriod:WeatherFileDays,\n";
    ss << "\\memo Use a weather file period for design sizing calculations.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\reference RunPeriodsAndDesignDays\n";
    ss << "\\required-field\n";
    ss << "\\note user supplied name for reporting\n";
    ss << "N1 , \\field Begin Month\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "\\type integer\n";
    ss << "N2 , \\field Begin Day of Month\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "\\type integer\n";
    ss << "N3 , \\field End Month\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "\\type integer\n";
    ss << "N4 , \\field End Day of Month\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "\\type integer\n";
    ss << "A2 , \\field Day of Week for Start Day\n";
    ss << "\\note  =[|Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|SummerDesignDay|WinterDesignDay|\n";
    ss << "\\note    |CustomDay1|CustomDay2];\n";
    ss << "\\note if you use SummerDesignDay or WinterDesignDay or the CustomDays then this will apply\n";
    ss << "\\note to the whole period; other days (i.e., Monday) will signify a start day and\n";
    ss << "\\note normal sequence of subsequent days\n";
    ss << "\\default Monday\n";
    ss << "\\type choice\n";
    ss << "\\key Sunday\n";
    ss << "\\key Monday\n";
    ss << "\\key Tuesday\n";
    ss << "\\key Wednesday\n";
    ss << "\\key Thursday\n";
    ss << "\\key Friday\n";
    ss << "\\key Saturday\n";
    ss << "\\key SummerDesignDay\n";
    ss << "\\key WinterDesignDay\n";
    ss << "\\key CustomDay1\n";
    ss << "\\key CustomDay2\n";
    ss << "A3,  \\field Use Weather File Daylight Saving Period\n";
    ss << "\\note If yes or blank, use daylight saving period as specified on Weatherfile.\n";
    ss << "\\note If no, do not use the daylight saving period as specified on the Weatherfile.\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A4;  \\field Use Weather File Rain and Snow Indicators\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";

    IddObjectType objType(IddObjectType::SizingPeriod_WeatherFileDays);
    OptionalIddObject oObj = IddObject::load("SizingPeriod:WeatherFileDays",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SizingPeriod_WeatherFileDays);
  return object;
}

IddObject createSizingPeriod_WeatherFileConditionTypeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SizingPeriod:WeatherFileConditionType,\n";
    ss << "\\memo Use a weather file period for design sizing calculations.\n";
    ss << "\\memo EPW weather files are created with typical and extreme periods\n";
    ss << "\\memo created heuristically from the weather file data.  For more\n";
    ss << "\\memo details on these periods, see AuxiliaryPrograms document.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference DesignDays\n";
    ss << "\\reference RunPeriodsAndDesignDays\n";
    ss << "\\note user supplied name for reporting\n";
    ss << "A2 , \\field Period Selection\n";
    ss << "\\required-field\n";
    ss << "\\retaincase\n";
    ss << "\\note Following is a list of all possible types of Extreme and Typical periods that\n";
    ss << "\\note might be identified in the Weather File. Not all possible types are available\n";
    ss << "\\note for all weather files.\n";
    ss << "\\type choice\n";
    ss << "\\key SummerExtreme\n";
    ss << "\\key SummerTypical\n";
    ss << "\\key WinterExtreme\n";
    ss << "\\key WinterTypical\n";
    ss << "\\key AutumnTypical\n";
    ss << "\\key SpringTypical\n";
    ss << "\\key WetSeason\n";
    ss << "\\key DrySeason\n";
    ss << "\\key NoDrySeason\n";
    ss << "\\key NoWetSeason\n";
    ss << "\\key TropicalHot\n";
    ss << "\\key TropicalCold\n";
    ss << "\\key NoDrySeasonMax\n";
    ss << "\\key NoDrySeasonMin\n";
    ss << "\\key NoWetSeasonMax\n";
    ss << "\\key NoWetSeasonMin\n";
    ss << "A3 , \\field Day of Week for Start Day\n";
    ss << "\\note  =[|Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|SummerDesignDay|WinterDesignDay|\n";
    ss << "\\note    |CustomDay1|CustomDay2];\n";
    ss << "\\note if you use SummerDesignDay or WinterDesignDay or the CustomDays then this will apply\n";
    ss << "\\note to the whole period; other days (i.e., Monday) will signify a start day and\n";
    ss << "\\note normal sequence ofsubsequent days\n";
    ss << "\\default Monday\n";
    ss << "\\type choice\n";
    ss << "\\key Sunday\n";
    ss << "\\key Monday\n";
    ss << "\\key Tuesday\n";
    ss << "\\key Wednesday\n";
    ss << "\\key Thursday\n";
    ss << "\\key Friday\n";
    ss << "\\key Saturday\n";
    ss << "\\key SummerDesignDay\n";
    ss << "\\key WinterDesignDay\n";
    ss << "\\key CustomDay1\n";
    ss << "\\key CustomDay2\n";
    ss << "A4,  \\field Use Weather File Daylight Saving Period\n";
    ss << "\\note If yes or blank, use daylight saving period as specified on Weatherfile.\n";
    ss << "\\note If no, do not use the daylight saving period as specified on the Weatherfile.\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A5;  \\field Use Weather File Rain and Snow Indicators\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";

    IddObjectType objType(IddObjectType::SizingPeriod_WeatherFileConditionType);
    OptionalIddObject oObj = IddObject::load("SizingPeriod:WeatherFileConditionType",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SizingPeriod_WeatherFileConditionType);
  return object;
}

IddObject createRunPeriodIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RunPeriod,\n";
    ss << "\\memo Specified a range of dates and other parameters for a weather file simulation.\n";
    ss << "\\memo Multiple run periods may be input, but they may not overlap.\n";
    ss << "\\min-fields 11\n";
    ss << "A1 , \\field Name\n";
    ss << "\\reference RunPeriodsAndDesignDays\n";
    ss << "\\note descriptive name (used in reporting mainly)\n";
    ss << "\\note if blank, weather file title is used.  if not blank, must be unique\n";
    ss << "N1 , \\field Begin Month\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "\\type integer\n";
    ss << "N2 , \\field Begin Day of Month\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "\\type integer\n";
    ss << "N3 , \\field End Month\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "\\type integer\n";
    ss << "N4 , \\field End Day of Month\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "\\type integer\n";
    ss << "A2 , \\field Day of Week for Start Day\n";
    ss << "\\note  =<blank - use WeatherFile>|Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday];\n";
    ss << "\\default UseWeatherFile\n";
    ss << "\\type choice\n";
    ss << "\\key Sunday\n";
    ss << "\\key Monday\n";
    ss << "\\key Tuesday\n";
    ss << "\\key Wednesday\n";
    ss << "\\key Thursday\n";
    ss << "\\key Friday\n";
    ss << "\\key Saturday\n";
    ss << "\\key UseWeatherFile\n";
    ss << "A3,  \\field Use Weather File Holidays and Special Days\n";
    ss << "\\note If yes or blank, use holidays as specified on Weatherfile.\n";
    ss << "\\note If no, do not use the holidays specified on the Weatherfile.\n";
    ss << "\\note Note: You can still specify holidays/special days using the RunPeriodControl:SpecialDays object(s).\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A4,  \\field Use Weather File Daylight Saving Period\n";
    ss << "\\note If yes or blank, use daylight saving period as specified on Weatherfile.\n";
    ss << "\\note If no, do not use the daylight saving period as specified on the Weatherfile.\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A5,  \\field Apply Weekend Holiday Rule\n";
    ss << "\\note if yes and single day holiday falls on weekend, \"holiday\" occurs on following Monday\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A6,  \\field Use Weather File Rain Indicators\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "A7,  \\field Use Weather File Snow Indicators\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "N5,  \\field Number of Times Runperiod to be Repeated\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";
    ss << "A8,  \\field Increment Day of Week on repeat\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "N6;  \\field Start Year\n";
    ss << "\\note this is the start year for the start date.  If the leap year is \"Yes\" in the weather file header\n";
    ss << "\\note (that is HOLIDAYS/SPECIAL DAYS header first field), then any year which is a leap year will assume\n";
    ss << "\\note there will be a Feb 29. A repeat of this runperiod will automatically increment the year.\n";

    IddObjectType objType(IddObjectType::RunPeriod);
    OptionalIddObject oObj = IddObject::load("RunPeriod",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RunPeriod);
  return object;
}

IddObject createRunPeriod_CustomRangeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RunPeriod:CustomRange,\n";
    ss << "\\memo run simulation for a custom created weather file\n";
    ss << "\\min-fields 13\n";
    ss << "A1 , \\field Name\n";
    ss << "\\reference RunPeriods\n";
    ss << "\\reference RunPeriodsAndDesignDays\n";
    ss << "\\note descriptive name (used in reporting mainly)\n";
    ss << "\\note if blank, weather file title is used.  if not blank, must be unique\n";
    ss << "N1 , \\field Begin Month\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "\\type integer\n";
    ss << "N2 , \\field Begin Day of Month\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "\\type integer\n";
    ss << "N3,  \\field Begin Year\n";
    ss << "\\required-field\n";
    ss << "\\note must be start year of this date on weather file\n";
    ss << "N4 , \\field End Month\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "\\type integer\n";
    ss << "N5 , \\field End Day of Month\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "\\type integer\n";
    ss << "N6,  \\field End Year\n";
    ss << "\\required-field\n";
    ss << "\\note must be end year of this date on weather file\n";
    ss << "A2 , \\field Day of Week for Start Day\n";
    ss << "\\note  =<blank - use WeatherFile>|Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday];\n";
    ss << "\\default UseWeatherFile\n";
    ss << "\\type choice\n";
    ss << "\\key Sunday\n";
    ss << "\\key Monday\n";
    ss << "\\key Tuesday\n";
    ss << "\\key Wednesday\n";
    ss << "\\key Thursday\n";
    ss << "\\key Friday\n";
    ss << "\\key Saturday\n";
    ss << "\\key UseWeatherFile\n";
    ss << "A3,  \\field Use Weather File Holidays and Special Days\n";
    ss << "\\note If yes or blank, use holidays as specified on Weatherfile.\n";
    ss << "\\note If no, do not use the holidays specified on the Weatherfile.\n";
    ss << "\\note Note: You can still specify holidays/special days using the RunPeriodControl:SpecialDays object(s).\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A4,  \\field Use Weather File Daylight Saving Period\n";
    ss << "\\note If yes or blank, use daylight saving period as specified on Weatherfile.\n";
    ss << "\\note If no, do not use the daylight saving period as specified on the Weatherfile.\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A5,  \\field Apply Weekend Holiday Rule\n";
    ss << "\\note if yes and single day holiday falls on weekend, \"holiday\" occurs on following Monday\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A6,  \\field Use Weather File Rain Indicators\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "A7;  \\field Use Weather File Snow Indicators\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";

    IddObjectType objType(IddObjectType::RunPeriod_CustomRange);
    OptionalIddObject oObj = IddObject::load("RunPeriod:CustomRange",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RunPeriod_CustomRange);
  return object;
}

IddObject createRunPeriodControl_SpecialDaysIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RunPeriodControl:SpecialDays,\n";
    ss << "\\min-fields 4\n";
    ss << "\\memo This object sets up holidays/special days to be used during weather file\n";
    ss << "\\memo run periods.  (These are not used with SizingPeriod:* objects.)\n";
    ss << "\\memo Depending on the value in the run period, days on the weather file may also\n";
    ss << "\\memo be used.  However, the weather file specification will take precedence over\n";
    ss << "\\memo any specification shown here.  (No error message on duplicate days or overlapping\n";
    ss << "\\memo days).\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Start Date\n";
    ss << "\\required-field\n";
    ss << "\\note  Dates can be several formats:\n";
    ss << "\\note  <number>/<number>  (month/day)\n";
    ss << "\\note  <number> <Month>\n";
    ss << "\\note  <Month> <number>\n";
    ss << "\\note <Nth> <Weekday> in <Month)\n";
    ss << "\\note Last <WeekDay> in <Month>\n";
    ss << "\\note <Month> can be January, February, March, April, May, June, July, August, September, October, November, December\n";
    ss << "\\note Months can be the first 3 letters of the month\n";
    ss << "\\note <Weekday> can be Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday\n";
    ss << "\\note <Nth> can be 1 or 1st, 2 or 2nd, etc. up to 5(?)\n";
    ss << "N1, \\field Duration\n";
    ss << "\\units days\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 366\n";
    ss << "\\default 1\n";
    ss << "A3; \\field Special Day Type\n";
    ss << "\\note Special Day Type selects the schedules appropriate for each day so labeled\n";
    ss << "\\type choice\n";
    ss << "\\key Holiday\n";
    ss << "\\key SummerDesignDay\n";
    ss << "\\key WinterDesignDay\n";
    ss << "\\key CustomDay1\n";
    ss << "\\key CustomDay2\n";
    ss << "\\default Holiday\n";

    IddObjectType objType(IddObjectType::RunPeriodControl_SpecialDays);
    OptionalIddObject oObj = IddObject::load("RunPeriodControl:SpecialDays",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RunPeriodControl_SpecialDays);
  return object;
}

IddObject createRunPeriodControl_DaylightSavingTimeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RunPeriodControl:DaylightSavingTime,\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 2\n";
    ss << "\\memo This object sets up the daylight saving time period for any RunPeriod.\n";
    ss << "\\memo Ignores any daylight saving time period on the weather file and uses this definition.\n";
    ss << "\\memo These are not used with SizingPeriod:DesignDay objects.\n";
    ss << "\\memo Use with SizingPeriod:WeatherFileDays object can be controlled in that object.\n";
    ss << "A1, \\field Start Date\n";
    ss << "\\required-field\n";
    ss << "A2; \\field End Date\n";
    ss << "\\required-field\n";
    ss << "\\note  Dates can be several formats:\n";
    ss << "\\note  <number>/<number>  (month/day)\n";
    ss << "\\note  <number> <Month>\n";
    ss << "\\note  <Month> <number>\n";
    ss << "\\note <Nth> <Weekday> in <Month)\n";
    ss << "\\note Last <WeekDay> in <Month>\n";
    ss << "\\note <Month> can be January, February, March, April, May, June, July, August, September, October, November, December\n";
    ss << "\\note Months can be the first 3 letters of the month\n";
    ss << "\\note <Weekday> can be Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday\n";
    ss << "\\note <Nth> can be 1 or 1st, 2 or 2nd, etc. up to 5(?)\n";

    IddObjectType objType(IddObjectType::RunPeriodControl_DaylightSavingTime);
    OptionalIddObject oObj = IddObject::load("RunPeriodControl:DaylightSavingTime",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RunPeriodControl_DaylightSavingTime);
  return object;
}

IddObject createWeatherProperty_SkyTemperatureIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WeatherProperty:SkyTemperature,\n";
    ss << "\\memo This object is used to override internal sky temperature calculations.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\note blank in this field will apply to all run periods (that is, all objects=\n";
    ss << "\\note SizingPeriod:WeatherFileDays, SizingPeriod:WeatherFileConditionType or RunPeriod\n";
    ss << "\\note otherwise, this name must match one of the environment object names.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RunPeriodsAndDesignDays\n";
    ss << "A2,  \\field Calculation Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key ScheduleValue\n";
    ss << "\\key DifferenceScheduleDryBulbValue\n";
    ss << "\\key DifferenceScheduleDewPointValue\n";
    ss << "A3;  \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\note if name matches a SizingPeriod:DesignDay, put in a day schedule of this name\n";
    ss << "\\note if name is for a SizingPeriod:WeatherFileDays, SizingPeriod:WeatherFileConditionType or\n";
    ss << "\\note RunPeriod, put in a full year schedule that covers the appropriate days.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleAndDayScheduleNames\n";

    IddObjectType objType(IddObjectType::WeatherProperty_SkyTemperature);
    OptionalIddObject oObj = IddObject::load("WeatherProperty:SkyTemperature",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WeatherProperty_SkyTemperature);
  return object;
}

IddObject createSite_WeatherStationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Site:WeatherStation,\n";
    ss << "\\unique-object\n";
    ss << "\\memo This object should only be used for non-standard weather data.  Standard weather data\n";
    ss << "\\memo such as TMY2, IWEC, and ASHRAE design day data are all measured at the\n";
    ss << "\\memo default conditions and do not require this object.\n";
    ss << "N1 , \\field Wind Sensor Height Above Ground\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 10.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2 , \\field Wind Speed Profile Exponent\n";
    ss << "\\type real\n";
    ss << "\\default 0.14\n";
    ss << "\\minimum 0.0\n";
    ss << "N3 , \\field Wind Speed Profile Boundary Layer Thickness\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 270.0\n";
    ss << "\\minimum 0.0\n";
    ss << "N4 ; \\field Air Temperature Sensor Height Above Ground\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 1.5\n";
    ss << "\\minimum 0.0\n";

    IddObjectType objType(IddObjectType::Site_WeatherStation);
    OptionalIddObject oObj = IddObject::load("Site:WeatherStation",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Site_WeatherStation);
  return object;
}

IddObject createSite_HeightVariationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Site:HeightVariation,\n";
    ss << "\\unique-object\n";
    ss << "\\memo This object is used if the user requires advanced control over height-dependent\n";
    ss << "\\memo variations in wind speed and temperature.  When this object is not present, the default model\n";
    ss << "\\memo for temperature dependence on height is used, and the wind speed is modeled according\n";
    ss << "\\memo to the Terrain field of the BUILDING object.\n";
    ss << "N1 , \\field Wind Speed Profile Exponent\n";
    ss << "\\note Set to zero for no wind speed dependence on height.\n";
    ss << "\\type real\n";
    ss << "\\default 0.22\n";
    ss << "\\minimum 0.0\n";
    ss << "N2 , \\field Wind Speed Profile Boundary Layer Thickness\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 370.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3 ; \\field Air Temperature Gradient Coefficient\n";
    ss << "\\note Set to zero for no air temperature dependence on height.\n";
    ss << "\\type real\n";
    ss << "\\units K/m\n";
    ss << "\\default 0.0065\n";
    ss << "\\minimum 0.0\n";

    IddObjectType objType(IddObjectType::Site_HeightVariation);
    OptionalIddObject oObj = IddObject::load("Site:HeightVariation",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Site_HeightVariation);
  return object;
}

IddObject createSite_GroundTemperature_BuildingSurfaceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Site:GroundTemperature:BuildingSurface,\n";
    ss << "\\memo These temperatures are specifically for those surfaces that have the outside environment\n";
    ss << "\\memo of \"Ground\".  Documentation about what values these should be is located in the\n";
    ss << "\\memo Auxiliary programs document (Ground Heat Transfer) as well as the InputOutput Reference.\n";
    ss << "\\memo CAUTION - Do not use the \"undisturbed\" ground temperatures from the weather data.\n";
    ss << "\\memo These values are too extreme for the soil under a conditioned building.\n";
    ss << "\\memo For best results, use the Slab or Basement program to calculate custom monthly\n";
    ss << "\\memo average ground temperatures (see Auxiliary Programs).  For typical commercial\n";
    ss << "\\memo buildings in the USA, a reasonable default value is 2C less than the average indoor space temperature.\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 12\n";
    ss << "\\format singleLine\n";
    ss << "N1 , \\field January Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 18\n";
    ss << "N2 , \\field February Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 18\n";
    ss << "N3 , \\field March Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 18\n";
    ss << "N4 , \\field April Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 18\n";
    ss << "N5 , \\field May Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 18\n";
    ss << "N6 , \\field June Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 18\n";
    ss << "N7 , \\field July Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 18\n";
    ss << "N8 , \\field August Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 18\n";
    ss << "N9 , \\field September Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 18\n";
    ss << "N10, \\field October Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 18\n";
    ss << "N11, \\field November Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 18\n";
    ss << "N12; \\field December Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 18\n";

    IddObjectType objType(IddObjectType::Site_GroundTemperature_BuildingSurface);
    OptionalIddObject oObj = IddObject::load("Site:GroundTemperature:BuildingSurface",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Site_GroundTemperature_BuildingSurface);
  return object;
}

IddObject createSite_GroundTemperature_FCfactorMethodIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Site:GroundTemperature:FCfactorMethod,\n";
    ss << "\\memo These temperatures are specifically for underground walls and ground floors\n";
    ss << "\\memo defined with the C-factor and F-factor methods, and should be close to the\n";
    ss << "\\memo monthly average outdoor air temperature delayed by 3 months for the location.\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 12\n";
    ss << "\\format singleLine\n";
    ss << "N1 , \\field January Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N2 , \\field February Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N3 , \\field March Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N4 , \\field April Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N5 , \\field May Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N6 , \\field June Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N7 , \\field July Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N8 , \\field August Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N9 , \\field September Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N10, \\field October Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N11, \\field November Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N12; \\field December Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";

    IddObjectType objType(IddObjectType::Site_GroundTemperature_FCfactorMethod);
    OptionalIddObject oObj = IddObject::load("Site:GroundTemperature:FCfactorMethod",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Site_GroundTemperature_FCfactorMethod);
  return object;
}

IddObject createSite_GroundTemperature_ShallowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Site:GroundTemperature:Shallow,\n";
    ss << "\\memo These temperatures are specifically for the Surface Ground Heat Exchanger and\n";
    ss << "\\memo should probably be close to the average outdoor air temperature for the location.\n";
    ss << "\\memo They are not used in other models.\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 12\n";
    ss << "\\format singleLine\n";
    ss << "N1 , \\field January Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N2 , \\field February Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N3 , \\field March Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N4 , \\field April Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N5 , \\field May Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N6 , \\field June Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N7 , \\field July Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N8 , \\field August Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N9 , \\field September Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N10, \\field October Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N11, \\field November Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N12; \\field December Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";

    IddObjectType objType(IddObjectType::Site_GroundTemperature_Shallow);
    OptionalIddObject oObj = IddObject::load("Site:GroundTemperature:Shallow",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Site_GroundTemperature_Shallow);
  return object;
}

IddObject createSite_GroundTemperature_DeepIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Site:GroundTemperature:Deep,\n";
    ss << "\\memo These temperatures are specifically for the ground heat exchangers that would use\n";
    ss << "\\memo \"deep\" (3-4 m depth) ground temperatures for their heat source.\n";
    ss << "\\memo They are not used in other models.\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 12\n";
    ss << "\\format singleLine\n";
    ss << "N1 , \\field January Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N2 , \\field February Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N3 , \\field March Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N4 , \\field April Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N5 , \\field May Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N6 , \\field June Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N7 , \\field July Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N8 , \\field August Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N9 , \\field September Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N10, \\field October Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N11, \\field November Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N12; \\field December Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";

    IddObjectType objType(IddObjectType::Site_GroundTemperature_Deep);
    OptionalIddObject oObj = IddObject::load("Site:GroundTemperature:Deep",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Site_GroundTemperature_Deep);
  return object;
}

IddObject createSite_GroundTemperature_Undisturbed_FiniteDifferenceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Site:GroundTemperature:Undisturbed:FiniteDifference,\n";
    ss << "\\memo Undisturbed ground temperature object using a\n";
    ss << "\\memo detailed finite difference 1-D model\n";
    ss << "\\min-fields 7\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference UndisturbedGroundTempModels\n";
    ss << "N1,  \\field Soil Thermal Conductivity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2,  \\field Soil Density\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kg/m3\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3,  \\field Soil Specific Heat\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units J/kg-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "N4,  \\field Soil Moisture Content Volume Fraction\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 100\n";
    ss << "\\default 30\n";
    ss << "N5,  \\field Soil Moisture Content Volume Fraction at Saturation\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 100\n";
    ss << "\\default 50\n";
    ss << "N6; \\field Evapotranspiration Ground Cover Parameter\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.5\n";
    ss << "\\default 0.4\n";
    ss << "\\note This specifies the ground cover effects during evapotranspiration\n";
    ss << "\\note  calculations.  The value roughly represents the following cases:\n";
    ss << "\\note  = 0   : concrete or other solid, non-permeable ground surface material\n";
    ss << "\\note  = 0.5 : short grass, much like a manicured lawn\n";
    ss << "\\note  = 1   : standard reference state (12 cm grass)\n";
    ss << "\\note  = 1.5 : wild growth\n";

    IddObjectType objType(IddObjectType::Site_GroundTemperature_Undisturbed_FiniteDifference);
    OptionalIddObject oObj = IddObject::load("Site:GroundTemperature:Undisturbed:FiniteDifference",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Site_GroundTemperature_Undisturbed_FiniteDifference);
  return object;
}

IddObject createSite_GroundTemperature_Undisturbed_KusudaAchenbachIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Site:GroundTemperature:Undisturbed:KusudaAchenbach,\n";
    ss << "\\memo Undisturbed ground temperature object using the\n";
    ss << "\\memo Kusuda-Achenbach 1965 correlation.\n";
    ss << "\\min-fields 7\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference UndisturbedGroundTempModels\n";
    ss << "N1,  \\field Soil Thermal Conductivity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2,  \\field Soil Density\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kg/m3\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3,  \\field Soil Specific Heat\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units J/kg-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "N4,  \\field Average Soil Surface Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Annual average surface temperature\n";
    ss << "\\note If left blank the Site:GroundTemperature:Shallow object must be included in the input\n";
    ss << "\\note The soil temperature, amplitude, and phase shift must all be included or omitted together\n";
    ss << "N5,  \\field Average Amplitude of Surface Temperature\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0\n";
    ss << "\\note Annual average surface temperature variation from average.\n";
    ss << "\\note If left blank the Site:GroundTemperature:Shallow object must be included in the input\n";
    ss << "\\note The soil temperature, amplitude, and phase shift must all be included or omitted together\n";
    ss << "N6;  \\field Phase Shift of Minimum Surface Temperature\n";
    ss << "\\type real\n";
    ss << "\\units days\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 365\n";
    ss << "\\note The phase shift of minimum surface temperature, or the day\n";
    ss << "\\note of the year when the minimum surface temperature occurs.\n";
    ss << "\\note If left blank the Site:GroundTemperature:Shallow object must be included in the input\n";
    ss << "\\note The soil temperature, amplitude, and phase shift must all be included or omitted together\n";

    IddObjectType objType(IddObjectType::Site_GroundTemperature_Undisturbed_KusudaAchenbach);
    OptionalIddObject oObj = IddObject::load("Site:GroundTemperature:Undisturbed:KusudaAchenbach",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Site_GroundTemperature_Undisturbed_KusudaAchenbach);
  return object;
}

IddObject createSite_GroundTemperature_Undisturbed_XingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Site:GroundTemperature:Undisturbed:Xing,\n";
    ss << "\\memo Undisturbed ground temperature object using the\n";
    ss << "\\memo Xing 2014 2 harmonic parameter model.\n";
    ss << "\\min-fields 9\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference UndisturbedGroundTempModels\n";
    ss << "N1,  \\field Soil Thermal Conductivity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2,  \\field Soil Density\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kg/m3\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3,  \\field Soil Specific Heat\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units J/kg-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "N4,  \\field Average Soil Surface Tempeature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N5,  \\field Soil Surface Temperature Amplitude 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "N6,  \\field Soil Surface Temperature Amplitude 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "N7,  \\field Phase Shift of Temperature Amplitude 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units days\n";
    ss << "\\maximum< 365\n";
    ss << "N8;  \\field Phase Shift of Temperature Amplitude 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units days\n";
    ss << "\\maximum< 365\n";

    IddObjectType objType(IddObjectType::Site_GroundTemperature_Undisturbed_Xing);
    OptionalIddObject oObj = IddObject::load("Site:GroundTemperature:Undisturbed:Xing",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Site_GroundTemperature_Undisturbed_Xing);
  return object;
}

IddObject createSite_GroundDomain_SlabIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Site:GroundDomain:Slab,\n";
    ss << "\\memo Ground-coupled slab model for on-grade and\n";
    ss << "\\memo in-grade cases with or without insulation.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "N1,  \\field Ground Domain Depth\n";
    ss << "\\type real\n";
    ss << "\\default 10\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2,  \\field Aspect Ratio\n";
    ss << "\\type real\n";
    ss << "\\default 1\n";
    ss << "N3,  \\field Perimeter Offset\n";
    ss << "\\type real\n";
    ss << "\\default 5\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "N4,  \\field Soil Thermal Conductivity\n";
    ss << "\\type real\n";
    ss << "\\default 1.5\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "N5,  \\field Soil Density\n";
    ss << "\\type real\n";
    ss << "\\default 2800\n";
    ss << "\\units kg/m3\n";
    ss << "\\minimum> 0.0\n";
    ss << "N6,  \\field Soil Specific Heat\n";
    ss << "\\type real\n";
    ss << "\\default 850\n";
    ss << "\\units J/kg-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "N7,  \\field Soil Moisture Content Volume Fraction\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 100\n";
    ss << "\\default 30\n";
    ss << "N8,  \\field Soil Moisture Content Volume Fraction at Saturation\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 100\n";
    ss << "\\default 50\n";
    ss << "A2,  \\field Undisturbed Ground Temperature Model Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Site:GroundTemperature:Undisturbed:FiniteDifference\n";
    ss << "\\key Site:GroundTemperature:Undisturbed:KusudaAchenbach\n";
    ss << "\\key Site:GroundTemperature:Undisturbed:Xing\n";
    ss << "A3,  \\field Undisturbed Ground Temperature Model Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UndisturbedGroundTempModels\n";
    ss << "N9,  \\field Evapotranspiration Ground Cover Parameter\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.5\n";
    ss << "\\default 0.4\n";
    ss << "\\note This specifies the ground cover effects during evapotranspiration\n";
    ss << "\\note  calculations.  The value roughly represents the following cases:\n";
    ss << "\\note  = 0   : concrete or other solid, non-permeable ground surface material\n";
    ss << "\\note  = 0.5 : short grass, much like a manicured lawn\n";
    ss << "\\note  = 1   : standard reference state (12 cm grass)\n";
    ss << "\\note  = 1.5 : wild growth\n";
    ss << "A4,  \\field Slab Boundary Condition Model Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OSCMNames\n";
    ss << "A5,  \\field Slab Location\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key InGrade\n";
    ss << "\\key OnGrade\n";
    ss << "\\note This field specifies whether the slab is located \"in-grade\" or \"on-grade\"\n";
    ss << "A6,  \\field Slab Material Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MaterialName\n";
    ss << "\\note Only applicable for the in-grade case\n";
    ss << "A7,  \\field Horizontal Insulation\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note This field specifies the presence of insulation beneath the slab.\n";
    ss << "\\note Only required for in-grade case.\n";
    ss << "A8,  \\field Horizontal Insulation Material Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MaterialName\n";
    ss << "\\note This field specifies the horizontal insulation material.\n";
    ss << "A9,  \\field Horizontal Insulation Extents\n";
    ss << "\\type choice\n";
    ss << "\\key Full\n";
    ss << "\\key Perimeter\n";
    ss << "\\default Full\n";
    ss << "\\note This field specifies whether the horizontal insulation fully insulates\n";
    ss << "\\note the surface or is perimeter only insulation\n";
    ss << "N10, \\field Perimeter Insulation Width\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note This field specifies the width of the underfloor perimeter insulation\n";
    ss << "A10, \\field Vertical Insulation\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note This field specifies the presence of vertical insulation at the slab edge.\n";
    ss << "A11, \\field Vertical Insulation Material Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MaterialName\n";
    ss << "\\note This field specifies the vertical insulation material.\n";
    ss << "N11, \\field Vertical Insulation Depth\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Only used when including vertical insulation\n";
    ss << "\\note This field specifies the depth of the vertical insulation\n";
    ss << "A12; \\field Simulation Timestep\n";
    ss << "\\type choice\n";
    ss << "\\key Hourly\n";
    ss << "\\key Timestep\n";
    ss << "\\default Hourly\n";
    ss << "\\note This field specifies the ground domain simulation timestep.\n";

    IddObjectType objType(IddObjectType::Site_GroundDomain_Slab);
    OptionalIddObject oObj = IddObject::load("Site:GroundDomain:Slab",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Site_GroundDomain_Slab);
  return object;
}

IddObject createSite_GroundDomain_BasementIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Site:GroundDomain:Basement,\n";
    ss << "\\memo Ground-coupled basement model for simulating basements\n";
    ss << "\\memo or other underground zones.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "N1,  \\field Ground Domain Depth\n";
    ss << "\\type real\n";
    ss << "\\default 10\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note The depth from ground surface to the deep ground boundary of the domain.\n";
    ss << "N2,  \\field Aspect Ratio\n";
    ss << "\\type real\n";
    ss << "\\default 1\n";
    ss << "\\note This defines the height to width ratio of the basement zone.\n";
    ss << "N3,  \\field Perimeter Offset\n";
    ss << "\\type real\n";
    ss << "\\default 5\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note The distance from the basement wall edge to the edge of the ground domain\n";
    ss << "N4,  \\field Soil Thermal Conductivity\n";
    ss << "\\type real\n";
    ss << "\\default 1.5\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "N5,  \\field Soil Density\n";
    ss << "\\type real\n";
    ss << "\\default 2800\n";
    ss << "\\units kg/m3\n";
    ss << "\\minimum> 0.0\n";
    ss << "N6,  \\field Soil Specific Heat\n";
    ss << "\\type real\n";
    ss << "\\default 850\n";
    ss << "\\units J/kg-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "N7, \\field Soil Moisture Content Volume Fraction\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 100\n";
    ss << "\\default 30\n";
    ss << "N8, \\field Soil Moisture Content Volume Fraction at Saturation\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 100\n";
    ss << "\\default 50\n";
    ss << "A2,  \\field Undisturbed Ground Temperature Model Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Site:GroundTemperature:Undisturbed:FiniteDifference\n";
    ss << "\\key Site:GroundTemperature:Undisturbed:KusudaAchenbach\n";
    ss << "\\key Site:GroundTemperature:Undisturbed:Xing\n";
    ss << "A3,  \\field Undisturbed Ground Temperature Model Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UndisturbedGroundTempModels\n";
    ss << "N9,  \\field Evapotranspiration Ground Cover Parameter\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.5\n";
    ss << "\\default 0.4\n";
    ss << "\\note This specifies the ground cover effects during evapotranspiration\n";
    ss << "\\note  calculations.  The value roughly represents the following cases:\n";
    ss << "\\note  = 0   : concrete or other solid, non-permeable ground surface material\n";
    ss << "\\note  = 0.5 : short grass, much like a manicured lawn\n";
    ss << "\\note  = 1   : standard reference state (12 cm grass)\n";
    ss << "\\note  = 1.5 : wild growth\n";
    ss << "A4,  \\field Basement Floor Boundary Condition Model Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OSCMNames\n";
    ss << "A5,  \\field Horizontal Insulation\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note This field specifies the presence of insulation beneath the basement floor.\n";
    ss << "A6,  \\field Horizontal Insulation Material Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MaterialName\n";
    ss << "A7,  \\field Horizontal Insulation Extents\n";
    ss << "\\type choice\n";
    ss << "\\key Perimeter\n";
    ss << "\\key Full\n";
    ss << "\\default Full\n";
    ss << "\\note This field specifies whether the horizontal insulation fully insulates\n";
    ss << "\\note the surface or is perimeter only insulation\n";
    ss << "N10, \\field Perimeter Horizontal Insulation Width\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Width of horizontal perimeter insulation measured from\n";
    ss << "\\note foundation wall inside surface.\n";
    ss << "N11, \\field Basement Wall Depth\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Depth measured from ground surface.\n";
    ss << "A8,  \\field Basement Wall Boundary Condition Model Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OSCMNames\n";
    ss << "A9,  \\field Vertical Insulation\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A10, \\field Basement Wall Vertical Insulation Material Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MaterialName\n";
    ss << "N12, \\field Vertical Insulation Depth\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Depth measured from the ground surface.\n";
    ss << "A11, \\field Simulation Timestep\n";
    ss << "\\type choice\n";
    ss << "\\key Timestep\n";
    ss << "\\key Hourly\n";
    ss << "\\default Hourly\n";
    ss << "\\note This field specifies the basement domain simulation interval.\n";
    ss << "N13; \\field Mesh Density Parameter\n";
    ss << "\\type integer\n";
    ss << "\\default 4\n";
    ss << "\\minimum 2\n";

    IddObjectType objType(IddObjectType::Site_GroundDomain_Basement);
    OptionalIddObject oObj = IddObject::load("Site:GroundDomain:Basement",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Site_GroundDomain_Basement);
  return object;
}

IddObject createSite_GroundReflectanceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Site:GroundReflectance,\n";
    ss << "\\memo Specifies the ground reflectance values used to calculate ground reflected solar.\n";
    ss << "\\memo The ground reflectance can be further modified when snow is on the ground\n";
    ss << "\\memo by Site:GroundReflectance:SnowModifier.\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 12\n";
    ss << "\\format singleLine\n";
    ss << "N1 , \\field January Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N2 , \\field February Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N3 , \\field March Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N4 , \\field April Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N5 , \\field May Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N6 , \\field June Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N7 , \\field July Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N8 , \\field August Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N9 , \\field September Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N10 , \\field October Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N11 , \\field November Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N12 ; \\field December Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";

    IddObjectType objType(IddObjectType::Site_GroundReflectance);
    OptionalIddObject oObj = IddObject::load("Site:GroundReflectance",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Site_GroundReflectance);
  return object;
}

IddObject createSite_GroundReflectance_SnowModifierIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Site:GroundReflectance:SnowModifier,\n";
    ss << "\\memo Specifies ground reflectance multipliers when snow resident on the ground.\n";
    ss << "\\memo These multipliers are applied to the \"normal\" ground reflectances specified\n";
    ss << "\\memo in Site:GroundReflectance.\n";
    ss << "N1, \\field Ground Reflected Solar Modifier\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Value for modifying the \"normal\" ground reflectance when Snow is on ground\n";
    ss << "\\note  when calculating the \"Ground Reflected Solar Radiation Value\"\n";
    ss << "\\note  a value of 1.0 here uses the \"normal\" ground reflectance\n";
    ss << "\\note  Ground Reflected Solar = (BeamSolar*CosSunZenith + DiffuseSolar)*GroundReflectance\n";
    ss << "\\note    This would be further modified by the Snow Ground Reflectance Modifier when Snow was on the ground\n";
    ss << "\\note    When Snow on ground, effective GroundReflectance is normal GroundReflectance*\"Ground Reflectance Snow Modifier\"\n";
    ss << "\\note  Ground Reflectance achieved in this manner will be restricted to [0.0,1.0]\n";
    ss << "N2; \\field Daylighting Ground Reflected Solar Modifier\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Value for modifying the \"normal\" daylighting ground reflectance when Snow is on ground\n";
    ss << "\\note  when calculating the \"Ground Reflected Solar Radiation Value\"\n";
    ss << "\\note  a value of 1.0 here uses the \"normal\" ground reflectance\n";
    ss << "\\note  Ground Reflected Solar = (BeamSolar*CosSunZenith + DiffuseSolar)*GroundReflectance\n";
    ss << "\\note    This would be further modified by the Snow Ground Reflectance Modifier when Snow was on the ground\n";
    ss << "\\note    When Snow on ground, effective GroundReflectance is normal GroundReflectance*\"Daylighting Ground Reflectance Snow Modifier\"\n";
    ss << "\\note  Ground Reflectance achieved in this manner will be restricted to [0.0,1.0]\n";

    IddObjectType objType(IddObjectType::Site_GroundReflectance_SnowModifier);
    OptionalIddObject oObj = IddObject::load("Site:GroundReflectance:SnowModifier",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Site_GroundReflectance_SnowModifier);
  return object;
}

IddObject createSite_WaterMainsTemperatureIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Site:WaterMainsTemperature,\n";
    ss << "\\memo Used to calculate water mains temperatures delivered by underground water main pipes.\n";
    ss << "\\memo Water mains temperatures are a function of outdoor climate conditions\n";
    ss << "\\memo and vary with time of year.\n";
    ss << "A1 , \\field Calculation Method\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Schedule\n";
    ss << "\\key Correlation\n";
    ss << "A2 , \\field Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Annual Average Outdoor Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N2 ; \\field Maximum Difference In Monthly Average Outdoor Air Temperatures\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0\n";

    IddObjectType objType(IddObjectType::Site_WaterMainsTemperature);
    OptionalIddObject oObj = IddObject::load("Site:WaterMainsTemperature",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Site_WaterMainsTemperature);
  return object;
}

IddObject createSite_PrecipitationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Site:Precipitation,\n";
    ss << "\\memo Used to describe the amount of water precipitation at the building site.\n";
    ss << "\\memo Precipitation includes both rain and the equivalent water content of snow.\n";
    ss << "A1, \\field Precipitation Model Type\n";
    ss << "\\type choice\n";
    ss << "\\key ScheduleAndDesignLevel\n";
    ss << "N1, \\field Design Level for Total Annual Precipitation\n";
    ss << "\\note meters of water per year used for design level\n";
    ss << "\\units m/yr\n";
    ss << "A2, \\field Precipitation Rates Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values in meters of water per hour\n";
    ss << "\\note values should be non-negative\n";
    ss << "N2; \\field Average Total Annual Precipitation\n";
    ss << "\\note meters of water per year from average weather statistics\n";
    ss << "\\minimum 0\n";
    ss << "\\units m/yr\n";

    IddObjectType objType(IddObjectType::Site_Precipitation);
    OptionalIddObject oObj = IddObject::load("Site:Precipitation",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Site_Precipitation);
  return object;
}

IddObject createRoofIrrigationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RoofIrrigation,\n";
    ss << "\\memo Used to describe the amount of irrigation on the ecoroof surface over the course\n";
    ss << "\\memo of the simulation runperiod.\n";
    ss << "A1, \\field Irrigation Model Type\n";
    ss << "\\type choice\n";
    ss << "\\key Schedule\n";
    ss << "\\key SmartSchedule\n";
    ss << "\\note SmartSchedule will not allow irrigation when soil is already moist.\n";
    ss << "\\note Current threshold set at 30% of saturation.\n";
    ss << "A2, \\field Irrigation Rate Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values in meters of water per hour\n";
    ss << "\\note values should be non-negative\n";
    ss << "N1; \\field Irrigation Maximum Saturation Threshold\n";
    ss << "\\note Used with SmartSchedule to set the saturation level at which no\n";
    ss << "\\note irrigation is allowed.\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\default 40.0\n";

    IddObjectType objType(IddObjectType::RoofIrrigation);
    OptionalIddObject oObj = IddObject::load("RoofIrrigation",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RoofIrrigation);
  return object;
}

IddObject createSite_SolarAndVisibleSpectrumIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Site:SolarAndVisibleSpectrum,\n";
    ss << "\\memo If this object is omitted, the default solar and visible spectrum data will be used.\n";
    ss << "\\unique-object\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2, \\field Spectrum Data Method\n";
    ss << "\\note The method specifies which of the solar and visible spectrum data to use in the calculations.\n";
    ss << "\\note Choices: Default - existing hard-wired spectrum data in EnergyPlus.\n";
    ss << "\\note UserDefined - user specified spectrum data referenced by the next two fields\n";
    ss << "\\type choice\n";
    ss << "\\key Default\n";
    ss << "\\key UserDefined\n";
    ss << "\\default Default\n";
    ss << "A3, \\field Solar Spectrum Data Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpectrumDataNames\n";
    ss << "A4; \\field Visible Spectrum Data Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpectrumDataNames\n";

    IddObjectType objType(IddObjectType::Site_SolarAndVisibleSpectrum);
    OptionalIddObject oObj = IddObject::load("Site:SolarAndVisibleSpectrum",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Site_SolarAndVisibleSpectrum);
  return object;
}

IddObject createSite_SpectrumDataIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Site:SpectrumData,\n";
    ss << "\\extensible:2\n";
    ss << "\\min-fields 8\n";
    ss << "\\memo Spectrum Data Type is followed by up to 107 sets of normal-incidence measured values of\n";
    ss << "\\memo [wavelength, spectrum] for wavelengths covering the solar (0.25 to 2.5 microns) or visible\n";
    ss << "\\memo spectrum (0.38 to 0.78 microns)\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SpectrumDataNames\n";
    ss << "A2, \\field Spectrum Data Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Solar\n";
    ss << "\\key Visible\n";
    ss << "N1, \\field Wavelength\n";
    ss << "\\type real\n";
    ss << "\\units micron\n";
    ss << "\\begin-extensible\n";
    ss << "N2; \\field Spectrum\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::Site_SpectrumData);
    OptionalIddObject oObj = IddObject::load("Site:SpectrumData",
                                             "Location and Climate",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Site_SpectrumData);
  return object;
}

IddObject createScheduleTypeLimitsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ScheduleTypeLimits,\n";
    ss << "\\memo ScheduleTypeLimits specifies the data types and limits for the values contained in schedules\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ScheduleTypeLimitsNames\n";
    ss << "\\note used to validate schedule types in various schedule objects\n";
    ss << "N1,  \\field Lower Limit Value\n";
    ss << "\\note lower limit (real or integer) for the Schedule Type.  e.g. if fraction, this is 0.0\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "N2,  \\field Upper Limit Value\n";
    ss << "\\note upper limit (real or integer) for the Schedule Type.  e.g. if fraction, this is 1.0\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "A2,  \\field Numeric Type\n";
    ss << "\\note Numeric type is either Continuous (all numbers within the min and\n";
    ss << "\\note max are valid or Discrete (only integer numbers between min and\n";
    ss << "\\note max are valid.  (Could also allow REAL and INTEGER to mean the\n";
    ss << "\\note same things)\n";
    ss << "\\type choice\n";
    ss << "\\key Continuous\n";
    ss << "\\key Discrete\n";
    ss << "A3;  \\field Unit Type\n";
    ss << "\\note Temperature (C or F)\n";
    ss << "\\note DeltaTemperature (C or F)\n";
    ss << "\\note PrecipitationRate (m/hr or ft/hr)\n";
    ss << "\\note Angle (degrees)\n";
    ss << "\\note Convection Coefficient (W/m2-K or Btu/sqft-hr-F)\n";
    ss << "\\note Activity Level (W/person)\n";
    ss << "\\note Velocity (m/s or ft/min)\n";
    ss << "\\note Capacity (W or Btu/h)\n";
    ss << "\\note Power (W)\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key DeltaTemperature\n";
    ss << "\\key PrecipitationRate\n";
    ss << "\\key Angle\n";
    ss << "\\key ConvectionCoefficient\n";
    ss << "\\key ActivityLevel\n";
    ss << "\\key Velocity\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";
    ss << "\\key Availability\n";
    ss << "\\key Percent\n";
    ss << "\\key Control\n";
    ss << "\\key Mode\n";
    ss << "\\default Dimensionless\n";

    IddObjectType objType(IddObjectType::ScheduleTypeLimits);
    OptionalIddObject oObj = IddObject::load("ScheduleTypeLimits",
                                             "Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ScheduleTypeLimits);
  return object;
}

IddObject createSchedule_Day_HourlyIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Schedule:Day:Hourly,\n";
    ss << "\\min-fields 26\n";
    ss << "\\memo A Schedule:Day:Hourly contains 24 values for each hour of the day.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference DayScheduleNames\n";
    ss << "\\reference ScheduleAndDayScheduleNames\n";
    ss << "A2 , \\field Schedule Type Limits Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleTypeLimitsNames\n";
    ss << "N1 , \\field Hour 1\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N2 , \\field Hour 2\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N3 , \\field Hour 3\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N4 , \\field Hour 4\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N5 , \\field Hour 5\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N6 , \\field Hour 6\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N7 , \\field Hour 7\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N8 , \\field Hour 8\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N9 , \\field Hour 9\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N10, \\field Hour 10\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N11, \\field Hour 11\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N12, \\field Hour 12\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N13, \\field Hour 13\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N14, \\field Hour 14\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N15, \\field Hour 15\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N16, \\field Hour 16\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N17, \\field Hour 17\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N18, \\field Hour 18\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N19, \\field Hour 19\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N20, \\field Hour 20\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N21, \\field Hour 21\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N22, \\field Hour 22\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N23, \\field Hour 23\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N24; \\field Hour 24\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";

    IddObjectType objType(IddObjectType::Schedule_Day_Hourly);
    OptionalIddObject oObj = IddObject::load("Schedule:Day:Hourly",
                                             "Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Schedule_Day_Hourly);
  return object;
}

IddObject createSchedule_Day_IntervalIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Schedule:Day:Interval,\n";
    ss << "\\extensible:2 - repeat last two fields, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\memo A Schedule:Day:Interval contains a full day of values with specified end times for each value\n";
    ss << "\\memo Currently, is set up to allow for 10 minute intervals for an entire day.\n";
    ss << "\\min-fields 5\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference DayScheduleNames\n";
    ss << "\\reference ScheduleAndDayScheduleNames\n";
    ss << "A2 , \\field Schedule Type Limits Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleTypeLimitsNames\n";
    ss << "A3 , \\field Interpolate to Timestep\n";
    ss << "\\note when the interval does not match the user specified timestep a Yes choice will average between the intervals request (to\n";
    ss << "\\note timestep resolution.  a No choice will use the interval value at the simulation timestep without regard to if it matches\n";
    ss << "\\note the boundary or not.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A4  , \\field Time 1\n";
    ss << "\\begin-extensible\n";
    ss << "\\note \"until\" includes the time entered.\n";
    ss << "\\units hh:mm\n";
    ss << "N1  ; \\field Value Until Time 1\n";

    IddObjectType objType(IddObjectType::Schedule_Day_Interval);
    OptionalIddObject oObj = IddObject::load("Schedule:Day:Interval",
                                             "Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Schedule_Day_Interval);
  return object;
}

IddObject createSchedule_Day_ListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Schedule:Day:List,\n";
    ss << "\\memo Schedule:Day:List will allow the user to list 24 hours worth of values, which can be sub-hourly in nature.\n";
    ss << "\\min-fields 5\n";
    ss << "\\extensible:1\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference DayScheduleNames\n";
    ss << "\\reference ScheduleAndDayScheduleNames\n";
    ss << "A2 , \\field Schedule Type Limits Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleTypeLimitsNames\n";
    ss << "A3 , \\field Interpolate to Timestep\n";
    ss << "\\note when the interval does not match the user specified timestep a \"Yes\" choice will average between the intervals request (to\n";
    ss << "\\note timestep resolution.  a \"No\" choice will use the interval value at the simulation timestep without regard to if it matches\n";
    ss << "\\note the boundary or not.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N1 , \\field Minutes per Item\n";
    ss << "\\note Must be evenly divisible into 60\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 60\n";
    ss << "N2;  \\field Value 1\n";
    ss << "\\default 0.0\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::Schedule_Day_List);
    OptionalIddObject oObj = IddObject::load("Schedule:Day:List",
                                             "Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Schedule_Day_List);
  return object;
}

IddObject createSchedule_Week_DailyIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Schedule:Week:Daily,\n";
    ss << "\\min-fields 13\n";
    ss << "\\memo  A Schedule:Week:Daily contains 12 Schedule:Day:Hourly objects, one for each day type.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference WeekScheduleNames\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Sunday Schedule:Day Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A3 , \\field Monday Schedule:Day Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A4 , \\field Tuesday Schedule:Day Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A5 , \\field Wednesday Schedule:Day Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A6 , \\field Thursday Schedule:Day Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A7 , \\field Friday Schedule:Day Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A8 , \\field Saturday Schedule:Day Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A9 , \\field Holiday Schedule:Day Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A10, \\field SummerDesignDay Schedule:Day Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A11, \\field WinterDesignDay Schedule:Day Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A12, \\field CustomDay1 Schedule:Day Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A13; \\field CustomDay2 Schedule:Day Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";

    IddObjectType objType(IddObjectType::Schedule_Week_Daily);
    OptionalIddObject oObj = IddObject::load("Schedule:Week:Daily",
                                             "Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Schedule_Week_Daily);
  return object;
}

IddObject createSchedule_Week_CompactIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Schedule:Week:Compact,\n";
    ss << "\\extensible:2 - repeat last two fields, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\memo Compact definition for Schedule:Day:List\n";
    ss << "\\min-fields 3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference WeekScheduleNames\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field DayType List 1\n";
    ss << "\\begin-extensible\n";
    ss << "\\note \"For\" is an optional prefix/start of the For fields.  Choices can be combined on single line\n";
    ss << "\\note if separated by spaces. i.e. \"Holiday Weekends\"\n";
    ss << "\\note Should have a space after For, if it is included. i.e. \"For Alldays\"\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key AllDays\n";
    ss << "\\key Weekdays\n";
    ss << "\\key Weekends\n";
    ss << "\\key Sunday\n";
    ss << "\\key Monday\n";
    ss << "\\key Tuesday\n";
    ss << "\\key Wednesday\n";
    ss << "\\key Thursday\n";
    ss << "\\key Friday\n";
    ss << "\\key Saturday\n";
    ss << "\\key Holiday\n";
    ss << "\\key SummerDesignDay\n";
    ss << "\\key WinterDesignDay\n";
    ss << "\\key CustomDay1\n";
    ss << "\\key CustomDay2\n";
    ss << "A3 ; \\field Schedule:Day Name 1\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";

    IddObjectType objType(IddObjectType::Schedule_Week_Compact);
    OptionalIddObject oObj = IddObject::load("Schedule:Week:Compact",
                                             "Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Schedule_Week_Compact);
  return object;
}

IddObject createSchedule_YearIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Schedule:Year,\n";
    ss << "\\min-fields 7\n";
    ss << "\\memo A Schedule:Year contains from 1 to 52 week schedules\n";
    ss << "\\extensible:5\n";
    ss << "\\max-fields 267\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ScheduleNames\n";
    ss << "A2 , \\field Schedule Type Limits Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleTypeLimitsNames\n";
    ss << "A3 , \\field Schedule:Week Name 1\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WeekScheduleNames\n";
    ss << "\\begin-extensible\n";
    ss << "N1 , \\field Start Month 1\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "N2 , \\field Start Day 1\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "N3 , \\field End Month 1\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "N4 ; \\field End Day 1\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";

    IddObjectType objType(IddObjectType::Schedule_Year);
    OptionalIddObject oObj = IddObject::load("Schedule:Year",
                                             "Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Schedule_Year);
  return object;
}

IddObject createSchedule_CompactIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Schedule:Compact,\n";
    ss << "\\extensible:1 - repeat last field, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo Irregular object.  Does not follow the usual definition for fields.  Fields A3... are:\n";
    ss << "\\memo Through: Date\n";
    ss << "\\memo For: Applicable days (ref: Schedule:Week:Compact)\n";
    ss << "\\memo Interpolate: Yes/No (ref: Schedule:Day:Interval) -- optional, if not used will be \"No\"\n";
    ss << "\\memo Until: <Time> (ref: Schedule:Day:Interval)\n";
    ss << "\\memo <numeric value>\n";
    ss << "\\memo words \"Through\",\"For\",\"Interpolate\",\"Until\" must be included.\n";
    ss << "\\format compactSchedule\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ScheduleNames\n";
    ss << "A2 , \\field Schedule Type Limits Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleTypeLimitsNames\n";
    ss << "A3 ; \\field Field 1\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::Schedule_Compact);
    OptionalIddObject oObj = IddObject::load("Schedule:Compact",
                                             "Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Schedule_Compact);
  return object;
}

IddObject createSchedule_ConstantIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Schedule:Constant,\n";
    ss << "\\memo Constant hourly value for entire year.\n";
    ss << "\\format singleLine\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ScheduleNames\n";
    ss << "A2 , \\field Schedule Type Limits Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleTypeLimitsNames\n";
    ss << "N1 ; \\field Hourly Value\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";

    IddObjectType objType(IddObjectType::Schedule_Constant);
    OptionalIddObject oObj = IddObject::load("Schedule:Constant",
                                             "Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Schedule_Constant);
  return object;
}

IddObject createSchedule_FileIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Schedule:File,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo A Schedule:File points to a text computer file that has 8760-8784 hours of data.\n";
    ss << "\\url-object\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ScheduleNames\n";
    ss << "A2 , \\field Schedule Type Limits Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleTypeLimitsNames\n";
    ss << "A3 , \\field File Name\n";
    ss << "\\required-field\n";
    ss << "\\retaincase\n";
    ss << "\\type url\n";
    ss << "N1 , \\field Column Number\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "N2 , \\field Rows to Skip at Top\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "N3 , \\field Number of Hours of Data\n";
    ss << "\\note 8760 hours does not account for leap years, 8784 does.\n";
    ss << "\\note should be either 8760 or 8784\n";
    ss << "\\default 8760\n";
    ss << "\\minimum 8760\n";
    ss << "\\maximum 8784\n";
    ss << "A4 , \\field Column Separator\n";
    ss << "\\type choice\n";
    ss << "\\key Comma\n";
    ss << "\\key Tab\n";
    ss << "\\key Fixed\n";
    ss << "\\key Semicolon\n";
    ss << "\\default Comma\n";
    ss << "A5 , \\field Interpolate to Timestep\n";
    ss << "\\note when the interval does not match the user specified timestep a \"Yes\" choice will average between the intervals request (to\n";
    ss << "\\note timestep resolution.  a \"No\" choice will use the interval value at the simulation timestep without regard to if it matches\n";
    ss << "\\note the boundary or not.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N4 ; \\field Minutes per Item\n";
    ss << "\\note Must be evenly divisible into 60\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 60\n";

    IddObjectType objType(IddObjectType::Schedule_File);
    OptionalIddObject oObj = IddObject::load("Schedule:File",
                                             "Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Schedule_File);
  return object;
}

IddObject createMaterialIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Material,\n";
    ss << "\\memo Regular materials described with full set of thermal properties\n";
    ss << "\\min-fields 6\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference MaterialName\n";
    ss << "A2 , \\field Roughness\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key VeryRough\n";
    ss << "\\key Rough\n";
    ss << "\\key MediumRough\n";
    ss << "\\key MediumSmooth\n";
    ss << "\\key Smooth\n";
    ss << "\\key VerySmooth\n";
    ss << "N1 , \\field Thickness\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 3.0\n";
    ss << "\\ip-units in\n";
    ss << "N2 , \\field Conductivity\n";
    ss << "\\required-field\n";
    ss << "\\units W/m-K\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "N3 , \\field Density\n";
    ss << "\\required-field\n";
    ss << "\\units kg/m3\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "N4 , \\field Specific Heat\n";
    ss << "\\required-field\n";
    ss << "\\units J/kg-K\n";
    ss << "\\type real\n";
    ss << "\\minimum 100\n";
    ss << "N5 , \\field Thermal Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default .9\n";
    ss << "\\maximum 0.99999\n";
    ss << "N6 , \\field Solar Absorptance\n";
    ss << "\\type real\n";
    ss << "\\default .7\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "N7 ; \\field Visible Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default .7\n";
    ss << "\\maximum 1\n";

    IddObjectType objType(IddObjectType::Material);
    OptionalIddObject oObj = IddObject::load("Material",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Material);
  return object;
}

IddObject createMaterial_NoMassIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Material:NoMass,\n";
    ss << "\\memo Regular materials properties described whose principal description is R (Thermal Resistance)\n";
    ss << "\\min-fields 3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference MaterialName\n";
    ss << "A2 , \\field Roughness\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key VeryRough\n";
    ss << "\\key Rough\n";
    ss << "\\key MediumRough\n";
    ss << "\\key MediumSmooth\n";
    ss << "\\key Smooth\n";
    ss << "\\key VerySmooth\n";
    ss << "N1 , \\field Thermal Resistance\n";
    ss << "\\required-field\n";
    ss << "\\units m2-K/W\n";
    ss << "\\type real\n";
    ss << "\\minimum .001\n";
    ss << "N2 , \\field Thermal Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default .9\n";
    ss << "\\maximum 0.99999\n";
    ss << "N3 , \\field Solar Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default .7\n";
    ss << "\\maximum 1\n";
    ss << "N4 ; \\field Visible Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default .7\n";
    ss << "\\maximum 1\n";

    IddObjectType objType(IddObjectType::Material_NoMass);
    OptionalIddObject oObj = IddObject::load("Material:NoMass",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Material_NoMass);
  return object;
}

IddObject createMaterial_InfraredTransparentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Material:InfraredTransparent,\n";
    ss << "\\memo Special infrared transparent material.  Similar to a Material:Nomass with low thermal resistance.\n";
    ss << "\\memo  High absorptance in both wavelengths.\n";
    ss << "\\memo  Area will be doubled internally to make internal radiant exchange accurate.\n";
    ss << "\\memo  Should be only material in single layer surface construction.\n";
    ss << "\\memo  All thermal properties are set internally. User needs only to supply name.\n";
    ss << "\\memo Cannot be used with ConductionFiniteDifference solution algorithms\n";
    ss << "\\min-fields 1\n";
    ss << "A1 ; \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference MaterialName\n";

    IddObjectType objType(IddObjectType::Material_InfraredTransparent);
    OptionalIddObject oObj = IddObject::load("Material:InfraredTransparent",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Material_InfraredTransparent);
  return object;
}

IddObject createMaterial_AirGapIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Material:AirGap,\n";
    ss << "\\min-fields 2\n";
    ss << "\\memo Air Space in Opaque Construction\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference MaterialName\n";
    ss << "N1 ; \\field Thermal Resistance\n";
    ss << "\\required-field\n";
    ss << "\\units m2-K/W\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";

    IddObjectType objType(IddObjectType::Material_AirGap);
    OptionalIddObject oObj = IddObject::load("Material:AirGap",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Material_AirGap);
  return object;
}

IddObject createMaterial_RoofVegetationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Material:RoofVegetation,\n";
    ss << "\\memo EcoRoof model, plant layer plus soil layer\n";
    ss << "\\memo Implemented by Portland State University\n";
    ss << "\\memo (Sailor et al., January, 2007)\n";
    ss << "\\memo only one material must be referenced per simulation though the same EcoRoof material could be\n";
    ss << "\\memo used in multiple constructions. New moisture redistribution scheme (2010) requires higher\n";
    ss << "\\memo number of timesteps per hour (minimum 12 recommended).\n";
    ss << "\\min-fields 18\n";
    ss << "A1 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference MaterialName\n";
    ss << "N1 ,\\field Height of Plants\n";
    ss << "\\type real\n";
    ss << "\\note The ecoroof module is designed for short plants and shrubs.\n";
    ss << "\\minimum> 0.005\n";
    ss << "\\maximum  1.0\n";
    ss << "\\units m\n";
    ss << "\\default .2\n";
    ss << "N2 ,\\field Leaf Area Index\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Entire surface is assumed covered, so decrease LAI accordingly.\n";
    ss << "\\minimum> 0.001\n";
    ss << "\\maximum 5.0\n";
    ss << "\\default 1.0\n";
    ss << "\\type real\n";
    ss << "N3 ,\\field Leaf Reflectivity\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Leaf reflectivity (albedo) is typically 0.18-0.25\n";
    ss << "\\maximum 0.5\n";
    ss << "\\minimum 0.05\n";
    ss << "\\default 0.22\n";
    ss << "N4 ,\\field Leaf Emissivity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.8\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.95\n";
    ss << "N5 ,\\field Minimum Stomatal Resistance\n";
    ss << "\\units s/m\n";
    ss << "\\default 180.0\n";
    ss << "\\note This depends upon plant type\n";
    ss << "\\minimum 50.0\n";
    ss << "\\maximum 300.\n";
    ss << "\\type real\n";
    ss << "A2 ,\\field Soil Layer Name\n";
    ss << "\\type alpha\n";
    ss << "\\default Green Roof Soil\n";
    ss << "A3 ,\\field Roughness\n";
    ss << "\\type choice\n";
    ss << "\\key VeryRough\n";
    ss << "\\key MediumRough\n";
    ss << "\\key Rough\n";
    ss << "\\key Smooth\n";
    ss << "\\key MediumSmooth\n";
    ss << "\\key VerySmooth\n";
    ss << "\\default MediumRough\n";
    ss << "N6 ,\\field Thickness\n";
    ss << "\\note thickness of the soil layer of the EcoRoof\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\note Soil depths of 0.15m (6in) and 0.30m (12in) are common.\n";
    ss << "\\default 0.1\n";
    ss << "\\minimum> 0.05\n";
    ss << "\\maximum 0.7\n";
    ss << "\\ip-units in\n";
    ss << "N7 ,\\field Conductivity of Dry Soil\n";
    ss << "\\units W/m-K\n";
    ss << "\\type real\n";
    ss << "\\note Thermal conductivity of dry soil.\n";
    ss << "\\note Typical ecoroof soils range from 0.3 to 0.5\n";
    ss << "\\default 0.35\n";
    ss << "\\minimum  0.2\n";
    ss << "\\maximum 1.5\n";
    ss << "N8 ,\\field Density of Dry Soil\n";
    ss << "\\units kg/m3\n";
    ss << "\\note Density of dry soil (the code modifies this as the soil becomes moist)\n";
    ss << "\\note Typical ecoroof soils range from 400 to 1000 (dry to wet)\n";
    ss << "\\type real\n";
    ss << "\\minimum 300\n";
    ss << "\\maximum 2000\n";
    ss << "\\default 1100\n";
    ss << "N9 ,\\field Specific Heat of Dry Soil\n";
    ss << "\\units J/kg-K\n";
    ss << "\\type real\n";
    ss << "\\note Specific heat of dry soil\n";
    ss << "\\minimum> 500\n";
    ss << "\\maximum 2000\n";
    ss << "\\default 1200\n";
    ss << "N10,\\field Thermal Absorptance\n";
    ss << "\\type real\n";
    ss << "\\note Soil emissivity is typically in range of 0.90 to 0.98\n";
    ss << "\\minimum> 0.8\n";
    ss << "\\default .9\n";
    ss << "\\maximum 1.0\n";
    ss << "N11,\\field Solar Absorptance\n";
    ss << "\\type real\n";
    ss << "\\note Solar absorptance of dry soil (1-albedo) is typically 0.60 to 0.85\n";
    ss << "\\note corresponding to a dry albedo of 0.15 to 0.40\n";
    ss << "\\default .70\n";
    ss << "\\minimum 0.40\n";
    ss << "\\maximum 0.9\n";
    ss << "N12,\\field Visible Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.5\n";
    ss << "\\default .75\n";
    ss << "\\maximum 1.0\n";
    ss << "N13,\\field Saturation Volumetric Moisture Content of the Soil Layer\n";
    ss << "\\type real\n";
    ss << "\\note Maximum moisture content is typically less than 0.5\n";
    ss << "\\minimum> 0.1\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.3\n";
    ss << "N14,\\field Residual Volumetric Moisture Content of the Soil Layer\n";
    ss << "\\type real\n";
    ss << "\\minimum  0.01\n";
    ss << "\\maximum  0.1\n";
    ss << "\\default 0.01\n";
    ss << "N15,\\field Initial Volumetric Moisture Content of the Soil Layer\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.05\n";
    ss << "\\maximum  0.5\n";
    ss << "\\default 0.1\n";
    ss << "A4; \\field Moisture Diffusion Calculation Method\n";
    ss << "\\note Advanced calculation requires increased number of timesteps (recommended >20).\n";
    ss << "\\type choice\n";
    ss << "\\key Simple\n";
    ss << "\\key Advanced\n";
    ss << "\\default Advanced\n";

    IddObjectType objType(IddObjectType::Material_RoofVegetation);
    OptionalIddObject oObj = IddObject::load("Material:RoofVegetation",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Material_RoofVegetation);
  return object;
}

IddObject createWindowMaterial_SimpleGlazingSystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowMaterial:SimpleGlazingSystem,\n";
    ss << "\\min-fields 3\n";
    ss << "\\memo Alternate method of describing windows\n";
    ss << "\\memo This window material object is used to define an entire glazing system\n";
    ss << "\\memo using simple performance parameters.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference MaterialName\n";
    ss << "\\reference GlazingMaterialName\n";
    ss << "N1 , \\field U-Factor\n";
    ss << "\\required-field\n";
    ss << "\\note Enter U-Factor including film coefficients\n";
    ss << "\\note Note that the effective upper limit for U-factor is 5.8 W/m2-K\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum  7\n";
    ss << "N2 , \\field Solar Heat Gain Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\note SHGC at Normal Incidence\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum< 1\n";
    ss << "N3 ; \\field Visible Transmittance\n";
    ss << "\\note VT at Normal Incidence\n";
    ss << "\\note optional\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum< 1\n";

    IddObjectType objType(IddObjectType::WindowMaterial_SimpleGlazingSystem);
    OptionalIddObject oObj = IddObject::load("WindowMaterial:SimpleGlazingSystem",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowMaterial_SimpleGlazingSystem);
  return object;
}

IddObject createWindowMaterial_GlazingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowMaterial:Glazing,\n";
    ss << "\\min-fields 14\n";
    ss << "\\memo Glass material properties for Windows or Glass Doors\n";
    ss << "\\memo Transmittance/Reflectance input method.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference MaterialName\n";
    ss << "\\reference GlazingMaterialName\n";
    ss << "\\reference CFSGlazingName\n";
    ss << "A2 , \\field Optical Data Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key SpectralAverage\n";
    ss << "\\key Spectral\n";
    ss << "\\key BSDF\n";
    ss << "A3 , \\field Window Glass Spectral Data Set Name\n";
    ss << "\\note Used only when Optical Data Type = Spectral\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpectralDataSets\n";
    ss << "N1 , \\field Thickness\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units in\n";
    ss << "N2 , \\field Solar Transmittance at Normal Incidence\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N3 , \\field Front Side Solar Reflectance at Normal Incidence\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\note Front Side is side closest to outdoor air\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N4 , \\field Back Side Solar Reflectance at Normal Incidence\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\note Back Side is side closest to zone air\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N5 , \\field Visible Transmittance at Normal Incidence\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N6 , \\field Front Side Visible Reflectance at Normal Incidence\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N7 , \\field Back Side Visible Reflectance at Normal Incidence\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N8 , \\field Infrared Transmittance at Normal Incidence\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N9 , \\field Front Side Infrared Hemispherical Emissivity\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\default 0.84\n";
    ss << "N10, \\field Back Side Infrared Hemispherical Emissivity\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\default 0.84\n";
    ss << "N11, \\field Conductivity\n";
    ss << "\\units W/m-K\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.9\n";
    ss << "N12, \\field Dirt Correction Factor for Solar and Visible Transmittance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A4,  \\field Solar Diffusing\n";
    ss << "\\type choice\n";
    ss << "\\key No\n";
    ss << "\\key Yes\n";
    ss << "\\default No\n";
    ss << "N13, \\field Youngs modulus\n";
    ss << "\\note coefficient used for deflection calculations. Used only with complex\n";
    ss << "\\note fenestration when deflection model is set to TemperatureAndPressureInput\n";
    ss << "\\units Pa\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 7.2e10\n";
    ss << "N14; \\field Poissons ratio\n";
    ss << "\\note coefficient used for deflection calculations. Used only with complex\n";
    ss << "\\note fenestration when deflection model is set to TemperatureAndPressureInput\n";
    ss << "\\type real\n";
    ss << "\\minimum>  0.0\n";
    ss << "\\maximum<  1.0\n";
    ss << "\\default 0.22\n";

    IddObjectType objType(IddObjectType::WindowMaterial_Glazing);
    OptionalIddObject oObj = IddObject::load("WindowMaterial:Glazing",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowMaterial_Glazing);
  return object;
}

IddObject createWindowMaterial_GlazingGroup_ThermochromicIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowMaterial:GlazingGroup:Thermochromic,\n";
    ss << "\\min-fields 3\n";
    ss << "\\extensible:2 - repeat last two fields remembering to remove ; from \"inner\" fields.\n";
    ss << "\\memo thermochromic glass at different temperatures\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference MaterialName\n";
    ss << "\\reference GlazingMaterialName\n";
    ss << "N1 , \\field Optical Data Temperature 1\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\ip-units F\n";
    ss << "\\type real\n";
    ss << "A2 ; \\field Window Material Glazing Name 1\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list GlazingMaterialName\n";

    IddObjectType objType(IddObjectType::WindowMaterial_GlazingGroup_Thermochromic);
    OptionalIddObject oObj = IddObject::load("WindowMaterial:GlazingGroup:Thermochromic",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowMaterial_GlazingGroup_Thermochromic);
  return object;
}

IddObject createWindowMaterial_Glazing_RefractionExtinctionMethodIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowMaterial:Glazing:RefractionExtinctionMethod,\n";
    ss << "\\memo Glass material properties for Windows or Glass Doors\n";
    ss << "\\memo Index of Refraction/Extinction Coefficient input method\n";
    ss << "\\memo Not to be used for coated glass\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference MaterialName\n";
    ss << "\\reference GlazingMaterialName\n";
    ss << "N1 , \\field Thickness\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units in\n";
    ss << "N2 , \\field Solar Index of Refraction\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 1.0\n";
    ss << "N3 , \\field Solar Extinction Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\units 1/m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N4 , \\field Visible Index of Refraction\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 1.0\n";
    ss << "N5 , \\field Visible Extinction Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\units 1/m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N6 , \\field Infrared Transmittance at Normal Incidence\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N7 , \\field Infrared Hemispherical Emissivity\n";
    ss << "\\note Emissivity of front and back side assumed equal\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.84\n";
    ss << "N8 , \\field Conductivity\n";
    ss << "\\units W/m-K\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.9\n";
    ss << "N9 , \\field Dirt Correction Factor for Solar and Visible Transmittance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A2 ; \\field Solar Diffusing\n";
    ss << "\\type choice\n";
    ss << "\\key No\n";
    ss << "\\key Yes\n";
    ss << "\\default No\n";

    IddObjectType objType(IddObjectType::WindowMaterial_Glazing_RefractionExtinctionMethod);
    OptionalIddObject oObj = IddObject::load("WindowMaterial:Glazing:RefractionExtinctionMethod",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowMaterial_Glazing_RefractionExtinctionMethod);
  return object;
}

IddObject createWindowMaterial_GasIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowMaterial:Gas,\n";
    ss << "\\memo Gas material properties that are used in Windows or Glass Doors\n";
    ss << "\\min-fields 3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference MaterialName\n";
    ss << "\\reference WindowGasAndGasMixtures\n";
    ss << "A2 , \\field Gas Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Air\n";
    ss << "\\key Argon\n";
    ss << "\\key Krypton\n";
    ss << "\\key Xenon\n";
    ss << "\\key Custom\n";
    ss << "N1 , \\field Thickness\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units in\n";
    ss << "N2 , \\field Conductivity Coefficient A\n";
    ss << "\\units W/m-K\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "N3 , \\field Conductivity Coefficient B\n";
    ss << "\\units W/m-K2\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "N4 , \\field Conductivity Coefficient C\n";
    ss << "\\units W/m-K3\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "N5 , \\field Viscosity Coefficient A\n";
    ss << "\\units kg/m-s\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "\\minimum> 0.0\n";
    ss << "N6 , \\field Viscosity Coefficient B\n";
    ss << "\\units kg/m-s-K\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "N7 , \\field Viscosity Coefficient C\n";
    ss << "\\units kg/m-s-K2\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "N8 , \\field Specific Heat Coefficient A\n";
    ss << "\\units J/kg-K\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "\\minimum> 0.0\n";
    ss << "N9 , \\field Specific Heat Coefficient B\n";
    ss << "\\units J/kg-K2\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "N10 ,\\field Specific Heat Coefficient C\n";
    ss << "\\units J/kg-K3\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "N11 ,\\field Molecular Weight\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "\\units g/mol\n";
    ss << "\\minimum 20.0\n";
    ss << "\\maximum 200.0\n";
    ss << "N12 ;\\field Specific Heat Ratio\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "\\minimum> 1.0\n";

    IddObjectType objType(IddObjectType::WindowMaterial_Gas);
    OptionalIddObject oObj = IddObject::load("WindowMaterial:Gas",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowMaterial_Gas);
  return object;
}

IddObject createWindowGap_SupportPillarIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowGap:SupportPillar,\n";
    ss << "\\memo used to define pillar geometry for support pillars\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WindowGapSupportPillars\n";
    ss << "N1 , \\field Spacing\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.04\n";
    ss << "N2 ; \\field Radius\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.0004\n";

    IddObjectType objType(IddObjectType::WindowGap_SupportPillar);
    OptionalIddObject oObj = IddObject::load("WindowGap:SupportPillar",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowGap_SupportPillar);
  return object;
}

IddObject createWindowGap_DeflectionStateIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowGap:DeflectionState,\n";
    ss << "\\memo Used to enter data describing deflection state of the gap. It is referenced from\n";
    ss << "\\memo WindowMaterial:Gap object only and it is used only when deflection model is set to\n";
    ss << "\\memo MeasuredDeflection, otherwise it is ignored.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WindowGapDeflectionStates\n";
    ss << "N1 , \\field Deflected Thickness\n";
    ss << "\\note If left blank will be considered that gap has no deflection.\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N2 , \\field Initial Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 25\n";
    ss << "N3 ; \\field Initial Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 101325\n";

    IddObjectType objType(IddObjectType::WindowGap_DeflectionState);
    OptionalIddObject oObj = IddObject::load("WindowGap:DeflectionState",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowGap_DeflectionState);
  return object;
}

IddObject createWindowMaterial_GasMixtureIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowMaterial:GasMixture,\n";
    ss << "\\memo Gas mixtures that are used in Windows or Glass Doors\n";
    ss << "\\min-fields 7\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference MaterialName\n";
    ss << "\\reference WindowGasAndGasMixtures\n";
    ss << "N1 , \\field Thickness\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2 , \\field Number of Gases in Mixture\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 4\n";
    ss << "A2 , \\field Gas 1 Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Air\n";
    ss << "\\key Argon\n";
    ss << "\\key Krypton\n";
    ss << "\\key Xenon\n";
    ss << "N3 , \\field Gas 1 Fraction\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A3 , \\field Gas 2 Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Air\n";
    ss << "\\key Argon\n";
    ss << "\\key Krypton\n";
    ss << "\\key Xenon\n";
    ss << "N4 , \\field Gas 2 Fraction\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A4 , \\field Gas 3 Type\n";
    ss << "\\type choice\n";
    ss << "\\key Air\n";
    ss << "\\key Argon\n";
    ss << "\\key Krypton\n";
    ss << "\\key Xenon\n";
    ss << "N5 , \\field Gas 3 Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A5 , \\field Gas 4 Type\n";
    ss << "\\type choice\n";
    ss << "\\key Air\n";
    ss << "\\key Argon\n";
    ss << "\\key Krypton\n";
    ss << "\\key Xenon\n";
    ss << "N6 ; \\field Gas 4 Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";

    IddObjectType objType(IddObjectType::WindowMaterial_GasMixture);
    OptionalIddObject oObj = IddObject::load("WindowMaterial:GasMixture",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowMaterial_GasMixture);
  return object;
}

IddObject createWindowMaterial_GapIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowMaterial:Gap,\n";
    ss << "\\memo Used to define the gap between two layers in a complex fenestration system, where the\n";
    ss << "\\memo Construction:ComplexFenestrationState object is used. It is referenced as a layer in the\n";
    ss << "\\memo Construction:ComplexFenestrationState object. It cannot be referenced as a layer from the\n";
    ss << "\\memo Construction object.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CFSGap\n";
    ss << "N1 , \\field Thickness\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "A2 , \\field Gas (or Gas Mixture)\n";
    ss << "\\note This field should reference only WindowMaterial:Gas\n";
    ss << "\\note or WindowMaterial:GasMixture objects\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowGasAndGasMixtures\n";
    ss << "N2 , \\field Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\type real\n";
    ss << "\\default 101325\n";
    ss << "A3 , \\field Deflection State\n";
    ss << "\\note If left blank, it will be considered that gap is not deflected\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowGapDeflectionStates\n";
    ss << "A4 ; \\field Support Pillar\n";
    ss << "\\note If left blank, it will be considered that gap does not have\n";
    ss << "\\note support pillars\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowGapSupportPillars\n";

    IddObjectType objType(IddObjectType::WindowMaterial_Gap);
    OptionalIddObject oObj = IddObject::load("WindowMaterial:Gap",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowMaterial_Gap);
  return object;
}

IddObject createWindowMaterial_ShadeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowMaterial:Shade,\n";
    ss << "\\memo Specifies the properties of window shade materials. Reflectance and emissivity\n";
    ss << "\\memo properties are assumed to be the same on both sides of the shade. Shades are considered\n";
    ss << "\\memo to be perfect diffusers (all transmitted and reflected radiation is\n";
    ss << "\\memo hemispherically-diffuse) independent of angle of incidence.\n";
    ss << "\\min-fields 15\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference MaterialName\n";
    ss << "\\reference WindowShadesScreensAndBlinds\n";
    ss << "N1 , \\field Solar Transmittance\n";
    ss << "\\required-field\n";
    ss << "\\note Assumed independent of incidence angle\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N2 , \\field Solar Reflectance\n";
    ss << "\\required-field\n";
    ss << "\\note Assumed same for both sides\n";
    ss << "\\note Assumed independent of incidence angle\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N3 , \\field Visible Transmittance\n";
    ss << "\\required-field\n";
    ss << "\\note Assumed independent of incidence angle\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N4 , \\field Visible Reflectance\n";
    ss << "\\required-field\n";
    ss << "\\note Assumed same for both sides\n";
    ss << "\\note Assumed independent of incidence angle\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N5 , \\field Infrared Hemispherical Emissivity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum> 0\n";
    ss << "N6 , \\field Infrared Transmittance\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "N7 , \\field Thickness\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units in\n";
    ss << "N8 , \\field Conductivity\n";
    ss << "\\required-field\n";
    ss << "\\units W/m-K\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "N9 , \\field Shade to Glass Distance\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.001\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.050\n";
    ss << "\\ip-units in\n";
    ss << "N10, \\field Top Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.5\n";
    ss << "N11, \\field Bottom Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.5\n";
    ss << "N12, \\field Left-Side Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.5\n";
    ss << "N13, \\field Right-Side Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.5\n";
    ss << "N14; \\field Airflow Permeability\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.8\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::WindowMaterial_Shade);
    OptionalIddObject oObj = IddObject::load("WindowMaterial:Shade",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowMaterial_Shade);
  return object;
}

IddObject createWindowMaterial_ComplexShadeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowMaterial:ComplexShade,\n";
    ss << "\\memo Complex window shading layer thermal properties\n";
    ss << "\\min-fields 12\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WindowComplexShades\n";
    ss << "A2 , \\field Layer Type\n";
    ss << "\\type choice\n";
    ss << "\\key Venetian\n";
    ss << "\\key Woven\n";
    ss << "\\key Perforated\n";
    ss << "\\key BSDF\n";
    ss << "\\key OtherShadingType\n";
    ss << "\\default OtherShadingType\n";
    ss << "N1 , \\field Thickness\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.002\n";
    ss << "N2 , \\field Conductivity\n";
    ss << "\\units W/m-K\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1\n";
    ss << "N3 , \\field IR Transmittance\n";
    ss << "\\type real\n";
    ss << "\\maximum 1\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N4 , \\field Front Emissivity\n";
    ss << "\\type real\n";
    ss << "\\maximum 1\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.84\n";
    ss << "N5 , \\field Back Emissivity\n";
    ss << "\\type real\n";
    ss << "\\maximum 1\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.84\n";
    ss << "N6 , \\field Top Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "N7 , \\field Bottom Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "N8 , \\field Left Side Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "N9 , \\field Right Side Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "N10 , \\field Front Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.05\n";
    ss << "N11 , \\field Slat Width\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.016\n";
    ss << "N12 , \\field Slat Spacing\n";
    ss << "\\note Distance between adjacent slat faces\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.012\n";
    ss << "N13 , \\field Slat Thickness\n";
    ss << "\\note Distance between top and bottom surfaces of slat\n";
    ss << "\\note Slat is assumed to be rectangular in cross section and flat\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.0006\n";
    ss << "N14 , \\field Slat Angle\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 90\n";
    ss << "\\minimum -90\n";
    ss << "\\maximum 90\n";
    ss << "N15 , \\field Slat Conductivity\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 160.0\n";
    ss << "N16 ; \\field Slat Curve\n";
    ss << "\\note this value represents curvature radius of the slat.\n";
    ss << "\\note if the slat is flat use zero.\n";
    ss << "\\note if this value is not zero, then it must be > SlatWidth/2.\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0\n";

    IddObjectType objType(IddObjectType::WindowMaterial_ComplexShade);
    OptionalIddObject oObj = IddObject::load("WindowMaterial:ComplexShade",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowMaterial_ComplexShade);
  return object;
}

IddObject createWindowMaterial_BlindIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowMaterial:Blind,\n";
    ss << "\\memo Window blind thermal properties\n";
    ss << "\\min-fields 29\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference MaterialName\n";
    ss << "\\reference WindowShadesScreensAndBlinds\n";
    ss << "A2 , \\field Slat Orientation\n";
    ss << "\\type choice\n";
    ss << "\\key Horizontal\n";
    ss << "\\key Vertical\n";
    ss << "\\default Horizontal\n";
    ss << "N1 , \\field Slat Width\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "\\ip-units in\n";
    ss << "N2 , \\field Slat Separation\n";
    ss << "\\required-field\n";
    ss << "\\note Distance between adjacent slat faces\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "\\ip-units in\n";
    ss << "N3 , \\field Slat Thickness\n";
    ss << "\\note Distance between top and bottom surfaces of slat\n";
    ss << "\\note Slat is assumed to be rectangular in cross section and flat\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 0.1\n";
    ss << "\\default 0.00025\n";
    ss << "\\ip-units in\n";
    ss << "N4 , \\field Slat Angle\n";
    ss << "\\note If WindowProperty:ShadingControl for the window that incorporates this blind\n";
    ss << "\\note has Type of Slat Angle Control for Blinds = FixedSlatAngle,\n";
    ss << "\\note then this is the fixed value of the slat angle;\n";
    ss << "\\note If WindowProperty:ShadingControl for the window that incorporates this blind\n";
    ss << "\\note has Type of Slat Angle Control for Blinds = BlockBeamSolar,\n";
    ss << "\\note then this is the slat angle when slat angle control\n";
    ss << "\\note is not in effect (e.g., when there is no beam solar on the blind);\n";
    ss << "\\note Not used if WindowProperty:ShadingControl for the window that incorporates this blind\n";
    ss << "\\note has Type of Slat Angle Control for Blinds = ScheduledSlatAngle.\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 45\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "N5 , \\field Slat Conductivity\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 221.0\n";
    ss << "\\note default is for aluminum\n";
    ss << "N6 , \\field Slat Beam Solar Transmittance\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N7 , \\field Front Side Slat Beam Solar Reflectance\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "N8 , \\field Back Side Slat Beam Solar Reflectance\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "N9 , \\field Slat Diffuse Solar Transmittance\n";
    ss << "\\note Must equal \"Slat beam solar transmittance\"\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N10, \\field Front Side Slat Diffuse Solar Reflectance\n";
    ss << "\\note Must equal \"Front Side Slat Beam Solar Reflectance\"\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "N11, \\field Back Side Slat Diffuse Solar Reflectance\n";
    ss << "\\note Must equal \"Back Side Slat Beam Solar Reflectance\"\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "N12, \\field Slat Beam Visible Transmittance\n";
    ss << "\\note Required for detailed daylighting calculation\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N13, \\field Front Side Slat Beam Visible Reflectance\n";
    ss << "\\note Required for detailed daylighting calculation\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "N14, \\field Back Side Slat Beam Visible Reflectance\n";
    ss << "\\note Required for detailed daylighting calculation\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "N15, \\field Slat Diffuse Visible Transmittance\n";
    ss << "\\note Used only for detailed daylighting calculation\n";
    ss << "\\note Must equal \"Slat Beam Visible Transmittance\"\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N16, \\field Front Side Slat Diffuse Visible Reflectance\n";
    ss << "\\note Required for detailed daylighting calculation\n";
    ss << "\\note Must equal \"Front Side Slat Beam Visible Reflectance\"\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "N17, \\field Back Side Slat Diffuse Visible Reflectance\n";
    ss << "\\note Required for detailed daylighting calculation\n";
    ss << "\\note Must equal \"Back Side Slat Beam Visible Reflectance\"\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "N18, \\field Slat Infrared Hemispherical Transmittance\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N19, \\field Front Side Slat Infrared Hemispherical Emissivity\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.9\n";
    ss << "N20, \\field Back Side Slat Infrared Hemispherical Emissivity\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.9\n";
    ss << "N21, \\field Blind to Glass Distance\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.01\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.050\n";
    ss << "\\ip-units in\n";
    ss << "N22, \\field Blind Top Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.5\n";
    ss << "N23, \\field Blind Bottom Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N24, \\field Blind Left Side Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.5\n";
    ss << "N25, \\field Blind Right Side Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.5\n";
    ss << "N26, \\field Minimum Slat Angle\n";
    ss << "\\note Used only if WindowProperty:ShadingControl for the window that incorporates\n";
    ss << "\\note this blind varies the slat angle (i.e., WindowProperty:ShadingControl with\n";
    ss << "\\note Type of Slat Angle Control for Blinds = ScheduledSlatAngle\n";
    ss << "\\note or BlockBeamSolar)\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 0\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "N27; \\field Maximum Slat Angle\n";
    ss << "\\note Used only if WindowProperty:ShadingControl for the window that incorporates\n";
    ss << "\\note this blind varies the slat angle (i.e., WindowProperty:ShadingControl with\n";
    ss << "\\note Type of Slat Angle Control for Blinds = ScheduledSlatAngle\n";
    ss << "\\note or BlockBeamSolar)\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 180\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";

    IddObjectType objType(IddObjectType::WindowMaterial_Blind);
    OptionalIddObject oObj = IddObject::load("WindowMaterial:Blind",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowMaterial_Blind);
  return object;
}

IddObject createWindowMaterial_ScreenIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowMaterial:Screen,\n";
    ss << "\\memo Window screen physical properties. Can only be located on the exterior side of a window construction.\n";
    ss << "\\min-fields 9\n";
    ss << "A1 , \\field Name\n";
    ss << "\\note Enter a unique name for this window screen material.\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference MaterialName\n";
    ss << "\\reference WindowShadesScreensAndBlinds\n";
    ss << "A2 , \\field Reflected Beam Transmittance Accounting Method\n";
    ss << "\\note Select the method used to account for the beam solar reflected off the material surface.\n";
    ss << "\\type choice\n";
    ss << "\\key DoNotModel\n";
    ss << "\\key ModelAsDirectBeam\n";
    ss << "\\key ModelAsDiffuse\n";
    ss << "\\default ModelAsDiffuse\n";
    ss << "N1 , \\field Diffuse Solar Reflectance\n";
    ss << "\\note Diffuse reflectance of the screen material over the entire solar radiation spectrum.\n";
    ss << "\\note Assumed to be the same for both sides of the screen.\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N2 , \\field Diffuse Visible Reflectance\n";
    ss << "\\note Diffuse visible reflectance of the screen material averaged over the solar spectrum\n";
    ss << "\\note and weighted by the response of the human eye.\n";
    ss << "\\note Assumed to be the same for both sides of the screen.\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N3 , \\field Thermal Hemispherical Emissivity\n";
    ss << "\\note Long-wave emissivity of the screen material.\n";
    ss << "\\note Assumed to be the same for both sides of the screen.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.9\n";
    ss << "N4 , \\field Conductivity\n";
    ss << "\\note Thermal conductivity of the screen material.\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 221.0\n";
    ss << "\\note Default is for aluminum.\n";
    ss << "N5 , \\field Screen Material Spacing\n";
    ss << "\\note Spacing assumed to be the same in both directions.\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units in\n";
    ss << "N6 , \\field Screen Material Diameter\n";
    ss << "\\note Diameter assumed to be the same in both directions.\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units in\n";
    ss << "N7 , \\field Screen to Glass Distance\n";
    ss << "\\note Distance from the window screen to the adjacent glass surface.\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.001\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.025\n";
    ss << "\\ip-units in\n";
    ss << "N8 , \\field Top Opening Multiplier\n";
    ss << "\\note Effective area for air flow at the top of the screen divided by the perpendicular\n";
    ss << "\\note area between the glass and the top of the screen.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N9 , \\field Bottom Opening Multiplier\n";
    ss << "\\note Effective area for air flow at the bottom of the screen divided by the perpendicular\n";
    ss << "\\note area between the glass and the bottom of the screen.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N10, \\field Left Side Opening Multiplier\n";
    ss << "\\note Effective area for air flow at the left side of the screen divided by the perpendicular\n";
    ss << "\\note area between the glass and the left side of the screen.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N11, \\field Right Side Opening Multiplier\n";
    ss << "\\note Effective area for air flow at the right side of the screen divided by the perpendicular\n";
    ss << "\\note area between the glass and the right side of the screen.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N12; \\field Angle of Resolution for Screen Transmittance Output Map\n";
    ss << "\\note Select the resolution of azimuth and altitude angles for the screen transmittance map.\n";
    ss << "\\note A value of 0 means no transmittance map will be generated.\n";
    ss << "\\note Valid values for this field are 0, 1, 2, 3 and 5.\n";
    ss << "\\type choice\n";
    ss << "\\units deg\n";
    ss << "\\key 0\n";
    ss << "\\key 1\n";
    ss << "\\key 2\n";
    ss << "\\key 3\n";
    ss << "\\key 5\n";
    ss << "\\default 0\n";

    IddObjectType objType(IddObjectType::WindowMaterial_Screen);
    OptionalIddObject oObj = IddObject::load("WindowMaterial:Screen",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowMaterial_Screen);
  return object;
}

IddObject createWindowMaterial_Shade_EquivalentLayerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowMaterial:Shade:EquivalentLayer,\n";
    ss << "\\memo Specifies the properties of equivalent layer window shade material\n";
    ss << "\\memo Shades are considered to be perfect diffusers (all transmitted and\n";
    ss << "\\memo reflected radiation is hemispherically-diffuse) independent of angle\n";
    ss << "\\memo  of incidence.  Shade represents roller blinds.\n";
    ss << "\\min-fields 6\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WindowEquivalentLayerMaterialNames\n";
    ss << "N1 , \\field Shade Beam-Beam Solar Transmittance\n";
    ss << "\\note The beam-beam solar transmittance at normal incidence.  This value is\n";
    ss << "\\note the same as the openness area fraction of the shade material. Assumed\n";
    ss << "\\note to be the same for front and back sides.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.8\n";
    ss << "\\default 0.0\n";
    ss << "N2 , \\field Front Side Shade Beam-Diffuse Solar Transmittance\n";
    ss << "\\required-field\n";
    ss << "\\note The front side beam-diffuse solar transmittance at normal incidence averaged\n";
    ss << "\\note over the entire spectrum of solar radiation.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N3 , \\field Back Side Shade Beam-Diffuse Solar Transmittance\n";
    ss << "\\required-field\n";
    ss << "\\note The back side beam-diffuse solar transmittance at normal incidence averaged\n";
    ss << "\\note over the entire spectrum of solar radiation.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N4 , \\field Front Side Shade Beam-Diffuse Solar Reflectance\n";
    ss << "\\required-field\n";
    ss << "\\note The front side beam-diffuse solar reflectance at normal incidence averaged\n";
    ss << "\\note over the entire spectrum of solar radiation.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N5 , \\field Back Side Shade Beam-Diffuse Solar Reflectance\n";
    ss << "\\required-field\n";
    ss << "\\note The back side beam-diffuse solar reflectance at normal incidence averaged\n";
    ss << "\\note over the entire spectrum of solar radiation.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N6 , \\field Shade Beam-Beam Visible Transmittance at Normal Incidence\n";
    ss << "\\note The beam-beam visible transmittance at normal incidence averaged over the\n";
    ss << "\\note visible spectrum range of solar radiation. Assumed to be the same for\n";
    ss << "\\note front and back sides of the shade.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N7 , \\field Shade Beam-Diffuse Visible Transmittance at Normal Incidence\n";
    ss << "\\note The beam-diffuse visible transmittance at normal incidence averaged over the\n";
    ss << "\\note visible spectrum range of solar radiation. Assumed to be the same for\n";
    ss << "\\note front and back sides of the shade.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N8 , \\field Shade Beam-Diffuse Visible Reflectance at Normal Incidence\n";
    ss << "\\note The beam-diffuse visible reflectance at normal incidence averaged over the\n";
    ss << "\\note visible spectrum range of solar radiation. Assumed to be the same for\n";
    ss << "\\note front and back sides of the shade.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N9 , \\field Shade Material Infrared Transmittance\n";
    ss << "\\note The long-wave transmittance of the shade material at zero shade openness.\n";
    ss << "\\note Assumed to be the same for front and back sides of the shade.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.05\n";
    ss << "N10, \\field Front Side Shade Material Infrared Emissivity\n";
    ss << "\\note The front side long-wave emissivity of the shade material at zero shade\n";
    ss << "\\note openness. Openness fraction is used to calculate the effective emissivity\n";
    ss << "\\note value.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.91\n";
    ss << "N11; \\field Back Side Shade Material Infrared Emissivity\n";
    ss << "\\note The back side long-wave emissivity of the shade material at zero shade\n";
    ss << "\\note openness. Openness fraction is used to calculate the effective emissivity\n";
    ss << "\\note value.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.91\n";

    IddObjectType objType(IddObjectType::WindowMaterial_Shade_EquivalentLayer);
    OptionalIddObject oObj = IddObject::load("WindowMaterial:Shade:EquivalentLayer",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowMaterial_Shade_EquivalentLayer);
  return object;
}

IddObject createWindowMaterial_Drape_EquivalentLayerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowMaterial:Drape:EquivalentLayer,\n";
    ss << "\\memo Specifies the properties of equivalent layer drape fabric materials.\n";
    ss << "\\memo Shades are considered to be perfect diffusers (all transmitted and reflected\n";
    ss << "\\memo radiation is hemispherically-diffuse) independent of angle of incidence.\n";
    ss << "\\memo unpleated drape fabric is treated as thin and flat layer.\n";
    ss << "\\min-fields 4\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WindowEquivalentLayerMaterialNames\n";
    ss << "N1 , \\field Drape Beam-Beam Solar Transmittance at Normal Incidence\n";
    ss << "\\note The beam-beam solar transmittance at normal incidence. This value is the\n";
    ss << "\\note same as the openness area fraction of the drape fabric. Assumed to be\n";
    ss << "\\note same for front and back sides.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.2\n";
    ss << "\\default 0.0\n";
    ss << "N2 , \\field Front Side Drape Beam-Diffuse Solar Transmittance\n";
    ss << "\\required-field\n";
    ss << "\\note The front side beam-diffuse solar transmittance at normal incidence averaged\n";
    ss << "\\note over the entire spectrum of solar radiation. Assumed to be the same for front\n";
    ss << "\\note and back sides.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N3 , \\field Back Side Drape Beam-Diffuse Solar Transmittance\n";
    ss << "\\required-field\n";
    ss << "\\note The back side beam-diffuse solar transmittance at normal incidence averaged\n";
    ss << "\\note over the entire spectrum of solar radiation. Assumed to be the same for front\n";
    ss << "\\note and back sides.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N4 , \\field Front Side Drape Beam-Diffuse Solar Reflectance\n";
    ss << "\\required-field\n";
    ss << "\\note The front side beam-diffuse solar reflectance at normal incidence averaged\n";
    ss << "\\note over the entire spectrum of solar radiation.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N5 , \\field Back Side Drape Beam-Diffuse Solar Reflectance\n";
    ss << "\\required-field\n";
    ss << "\\note The back side beam-diffuse solar reflectance at normal incidence averaged\n";
    ss << "\\note over the entire spectrum of solar radiation.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N6 , \\field Drape Beam-Beam Visible Transmittance\n";
    ss << "\\note The beam-beam visible transmittance at normal incidence averaged over the\n";
    ss << "\\note visible spectrum of solar radiation. Assumed same for front and back sides.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N7 , \\field Drape Beam-Diffuse Visible Transmittance\n";
    ss << "\\note The beam-diffuse visible transmittance at normal incidence averaged over the\n";
    ss << "\\note visible spectrum range of solar radiation. Assumed to be the same for front\n";
    ss << "\\note and back sides.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N8 , \\field Drape Beam-Diffuse Visible Reflectance\n";
    ss << "\\note The beam-diffuse visible reflectance at normal incidence average over the\n";
    ss << "\\note visible spectrum range of solar radiation. Assumed to be the same for front\n";
    ss << "\\note and back sides.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N9 , \\field Drape Material Infrared Transmittance\n";
    ss << "\\note Long-wave transmittance of the drape fabric at zero openness fraction.\n";
    ss << "\\note Assumed same for front and back sides.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.05\n";
    ss << "N10, \\field Front Side Drape Material Infrared Emissivity\n";
    ss << "\\note Front side long-wave emissivity of the drape fabric at zero shade openness.\n";
    ss << "\\note Openness fraction specified above is used to calculate the effective\n";
    ss << "\\note emissivity value.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.87\n";
    ss << "N11, \\field Back Side Drape Material Infrared Emissivity\n";
    ss << "\\note Back side long-wave emissivity of the drape fabric at zero shade openness.\n";
    ss << "\\note Openness fraction specified above is used to calculate the effective\n";
    ss << "\\note emissivity value.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.87\n";
    ss << "N12, \\field Width of Pleated Fabric\n";
    ss << "\\note Width of the pleated section of the draped fabric. If the drape fabric is\n";
    ss << "\\note unpleated or is flat, then the pleated section width is set to zero.\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0\n";
    ss << "\\ip-units in\n";
    ss << "\\default 0\n";
    ss << "N13; \\field Length of Pleated Fabric\n";
    ss << "\\note Length of the pleated section of the draped fabric. If the drape fabric is\n";
    ss << "\\note unpleated or is flat, then the pleated section length is set to zero.\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0\n";
    ss << "\\ip-units in\n";
    ss << "\\default 0\n";

    IddObjectType objType(IddObjectType::WindowMaterial_Drape_EquivalentLayer);
    OptionalIddObject oObj = IddObject::load("WindowMaterial:Drape:EquivalentLayer",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowMaterial_Drape_EquivalentLayer);
  return object;
}

IddObject createWindowMaterial_Blind_EquivalentLayerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowMaterial:Blind:EquivalentLayer,\n";
    ss << "\\memo Window equivalent layer blind slat optical and thermal properties.\n";
    ss << "\\memo The model assumes that slats are thin and flat, applies correction\n";
    ss << "\\memo empirical correlation to account for curvature effect. Slats are\n";
    ss << "\\memo assumed to transmit and reflect diffusely.\n";
    ss << "\\min-fields 10\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WindowEquivalentLayerMaterialNames\n";
    ss << "A2 , \\field Slat Orientation\n";
    ss << "\\type choice\n";
    ss << "\\key Horizontal\n";
    ss << "\\key Vertical\n";
    ss << "\\default Horizontal\n";
    ss << "N1 , \\field Slat Width\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 0.025\n";
    ss << "\\ip-units in\n";
    ss << "N2 , \\field Slat Separation\n";
    ss << "\\required-field\n";
    ss << "\\note Distance between adjacent slat faces\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 0.025\n";
    ss << "\\ip-units in\n";
    ss << "N3 , \\field Slat Crown\n";
    ss << "\\note Perpendicular length between the cord and the curve.\n";
    ss << "\\note Slat is assumed to be rectangular in cross section\n";
    ss << "\\note and flat. Crown=0.0625xSlat width\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 0.00156\n";
    ss << "\\default 0.0015\n";
    ss << "\\ip-units in\n";
    ss << "N4 , \\field Slat Angle\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "\\default 45\n";
    ss << "N5 , \\field Front Side Slat Beam-Diffuse Solar Transmittance\n";
    ss << "\\note The front side beam-diffuse solar transmittance of the slat at normal\n";
    ss << "\\note incidence averaged over the entire spectrum of solar radiation.\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N6 , \\field Back Side Slat Beam-Diffuse Solar Transmittance\n";
    ss << "\\note The back side beam-diffuse solar transmittance of the slat at normal\n";
    ss << "\\note incidence averaged over the entire spectrum of solar radiation.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N7,  \\field Front Side Slat Beam-Diffuse Solar Reflectance\n";
    ss << "\\note The front side beam-diffuse solar reflectance of the slat at normal\n";
    ss << "\\note incidence averaged over the entire spectrum of solar radiation.\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "N8,  \\field Back Side Slat Beam-Diffuse Solar Reflectance\n";
    ss << "\\note The back side beam-diffuse solar reflectance of the slat at normal\n";
    ss << "\\note incidence averaged over the entire spectrum of solar radiation.\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "N9 , \\field Front Side Slat Beam-Diffuse Visible Transmittance\n";
    ss << "\\note The front side beam-diffuse visible transmittance of the slat\n";
    ss << "\\note at normal incidence averaged over the visible spectrum range\n";
    ss << "\\note of solar radiation.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N10, \\field Back Side Slat Beam-Diffuse Visible Transmittance\n";
    ss << "\\note The back side beam-diffuse visible transmittance of the slat\n";
    ss << "\\note at normal incidence averaged over the visible spectrum range\n";
    ss << "\\note of solar radiation.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N11, \\field Front Side Slat Beam-Diffuse Visible Reflectance\n";
    ss << "\\note The front side beam-diffuse visible reflectance of the slat\n";
    ss << "\\note at normal incidence averaged over the visible spectrum range\n";
    ss << "\\note of solar radiation.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "N12, \\field Back Side Slat Beam-Diffuse Visible Reflectance\n";
    ss << "\\note The back side beam-diffuse visible reflectance of the slat\n";
    ss << "\\note at normal incidence averaged over the visible spectrum range\n";
    ss << "\\note of solar radiation.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "N13, \\field Slat Diffuse-Diffuse Solar Transmittance\n";
    ss << "\\note The beam-diffuse solar transmittance of the slat averaged\n";
    ss << "\\note over the entire solar spectrum of solar radiation.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N14, \\field Front Side Slat Diffuse-Diffuse Solar Reflectance\n";
    ss << "\\note The front side beam-diffuse solar reflectance of the slat\n";
    ss << "\\note averaged over the entire solar spectrum of solar radiation.\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "N15, \\field Back Side Slat Diffuse-Diffuse Solar Reflectance\n";
    ss << "\\note The back side beam-diffuse solar reflectance of the slat\n";
    ss << "\\note averaged over the entire solar spectrum of solar radiation.\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "N16, \\field Slat Diffuse-Diffuse Visible Transmittance\n";
    ss << "\\note The beam-diffuse visible transmittance of the slat averaged\n";
    ss << "\\note over the visible spectrum range of solar radiation.\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "N17, \\field Front Side Slat Diffuse-Diffuse Visible Reflectance\n";
    ss << "\\note The front side beam-diffuse visible reflectance of the slat\n";
    ss << "\\note averaged over the visible spectrum range of solar radiation.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "N18, \\field Back Side Slat Diffuse-Diffuse Visible Reflectance\n";
    ss << "\\note The back side beam-diffuse visible reflectance of the slat\n";
    ss << "\\note averaged over the visible spectrum range of solar radiation.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "N19, \\field Slat Infrared Transmittance\n";
    ss << "\\note Long-wave hemispherical transmittance of the slat material.\n";
    ss << "\\note Assumed to be the same for both sides of the slat.\n";
    ss << "\\type real\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N20, \\field Front Side Slat Infrared Emissivity\n";
    ss << "\\note Front side long-wave hemispherical emissivity of the slat material.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.9\n";
    ss << "N21, \\field Back Side Slat Infrared Emissivity\n";
    ss << "\\note Back side long-wave hemispherical emissivity of the slat material.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.9\n";
    ss << "A3;  \\field Slat Angle Control\n";
    ss << "\\note Used only if slat angle control is desired to either maximize solar\n";
    ss << "\\note gain (MaximizeSolar), maximize visibility while eliminating beam solar\n";
    ss << "\\note radiation (BlockBeamSolar), or fixed slate angle (FixedSlatAngle).\n";
    ss << "\\note If FixedSlatAngle is selected, the slat angle entered above is used.\n";
    ss << "\\type choice\n";
    ss << "\\key FixedSlatAngle\n";
    ss << "\\key MaximizeSolar\n";
    ss << "\\key BlockBeamSolar\n";
    ss << "\\default FixedSlatAngle\n";

    IddObjectType objType(IddObjectType::WindowMaterial_Blind_EquivalentLayer);
    OptionalIddObject oObj = IddObject::load("WindowMaterial:Blind:EquivalentLayer",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowMaterial_Blind_EquivalentLayer);
  return object;
}

IddObject createWindowMaterial_Screen_EquivalentLayerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowMaterial:Screen:EquivalentLayer,\n";
    ss << "\\memo Equivalent layer window screen physical properties. Can only be\n";
    ss << "\\memo located on the exterior side of a window construction.\n";
    ss << "\\min-fields 4\n";
    ss << "A1 , \\field Name\n";
    ss << "\\note Enter a unique name for this window screen material.\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WindowEquivalentLayerMaterialNames\n";
    ss << "N1 , \\field Screen Beam-Beam Solar Transmittance\n";
    ss << "\\note The beam-beam transmittance of the screen material at normal incidence.\n";
    ss << "\\note This input field is the same as the material openness area fraction\n";
    ss << "\\note and can be autocalculated from the wire spacing and wire and diameter.\n";
    ss << "\\note Assumed to be the same for both sides of the screen.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "N2 , \\field Screen Beam-Diffuse Solar Transmittance\n";
    ss << "\\note The beam-diffuse solar transmittance of the screen material at normal\n";
    ss << "\\note incidence averaged over the entire spectrum of solar radiation.\n";
    ss << "\\note Assumed to be the same for both sides of the screen.\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N3 , \\field Screen Beam-Diffuse Solar Reflectance\n";
    ss << "\\note The beam-diffuse solar reflectance of the screen material at normal\n";
    ss << "\\note incidence averaged over the entire spectrum of solar radiation.\n";
    ss << "\\note Assumed to be the same for both sides of the screen.\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N4 , \\field Screen Beam-Beam Visible Transmittance\n";
    ss << "\\note The beam-beam visible transmittance of the screen material at normal\n";
    ss << "\\note incidence averaged over the visible spectrum range of solar radiation.\n";
    ss << "\\note Assumed to be the same for both sides of the screen.\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N5 , \\field Screen Beam-Diffuse Visible Transmittance\n";
    ss << "\\note The beam-diffuse visible transmittance of the screen material at normal\n";
    ss << "\\note incidence averaged over the visible spectrum range of solar radiation.\n";
    ss << "\\note Assumed to be the same for both sides of the screen.\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N6 , \\field Screen Beam-Diffuse Visible Reflectance\n";
    ss << "\\note Beam-diffuse visible reflectance of the screen material at normal\n";
    ss << "\\note incidence averaged over the visible spectrum range of solar radiation.\n";
    ss << "\\note Assumed to be the same for both sides of the screen.\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N7 , \\field Screen Infrared Transmittance\n";
    ss << "\\note The long-wave hemispherical transmittance of the screen material.\n";
    ss << "\\note Assumed to be the same for both sides of the screen.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "\\default 0.02\n";
    ss << "N8 , \\field Screen Infrared Emissivity\n";
    ss << "\\note The long-wave hemispherical emissivity of the screen material.\n";
    ss << "\\note Assumed to be the same for both sides of the screen.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum< 1\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.93\n";
    ss << "N9 , \\field Screen Wire Spacing\n";
    ss << "\\note Spacing assumed to be the same in both directions.\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units in\n";
    ss << "\\default 0.025\n";
    ss << "N10; \\field Screen Wire Diameter\n";
    ss << "\\note Diameter assumed to be the same in both directions.\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units in\n";
    ss << "\\default 0.005\n";

    IddObjectType objType(IddObjectType::WindowMaterial_Screen_EquivalentLayer);
    OptionalIddObject oObj = IddObject::load("WindowMaterial:Screen:EquivalentLayer",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowMaterial_Screen_EquivalentLayer);
  return object;
}

IddObject createWindowMaterial_Glazing_EquivalentLayerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowMaterial:Glazing:EquivalentLayer,\n";
    ss << "\\min-fields 11\n";
    ss << "\\memo Glass material properties for Windows or Glass Doors\n";
    ss << "\\memo Transmittance/Reflectance input method.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WindowEquivalentLayerMaterialNames\n";
    ss << "A2 , \\field Optical Data Type\n";
    ss << "\\type choice\n";
    ss << "\\key SpectralAverage\n";
    ss << "\\default SpectralAverage\n";
    ss << "A3 , \\field Window Glass Spectral Data Set Name\n";
    ss << "\\note Used only when Optical Data Type = Spectral\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpectralDataSets\n";
    ss << "N1 , \\field Front Side Beam-Beam Solar Transmittance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N2 , \\field Back Side Beam-Beam Solar Transmittance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N3 , \\field Front Side Beam-Beam Solar Reflectance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\note Front Side is side closest to outdoor air\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N4 , \\field Back Side Beam-Beam Solar Reflectance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\note Back Side is side closest to zone air\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N5 , \\field Front Side Beam-Beam Visible Solar Transmittance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N6 , \\field Back Side Beam-Beam Visible Solar Transmittance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N7 , \\field Front Side Beam-Beam Visible Solar Reflectance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\note Front Side is side closest to outdoor air\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N8 , \\field Back Side Beam-Beam Visible Solar Reflectance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\note Back Side is side closest to zone air\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N9 , \\field Front Side Beam-Diffuse Solar Transmittance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N10, \\field Back Side Beam-Diffuse Solar Transmittance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N11, \\field Front Side Beam-Diffuse Solar Reflectance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\note Front Side is side closest to outdoor air\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N12, \\field Back Side Beam-Diffuse Solar Reflectance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\note Back Side is side closest to zone air\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units dimensionless\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N13, \\field Front Side Beam-Diffuse Visible Solar Transmittance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N14, \\field Back Side Beam-Diffuse Visible Solar Transmittance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N15, \\field Front Side Beam-Diffuse Visible Solar Reflectance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\note Front Side is side closest to outdoor air\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N16, \\field Back Side Beam-Diffuse Visible Solar Reflectance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\note Back Side is side closest to zone air\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N17, \\field Diffuse-Diffuse Solar Transmittance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\note If this field is autocalculate, then the diffuse-diffuse solar\n";
    ss << "\\note transmittance is automatically estimated from other inputs and used\n";
    ss << "\\note in subsequent calculations. If this field is zero or positive, then\n";
    ss << "\\note the value entered here will be used.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "N18, \\field Front Side Diffuse-Diffuse Solar Reflectance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\note If this field is autocalculate, then the front diffuse-diffuse solar\n";
    ss << "\\note reflectance is automatically estimated from other inputs and used in\n";
    ss << "\\note subsequent calculations. If this field is zero or positive, then the value\n";
    ss << "\\note entered here will be used.  Front Side is side closest to outdoor air.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "N19, \\field Back Side Diffuse-Diffuse Solar Reflectance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\note If this field is autocalculate, then the back diffuse-diffuse solar\n";
    ss << "\\note reflectance is automatically estimated from other inputs and used in\n";
    ss << "\\note subsequent calculations. If this field is zero or positive, then the value\n";
    ss << "\\note entered here will be used.  Back side is side closest to indoor air.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "N20, \\field Diffuse-Diffuse Visible Solar Transmittance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\note This input field is not used currently.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "N21,  \\field Front Side Diffuse-Diffuse Visible Solar Reflectance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\note This input field is not used currently.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "N22, \\field Back Side Diffuse-Diffuse Visible Solar Reflectance\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\note This input field is not used currently.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "N23, \\field Infrared Transmittance (applies to front and back)\n";
    ss << "\\note The long-wave hemispherical transmittance of the glazing.\n";
    ss << "\\note Assumed to be the same for both sides of the glazing.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N24, \\field Front Side Infrared Emissivity\n";
    ss << "\\note The front side long-wave hemispherical emissivity of the glazing.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\default 0.84\n";
    ss << "N25; \\field Back Side Infrared Emissivity\n";
    ss << "\\note The back side long-wave hemispherical emissivity of the glazing.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\default 0.84\n";

    IddObjectType objType(IddObjectType::WindowMaterial_Glazing_EquivalentLayer);
    OptionalIddObject oObj = IddObject::load("WindowMaterial:Glazing:EquivalentLayer",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowMaterial_Glazing_EquivalentLayer);
  return object;
}

IddObject createWindowMaterial_Gap_EquivalentLayerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowMaterial:Gap:EquivalentLayer,\n";
    ss << "\\memo Gas material properties that are used in Windows Equivalent Layer\n";
    ss << "\\memo References only WindowMaterial:Gas properties\n";
    ss << "\\min-fields 3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WindowEquivalentLayerMaterialNames\n";
    ss << "A2 , \\field Gas Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key AIR\n";
    ss << "\\key ARGON\n";
    ss << "\\key KRYPTON\n";
    ss << "\\key XENON\n";
    ss << "\\key CUSTOM\n";
    ss << "N1 , \\field Thickness\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units in\n";
    ss << "A3 , \\field Gap Vent Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Sealed\n";
    ss << "\\key VentedIndoor\n";
    ss << "\\key VentedOutdoor\n";
    ss << "\\reference GapVentTypeName\n";
    ss << "\\note Sealed means the gap is enclosed and gas tight, i.e., no venting to indoor or\n";
    ss << "\\note outdoor environment.  VentedIndoor means the gap is vented to indoor environment, and\n";
    ss << "\\note VentedOutdoor means the gap is vented to the outdoor environment. The gap types\n";
    ss << "\\note VentedIndoor and VentedOutdoor are used with gas type Air only.\n";
    ss << "N2 , \\field Conductivity Coefficient A\n";
    ss << "\\units W/m-K\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "N3 , \\field Conductivity Coefficient B\n";
    ss << "\\units W/m-K2\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "N4 , \\field Conductivity Coefficient C\n";
    ss << "\\units W/m-K3\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "N5 , \\field Viscosity Coefficient A\n";
    ss << "\\units kg/m-s\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "\\minimum> 0.0\n";
    ss << "N6 , \\field Viscosity Coefficient B\n";
    ss << "\\units kg/m-s-K\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "N7 , \\field Viscosity Coefficient C\n";
    ss << "\\units kg/m-s-K2\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "N8 , \\field Specific Heat Coefficient A\n";
    ss << "\\units J/kg-K\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "\\minimum> 0.0\n";
    ss << "N9 , \\field Specific Heat Coefficient B\n";
    ss << "\\units J/kg-K2\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "N10 ,\\field Specific Heat Coefficient C\n";
    ss << "\\units J/kg-K3\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "N11 ,\\field Molecular Weight\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "\\units g/mol\n";
    ss << "\\minimum 20.0\n";
    ss << "\\maximum 200.0\n";
    ss << "N12 ;\\field Specific Heat Ratio\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "\\minimum> 1.0\n";

    IddObjectType objType(IddObjectType::WindowMaterial_Gap_EquivalentLayer);
    OptionalIddObject oObj = IddObject::load("WindowMaterial:Gap:EquivalentLayer",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowMaterial_Gap_EquivalentLayer);
  return object;
}

IddObject createMaterialProperty_MoisturePenetrationDepth_SettingsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "MaterialProperty:MoisturePenetrationDepth:Settings,\n";
    ss << "\\memo Additional properties for moisture using EMPD procedure\n";
    ss << "\\memo HeatBalanceAlgorithm choice=MoisturePenetrationDepthConductionTransferFunction only\n";
    ss << "\\memo Has no effect with other HeatBalanceAlgorithm solution algorithms\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MaterialName\n";
    ss << "\\note Material Name that the moisture properties will be added to.\n";
    ss << "\\note Additional material properties required to perform the EMPD model.\n";
    ss << "\\note Effective Mean Penetration Depth (EMPD)\n";
    ss << "N1 , \\field Moisture Penetration Depth\n";
    ss << "\\required-field\n";
    ss << "\\note This is the penetration depth\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Moisture Equation Coefficient a\n";
    ss << "\\required-field\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Moisture Equation Coefficient b\n";
    ss << "\\required-field\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Moisture Equation Coefficient c\n";
    ss << "\\required-field\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "N5 ; \\field Moisture Equation Coefficient d\n";
    ss << "\\required-field\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::MaterialProperty_MoisturePenetrationDepth_Settings);
    OptionalIddObject oObj = IddObject::load("MaterialProperty:MoisturePenetrationDepth:Settings",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::MaterialProperty_MoisturePenetrationDepth_Settings);
  return object;
}

IddObject createMaterialProperty_PhaseChangeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "MaterialProperty:PhaseChange,\n";
    ss << "\\memo Additional properties for temperature dependent thermal conductivity\n";
    ss << "\\memo and enthalpy for Phase Change Materials (PCM)\n";
    ss << "\\memo HeatBalanceAlgorithm = CondFD(ConductionFiniteDifference) solution algorithm only.\n";
    ss << "\\memo Constructions with this should use the detailed CondFD process.\n";
    ss << "\\memo Has no effect with other HeatBalanceAlgorithm solution algorithms\n";
    ss << "\\extensible:2\n";
    ss << "\\max-fields 34\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MaterialName\n";
    ss << "\\note Regular Material Name to which the additional properties will be added.\n";
    ss << "\\note this the material name for the basic material properties.\n";
    ss << "N1 , \\field Temperature Coefficient for Thermal Conductivity\n";
    ss << "\\note The base temperature is 20C.\n";
    ss << "\\note This is the thermal conductivity change per degree excursion from 20C.\n";
    ss << "\\note This variable conductivity function is overridden by the VariableThermalConductivity object, if present.\n";
    ss << "\\units W/m-K2\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "N2 , \\field Temperature 1\n";
    ss << "\\note for Temperature-enthalpy function\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "\\begin-extensible\n";
    ss << "N3;  \\field Enthalpy 1\n";
    ss << "\\note for Temperature-enthalpy function corresponding to temperature 1\n";
    ss << "\\units J/kg\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::MaterialProperty_PhaseChange);
    OptionalIddObject oObj = IddObject::load("MaterialProperty:PhaseChange",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::MaterialProperty_PhaseChange);
  return object;
}

IddObject createMaterialProperty_VariableThermalConductivityIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "MaterialProperty:VariableThermalConductivity,\n";
    ss << "\\memo Additional properties for temperature dependent thermal conductivity\n";
    ss << "\\memo using piecewise linear temperature-conductivity function.\n";
    ss << "\\memo HeatBalanceAlgorithm = CondFD(ConductionFiniteDifference) solution algorithm only.\n";
    ss << "\\memo Has no effect with other HeatBalanceAlgorithm solution algorithms\n";
    ss << "\\extensible:2\n";
    ss << "\\max-fields 21\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MaterialName\n";
    ss << "\\note Regular Material Name to which the additional properties will be added.\n";
    ss << "\\note this the material name for the basic material properties.\n";
    ss << "N1 , \\field Temperature 1\n";
    ss << "\\note for Temperature-Thermal Conductivity function\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "\\begin-extensible\n";
    ss << "N2;  \\field Thermal Conductivity 1\n";
    ss << "\\note for Temperature-Thermal Conductivity function corresponding to temperature 1\n";
    ss << "\\units W/m-K\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::MaterialProperty_VariableThermalConductivity);
    OptionalIddObject oObj = IddObject::load("MaterialProperty:VariableThermalConductivity",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::MaterialProperty_VariableThermalConductivity);
  return object;
}

IddObject createMaterialProperty_HeatAndMoistureTransfer_SettingsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "MaterialProperty:HeatAndMoistureTransfer:Settings,\n";
    ss << "\\memo HeatBalanceAlgorithm = CombinedHeatAndMoistureFiniteElement solution algorithm only.\n";
    ss << "\\memo Additional material properties for surfaces.\n";
    ss << "\\memo Has no effect with other HeatBalanceAlgorithm solution algorithms\n";
    ss << "\\min-fields 3\n";
    ss << "A1, \\field Material Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MaterialName\n";
    ss << "\\note Material Name that the moisture properties will be added to.\n";
    ss << "\\note This augments material properties needed for combined heat and moisture transfer for surfaces.\n";
    ss << "N1, \\field Porosity\n";
    ss << "\\required-field\n";
    ss << "\\units m3/m3\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\type real\n";
    ss << "N2; \\field Initial Water Content Ratio\n";
    ss << "\\note units are the water/material density ratio at the beginning of each run period.\n";
    ss << "\\units kg/kg\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::MaterialProperty_HeatAndMoistureTransfer_Settings);
    OptionalIddObject oObj = IddObject::load("MaterialProperty:HeatAndMoistureTransfer:Settings",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::MaterialProperty_HeatAndMoistureTransfer_Settings);
  return object;
}

IddObject createMaterialProperty_HeatAndMoistureTransfer_SorptionIsothermIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "MaterialProperty:HeatAndMoistureTransfer:SorptionIsotherm,\n";
    ss << "\\memo HeatBalanceAlgorithm = CombinedHeatAndMoistureFiniteElement solution algorithm only.\n";
    ss << "\\memo Relationship between moisture content and relative humidity fraction.\n";
    ss << "\\memo Has no effect with other HeatBalanceAlgorithm solution algorithms\n";
    ss << "\\extensible:2\n";
    ss << "\\min-fields 4\n";
    ss << "\\max-fields 52\n";
    ss << "A1 , \\field Material Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MaterialName\n";
    ss << "\\note The Material Name that the moisture sorption isotherm will be added to.\n";
    ss << "N1,  \\field Number of Isotherm Coordinates\n";
    ss << "\\required-field\n";
    ss << "\\note Number of data Coordinates\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 25\n";
    ss << "\\type integer\n";
    ss << "N2, \\field Relative Humidity Fraction 1\n";
    ss << "\\required-field\n";
    ss << "\\note The relative humidity is entered as a fraction.\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "\\begin-extensible\n";
    ss << "N3; \\field Moisture Content 1\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units kg/m3\n";

    IddObjectType objType(IddObjectType::MaterialProperty_HeatAndMoistureTransfer_SorptionIsotherm);
    OptionalIddObject oObj = IddObject::load("MaterialProperty:HeatAndMoistureTransfer:SorptionIsotherm",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::MaterialProperty_HeatAndMoistureTransfer_SorptionIsotherm);
  return object;
}

IddObject createMaterialProperty_HeatAndMoistureTransfer_SuctionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "MaterialProperty:HeatAndMoistureTransfer:Suction,\n";
    ss << "\\memo HeatBalanceAlgorithm = CombinedHeatAndMoistureFiniteElement solution algorithm only.\n";
    ss << "\\memo Relationship between liquid suction transport coefficient and moisture content\n";
    ss << "\\memo Has no effect with other HeatBalanceAlgorithm solution algorithms\n";
    ss << "\\extensible:2\n";
    ss << "\\min-fields 4\n";
    ss << "\\max-fields 52\n";
    ss << "A1 , \\field Material Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MaterialName\n";
    ss << "\\note Material Name that the moisture properties will be added to.\n";
    ss << "N1,  \\field Number of Suction points\n";
    ss << "\\required-field\n";
    ss << "\\note Number of Suction Liquid Transport Coefficient coordinates\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 25\n";
    ss << "\\type integer\n";
    ss << "N2,\\field Moisture Content 1\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units kg/m3\n";
    ss << "\\begin-extensible\n";
    ss << "N3;\\field Liquid Transport Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units m2/s\n";

    IddObjectType objType(IddObjectType::MaterialProperty_HeatAndMoistureTransfer_Suction);
    OptionalIddObject oObj = IddObject::load("MaterialProperty:HeatAndMoistureTransfer:Suction",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::MaterialProperty_HeatAndMoistureTransfer_Suction);
  return object;
}

IddObject createMaterialProperty_HeatAndMoistureTransfer_RedistributionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "MaterialProperty:HeatAndMoistureTransfer:Redistribution,\n";
    ss << "\\memo HeatBalanceAlgorithm = CombinedHeatAndMoistureFiniteElement solution algorithm only.\n";
    ss << "\\memo Relationship between liquid transport coefficient and moisture content\n";
    ss << "\\memo Has no effect with other HeatBalanceAlgorithm solution algorithms\n";
    ss << "\\extensible:2\n";
    ss << "\\min-fields 4\n";
    ss << "\\max-fields 52\n";
    ss << "A1 , \\field Material Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MaterialName\n";
    ss << "\\note Moisture Material Name that the moisture properties will be added to.\n";
    ss << "N1,  \\field Number of Redistribution points\n";
    ss << "\\required-field\n";
    ss << "\\note number of data points\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 25\n";
    ss << "\\type integer\n";
    ss << "N2,\\field Moisture Content 1\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "\\units kg/m3\n";
    ss << "\\begin-extensible\n";
    ss << "N3;\\field Liquid Transport Coefficient 1\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "\\units m2/s\n";

    IddObjectType objType(IddObjectType::MaterialProperty_HeatAndMoistureTransfer_Redistribution);
    OptionalIddObject oObj = IddObject::load("MaterialProperty:HeatAndMoistureTransfer:Redistribution",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::MaterialProperty_HeatAndMoistureTransfer_Redistribution);
  return object;
}

IddObject createMaterialProperty_HeatAndMoistureTransfer_DiffusionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "MaterialProperty:HeatAndMoistureTransfer:Diffusion,\n";
    ss << "\\memo HeatBalanceAlgorithm = CombinedHeatAndMoistureFiniteElement solution algorithm only.\n";
    ss << "\\memo Relationship between water vapor diffusion and relative humidity fraction\n";
    ss << "\\memo Has no effect with other HeatBalanceAlgorithm solution algorithms\n";
    ss << "\\extensible:2\n";
    ss << "\\min-fields 4\n";
    ss << "\\max-fields 52\n";
    ss << "A1 , \\field Material Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MaterialName\n";
    ss << "\\note Moisture Material Name that the moisture properties will be added to.\n";
    ss << "N1,  \\field Number of Data Pairs\n";
    ss << "\\required-field\n";
    ss << "\\note Water Vapor Diffusion Resistance Factor\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 25\n";
    ss << "\\type integer\n";
    ss << "N2, \\field Relative Humidity Fraction 1\n";
    ss << "\\required-field\n";
    ss << "\\note The relative humidity is entered as a fraction.\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "\\begin-extensible\n";
    ss << "N3;\\field Water Vapor Diffusion Resistance Factor 1\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units dimensionless\n";

    IddObjectType objType(IddObjectType::MaterialProperty_HeatAndMoistureTransfer_Diffusion);
    OptionalIddObject oObj = IddObject::load("MaterialProperty:HeatAndMoistureTransfer:Diffusion",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::MaterialProperty_HeatAndMoistureTransfer_Diffusion);
  return object;
}

IddObject createMaterialProperty_HeatAndMoistureTransfer_ThermalConductivityIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "MaterialProperty:HeatAndMoistureTransfer:ThermalConductivity,\n";
    ss << "\\memo HeatBalanceAlgorithm = CombinedHeatAndMoistureFiniteElement solution algorithm only.\n";
    ss << "\\memo Relationship between thermal conductivity and moisture content\n";
    ss << "\\memo Has no effect with other HeatBalanceAlgorithm solution algorithms\n";
    ss << "\\extensible:2\n";
    ss << "\\min-fields 4\n";
    ss << "\\max-fields 52\n";
    ss << "A1 , \\field Material Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MaterialName\n";
    ss << "\\note Moisture Material Name that the Thermal Conductivity will be added to.\n";
    ss << "N1,  \\field Number of Thermal Coordinates\n";
    ss << "\\required-field\n";
    ss << "\\note number of data coordinates\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 25\n";
    ss << "\\type integer\n";
    ss << "N2, \\field Moisture Content 1\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units kg/m3\n";
    ss << "\\begin-extensible\n";
    ss << "N3; \\field Thermal Conductivity 1\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W/m-K\n";

    IddObjectType objType(IddObjectType::MaterialProperty_HeatAndMoistureTransfer_ThermalConductivity);
    OptionalIddObject oObj = IddObject::load("MaterialProperty:HeatAndMoistureTransfer:ThermalConductivity",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::MaterialProperty_HeatAndMoistureTransfer_ThermalConductivity);
  return object;
}

IddObject createMaterialProperty_GlazingSpectralDataIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "MaterialProperty:GlazingSpectralData,\n";
    ss << "\\memo Name is followed by up to 800 sets of normal-incidence measured values of\n";
    ss << "\\memo [wavelength, transmittance, front reflectance, back reflectance] for wavelengths\n";
    ss << "\\memo covering the solar spectrum (from about 0.25 to 2.5 microns)\n";
    ss << "\\format Spectral\n";
    ss << "\\extensible:4\n";
    ss << "\\min-fields 1\n";
    ss << "\\max-fields 3201\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SpectralDataSets\n";
    ss << "N1,  \\field Wavelength\n";
    ss << "\\begin-extensible\n";
    ss << "\\type real\n";
    ss << "\\units micron\n";
    ss << "N2,  \\field transmittance\n";
    ss << "N3,  \\field front reflectance\n";
    ss << "N4;  \\field back reflectance\n";

    IddObjectType objType(IddObjectType::MaterialProperty_GlazingSpectralData);
    OptionalIddObject oObj = IddObject::load("MaterialProperty:GlazingSpectralData",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::MaterialProperty_GlazingSpectralData);
  return object;
}

IddObject createConstructionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Construction,\n";
    ss << "\\memo Start with outside layer and work your way to the inside layer\n";
    ss << "\\memo Up to 10 layers total, 8 for windows\n";
    ss << "\\memo Enter the material name for each layer\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 1\n";
    ss << "\\max-fields 11\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConstructionNames\n";
    ss << "A2 ; \\field Layer\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MaterialName\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::Construction);
    OptionalIddObject oObj = IddObject::load("Construction",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Construction);
  return object;
}

IddObject createConstruction_CfactorUndergroundWallIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Construction:CfactorUndergroundWall,\n";
    ss << "\\memo Alternate method of describing underground wall constructions\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConstructionNames\n";
    ss << "N1 , \\field C-Factor\n";
    ss << "\\required-field\n";
    ss << "\\units W/m2-K\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Enter C-Factor without film coefficients or soil\n";
    ss << "N2 ; \\field Height\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Enter height of the underground wall\n";

    IddObjectType objType(IddObjectType::Construction_CfactorUndergroundWall);
    OptionalIddObject oObj = IddObject::load("Construction:CfactorUndergroundWall",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Construction_CfactorUndergroundWall);
  return object;
}

IddObject createConstruction_FfactorGroundFloorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Construction:FfactorGroundFloor,\n";
    ss << "\\memo Alternate method of describing slab-on-grade or underground floor constructions\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConstructionNames\n";
    ss << "N1 , \\field F-Factor\n";
    ss << "\\required-field\n";
    ss << "\\units W/m-K\n";
    ss << "\\ip-units Btu/h-ft-F\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2 , \\field Area\n";
    ss << "\\required-field\n";
    ss << "\\units m2\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Enter area of the floor\n";
    ss << "N3 ; \\field PerimeterExposed\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter exposed perimeter of the floor\n";

    IddObjectType objType(IddObjectType::Construction_FfactorGroundFloor);
    OptionalIddObject oObj = IddObject::load("Construction:FfactorGroundFloor",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Construction_FfactorGroundFloor);
  return object;
}

IddObject createConstruction_InternalSourceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Construction:InternalSource,\n";
    ss << "\\memo Start with outside layer and work your way to the inside Layer\n";
    ss << "\\memo Up to 10 layers total, 8 for windows\n";
    ss << "\\memo Enter the material name for each layer\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 6\n";
    ss << "\\max-fields 15\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConstructionNames\n";
    ss << "N1 , \\field Source Present After Layer Number\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\note refers to the list of materials which follows\n";
    ss << "N2 , \\field Temperature Calculation Requested After Layer Number\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\note refers to the list of materials which follows\n";
    ss << "N3 , \\field Dimensions for the CTF Calculation\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 2\n";
    ss << "\\note 1 = 1-dimensional calculation, 2 = 2-dimensional calculation\n";
    ss << "N4 , \\field Tube Spacing\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\note uniform spacing between tubes or resistance wires in direction\n";
    ss << "\\note perpendicular to main intended direction of heat transfer\n";
    ss << "A2 ; \\field Layer\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MaterialName\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::Construction_InternalSource);
    OptionalIddObject oObj = IddObject::load("Construction:InternalSource",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Construction_InternalSource);
  return object;
}

IddObject createWindowThermalModel_ParamsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowThermalModel:Params,\n";
    ss << "\\memo object is used to select which thermal model should be used in tarcog simulations\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WindowThermalModelParameters\n";
    ss << "A2 , \\field standard\n";
    ss << "\\type choice\n";
    ss << "\\key ISO15099\n";
    ss << "\\key EN673Declared\n";
    ss << "\\key EN673Design\n";
    ss << "\\default ISO15099\n";
    ss << "A3 , \\field Thermal Model\n";
    ss << "\\type choice\n";
    ss << "\\key ISO15099\n";
    ss << "\\key ScaledCavityWidth\n";
    ss << "\\key ConvectiveScalarModel_NoSDThickness\n";
    ss << "\\key ConvectiveScalarModel_withSDThickness\n";
    ss << "\\default ISO15099\n";
    ss << "N1 , \\field SDScalar\n";
    ss << "\\type real\n";
    ss << "\\minimum  0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1\n";
    ss << "A4 , \\field Deflection Model\n";
    ss << "\\type choice\n";
    ss << "\\key NoDeflection\n";
    ss << "\\key TemperatureAndPressureInput\n";
    ss << "\\key MeasuredDeflection\n";
    ss << "\\default NoDeflection\n";
    ss << "N2 , \\field Vacuum Pressure Limit\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 13.238\n";
    ss << "N3 , \\field Initial temperature\n";
    ss << "\\note This is temperature in time of window fabrication\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 25\n";
    ss << "N4 ; \\field Initial pressure\n";
    ss << "\\note This is pressure in time of window fabrication\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 101325\n";

    IddObjectType objType(IddObjectType::WindowThermalModel_Params);
    OptionalIddObject oObj = IddObject::load("WindowThermalModel:Params",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowThermalModel_Params);
  return object;
}

IddObject createConstruction_ComplexFenestrationStateIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Construction:ComplexFenestrationState,\n";
    ss << "\\memo Describes one state for a complex glazing system\n";
    ss << "\\memo These input objects are typically generated by using WINDOW software and export to IDF syntax\n";
    ss << "\\extensible:6\n";
    ss << "\\min-fields 12\n";
    ss << "\\max-fields 39\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ComplexFenestrationStates\n";
    ss << "A2 , \\field Basis Type\n";
    ss << "\\type choice\n";
    ss << "\\key LBNLWINDOW\n";
    ss << "\\key UserDefined\n";
    ss << "\\default LBNLWINDOW\n";
    ss << "A3 , \\field Basis Symmetry Type\n";
    ss << "\\type choice\n";
    ss << "\\key Axisymmetric\n";
    ss << "\\key None\n";
    ss << "\\default None\n";
    ss << "A4 , \\field Window Thermal Model\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowThermalModelParameters\n";
    ss << "A5 , \\field Basis Matrix Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DataMatrices\n";
    ss << "\\required-field\n";
    ss << "A6 , \\field Solar Optical Complex Front Transmittance Matrix Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DataMatrices\n";
    ss << "\\required-field\n";
    ss << "A7 , \\field Solar Optical Complex Back Reflectance Matrix Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DataMatrices\n";
    ss << "\\required-field\n";
    ss << "A8 , \\field Visible Optical Complex Front Transmittance Matrix Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DataMatrices\n";
    ss << "\\required-field\n";
    ss << "A9 , \\field Visible Optical Complex Back Transmittance Matrix Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DataMatrices\n";
    ss << "\\required-field\n";
    ss << "A10, \\field Layer Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CFSGlazingName\n";
    ss << "\\object-list WindowComplexShades\n";
    ss << "\\begin-extensible\n";
    ss << "A11, \\field Layer Directional Front Absoptance Matrix Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DataMatrices\n";
    ss << "A12, \\field Layer Directional Back Absoptance Matrix Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DataMatrices\n";
    ss << "A13, \\field Gap Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CFSGap\n";
    ss << "A14, \\field CFS Gap Directional Front Absoptance Matrix Name\n";
    ss << "\\note Reserved for future use. Leave it blank for this version\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DataMatrices\n";
    ss << "A15; \\field CFS Gap Directional Back Absoptance Matrix Name\n";
    ss << "\\note Reserved for future use. Leave it blank for this version\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DataMatrices\n";

    IddObjectType objType(IddObjectType::Construction_ComplexFenestrationState);
    OptionalIddObject oObj = IddObject::load("Construction:ComplexFenestrationState",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Construction_ComplexFenestrationState);
  return object;
}

IddObject createConstruction_WindowEquivalentLayerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Construction:WindowEquivalentLayer,\n";
    ss << "\\memo Start with outside layer and work your way to the inside Layer\n";
    ss << "\\memo Up to 11 layers total. Up to six solid layers and up to five gaps.\n";
    ss << "\\memo Enter the material name for each layer\n";
    ss << "\\min-fields 2\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConstructionNames\n";
    ss << "A2 , \\field Outside Layer\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowEquivalentLayerMaterialNames\n";
    ss << "A3 , \\field Layer 2\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowEquivalentLayerMaterialNames\n";
    ss << "A4 , \\field Layer 3\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowEquivalentLayerMaterialNames\n";
    ss << "A5 , \\field Layer 4\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowEquivalentLayerMaterialNames\n";
    ss << "A6 , \\field Layer 5\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowEquivalentLayerMaterialNames\n";
    ss << "A7 , \\field Layer 6\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowEquivalentLayerMaterialNames\n";
    ss << "A8 , \\field Layer 7\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowEquivalentLayerMaterialNames\n";
    ss << "A9 , \\field Layer 8\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowEquivalentLayerMaterialNames\n";
    ss << "A10, \\field Layer 9\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowEquivalentLayerMaterialNames\n";
    ss << "A11, \\field Layer 10\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowEquivalentLayerMaterialNames\n";
    ss << "A12; \\field Layer 11\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowEquivalentLayerMaterialNames\n";

    IddObjectType objType(IddObjectType::Construction_WindowEquivalentLayer);
    OptionalIddObject oObj = IddObject::load("Construction:WindowEquivalentLayer",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Construction_WindowEquivalentLayer);
  return object;
}

IddObject createConstruction_WindowDataFileIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Construction:WindowDataFile,\n";
    ss << "\\memo Initiates search of the Window data file for a window called Name.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConstructionNames\n";
    ss << "A2 ; \\field File Name\n";
    ss << "\\retaincase\n";
    ss << "\\note default file name is \"Window5DataFile.dat\"\n";
    ss << "\\note limit on this field is 100 characters.\n";

    IddObjectType objType(IddObjectType::Construction_WindowDataFile);
    OptionalIddObject oObj = IddObject::load("Construction:WindowDataFile",
                                             "Surface Construction Elements",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Construction_WindowDataFile);
  return object;
}

IddObject createGlobalGeometryRulesIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GlobalGeometryRules,\n";
    ss << "\\memo Specifies the geometric rules used to describe the input of surface vertices and\n";
    ss << "\\memo daylighting reference points.\n";
    ss << "\\required-object\n";
    ss << "\\unique-object\n";
    ss << "A1, \\field Starting Vertex Position\n";
    ss << "\\required-field\n";
    ss << "\\note Specified as entry for a 4 sided surface/rectangle\n";
    ss << "\\note Surfaces are specified as viewed from outside the surface\n";
    ss << "\\note Shading surfaces as viewed from behind.  (towards what they are shading)\n";
    ss << "\\type choice\n";
    ss << "\\key UpperLeftCorner\n";
    ss << "\\key LowerLeftCorner\n";
    ss << "\\key UpperRightCorner\n";
    ss << "\\key LowerRightCorner\n";
    ss << "A2, \\field Vertex Entry Direction\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Counterclockwise\n";
    ss << "\\key Clockwise\n";
    ss << "A3, \\field Coordinate System\n";
    ss << "\\required-field\n";
    ss << "\\note relative -- coordinates are entered relative to zone origin\n";
    ss << "\\note world -- all coordinates entered are \"absolute\" for this facility\n";
    ss << "\\note absolute -- same as world\n";
    ss << "\\type choice\n";
    ss << "\\key Relative\n";
    ss << "\\key World\n";
    ss << "\\key Absolute\n";
    ss << "A4, \\field Daylighting Reference Point Coordinate System\n";
    ss << "\\type choice\n";
    ss << "\\key Relative\n";
    ss << "\\default Relative\n";
    ss << "\\note Relative -- coordinates are entered relative to zone origin\n";
    ss << "\\key World\n";
    ss << "\\note World -- all coordinates entered are \"absolute\" for this facility\n";
    ss << "\\key Absolute\n";
    ss << "\\note absolute -- same as world\n";
    ss << "A5; \\field Rectangular Surface Coordinate System\n";
    ss << "\\type choice\n";
    ss << "\\key Relative\n";
    ss << "\\default Relative\n";
    ss << "\\note Relative -- Starting corner is entered relative to zone origin\n";
    ss << "\\key World\n";
    ss << "\\note World -- Starting corner is entered in \"absolute\"\n";
    ss << "\\key Absolute\n";
    ss << "\\note absolute -- same as world\n";

    IddObjectType objType(IddObjectType::GlobalGeometryRules);
    OptionalIddObject oObj = IddObject::load("GlobalGeometryRules",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GlobalGeometryRules);
  return object;
}

IddObject createGeometryTransformIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GeometryTransform,\n";
    ss << "\\memo Provides a simple method of altering the footprint geometry of a model. The intent\n";
    ss << "\\memo is to provide a single parameter that can be used to reshape the building description\n";
    ss << "\\memo contained in the rest of the input file.\n";
    ss << "\\unique-object\n";
    ss << "A1, \\field Plane of Transform\n";
    ss << "\\type choice\n";
    ss << "\\key XY\n";
    ss << "\\default XY\n";
    ss << "\\note only current allowed value is \"XY\"\n";
    ss << "N1, \\field Current Aspect Ratio\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Aspect ratio of building as described in idf\n";
    ss << "N2; \\field New Aspect Ratio\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Aspect ratio to transform to during run\n";

    IddObjectType objType(IddObjectType::GeometryTransform);
    OptionalIddObject oObj = IddObject::load("GeometryTransform",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GeometryTransform);
  return object;
}

IddObject createZoneIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Zone,\n";
    ss << "\\memo Defines a thermal zone of the building.\n";
    ss << "\\format vertices\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ZoneNames\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "\\reference ZoneAndZoneListNames\n";
    ss << "\\reference AirflowNetworkNodeAndZoneNames\n";
    ss << "N1 , \\field Direction of Relative North\n";
    ss << "\\units deg\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N2 , \\field X Origin\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N3 , \\field Y Origin\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N4 , \\field Z Origin\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N5 , \\field Type\n";
    ss << "\\type integer\n";
    ss << "\\maximum 1\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";
    ss << "N6 , \\field Multiplier\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";
    ss << "N7 , \\field Ceiling Height\n";
    ss << "\\note If this field is 0.0, negative or autocalculate, then the average height\n";
    ss << "\\note of the zone is automatically calculated and used in subsequent calculations.\n";
    ss << "\\note If this field is positive, then the number entered here will be used.\n";
    ss << "\\note Note that the Zone Ceiling Height is the distance from the Floor to\n";
    ss << "\\note the Ceiling in the Zone, not an absolute height from the ground.\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "N8 , \\field Volume\n";
    ss << "\\note If this field is 0.0, negative or autocalculate, then the volume of the zone\n";
    ss << "\\note is automatically calculated and used in subsequent calculations.\n";
    ss << "\\note If this field is positive, then the number entered here will be used.\n";
    ss << "\\units m3\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "N9 , \\field Floor Area\n";
    ss << "\\note If this field is 0.0, negative or autocalculate, then the floor area of the zone\n";
    ss << "\\note is automatically calculated and used in subsequent calculations.\n";
    ss << "\\note If this field is positive, then the number entered here will be used.\n";
    ss << "\\units m2\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "A2 , \\field Zone Inside Convection Algorithm\n";
    ss << "\\type choice\n";
    ss << "\\key Simple\n";
    ss << "\\key TARP\n";
    ss << "\\key CeilingDiffuser\n";
    ss << "\\key AdaptiveConvectionAlgorithm\n";
    ss << "\\key TrombeWall\n";
    ss << "\\note Will default to same value as SurfaceConvectionAlgorithm:Inside object\n";
    ss << "\\note setting this field overrides the default SurfaceConvectionAlgorithm:Inside for this zone\n";
    ss << "\\note Simple = constant natural convection (ASHRAE)\n";
    ss << "\\note TARP = variable natural convection based on temperature difference (ASHRAE)\n";
    ss << "\\note CeilingDiffuser = ACH based forced and mixed convection correlations\n";
    ss << "\\note  for ceiling diffuser configuration with simple natural convection limit\n";
    ss << "\\note AdaptiveConvectionAlgorithm = dynamic selection of convection models based on conditions\n";
    ss << "\\note TrombeWall = variable natural convection in an enclosed rectangular cavity\n";
    ss << "A3,  \\field Zone Outside Convection Algorithm\n";
    ss << "\\note Will default to same value as SurfaceConvectionAlgorithm:Outside object\n";
    ss << "\\note setting this field overrides the default SurfaceConvectionAlgorithm:Outside for this zone\n";
    ss << "\\type choice\n";
    ss << "\\key SimpleCombined\n";
    ss << "\\key TARP\n";
    ss << "\\key DOE-2\n";
    ss << "\\key MoWiTT\n";
    ss << "\\key AdaptiveConvectionAlgorithm\n";
    ss << "\\note SimpleCombined = Combined radiation and convection coefficient using simple ASHRAE model\n";
    ss << "\\note TARP = correlation from models developed by ASHRAE, Walton, and Sparrow et. al.\n";
    ss << "\\note MoWiTT = correlation from measurements by Klems and Yazdanian for smooth surfaces\n";
    ss << "\\note DOE-2 = correlation from measurements by Klems and Yazdanian for rough surfaces\n";
    ss << "\\note AdaptiveConvectionAlgorithm = dynamic selection of correlations based on conditions\n";
    ss << "A4;  \\field Part of Total Floor Area\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";

    IddObjectType objType(IddObjectType::Zone);
    OptionalIddObject oObj = IddObject::load("Zone",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Zone);
  return object;
}

IddObject createZoneListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneList,\n";
    ss << "\\memo Defines a list of thermal zones which can be referenced as a group. The ZoneList name\n";
    ss << "\\memo may be used elsewhere in the input to apply a parameter to all zones in the list.\n";
    ss << "\\memo ZoneLists can be used effectively with the following objects: People, Lights,\n";
    ss << "\\memo ElectricEquipment, GasEquipment, HotWaterEquipment, ZoneInfiltration:DesignFlowRate,\n";
    ss << "\\memo ZoneVentilation:DesignFlowRate, Sizing:Zone, ZoneControl:Thermostat, and others.\n";
    ss << "\\min-fields 2\n";
    ss << "\\extensible:1 - repeat last field, remembering to remove ; from \"inner\" fields.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\note Name of the Zone List\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ZoneListNames\n";
    ss << "\\reference ZoneAndZoneListNames\n";
    ss << "A2 ; \\field Zone 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";

    IddObjectType objType(IddObjectType::ZoneList);
    OptionalIddObject oObj = IddObject::load("ZoneList",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneList);
  return object;
}

IddObject createZoneGroupIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneGroup,\n";
    ss << "\\memo Adds a multiplier to a ZoneList. This can be used to reduce the amount of input\n";
    ss << "\\memo necessary for simulating repetitive structures, such as the identical floors of a\n";
    ss << "\\memo multi-story building.\n";
    ss << "\\min-fields 2\n";
    ss << "A1 , \\field Name\n";
    ss << "\\note Name of the Zone Group\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2,  \\field Zone List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneListNames\n";
    ss << "N1;  \\field Zone List Multiplier\n";
    ss << "\\type integer\n";
    ss << "\\default 1\n";
    ss << "\\minimum 1\n";

    IddObjectType objType(IddObjectType::ZoneGroup);
    OptionalIddObject oObj = IddObject::load("ZoneGroup",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneGroup);
  return object;
}

IddObject createBuildingSurface_DetailedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "BuildingSurface:Detailed,\n";
    ss << "\\memo Allows for detailed entry of building heat transfer surfaces.  Does not include subsurfaces such as windows or doors.\n";
    ss << "\\extensible:3 -- duplicate last set of x,y,z coordinates (last 3 fields), remembering to remove ; from \"inner\" fields.\n";
    ss << "\\format vertices\n";
    ss << "\\min-fields 19\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SurfaceNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadiantSurfaceNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "\\reference FloorSurfaceNames\n";
    ss << "A2 , \\field Surface Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Floor\n";
    ss << "\\key Wall\n";
    ss << "\\key Ceiling\n";
    ss << "\\key Roof\n";
    ss << "A3 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A4 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone the surface is a part of\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A5 , \\field Outside Boundary Condition\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Adiabatic\n";
    ss << "\\key Surface\n";
    ss << "\\key Zone\n";
    ss << "\\key Outdoors\n";
    ss << "\\key Ground\n";
    ss << "\\key GroundFCfactorMethod\n";
    ss << "\\key OtherSideCoefficients\n";
    ss << "\\key OtherSideConditionsModel\n";
    ss << "\\key GroundSlabPreprocessorAverage\n";
    ss << "\\key GroundSlabPreprocessorCore\n";
    ss << "\\key GroundSlabPreprocessorPerimeter\n";
    ss << "\\key GroundBasementPreprocessorAverageWall\n";
    ss << "\\key GroundBasementPreprocessorAverageFloor\n";
    ss << "\\key GroundBasementPreprocessorUpperWall\n";
    ss << "\\key GroundBasementPreprocessorLowerWall\n";
    ss << "A6,  \\field Outside Boundary Condition Object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutFaceEnvNames\n";
    ss << "\\note Non-blank only if the field Outside Boundary Condition is Surface,\n";
    ss << "\\note Zone, OtherSideCoefficients or OtherSideConditionsModel\n";
    ss << "\\note If Surface, specify name of corresponding surface in adjacent zone or\n";
    ss << "\\note specify current surface name for internal partition separating like zones\n";
    ss << "\\note If Zone, specify the name of the corresponding zone and\n";
    ss << "\\note the program will generate the corresponding interzone surface\n";
    ss << "\\note If OtherSideCoefficients, specify name of SurfaceProperty:OtherSideCoefficients\n";
    ss << "\\note If OtherSideConditionsModel, specify name of SurfaceProperty:OtherSideConditionsModel\n";
    ss << "A7 , \\field Sun Exposure\n";
    ss << "\\type choice\n";
    ss << "\\key SunExposed\n";
    ss << "\\key NoSun\n";
    ss << "\\default SunExposed\n";
    ss << "A8,  \\field Wind Exposure\n";
    ss << "\\type choice\n";
    ss << "\\key WindExposed\n";
    ss << "\\key NoWind\n";
    ss << "\\default WindExposed\n";
    ss << "N1,  \\field View Factor to Ground\n";
    ss << "\\type real\n";
    ss << "\\note From the exterior of the surface\n";
    ss << "\\note Unused if one uses the \"reflections\" options in Solar Distribution in Building input\n";
    ss << "\\note unless a DaylightingDevice:Shelf or DaylightingDevice:Tubular object has been specified.\n";
    ss << "\\note autocalculate will automatically calculate this value from the tilt of the surface\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default autocalculate\n";
    ss << "N2 , \\field Number of Vertices\n";
    ss << "\\note shown with 120 vertex coordinates -- extensible object\n";
    ss << "\\note  \"extensible\" -- duplicate last set of x,y,z coordinates (last 3 fields),\n";
    ss << "\\note remembering to remove ; from \"inner\" fields.\n";
    ss << "\\note for clarity in any error messages, renumber the fields as well.\n";
    ss << "\\note (and changing z terminator to a comma \",\" for all but last one which needs a semi-colon \";\")\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 3\n";
    ss << "\\default autocalculate\n";
    ss << "\\note vertices are given in GlobalGeometryRules coordinates -- if relative, all surface coordinates\n";
    ss << "\\note are \"relative\" to the Zone Origin.  If world, then building and zone origins are used\n";
    ss << "\\note for some internal calculations, but all coordinates are given in an \"absolute\" system.\n";
    ss << "N3,  \\field Vertex 1 X-coordinate\n";
    ss << "\\begin-extensible\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Vertex 1 Y-coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N5 ; \\field Vertex 1 Z-coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::BuildingSurface_Detailed);
    OptionalIddObject oObj = IddObject::load("BuildingSurface:Detailed",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::BuildingSurface_Detailed);
  return object;
}

IddObject createWall_DetailedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Wall:Detailed,\n";
    ss << "\\memo Allows for detailed entry of wall heat transfer surfaces.\n";
    ss << "\\extensible:3 -- duplicate last set of x,y,z coordinates (last 3 fields), remembering to remove ; from \"inner\" fields.\n";
    ss << "\\format vertices\n";
    ss << "\\min-fields 18\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SurfaceNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadiantSurfaceNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone the surface is a part of\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A4 , \\field Outside Boundary Condition\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Adiabatic\n";
    ss << "\\key Surface\n";
    ss << "\\key Zone\n";
    ss << "\\key Outdoors\n";
    ss << "\\key Ground\n";
    ss << "\\key GroundFCfactorMethod\n";
    ss << "\\key OtherSideCoefficients\n";
    ss << "\\key OtherSideConditionsModel\n";
    ss << "\\key GroundSlabPreprocessorAverage\n";
    ss << "\\key GroundSlabPreprocessorCore\n";
    ss << "\\key GroundSlabPreprocessorPerimeter\n";
    ss << "\\key GroundBasementPreprocessorAverageWall\n";
    ss << "\\key GroundBasementPreprocessorAverageFloor\n";
    ss << "\\key GroundBasementPreprocessorUpperWall\n";
    ss << "\\key GroundBasementPreprocessorLowerWall\n";
    ss << "A5,  \\field Outside Boundary Condition Object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutFaceEnvNames\n";
    ss << "\\note Non-blank only if the field Outside Boundary Condition is Surface,\n";
    ss << "\\note Zone, OtherSideCoefficients or OtherSideConditionsModel\n";
    ss << "\\note If Surface, specify name of corresponding surface in adjacent zone or\n";
    ss << "\\note specify current surface name for internal partition separating like zones\n";
    ss << "\\note If Zone, specify the name of the corresponding zone and\n";
    ss << "\\note the program will generate the corresponding interzone surface\n";
    ss << "\\note If OtherSideCoefficients, specify name of SurfaceProperty:OtherSideCoefficients\n";
    ss << "\\note If OtherSideConditionsModel, specify name of SurfaceProperty:OtherSideConditionsModel\n";
    ss << "A6 , \\field Sun Exposure\n";
    ss << "\\type choice\n";
    ss << "\\key SunExposed\n";
    ss << "\\key NoSun\n";
    ss << "\\default SunExposed\n";
    ss << "A7,  \\field Wind Exposure\n";
    ss << "\\type choice\n";
    ss << "\\key WindExposed\n";
    ss << "\\key NoWind\n";
    ss << "\\default WindExposed\n";
    ss << "N1,  \\field View Factor to Ground\n";
    ss << "\\type real\n";
    ss << "\\note From the exterior of the surface\n";
    ss << "\\note Unused if one uses the \"reflections\" options in Solar Distribution in Building input\n";
    ss << "\\note unless a DaylightingDevice:Shelf or DaylightingDevice:Tubular object has been specified.\n";
    ss << "\\note autocalculate will automatically calculate this value from the tilt of the surface\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default autocalculate\n";
    ss << "N2 , \\field Number of Vertices\n";
    ss << "\\note shown with 10 vertex coordinates -- extensible object\n";
    ss << "\\note  \"extensible\" -- duplicate last set of x,y,z coordinates, renumbering please\n";
    ss << "\\note (and changing z terminator to a comma \",\" for all but last one which needs a semi-colon \";\")\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 3\n";
    ss << "\\default autocalculate\n";
    ss << "\\note vertices are given in GlobalGeometryRules coordinates -- if relative, all surface coordinates\n";
    ss << "\\note are \"relative\" to the Zone Origin.  If world, then building and zone origins are used\n";
    ss << "\\note for some internal calculations, but all coordinates are given in an \"absolute\" system.\n";
    ss << "N3,  \\field Vertex 1 X-coordinate\n";
    ss << "\\begin-extensible\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Vertex 1 Y-coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N5 ; \\field Vertex 1 Z-coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::Wall_Detailed);
    OptionalIddObject oObj = IddObject::load("Wall:Detailed",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Wall_Detailed);
  return object;
}

IddObject createRoofCeiling_DetailedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RoofCeiling:Detailed,\n";
    ss << "\\memo Allows for detailed entry of wall heat transfer surfaces.\n";
    ss << "\\extensible:3 -- duplicate last set of x,y,z coordinates (last 3 fields), remembering to remove ; from \"inner\" fields.\n";
    ss << "\\min-fields 18\n";
    ss << "\\format vertices\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SurfaceNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadiantSurfaceNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone the surface is a part of\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A4 , \\field Outside Boundary Condition\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Adiabatic\n";
    ss << "\\key Surface\n";
    ss << "\\key Zone\n";
    ss << "\\key Outdoors\n";
    ss << "\\key Ground\n";
    ss << "\\key OtherSideCoefficients\n";
    ss << "\\key OtherSideConditionsModel\n";
    ss << "\\key GroundSlabPreprocessorAverage\n";
    ss << "\\key GroundSlabPreprocessorCore\n";
    ss << "\\key GroundSlabPreprocessorPerimeter\n";
    ss << "\\key GroundBasementPreprocessorAverageWall\n";
    ss << "\\key GroundBasementPreprocessorAverageFloor\n";
    ss << "\\key GroundBasementPreprocessorUpperWall\n";
    ss << "\\key GroundBasementPreprocessorLowerWall\n";
    ss << "A5,  \\field Outside Boundary Condition Object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutFaceEnvNames\n";
    ss << "\\note Non-blank only if the field Outside Boundary Condition is Surface,\n";
    ss << "\\note Zone, OtherSideCoefficients or OtherSideConditionsModel\n";
    ss << "\\note If Surface, specify name of corresponding surface in adjacent zone or\n";
    ss << "\\note specify current surface name for internal partition separating like zones\n";
    ss << "\\note If Zone, specify the name of the corresponding zone and\n";
    ss << "\\note the program will generate the corresponding interzone surface\n";
    ss << "\\note If OtherSideCoefficients, specify name of SurfaceProperty:OtherSideCoefficients\n";
    ss << "\\note If OtherSideConditionsModel, specify name of SurfaceProperty:OtherSideConditionsModel\n";
    ss << "A6 , \\field Sun Exposure\n";
    ss << "\\type choice\n";
    ss << "\\key SunExposed\n";
    ss << "\\key NoSun\n";
    ss << "\\default SunExposed\n";
    ss << "A7,  \\field Wind Exposure\n";
    ss << "\\type choice\n";
    ss << "\\key WindExposed\n";
    ss << "\\key NoWind\n";
    ss << "\\default WindExposed\n";
    ss << "N1,  \\field View Factor to Ground\n";
    ss << "\\type real\n";
    ss << "\\note From the exterior of the surface\n";
    ss << "\\note Unused if one uses the \"reflections\" options in Solar Distribution in Building input\n";
    ss << "\\note unless a DaylightingDevice:Shelf or DaylightingDevice:Tubular object has been specified.\n";
    ss << "\\note autocalculate will automatically calculate this value from the tilt of the surface\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default autocalculate\n";
    ss << "N2 , \\field Number of Vertices\n";
    ss << "\\note shown with 10 vertex coordinates -- extensible object\n";
    ss << "\\note  \"extensible\" -- duplicate last set of x,y,z coordinates, renumbering please\n";
    ss << "\\note (and changing z terminator to a comma \",\" for all but last one which needs a semi-colon \";\")\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 3\n";
    ss << "\\default autocalculate\n";
    ss << "\\note vertices are given in GlobalGeometryRules coordinates -- if relative, all surface coordinates\n";
    ss << "\\note are \"relative\" to the Zone Origin.  If world, then building and zone origins are used\n";
    ss << "\\note for some internal calculations, but all coordinates are given in an \"absolute\" system.\n";
    ss << "N3,  \\field Vertex 1 X-coordinate\n";
    ss << "\\begin-extensible\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Vertex 1 Y-coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N5 ; \\field Vertex 1 Z-coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::RoofCeiling_Detailed);
    OptionalIddObject oObj = IddObject::load("RoofCeiling:Detailed",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RoofCeiling_Detailed);
  return object;
}

IddObject createFloor_DetailedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Floor:Detailed,\n";
    ss << "\\memo Allows for detailed entry of floor heat transfer surfaces.\n";
    ss << "\\extensible:3 -- duplicate last set of x,y,z coordinates (last 3 fields), remembering to remove ; from \"inner\" fields.\n";
    ss << "\\format vertices\n";
    ss << "\\min-fields 18\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SurfaceNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadiantSurfaceNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "\\reference FloorSurfaceNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone the surface is a part of\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A4 , \\field Outside Boundary Condition\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Adiabatic\n";
    ss << "\\key Surface\n";
    ss << "\\key Zone\n";
    ss << "\\key Outdoors\n";
    ss << "\\key Ground\n";
    ss << "\\key GroundFCfactorMethod\n";
    ss << "\\key OtherSideCoefficients\n";
    ss << "\\key OtherSideConditionsModel\n";
    ss << "\\key GroundSlabPreprocessorAverage\n";
    ss << "\\key GroundSlabPreprocessorCore\n";
    ss << "\\key GroundSlabPreprocessorPerimeter\n";
    ss << "\\key GroundBasementPreprocessorAverageWall\n";
    ss << "\\key GroundBasementPreprocessorAverageFloor\n";
    ss << "\\key GroundBasementPreprocessorUpperWall\n";
    ss << "\\key GroundBasementPreprocessorLowerWall\n";
    ss << "A5,  \\field Outside Boundary Condition Object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutFaceEnvNames\n";
    ss << "\\note Non-blank only if the field Outside Boundary Condition is Surface,\n";
    ss << "\\note Zone, OtherSideCoefficients or OtherSideConditionsModel\n";
    ss << "\\note If Surface, specify name of corresponding surface in adjacent zone or\n";
    ss << "\\note specify current surface name for internal partition separating like zones\n";
    ss << "\\note If Zone, specify the name of the corresponding zone and\n";
    ss << "\\note the program will generate the corresponding interzone surface\n";
    ss << "\\note If OtherSideCoefficients, specify name of SurfaceProperty:OtherSideCoefficients\n";
    ss << "\\note If OtherSideConditionsModel, specify name of SurfaceProperty:OtherSideConditionsModel\n";
    ss << "A6 , \\field Sun Exposure\n";
    ss << "\\type choice\n";
    ss << "\\key SunExposed\n";
    ss << "\\key NoSun\n";
    ss << "\\default SunExposed\n";
    ss << "A7,  \\field Wind Exposure\n";
    ss << "\\type choice\n";
    ss << "\\key WindExposed\n";
    ss << "\\key NoWind\n";
    ss << "\\default WindExposed\n";
    ss << "N1,  \\field View Factor to Ground\n";
    ss << "\\type real\n";
    ss << "\\note From the exterior of the surface\n";
    ss << "\\note Unused if one uses the \"reflections\" options in Solar Distribution in Building input\n";
    ss << "\\note unless a DaylightingDevice:Shelf or DaylightingDevice:Tubular object has been specified.\n";
    ss << "\\note autocalculate will automatically calculate this value from the tilt of the surface\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default autocalculate\n";
    ss << "N2 , \\field Number of Vertices\n";
    ss << "\\note shown with 10 vertex coordinates -- extensible object\n";
    ss << "\\note  \"extensible\" -- duplicate last set of x,y,z coordinates, renumbering please\n";
    ss << "\\note (and changing z terminator to a comma \",\" for all but last one which needs a semi-colon \";\")\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 3\n";
    ss << "\\default autocalculate\n";
    ss << "\\note vertices are given in GlobalGeometryRules coordinates -- if relative, all surface coordinates\n";
    ss << "\\note are \"relative\" to the Zone Origin.  If world, then building and zone origins are used\n";
    ss << "\\note for some internal calculations, but all coordinates are given in an \"absolute\" system.\n";
    ss << "N3,  \\field Vertex 1 X-coordinate\n";
    ss << "\\begin-extensible\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Vertex 1 Y-coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N5 ; \\field Vertex 1 Z-coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::Floor_Detailed);
    OptionalIddObject oObj = IddObject::load("Floor:Detailed",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Floor_Detailed);
  return object;
}

IddObject createWall_ExteriorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Wall:Exterior,\n";
    ss << "\\memo Allows for simplified entry of exterior walls.\n";
    ss << "\\memo View Factor to Ground is automatically calculated.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SurfaceNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadiantSurfaceNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone the surface is a part of\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1,  \\field Azimuth Angle\n";
    ss << "\\note Facing direction of outside of wall (S=180,N=0,E=90,W=270)\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 360\n";
    ss << "\\units deg\n";
    ss << "N2,  \\field Tilt Angle\n";
    ss << "\\note Walls are usually tilted 90 degrees\n";
    ss << "\\default 90\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "\\units deg\n";
    ss << "N3,  \\field Starting X Coordinate\n";
    ss << "\\note Starting (x,y,z) coordinate is the Lower Left Corner of the Wall\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Starting Y Coordinate\n";
    ss << "\\units m\n";
    ss << "N5,  \\field Starting Z Coordinate\n";
    ss << "\\units m\n";
    ss << "N6,  \\field Length\n";
    ss << "\\units m\n";
    ss << "N7;  \\field Height\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::Wall_Exterior);
    OptionalIddObject oObj = IddObject::load("Wall:Exterior",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Wall_Exterior);
  return object;
}

IddObject createWall_AdiabaticIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Wall:Adiabatic,\n";
    ss << "\\memo Allows for simplified entry of interior walls.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SurfaceNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadiantSurfaceNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone the surface is a part of\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1,  \\field Azimuth Angle\n";
    ss << "\\note Facing direction of outside of wall (S=180,N=0,E=90,W=270)\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 360\n";
    ss << "\\units deg\n";
    ss << "N2,  \\field Tilt Angle\n";
    ss << "\\note Walls are usually tilted 90 degrees\n";
    ss << "\\default 90\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "\\units deg\n";
    ss << "N3,  \\field Starting X Coordinate\n";
    ss << "\\note Starting (x,y,z) coordinate is the Lower Left Corner of the Wall\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Starting Y Coordinate\n";
    ss << "\\units m\n";
    ss << "N5,  \\field Starting Z Coordinate\n";
    ss << "\\units m\n";
    ss << "N6,  \\field Length\n";
    ss << "\\units m\n";
    ss << "N7;  \\field Height\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::Wall_Adiabatic);
    OptionalIddObject oObj = IddObject::load("Wall:Adiabatic",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Wall_Adiabatic);
  return object;
}

IddObject createWall_UndergroundIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Wall:Underground,\n";
    ss << "\\memo Allows for simplified entry of underground walls.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SurfaceNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadiantSurfaceNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file.\n";
    ss << "\\note If the construction is type \"Construction:CfactorUndergroundWall\",\n";
    ss << "\\note then the GroundFCfactorMethod will be used.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone the surface is a part of\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1,  \\field Azimuth Angle\n";
    ss << "\\note Facing direction of outside of wall (S=180,N=0,E=90,W=270)\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 360\n";
    ss << "\\units deg\n";
    ss << "N2,  \\field Tilt Angle\n";
    ss << "\\note Walls are usually tilted 90 degrees\n";
    ss << "\\default 90\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "\\units deg\n";
    ss << "N3,  \\field Starting X Coordinate\n";
    ss << "\\note Starting (x,y,z) coordinate is the Lower Left Corner of the Wall\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Starting Y Coordinate\n";
    ss << "\\units m\n";
    ss << "N5,  \\field Starting Z Coordinate\n";
    ss << "\\units m\n";
    ss << "N6,  \\field Length\n";
    ss << "\\units m\n";
    ss << "N7;  \\field Height\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::Wall_Underground);
    OptionalIddObject oObj = IddObject::load("Wall:Underground",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Wall_Underground);
  return object;
}

IddObject createWall_InterzoneIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Wall:Interzone,\n";
    ss << "\\memo Allows for simplified entry of interzone walls (walls between zones).\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SurfaceNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadiantSurfaceNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone for the inside of the surface\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A4 , \\field Outside Boundary Condition Object\n";
    ss << "\\required-field\n";
    ss << "\\note Specify a surface name in an adjacent zone for known interior walls.\n";
    ss << "\\note Specify a zone name of an adjacent zone to automatically generate\n";
    ss << "\\note the interior wall in the adjacent zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutFaceEnvNames\n";
    ss << "N1,  \\field Azimuth Angle\n";
    ss << "\\note Facing direction of outside of wall (S=180,N=0,E=90,W=270)\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 360\n";
    ss << "\\units deg\n";
    ss << "N2,  \\field Tilt Angle\n";
    ss << "\\note Walls are usually tilted 90 degrees\n";
    ss << "\\default 90\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "\\units deg\n";
    ss << "N3,  \\field Starting X Coordinate\n";
    ss << "\\note Starting (x,y,z) coordinate is the Lower Left Corner of the Wall\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Starting Y Coordinate\n";
    ss << "\\units m\n";
    ss << "N5,  \\field Starting Z Coordinate\n";
    ss << "\\units m\n";
    ss << "N6,  \\field Length\n";
    ss << "\\units m\n";
    ss << "N7;  \\field Height\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::Wall_Interzone);
    OptionalIddObject oObj = IddObject::load("Wall:Interzone",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Wall_Interzone);
  return object;
}

IddObject createRoofIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Roof,\n";
    ss << "\\memo Allows for simplified entry of roofs (exterior).\n";
    ss << "\\memo View Factor to Ground is automatically calculated.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SurfaceNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadiantSurfaceNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone the surface is a part of\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1,  \\field Azimuth Angle\n";
    ss << "\\note Facing direction of outside of Roof\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 360\n";
    ss << "\\units deg\n";
    ss << "N2,  \\field Tilt Angle\n";
    ss << "\\note Flat Roofs are tilted 0 degrees\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "\\default 0\n";
    ss << "\\units deg\n";
    ss << "N3,  \\field Starting X Coordinate\n";
    ss << "\\note If not Flat, Starting coordinate is the Lower Left Corner of the Roof\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Starting Y Coordinate\n";
    ss << "\\units m\n";
    ss << "N5,  \\field Starting Z Coordinate\n";
    ss << "\\units m\n";
    ss << "N6,  \\field Length\n";
    ss << "\\note Along X Axis\n";
    ss << "\\units m\n";
    ss << "N7;  \\field Width\n";
    ss << "\\note Along Y Axis\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::Roof);
    OptionalIddObject oObj = IddObject::load("Roof",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Roof);
  return object;
}

IddObject createCeiling_AdiabaticIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Ceiling:Adiabatic,\n";
    ss << "\\memo Allows for simplified entry of interior ceilings.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SurfaceNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadiantSurfaceNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone the surface is a part of\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1,  \\field Azimuth Angle\n";
    ss << "\\note Facing direction of outside of Ceiling\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 360\n";
    ss << "\\units deg\n";
    ss << "N2,  \\field Tilt Angle\n";
    ss << "\\note Ceilings are usually tilted 0 degrees\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "\\default 0\n";
    ss << "\\units deg\n";
    ss << "N3,  \\field Starting X Coordinate\n";
    ss << "\\note If not Flat, Starting coordinate is the Lower Left Corner of the Ceiling\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Starting Y Coordinate\n";
    ss << "\\units m\n";
    ss << "N5,  \\field Starting Z Coordinate\n";
    ss << "\\units m\n";
    ss << "N6,  \\field Length\n";
    ss << "\\note Along X Axis\n";
    ss << "\\units m\n";
    ss << "N7;  \\field Width\n";
    ss << "\\note Along Y Axis\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::Ceiling_Adiabatic);
    OptionalIddObject oObj = IddObject::load("Ceiling:Adiabatic",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Ceiling_Adiabatic);
  return object;
}

IddObject createCeiling_InterzoneIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Ceiling:Interzone,\n";
    ss << "\\memo Allows for simplified entry of ceilings using adjacent zone\n";
    ss << "\\memo (interzone) heat transfer - adjacent surface should be a floor\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SurfaceNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadiantSurfaceNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone for the inside of the surface\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A4 , \\field Outside Boundary Condition Object\n";
    ss << "\\required-field\n";
    ss << "\\note Specify a surface name in an adjacent zone for known interior floors\n";
    ss << "\\note Specify a zone name of an adjacent zone to automatically generate\n";
    ss << "\\note the interior floor in the adjacent zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutFaceEnvNames\n";
    ss << "N1,  \\field Azimuth Angle\n";
    ss << "\\note Facing direction of outside of wall (S=180,N=0,E=90,W=270)\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 360\n";
    ss << "\\units deg\n";
    ss << "N2,  \\field Tilt Angle\n";
    ss << "\\note Ceilings are usually tilted 0 degrees\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "\\default 0\n";
    ss << "\\units deg\n";
    ss << "N3,  \\field Starting X Coordinate\n";
    ss << "\\note If not Flat, should be Lower Left Corner (from outside)\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Starting Y Coordinate\n";
    ss << "\\units m\n";
    ss << "N5,  \\field Starting Z Coordinate\n";
    ss << "\\units m\n";
    ss << "N6,  \\field Length\n";
    ss << "\\note Along X Axis\n";
    ss << "\\units m\n";
    ss << "N7;  \\field Width\n";
    ss << "\\note Along Y Axis\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::Ceiling_Interzone);
    OptionalIddObject oObj = IddObject::load("Ceiling:Interzone",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Ceiling_Interzone);
  return object;
}

IddObject createFloor_GroundContactIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Floor:GroundContact,\n";
    ss << "\\memo Allows for simplified entry of exterior floors with ground contact.\n";
    ss << "\\memo View Factors to Ground is automatically calculated.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SurfaceNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadiantSurfaceNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "\\reference FloorSurfaceNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\note If the construction is type \"Construction:FfactorGroundFloor\",\n";
    ss << "\\note then the GroundFCfactorMethod will be used.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone the surface is a part of\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1,  \\field Azimuth Angle\n";
    ss << "\\units deg\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 360\n";
    ss << "N2,  \\field Tilt Angle\n";
    ss << "\\note Floors are usually tilted 180 degrees\n";
    ss << "\\units deg\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "\\default 180\n";
    ss << "N3,  \\field Starting X Coordinate\n";
    ss << "\\note if not flat, should be lower left corner (from outside)\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Starting Y Coordinate\n";
    ss << "\\units m\n";
    ss << "N5,  \\field Starting Z Coordinate\n";
    ss << "\\units m\n";
    ss << "N6,  \\field Length\n";
    ss << "\\note Along X Axis\n";
    ss << "\\units m\n";
    ss << "N7;  \\field Width\n";
    ss << "\\note Along Y Axis\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::Floor_GroundContact);
    OptionalIddObject oObj = IddObject::load("Floor:GroundContact",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Floor_GroundContact);
  return object;
}

IddObject createFloor_AdiabaticIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Floor:Adiabatic,\n";
    ss << "\\memo Allows for simplified entry of exterior floors\n";
    ss << "\\memo ignoring ground contact or interior floors.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SurfaceNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadiantSurfaceNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "\\reference FloorSurfaceNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone the surface is a part of\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1,  \\field Azimuth Angle\n";
    ss << "\\units deg\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 360\n";
    ss << "N2,  \\field Tilt Angle\n";
    ss << "\\note Floors are usually tilted 180 degrees\n";
    ss << "\\units deg\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "\\default 180\n";
    ss << "N3,  \\field Starting X Coordinate\n";
    ss << "\\note if not flat, should be lower left corner (from outside)\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Starting Y Coordinate\n";
    ss << "\\units m\n";
    ss << "N5,  \\field Starting Z Coordinate\n";
    ss << "\\units m\n";
    ss << "N6,  \\field Length\n";
    ss << "\\note Along X Axis\n";
    ss << "\\units m\n";
    ss << "N7;  \\field Width\n";
    ss << "\\note Along Y Axis\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::Floor_Adiabatic);
    OptionalIddObject oObj = IddObject::load("Floor:Adiabatic",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Floor_Adiabatic);
  return object;
}

IddObject createFloor_InterzoneIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Floor:Interzone,\n";
    ss << "\\memo Allows for simplified entry of floors using adjacent zone\n";
    ss << "\\memo (interzone) heat transfer - adjacent surface should be a ceiling.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SurfaceNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadiantSurfaceNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "\\reference FloorSurfaceNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone for the inside of the surface\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A4 , \\field Outside Boundary Condition Object\n";
    ss << "\\required-field\n";
    ss << "\\note Specify a surface name in an adjacent zone for known interior ceilings.\n";
    ss << "\\note Specify a zone name of an adjacent zone to automatically generate\n";
    ss << "\\note the interior ceiling in the adjacent zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutFaceEnvNames\n";
    ss << "N1,  \\field Azimuth Angle\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 360\n";
    ss << "\\units deg\n";
    ss << "N2,  \\field Tilt Angle\n";
    ss << "\\note Floors are usually tilted 180 degrees\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "\\default 180\n";
    ss << "\\units deg\n";
    ss << "N3,  \\field Starting X Coordinate\n";
    ss << "\\note If not Flat, should be Lower Left Corner (from outside)\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Starting Y Coordinate\n";
    ss << "\\units m\n";
    ss << "N5,  \\field Starting Z Coordinate\n";
    ss << "\\units m\n";
    ss << "N6,  \\field Length\n";
    ss << "\\note Along X Axis\n";
    ss << "\\units m\n";
    ss << "N7;  \\field Width\n";
    ss << "\\note Along Y Axis\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::Floor_Interzone);
    OptionalIddObject oObj = IddObject::load("Floor:Interzone",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Floor_Interzone);
  return object;
}

IddObject createFenestrationSurface_DetailedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FenestrationSurface:Detailed,\n";
    ss << "\\memo Allows for detailed entry of subsurfaces\n";
    ss << "\\memo (windows, doors, glass doors, tubular daylighting devices).\n";
    ss << "\\min-fields 19\n";
    ss << "\\max-fields 22\n";
    ss << "\\format vertices\n";
    ss << "\\extensible:3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SubSurfNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadiantSurfaceNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "A2 , \\field Surface Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Window\n";
    ss << "\\key Door\n";
    ss << "\\key GlassDoor\n";
    ss << "\\key TubularDaylightDome\n";
    ss << "\\key TubularDaylightDiffuser\n";
    ss << "A3 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "\\object-list ComplexFenestrationStates\n";
    ss << "A4 , \\field Building Surface Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceNames\n";
    ss << "A5,  \\field Outside Boundary Condition Object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutFaceEnvNames\n";
    ss << "\\note Non-blank only if base surface field Outside Boundary Condition is\n";
    ss << "\\note Surface or OtherSideCoefficients\n";
    ss << "\\note If Base Surface's Surface, specify name of corresponding subsurface in adjacent zone or\n";
    ss << "\\note specify current subsurface name for internal partition separating like zones\n";
    ss << "\\note If OtherSideCoefficients, specify name of SurfaceProperty:OtherSideCoefficients\n";
    ss << "\\note  or leave blank to inherit Base Surface's OtherSide Coefficients\n";
    ss << "N1, \\field View Factor to Ground\n";
    ss << "\\type real\n";
    ss << "\\note From the exterior of the surface\n";
    ss << "\\note Unused if one uses the \"reflections\" options in Solar Distribution in Building input\n";
    ss << "\\note unless a DaylightingDevice:Shelf or DaylightingDevice:Tubular object has been specified.\n";
    ss << "\\note autocalculate will automatically calculate this value from the tilt of the surface\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default autocalculate\n";
    ss << "A6, \\field Shading Control Name\n";
    ss << "\\note enter the name of a WindowProperty:ShadingControl object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowShadeControlNames\n";
    ss << "\\note used for windows and glass doors only\n";
    ss << "\\note If not specified, window or glass door has no shading (blind, roller shade, etc.)\n";
    ss << "A7, \\field Frame and Divider Name\n";
    ss << "\\note Enter the name of a WindowProperty:FrameAndDivider object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowFrameAndDividerNames\n";
    ss << "\\note Used only for exterior windows (rectangular) and glass doors.\n";
    ss << "\\note Unused for triangular windows.\n";
    ss << "\\note If not specified (blank), window or glass door has no frame or divider\n";
    ss << "\\note and no beam solar reflection from reveal surfaces.\n";
    ss << "N2 , \\field Multiplier\n";
    ss << "\\note Used only for Surface Type = WINDOW, GLASSDOOR or DOOR\n";
    ss << "\\note Non-integer values will be truncated to integer\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum 1.0\n";
    ss << "N3 , \\field Number of Vertices\n";
    ss << "\\minimum 3\n";
    ss << "\\maximum 4\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "\\note vertices are given in GlobalGeometryRules coordinates -- if relative, all surface coordinates\n";
    ss << "\\note are \"relative\" to the Zone Origin.  If world, then building and zone origins are used\n";
    ss << "\\note for some internal calculations, but all coordinates are given in an \"absolute\" system.\n";
    ss << "N4,  \\field Vertex 1 X-coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\begin-extensible\n";
    ss << "N5 , \\field Vertex 1 Y-coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N6 ; \\field Vertex 1 Z-coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::FenestrationSurface_Detailed);
    OptionalIddObject oObj = IddObject::load("FenestrationSurface:Detailed",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FenestrationSurface_Detailed);
  return object;
}

IddObject createWindowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Window,\n";
    ss << "\\memo Allows for simplified entry of Windows.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SubSurfNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadGroupAndSurfNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Building Surface Name\n";
    ss << "\\note Name of Surface (Wall, usually) the Window is on (i.e., Base Surface)\n";
    ss << "\\note Window assumes the azimuth and tilt angles of the surface it is on.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceNames\n";
    ss << "A4, \\field Shading Control Name\n";
    ss << "\\note enter the name of a WindowProperty:ShadingControl object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowShadeControlNames\n";
    ss << "\\note used for windows and glass doors only\n";
    ss << "\\note If not specified, window or glass door has no shading (blind, roller shade, etc.)\n";
    ss << "A5, \\field Frame and Divider Name\n";
    ss << "\\note Enter the name of a WindowProperty:FrameAndDivider object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowFrameAndDividerNames\n";
    ss << "\\note Used only for exterior windows (rectangular) and glass doors.\n";
    ss << "\\note Unused for triangular windows.\n";
    ss << "\\note If not specified (blank), window or glass door has no frame or divider\n";
    ss << "\\note and no beam solar reflection from reveal surfaces.\n";
    ss << "N1 , \\field Multiplier\n";
    ss << "\\note Used only for Surface Type = WINDOW, GLASSDOOR or DOOR\n";
    ss << "\\note Non-integer values will be truncated to integer\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum 1.0\n";
    ss << "N2,  \\field Starting X Coordinate\n";
    ss << "\\note Window starting coordinate is specified relative to the Base Surface origin.\n";
    ss << "\\units m\n";
    ss << "N3,  \\field Starting Z Coordinate\n";
    ss << "\\note How far up the wall the Window starts. (in 2-d, this would be a Y Coordinate)\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Length\n";
    ss << "\\units m\n";
    ss << "N5;  \\field Height\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::Window);
    OptionalIddObject oObj = IddObject::load("Window",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Window);
  return object;
}

IddObject createDoorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Door,\n";
    ss << "\\memo Allows for simplified entry of opaque Doors.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SubSurfNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadiantSurfaceNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Building Surface Name\n";
    ss << "\\note Name of Surface (Wall, usually) the Door is on (i.e., Base Surface)\n";
    ss << "\\note Door assumes the azimuth and tilt angles of the surface it is on.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceNames\n";
    ss << "N1 , \\field Multiplier\n";
    ss << "\\note Used only for Surface Type = WINDOW, GLASSDOOR or DOOR\n";
    ss << "\\note Non-integer values will be truncated to integer\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum 1.0\n";
    ss << "N2,  \\field Starting X Coordinate\n";
    ss << "\\note Door starting coordinate is specified relative to the Base Surface origin.\n";
    ss << "\\units m\n";
    ss << "N3,  \\field Starting Z Coordinate\n";
    ss << "\\note How far up the wall the Door starts. (in 2-d, this would be a Y Coordinate)\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Length\n";
    ss << "\\units m\n";
    ss << "N5;  \\field Height\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::Door);
    OptionalIddObject oObj = IddObject::load("Door",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Door);
  return object;
}

IddObject createGlazedDoorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GlazedDoor,\n";
    ss << "\\memo Allows for simplified entry of glass Doors.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SubSurfNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Building Surface Name\n";
    ss << "\\note Name of Surface (Wall, usually) the Door is on (i.e., Base Surface)\n";
    ss << "\\note Door assumes the azimuth and tilt angles of the surface it is on.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceNames\n";
    ss << "A4, \\field Shading Control Name\n";
    ss << "\\note enter the name of a WindowProperty:ShadingControl object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowShadeControlNames\n";
    ss << "\\note used for windows and glass doors only\n";
    ss << "\\note If not specified, window or glass door has no shading (blind, roller shade, etc.)\n";
    ss << "A5, \\field Frame and Divider Name\n";
    ss << "\\note Enter the name of a WindowProperty:FrameAndDivider object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowFrameAndDividerNames\n";
    ss << "\\note Used only for exterior windows (rectangular) and glass doors.\n";
    ss << "\\note Unused for triangular windows.\n";
    ss << "\\note If not specified (blank), window or glass door has no frame or divider\n";
    ss << "\\note and no beam solar reflection from reveal surfaces.\n";
    ss << "N1 , \\field Multiplier\n";
    ss << "\\note Used only for Surface Type = WINDOW, GLASSDOOR or DOOR\n";
    ss << "\\note Non-integer values will be truncated to integer\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum 1.0\n";
    ss << "N2,  \\field Starting X Coordinate\n";
    ss << "\\note Door starting coordinate is specified relative to the Base Surface origin.\n";
    ss << "\\units m\n";
    ss << "N3,  \\field Starting Z Coordinate\n";
    ss << "\\note How far up the wall the Door starts. (in 2-d, this would be a Y Coordinate)\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Length\n";
    ss << "\\units m\n";
    ss << "N5;  \\field Height\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::GlazedDoor);
    OptionalIddObject oObj = IddObject::load("GlazedDoor",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GlazedDoor);
  return object;
}

IddObject createWindow_InterzoneIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Window:Interzone,\n";
    ss << "\\memo Allows for simplified entry of interzone windows (adjacent to\n";
    ss << "\\memo other zones).\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SubSurfNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadGroupAndSurfNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Building Surface Name\n";
    ss << "\\note Name of Surface (Wall, usually) the Window is on (i.e., Base Surface)\n";
    ss << "\\note Window assumes the azimuth and tilt angles of the surface it is on.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceNames\n";
    ss << "A4,  \\field Outside Boundary Condition Object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutFaceEnvNames\n";
    ss << "\\note Specify a surface name in an adjacent zone for known interior windows.\n";
    ss << "\\note Specify a zone name of an adjacent zone to automatically generate\n";
    ss << "\\note the interior window in the adjacent zone.\n";
    ss << "\\note a blank field will set up a Window in an adjacent zone\n";
    ss << "\\note (same zone as adjacent to base surface)\n";
    ss << "N1 , \\field Multiplier\n";
    ss << "\\note Used only for Surface Type = WINDOW, GLASSDOOR or DOOR\n";
    ss << "\\note Non-integer values will be truncated to integer\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum 1.0\n";
    ss << "N2,  \\field Starting X Coordinate\n";
    ss << "\\note Window starting coordinate is specified relative to the Base Surface origin.\n";
    ss << "\\units m\n";
    ss << "N3,  \\field Starting Z Coordinate\n";
    ss << "\\note How far up the wall the Window starts. (in 2-d, this would be a Y Coordinate)\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Length\n";
    ss << "\\units m\n";
    ss << "N5;  \\field Height\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::Window_Interzone);
    OptionalIddObject oObj = IddObject::load("Window:Interzone",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Window_Interzone);
  return object;
}

IddObject createDoor_InterzoneIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Door:Interzone,\n";
    ss << "\\memo Allows for simplified entry of interzone (opaque interior) doors (adjacent to\n";
    ss << "\\memo other zones).\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SubSurfNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadiantSurfaceNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Building Surface Name\n";
    ss << "\\note Name of Surface (Wall, usually) the Door is on (i.e., Base Surface)\n";
    ss << "\\note Door assumes the azimuth and tilt angles of the surface it is on.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceNames\n";
    ss << "A4,  \\field Outside Boundary Condition Object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutFaceEnvNames\n";
    ss << "\\note Specify a surface name in an adjacent zone for known interior doors.\n";
    ss << "\\note Specify a zone name of an adjacent zone to automatically generate\n";
    ss << "\\note the interior door in the adjacent zone.\n";
    ss << "\\note a blank field will set up a Window in an adjacent zone\n";
    ss << "\\note (same zone as adjacent to base surface)\n";
    ss << "N1 , \\field Multiplier\n";
    ss << "\\note Used only for Surface Type = WINDOW, GLASSDOOR or DOOR\n";
    ss << "\\note Non-integer values will be truncated to integer\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum 1.0\n";
    ss << "N2,  \\field Starting X Coordinate\n";
    ss << "\\note Door starting coordinate is specified relative to the Base Surface origin.\n";
    ss << "\\units m\n";
    ss << "N3,  \\field Starting Z Coordinate\n";
    ss << "\\note How far up the wall the Door starts. (in 2-d, this would be a Y Coordinate)\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Length\n";
    ss << "\\units m\n";
    ss << "N5;  \\field Height\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::Door_Interzone);
    OptionalIddObject oObj = IddObject::load("Door:Interzone",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Door_Interzone);
  return object;
}

IddObject createGlazedDoor_InterzoneIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GlazedDoor:Interzone,\n";
    ss << "\\memo Allows for simplified entry of interzone (glass interior) doors (adjacent to\n";
    ss << "\\memo other zones).\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SubSurfNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadGroupAndSurfNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Building Surface Name\n";
    ss << "\\note Name of Surface (Wall, usually) the Door is on (i.e., Base Surface)\n";
    ss << "\\note Door assumes the azimuth and tilt angles of the surface it is on.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceNames\n";
    ss << "A4,  \\field Outside Boundary Condition Object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutFaceEnvNames\n";
    ss << "\\note Specify a surface name in an adjacent zone for known interior doors.\n";
    ss << "\\note Specify a zone name of an adjacent zone to automatically generate\n";
    ss << "\\note the interior door in the adjacent zone.\n";
    ss << "\\note a blank field will set up a Window in an adjacent zone\n";
    ss << "\\note (same zone as adjacent to base surface)\n";
    ss << "N1 , \\field Multiplier\n";
    ss << "\\note Used only for Surface Type = WINDOW, GLASSDOOR or DOOR\n";
    ss << "\\note Non-integer values will be truncated to integer\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum 1.0\n";
    ss << "N2,  \\field Starting X Coordinate\n";
    ss << "\\note Door starting coordinate is specified relative to the Base Surface origin.\n";
    ss << "\\units m\n";
    ss << "N3,  \\field Starting Z Coordinate\n";
    ss << "\\note How far up the wall the Door starts. (in 2-d, this would be a Y Coordinate)\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Length\n";
    ss << "\\units m\n";
    ss << "N5;  \\field Height\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::GlazedDoor_Interzone);
    OptionalIddObject oObj = IddObject::load("GlazedDoor:Interzone",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GlazedDoor_Interzone);
  return object;
}

IddObject createWindowProperty_ShadingControlIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowProperty:ShadingControl,\n";
    ss << "\\memo Specifies the type, location, and controls for window shades, window blinds, and\n";
    ss << "\\memo switchable glazing. Referenced by the surface objects for exterior windows and glass\n";
    ss << "\\memo doors (ref: FenestrationSurface:Detailed, Window, and GlazedDoor).\n";
    ss << "\\min-fields 11\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WindowShadeControlNames\n";
    ss << "\\note Referenced by surfaces that are exterior windows\n";
    ss << "\\note Not used by interzone windows\n";
    ss << "A2 , \\field Shading Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key InteriorShade\n";
    ss << "\\key ExteriorShade\n";
    ss << "\\key ExteriorScreen\n";
    ss << "\\key InteriorBlind\n";
    ss << "\\key ExteriorBlind\n";
    ss << "\\key BetweenGlassShade\n";
    ss << "\\key BetweenGlassBlind\n";
    ss << "\\key SwitchableGlazing\n";
    ss << "A3 , \\field Construction with Shading Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "\\note Required if Shading Type = SwitchableGlazing\n";
    ss << "\\note Required if Shading Type = interior or exterior shade or blind, or exterior screen, and\n";
    ss << "\\note \"Shading Device Material Name\" is not specified.\n";
    ss << "\\note If both \"Construction with Shading Name\" and \"Shading Device Material Name\" are entered,\n";
    ss << "\\note the former takes precedence.\n";
    ss << "A4 , \\field Shading Control Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key AlwaysOn\n";
    ss << "\\key AlwaysOff\n";
    ss << "\\key OnIfScheduleAllows\n";
    ss << "\\note OnIfScheduleAllows requires that Schedule Name be specified and\n";
    ss << "\\note Shading Control Is Scheduled = Yes.\n";
    ss << "\\note AlwaysOn, AlwaysOff and OnIfScheduleAllows are the only valid control types for ExteriorScreen.\n";
    ss << "\\note The following six control types are used primarily to reduce\n";
    ss << "\\note zone cooling load due to window solar gain\n";
    ss << "\\key OnIfHighSolarOnWindow\n";
    ss << "\\key OnIfHighHorizontalSolar\n";
    ss << "\\key OnIfHighOutdoorAirTemperature\n";
    ss << "\\key OnIfHighZoneAirTemperature\n";
    ss << "\\key OnIfHighZoneCooling\n";
    ss << "\\key OnIfHighGlare\n";
    ss << "\\note Following entry should be used only if Shading Type = SwitchableGlazing\n";
    ss << "\\note and window is in a daylit zone\n";
    ss << "\\key MeetDaylightIlluminanceSetpoint\n";
    ss << "\\note The following three control types are used to reduce zone Heating load. They can be\n";
    ss << "\\note used with any Shading Type but are most appropriate for opaque interior or exterior\n";
    ss << "\\note shades with high insulating value (\"opaque movable insulation\")\n";
    ss << "\\key OnNightIfLowOutdoorTempAndOffDay\n";
    ss << "\\key OnNightIfLowInsideTempAndOffDay\n";
    ss << "\\key OnNightIfHeatingAndOffDay\n";
    ss << "\\note The following two control types are used to reduce zone heating and cooling load.\n";
    ss << "\\note They can be used with any Shading Type but are most appropriate for translucent interior\n";
    ss << "\\note or exterior shades with high insulating value (\"translucent movable insulation\")\n";
    ss << "\\key OnNightIfLowOutdoorTempAndOnDayIfCooling\n";
    ss << "\\key OnNightIfHeatingAndOnDayIfCooling\n";
    ss << "\\note The following two control types are used to reduce zone Cooling load.\n";
    ss << "\\note They can be used with any Shading Type but are most appropriate for interior\n";
    ss << "\\note or exterior blinds,interior or exterior shades with low insulating value, or\n";
    ss << "\\note switchable glazing\n";
    ss << "\\key OffNightAndOnDayIfCoolingAndHighSolarOnWindow\n";
    ss << "\\key OnNightAndOnDayIfCoolingAndHighSolarOnWindow\n";
    ss << "\\note The following four control types require that both Setpoint and Setpoint2 be specified\n";
    ss << "\\note Setpoint will correspond to outdoor air temp or zone air temp (deg C)\n";
    ss << "\\note Setpoint2 will correspond to solar on window or horizontal solar (W/m2)\n";
    ss << "\\key OnIfHighOutdoorAirTempAndHighSolarOnWindow\n";
    ss << "\\key OnIfHighOutdoorAirTempAndHighHorizontalSolar\n";
    ss << "\\key OnIfHighZoneAirTempAndHighSolarOnWindow\n";
    ss << "\\key OnIfHighZoneAirTempAndHighHorizontalSolar\n";
    ss << "A5 , \\field Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Required if Shading Control Is Scheduled = Yes.\n";
    ss << "\\note If schedule value = 1, shading control is active, i.e., shading can take place only\n";
    ss << "\\note if the control test passes. If schedule value = 0, shading is off whether or not\n";
    ss << "\\note the control test passes. Schedule Name is required if Shading Control Is Scheduled = Yes.\n";
    ss << "\\note If Schedule Name is not specified, shading control is assumed to be active at all times.\n";
    ss << "N1 , \\field Setpoint\n";
    ss << "\\units BasedOnField A4\n";
    ss << "\\note W/m2 for solar-based controls, W for cooling- or heating-based controls,\n";
    ss << "\\note deg C for temperature-based controls.\n";
    ss << "\\note Unused for Shading Control Type = AlwaysOn, AlwaysOff, OnIfScheduleAllows,\n";
    ss << "\\note OnIfHighGlare, Glare, and DaylightIlluminance\n";
    ss << "\\type real\n";
    ss << "A6 , \\field Shading Control Is Scheduled\n";
    ss << "\\type choice\n";
    ss << "\\key No\n";
    ss << "\\key Yes\n";
    ss << "\\default No\n";
    ss << "\\note If Yes, Schedule Name is required; if No, Schedule Name is not used.\n";
    ss << "\\note Shading Control Is Scheduled = Yes is required if Shading Control Type = OnIfScheduleAllows.\n";
    ss << "A7 , \\field Glare Control Is Active\n";
    ss << "\\type choice\n";
    ss << "\\key No\n";
    ss << "\\key Yes\n";
    ss << "\\default No\n";
    ss << "\\note If Yes and window is in a daylit zone, shading is on if zone's discomfort glare index exceeds\n";
    ss << "\\note the maximum discomfort glare index specified in the Daylighting object referenced by the zone.\n";
    ss << "\\note The glare test is OR'ed with the test specified by Shading Control Type.\n";
    ss << "\\note Glare Control Is Active = Yes is required if Shading Control Type = OnIfHighGlare.\n";
    ss << "A8,  \\field Shading Device Material Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowShadesScreensAndBlinds\n";
    ss << "\\note Enter the name of a WindowMaterial:Shade, WindowMaterial:Screen or WindowMaterial:Blind object.\n";
    ss << "\\note Required if \"Construction with Shading Name\" is not specified.\n";
    ss << "\\note Not used if Shading Control Type = SwitchableGlazing, BetweenGlassShade, or BetweenGlassBlind.\n";
    ss << "\\note If both \"Construction with Shading Name\" and \"Shading Device Material Name\" are entered,\n";
    ss << "\\note the former takes precedence.\n";
    ss << "A9 , \\field Type of Slat Angle Control for Blinds\n";
    ss << "\\type choice\n";
    ss << "\\key FixedSlatAngle\n";
    ss << "\\key ScheduledSlatAngle\n";
    ss << "\\key BlockBeamSolar\n";
    ss << "\\default FixedSlatAngle\n";
    ss << "\\note Used only if Shading Type = InteriorBlind, ExteriorBlind or BetweenGlassBlind.\n";
    ss << "\\note If choice is ScheduledSlatAngle then Slat Angle Schedule Name is required.\n";
    ss << "A10, \\field Slat Angle Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Used only if Shading Type = InteriorBlind, ExteriorBlind or BetweenGlassBlind.\n";
    ss << "\\note Required if Type of Slat Angle Control for Blinds = ScheduledSlatAngle\n";
    ss << "\\note Schedule values should be degrees (0 minimum, 180 maximum)\n";
    ss << "N2 ; \\field Setpoint 2\n";
    ss << "\\units BasedOnField A4\n";
    ss << "\\note W/m2 for solar-based controls, deg C for temperature-based controls.\n";
    ss << "\\note Used only as the second setpoint for the following two-setpoint control types:\n";
    ss << "\\note OnIfHighOutdoorAirTempAndHighSolarOnWindow, OnIfHighOutdoorAirTempAndHighHorizontalSolar,\n";
    ss << "\\note OnIfHighZoneAirTempAndHighSolarOnWindow, and OnIfHighZoneAirTempAndHighHorizontalSolar\n";
    ss << "\\type real\n";
    ss << "\\ip-units unknown\n";

    IddObjectType objType(IddObjectType::WindowProperty_ShadingControl);
    OptionalIddObject oObj = IddObject::load("WindowProperty:ShadingControl",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowProperty_ShadingControl);
  return object;
}

IddObject createWindowProperty_FrameAndDividerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowProperty:FrameAndDivider,\n";
    ss << "\\memo Specifies the dimensions of a window frame, dividers, and inside reveal surfaces.\n";
    ss << "\\memo Referenced by the surface objects for exterior windows and glass doors\n";
    ss << "\\memo (ref: FenestrationSurface:Detailed, Window, and GlazedDoor).\n";
    ss << "\\min-fields 20\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WindowFrameAndDividerNames\n";
    ss << "\\note Referenced by surfaces that are exterior windows\n";
    ss << "\\note Not used by interzone windows\n";
    ss << "N1 , \\field Frame Width\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Width of frame in plane of window\n";
    ss << "\\note Frame width assumed the same on all sides of window\n";
    ss << "N2 , \\field Frame Outside Projection\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.0\n";
    ss << "\\note Amount that frame projects outward from the outside face of the glazing\n";
    ss << "N3 , \\field Frame Inside Projection\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.0\n";
    ss << "\\note Amount that frame projects inward from the inside face of the glazing\n";
    ss << "N4 , \\field Frame Conductance\n";
    ss << "\\units W/m2-K\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Effective conductance of frame\n";
    ss << "\\note Excludes air films\n";
    ss << "\\note Obtained from WINDOW 5 or other 2-D calculation\n";
    ss << "N5 , \\field Ratio of Frame-Edge Glass Conductance to Center-Of-Glass Conductance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 4.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Excludes air films; applies only to multipane windows\n";
    ss << "\\note Obtained from WINDOW 5 or other 2-D calculation\n";
    ss << "N6 , \\field Frame Solar Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "\\note Assumed same on outside and inside of frame\n";
    ss << "N7 , \\field Frame Visible Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "\\note Assumed same on outside and inside of frame\n";
    ss << "N8 , \\field Frame Thermal Hemispherical Emissivity\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.9\n";
    ss << "\\note Assumed same on outside and inside of frame\n";
    ss << "A2 , \\field Divider Type\n";
    ss << "\\type choice\n";
    ss << "\\key DividedLite\n";
    ss << "\\key Suspended\n";
    ss << "\\default DividedLite\n";
    ss << "N9 , \\field Divider Width\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.0\n";
    ss << "\\note Width of dividers in plane of window\n";
    ss << "\\note Width assumed the same for all dividers\n";
    ss << "N10, \\field Number of Horizontal Dividers\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note \"Horizontal\" means parallel to local window X-axis\n";
    ss << "N11, \\field Number of Vertical Dividers\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note \"Vertical\" means parallel to local window Y-axis\n";
    ss << "N12, \\field Divider Outside Projection\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.0\n";
    ss << "\\note Amount that divider projects outward from the outside face of the glazing\n";
    ss << "\\note Outside projection assumed the same for all divider elements\n";
    ss << "N13, \\field Divider Inside Projection\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.0\n";
    ss << "\\note Amount that divider projects inward from the inside face of the glazing\n";
    ss << "\\note Inside projection assumed the same for all divider elements\n";
    ss << "N14, \\field Divider Conductance\n";
    ss << "\\units W/m2-K\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Effective conductance of divider\n";
    ss << "\\note Excludes air films\n";
    ss << "\\note Obtained from WINDOW 5 or other 2-D calculation\n";
    ss << "N15, \\field Ratio of Divider-Edge Glass Conductance to Center-Of-Glass Conductance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 4.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Excludes air films\n";
    ss << "\\note Obtained from WINDOW 5 or other 2-D calculation\n";
    ss << "N16, \\field Divider Solar Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Assumed same on outside and inside of divider\n";
    ss << "N17, \\field Divider Visible Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Assumed same on outside and inside of divider\n";
    ss << "N18, \\field Divider Thermal Hemispherical Emissivity\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\default 0.9\n";
    ss << "\\note Assumed same on outside and inside of divider\n";
    ss << "N19, \\field Outside Reveal Solar Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N20, \\field Inside Sill Depth\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 2.0\n";
    ss << "\\default 0.0\n";
    ss << "N21, \\field Inside Sill Solar Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N22, \\field Inside Reveal Depth\n";
    ss << "\\note Distance from plane of inside surface of glazing\n";
    ss << "\\note to plane of inside surface of wall.\n";
    ss << "\\note Outside reveal depth is determined from the geometry\n";
    ss << "\\note of the window and the wall it is on; it is non-zero if the plane of\n";
    ss << "\\note the outside surface of the glazing is set back from the plane of the\n";
    ss << "\\note outside surface of the wall.\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 2.0\n";
    ss << "\\default 0.0\n";
    ss << "N23; \\field Inside Reveal Solar Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::WindowProperty_FrameAndDivider);
    OptionalIddObject oObj = IddObject::load("WindowProperty:FrameAndDivider",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowProperty_FrameAndDivider);
  return object;
}

IddObject createWindowProperty_AirflowControlIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowProperty:AirflowControl,\n";
    ss << "\\memo Used to control forced airflow through a gap between glass layers\n";
    ss << "\\min-fields 7\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SubSurfNames\n";
    ss << "\\note Name must be that of an exterior window with two or three glass layers.\n";
    ss << "A2 , \\field Airflow Source\n";
    ss << "\\type choice\n";
    ss << "\\key IndoorAir\n";
    ss << "\\key OutdoorAir\n";
    ss << "\\default IndoorAir\n";
    ss << "A3 , \\field Airflow Destination\n";
    ss << "\\type choice\n";
    ss << "\\key IndoorAir\n";
    ss << "\\key OutdoorAir\n";
    ss << "\\key ReturnAir\n";
    ss << "\\default OutdoorAir\n";
    ss << "N1 , \\field Maximum Flow Rate\n";
    ss << "\\units m3/s-m\n";
    ss << "\\note Above is m3/s per m of glazing width\n";
    ss << "\\ip-units ft3/min-ft\n";
    ss << "\\default 0.0\n";
    ss << "\\minimum 0.0\n";
    ss << "A4 , \\field Airflow Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key AlwaysOnAtMaximumFlow\n";
    ss << "\\key AlwaysOff\n";
    ss << "\\key ScheduledOnly\n";
    ss << "\\note ScheduledOnly requires that Airflow Has Multiplier Schedule Name = Yes\n";
    ss << "\\note  and that Airflow Multiplier Schedule Name is specified.\n";
    ss << "\\default AlwaysOnAtMaximumFlow\n";
    ss << "A5 , \\field Airflow Is Scheduled\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note If Yes, then Airflow Multiplier Schedule Name must be specified\n";
    ss << "A6 ; \\field Airflow Multiplier Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Required if Airflow Is Scheduled = Yes.\n";
    ss << "\\note Schedule values are 0.0 or 1.0 and multiply Maximum Air Flow.\n";

    IddObjectType objType(IddObjectType::WindowProperty_AirflowControl);
    OptionalIddObject oObj = IddObject::load("WindowProperty:AirflowControl",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowProperty_AirflowControl);
  return object;
}

IddObject createWindowProperty_StormWindowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WindowProperty:StormWindow,\n";
    ss << "\\min-fields 7\n";
    ss << "\\memo This is a movable exterior glass layer that is usually applied in the winter\n";
    ss << "\\memo and removed in the summer.\n";
    ss << "A1,  \\field Window Name\n";
    ss << "\\note Must be the name of a FenestrationSurface:Detailed object with Surface Type = WINDOW.\n";
    ss << "\\note The WindowProperty:StormWindow object can only be used with exterior windows.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SubSurfNames\n";
    ss << "A2,  \\field Storm Glass Layer Name\n";
    ss << "\\note Must be a WindowMaterial:Glazing or WindowMaterial:Glazing:RefractionExtinctionMethod\n";
    ss << "\\note Gap between storm glass layer and adjacent glass layer is assumed to be filled\n";
    ss << "\\note with Air\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list GlazingMaterialName\n";
    ss << "N1,  \\field Distance Between Storm Glass Layer and Adjacent Glass\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.050\n";
    ss << "N2,  \\field Month that Storm Glass Layer is Put On\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "\\type integer\n";
    ss << "N3,  \\field Day of Month that Storm Glass Layer is Put On\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "\\type integer\n";
    ss << "N4,  \\field Month that Storm Glass Layer is Taken Off\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "\\type integer\n";
    ss << "N5;  \\field Day of Month that Storm Glass Layer is Taken Off\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "\\type integer\n";

    IddObjectType objType(IddObjectType::WindowProperty_StormWindow);
    OptionalIddObject oObj = IddObject::load("WindowProperty:StormWindow",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WindowProperty_StormWindow);
  return object;
}

IddObject createInternalMassIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "InternalMass,\n";
    ss << "\\memo Used to describe internal zone surface area that does not need to be part of geometric\n";
    ss << "\\memo representation. This should be the total surface area exposed to the zone air.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference RadiantSurfaceNames\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\note To be matched with a construction in this input file\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone the surface is a part of\n";
    ss << "\\note used to be Interior Environment\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1 ; \\field Surface Area\n";
    ss << "\\required-field\n";
    ss << "\\units m2\n";
    ss << "\\minimum> 0\n";

    IddObjectType objType(IddObjectType::InternalMass);
    OptionalIddObject oObj = IddObject::load("InternalMass",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::InternalMass);
  return object;
}

IddObject createShading_SiteIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Shading:Site,\n";
    ss << "\\memo used for shading elements such as trees\n";
    ss << "\\memo these items are fixed in space and would not move with relative geometry\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "\\reference AllShadingSurfNames\n";
    ss << "N1,  \\field Azimuth Angle\n";
    ss << "\\note Facing direction of outside of shading device (S=180,N=0,E=90,W=270)\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 360\n";
    ss << "\\units deg\n";
    ss << "N2,  \\field Tilt Angle\n";
    ss << "\\default 90\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "\\units deg\n";
    ss << "N3,  \\field Starting X Coordinate\n";
    ss << "\\note Starting coordinate is the Lower Left Corner of the Shade\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Starting Y Coordinate\n";
    ss << "\\units m\n";
    ss << "N5,  \\field Starting Z Coordinate\n";
    ss << "\\units m\n";
    ss << "N6,  \\field Length\n";
    ss << "\\units m\n";
    ss << "N7;  \\field Height\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::Shading_Site);
    OptionalIddObject oObj = IddObject::load("Shading:Site",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Shading_Site);
  return object;
}

IddObject createShading_BuildingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Shading:Building,\n";
    ss << "\\memo used for shading elements such as trees, other buildings, parts of this building not being modeled\n";
    ss << "\\memo these items are relative to the current building and would move with relative geometry\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "\\reference AllShadingSurfNames\n";
    ss << "N1,  \\field Azimuth Angle\n";
    ss << "\\note Facing direction of outside of shading device (S=180,N=0,E=90,W=270)\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 360\n";
    ss << "\\units deg\n";
    ss << "N2,  \\field Tilt Angle\n";
    ss << "\\default 90\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "\\units deg\n";
    ss << "N3,  \\field Starting X Coordinate\n";
    ss << "\\note Starting coordinate is the Lower Left Corner of the Shade\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Starting Y Coordinate\n";
    ss << "\\units m\n";
    ss << "N5,  \\field Starting Z Coordinate\n";
    ss << "\\units m\n";
    ss << "N6,  \\field Length\n";
    ss << "\\units m\n";
    ss << "N7;  \\field Height\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::Shading_Building);
    OptionalIddObject oObj = IddObject::load("Shading:Building",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Shading_Building);
  return object;
}

IddObject createShading_Site_DetailedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Shading:Site:Detailed,\n";
    ss << "\\extensible:3 -- duplicate last set of x,y,z coordinates, renumbering please (and changing z terminator to , for all but last)\n";
    ss << "\\memo used for shading elements such as trees\n";
    ss << "\\memo these items are fixed in space and would not move with relative geometry\n";
    ss << "\\format vertices\n";
    ss << "\\min-fields 12\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "\\reference AllShadingSurfNames\n";
    ss << "A2,  \\field Transmittance Schedule Name\n";
    ss << "\\note Transmittance schedule for the shading device, defaults to zero (always opaque)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Number of Vertices\n";
    ss << "\\note shown with 6 vertex coordinates -- extensible object\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "\\minimum 3\n";
    ss << "\\note Rules for vertices are given in GlobalGeometryRules coordinates --\n";
    ss << "\\note For this object all surface coordinates are in world coordinates.\n";
    ss << "N2,  \\field Vertex 1 X-coordinate\n";
    ss << "\\begin-extensible\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Vertex 1 Y-coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N4 ; \\field Vertex 1 Z-coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::Shading_Site_Detailed);
    OptionalIddObject oObj = IddObject::load("Shading:Site:Detailed",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Shading_Site_Detailed);
  return object;
}

IddObject createShading_Building_DetailedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Shading:Building:Detailed,\n";
    ss << "\\extensible:3 -- duplicate last set of x,y,z coordinates, renumbering please (and changing z terminator to , for all but last)\n";
    ss << "\\memo used for shading elements such as trees, other buildings, parts of this building not being modeled\n";
    ss << "\\memo these items are relative to the current building and would move with relative geometry\n";
    ss << "\\format vertices\n";
    ss << "\\min-fields 12\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "\\reference AllShadingSurfNames\n";
    ss << "A2,  \\field Transmittance Schedule Name\n";
    ss << "\\note Transmittance schedule for the shading device, defaults to zero (always opaque)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Number of Vertices\n";
    ss << "\\note shown with 6 vertex coordinates -- extensible object\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "\\minimum 3\n";
    ss << "\\note Rules for vertices are given in GlobalGeometryRules coordinates --\n";
    ss << "\\note For this object all surface coordinates are relative to the building origin (0,0,0)\n";
    ss << "\\note and will rotate with the BUILDING north axis.\n";
    ss << "N2,  \\field Vertex 1 X-coordinate\n";
    ss << "\\begin-extensible\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Vertex 1 Y-coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N4 ; \\field Vertex 1 Z-coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::Shading_Building_Detailed);
    OptionalIddObject oObj = IddObject::load("Shading:Building:Detailed",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Shading_Building_Detailed);
  return object;
}

IddObject createShading_OverhangIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Shading:Overhang,\n";
    ss << "\\memo Overhangs are usually flat shading surfaces that reference a window or door.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AttachedShadingSurfNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "\\reference AllShadingSurfNames\n";
    ss << "A2 , \\field Window or Door Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SubSurfNames\n";
    ss << "N1,  \\field Height above Window or Door\n";
    ss << "\\units m\n";
    ss << "N2,  \\field Tilt Angle from Window/Door\n";
    ss << "\\units deg\n";
    ss << "\\default 90\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "N3,  \\field Left extension from Window/Door Width\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Right extension from Window/Door Width\n";
    ss << "\\note N3 + N4 + Window/Door Width is Overhang Length\n";
    ss << "\\units m\n";
    ss << "N5;  \\field Depth\n";
    ss << "\\units m\n";
    ss << "\\minimum 0\n";

    IddObjectType objType(IddObjectType::Shading_Overhang);
    OptionalIddObject oObj = IddObject::load("Shading:Overhang",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Shading_Overhang);
  return object;
}

IddObject createShading_Overhang_ProjectionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Shading:Overhang:Projection,\n";
    ss << "\\memo Overhangs are typically flat shading surfaces that reference a window or door.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AttachedShadingSurfNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "\\reference AllShadingSurfNames\n";
    ss << "A2 , \\field Window or Door Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SubSurfNames\n";
    ss << "N1,  \\field Height above Window or Door\n";
    ss << "\\units m\n";
    ss << "N2,  \\field Tilt Angle from Window/Door\n";
    ss << "\\units deg\n";
    ss << "\\default 90\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "N3,  \\field Left extension from Window/Door Width\n";
    ss << "\\units m\n";
    ss << "N4,  \\field Right extension from Window/Door Width\n";
    ss << "\\units m\n";
    ss << "\\note N3 + N4 + Window/Door Width is Overhang Length\n";
    ss << "N5;  \\field Depth as Fraction of Window/Door Height\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";

    IddObjectType objType(IddObjectType::Shading_Overhang_Projection);
    OptionalIddObject oObj = IddObject::load("Shading:Overhang:Projection",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Shading_Overhang_Projection);
  return object;
}

IddObject createShading_FinIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Shading:Fin,\n";
    ss << "\\memo Fins are usually shading surfaces that are perpendicular to a window or door.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AttachedShadingSurfNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "\\reference AllShadingSurfNames\n";
    ss << "A2 , \\field Window or Door Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SubSurfNames\n";
    ss << "N1,  \\field Left Extension from Window/Door\n";
    ss << "\\units m\n";
    ss << "N2,  \\field Left Distance Above Top of Window\n";
    ss << "\\units m\n";
    ss << "N3,  \\field Left Distance Below Bottom of Window\n";
    ss << "\\units m\n";
    ss << "\\note N2 + N3 + height of Window/Door is height of Fin\n";
    ss << "N4,  \\field Left Tilt Angle from Window/Door\n";
    ss << "\\units deg\n";
    ss << "\\default 90\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "N5,  \\field Left Depth\n";
    ss << "\\units m\n";
    ss << "\\minimum 0\n";
    ss << "N6,  \\field Right Extension from Window/Door\n";
    ss << "\\units m\n";
    ss << "N7,  \\field Right Distance Above Top of Window\n";
    ss << "\\units m\n";
    ss << "N8,  \\field Right Distance Below Bottom of Window\n";
    ss << "\\note N7 + N8 + height of Window/Door is height of Fin\n";
    ss << "\\units m\n";
    ss << "N9,  \\field Right Tilt Angle from Window/Door\n";
    ss << "\\units deg\n";
    ss << "\\default 90\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "N10; \\field Right Depth\n";
    ss << "\\units m\n";
    ss << "\\minimum 0\n";

    IddObjectType objType(IddObjectType::Shading_Fin);
    OptionalIddObject oObj = IddObject::load("Shading:Fin",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Shading_Fin);
  return object;
}

IddObject createShading_Fin_ProjectionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Shading:Fin:Projection,\n";
    ss << "\\memo Fins are usually shading surfaces that are perpendicular to a window or door.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AttachedShadingSurfNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "\\reference AllShadingSurfNames\n";
    ss << "A2 , \\field Window or Door Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SubSurfNames\n";
    ss << "N1,  \\field Left Extension from Window/Door\n";
    ss << "\\units m\n";
    ss << "N2,  \\field Left Distance Above Top of Window\n";
    ss << "\\units m\n";
    ss << "N3,  \\field Left Distance Below Bottom of Window\n";
    ss << "\\units m\n";
    ss << "\\note N2 + N3 + height of Window/Door is height of Fin\n";
    ss << "N4,  \\field Left Tilt Angle from Window/Door\n";
    ss << "\\units deg\n";
    ss << "\\default 90\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "N5,  \\field Left Depth as Fraction of Window/Door Width\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "N6,  \\field Right Extension from Window/Door\n";
    ss << "\\units m\n";
    ss << "N7,  \\field Right Distance Above Top of Window\n";
    ss << "\\units m\n";
    ss << "N8,  \\field Right Distance Below Bottom of Window\n";
    ss << "\\note N7 + N8 + height of Window/Door is height of Fin\n";
    ss << "\\units m\n";
    ss << "N9,  \\field Right Tilt Angle from Window/Door\n";
    ss << "\\units deg\n";
    ss << "\\default 90\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "N10; \\field Right Depth as Fraction of Window/Door Width\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";

    IddObjectType objType(IddObjectType::Shading_Fin_Projection);
    OptionalIddObject oObj = IddObject::load("Shading:Fin:Projection",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Shading_Fin_Projection);
  return object;
}

IddObject createShading_Zone_DetailedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Shading:Zone:Detailed,\n";
    ss << "\\extensible:3 -- duplicate last set of x,y,z coordinates, renumbering please (and changing z terminator to , for all but last)\n";
    ss << "\\memo used For fins, overhangs, elements that shade the building, are attached to the building\n";
    ss << "\\memo but are not part of the heat transfer calculations\n";
    ss << "\\format vertices\n";
    ss << "\\min-fields 13\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AttachedShadingSurfNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "\\reference AllShadingSurfNames\n";
    ss << "A2 , \\field Base Surface Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceNames\n";
    ss << "A3,  \\field Transmittance Schedule Name\n";
    ss << "\\note Transmittance schedule for the shading device, defaults to zero (always opaque)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Number of Vertices\n";
    ss << "\\note shown with 6 vertex coordinates -- extensible object\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "\\minimum 3\n";
    ss << "\\note vertices are given in GlobalGeometryRules coordinates -- if relative, all surface coordinates\n";
    ss << "\\note are \"relative\" to the Zone Origin.  if world, then building and zone origins are used\n";
    ss << "\\note for some internal calculations, but all coordinates are given in an \"absolute\" system.\n";
    ss << "N2,  \\field Vertex 1 X-coordinate\n";
    ss << "\\begin-extensible\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Vertex 1 Y-coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N4 ; \\field Vertex 1 Z-coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::Shading_Zone_Detailed);
    OptionalIddObject oObj = IddObject::load("Shading:Zone:Detailed",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Shading_Zone_Detailed);
  return object;
}

IddObject createShadingProperty_ReflectanceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ShadingProperty:Reflectance,\n";
    ss << "\\min-fields 3\n";
    ss << "\\memo If this object is not defined for a shading surface the default values\n";
    ss << "\\memo listed in following fields will be used in the solar reflection calculation.\n";
    ss << "A1,  \\field Shading Surface Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllShadingSurfNames\n";
    ss << "N1,  \\field Diffuse Solar Reflectance of Unglazed Part of Shading Surface\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.2\n";
    ss << "N2,  \\field Diffuse Visible Reflectance of Unglazed Part of Shading Surface\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.2\n";
    ss << "N3,  \\field Fraction of Shading Surface That Is Glazed\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "A2;  \\field Glazing Construction Name\n";
    ss << "\\note Required if Fraction of Shading Surface That Is Glazed > 0.0\n";

    IddObjectType objType(IddObjectType::ShadingProperty_Reflectance);
    OptionalIddObject oObj = IddObject::load("ShadingProperty:Reflectance",
                                             "Thermal Zones and Surfaces",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ShadingProperty_Reflectance);
  return object;
}

IddObject createSurfaceProperty_HeatTransferAlgorithmIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceProperty:HeatTransferAlgorithm,\n";
    ss << "\\memo Determines which Heat Balance Algorithm will be used for a specific surface\n";
    ss << "\\memo Allows selectively overriding the global setting in HeatBalanceAlgorithm\n";
    ss << "\\memo CTF (Conduction Transfer Functions),\n";
    ss << "\\memo EMPD (Effective Moisture Penetration Depth with Conduction Transfer Functions).\n";
    ss << "\\memo Advanced/Research Usage: CondFD (Conduction Finite Difference)\n";
    ss << "\\memo Advanced/Research Usage: HAMT (Combined Heat And Moisture Finite Element)\n";
    ss << "\\min-fields 2\n";
    ss << "A1 , \\field Surface Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceNames\n";
    ss << "A2 ; \\field Algorithm\n";
    ss << "\\type choice\n";
    ss << "\\key ConductionTransferFunction\n";
    ss << "\\key MoisturePenetrationDepthConductionTransferFunction\n";
    ss << "\\key ConductionFiniteDifference\n";
    ss << "\\key CombinedHeatAndMoistureFiniteElement\n";
    ss << "\\default ConductionTransferFunction\n";

    IddObjectType objType(IddObjectType::SurfaceProperty_HeatTransferAlgorithm);
    OptionalIddObject oObj = IddObject::load("SurfaceProperty:HeatTransferAlgorithm",
                                             "Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceProperty_HeatTransferAlgorithm);
  return object;
}

IddObject createSurfaceProperty_HeatTransferAlgorithm_MultipleSurfaceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceProperty:HeatTransferAlgorithm:MultipleSurface,\n";
    ss << "\\memo Determines which Heat Balance Algorithm will be used for a group of surface types\n";
    ss << "\\memo Allows selectively overriding the global setting in HeatBalanceAlgorithm\n";
    ss << "\\memo CTF (Conduction Transfer Functions),\n";
    ss << "\\memo EMPD (Effective Moisture Penetration Depth with Conduction Transfer Functions).\n";
    ss << "\\memo Advanced/Research Usage: CondFD (Conduction Finite Difference)\n";
    ss << "\\memo Advanced/Research Usage: HAMT (Combined Heat And Moisture Finite Element)\n";
    ss << "\\min-fields 3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Surface Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key AllExteriorSurfaces\n";
    ss << "\\key AllExteriorWalls\n";
    ss << "\\key AllExteriorRoofs\n";
    ss << "\\key AllExteriorFloors\n";
    ss << "\\key AllGroundContactSurfaces\n";
    ss << "\\key AllInteriorSurfaces\n";
    ss << "\\key AllInteriorWalls\n";
    ss << "\\key AllInteriorCeilings\n";
    ss << "\\key AllInteriorFloors\n";
    ss << "A3 ; \\field Algorithm\n";
    ss << "\\type choice\n";
    ss << "\\key ConductionTransferFunction\n";
    ss << "\\key MoisturePenetrationDepthConductionTransferFunction\n";
    ss << "\\key ConductionFiniteDifference\n";
    ss << "\\key CombinedHeatAndMoistureFiniteElement\n";
    ss << "\\default ConductionTransferFunction\n";

    IddObjectType objType(IddObjectType::SurfaceProperty_HeatTransferAlgorithm_MultipleSurface);
    OptionalIddObject oObj = IddObject::load("SurfaceProperty:HeatTransferAlgorithm:MultipleSurface",
                                             "Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceProperty_HeatTransferAlgorithm_MultipleSurface);
  return object;
}

IddObject createSurfaceProperty_HeatTransferAlgorithm_SurfaceListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceProperty:HeatTransferAlgorithm:SurfaceList,\n";
    ss << "\\min-fields 3\n";
    ss << "\\extensible:1\n";
    ss << "\\memo Determines which Heat Balance Algorithm will be used for a list of surfaces\n";
    ss << "\\memo Allows selectively overriding the global setting in HeatBalanceAlgorithm\n";
    ss << "\\memo CTF (Conduction Transfer Functions),\n";
    ss << "\\memo EMPD (Effective Moisture Penetration Depth with Conduction Transfer Functions).\n";
    ss << "\\memo Advanced/Research Usage: CondFD (Conduction Finite Difference)\n";
    ss << "\\memo Advanced/Research Usage: HAMT (Combined Heat And Moisture Finite Element)\n";
    ss << "\\min-fields 3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Algorithm\n";
    ss << "\\type choice\n";
    ss << "\\key ConductionTransferFunction\n";
    ss << "\\key MoisturePenetrationDepthConductionTransferFunction\n";
    ss << "\\key ConductionFiniteDifference\n";
    ss << "\\key CombinedHeatAndMoistureFiniteElement\n";
    ss << "\\default ConductionTransferFunction\n";
    ss << "A3 ; \\field Surface Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceNames\n";

    IddObjectType objType(IddObjectType::SurfaceProperty_HeatTransferAlgorithm_SurfaceList);
    OptionalIddObject oObj = IddObject::load("SurfaceProperty:HeatTransferAlgorithm:SurfaceList",
                                             "Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceProperty_HeatTransferAlgorithm_SurfaceList);
  return object;
}

IddObject createSurfaceProperty_HeatTransferAlgorithm_ConstructionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceProperty:HeatTransferAlgorithm:Construction,\n";
    ss << "\\memo Determines which Heat Balance Algorithm will be used for surfaces that have a specific type of construction\n";
    ss << "\\memo Allows selectively overriding the global setting in HeatBalanceAlgorithm\n";
    ss << "\\memo CTF (Conduction Transfer Functions),\n";
    ss << "\\memo EMPD (Effective Moisture Penetration Depth with Conduction Transfer Functions).\n";
    ss << "\\memo Advanced/Research Usage: CondFD (Conduction Finite Difference)\n";
    ss << "\\memo Advanced/Research Usage: HAMT (Combined Heat And Moisture Finite Element)\n";
    ss << "\\min-fields 3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Algorithm\n";
    ss << "\\type choice\n";
    ss << "\\key ConductionTransferFunction\n";
    ss << "\\key MoisturePenetrationDepthConductionTransferFunction\n";
    ss << "\\key ConductionFiniteDifference\n";
    ss << "\\key CombinedHeatAndMoistureFiniteElement\n";
    ss << "\\default ConductionTransferFunction\n";
    ss << "A3 ; \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";

    IddObjectType objType(IddObjectType::SurfaceProperty_HeatTransferAlgorithm_Construction);
    OptionalIddObject oObj = IddObject::load("SurfaceProperty:HeatTransferAlgorithm:Construction",
                                             "Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceProperty_HeatTransferAlgorithm_Construction);
  return object;
}

IddObject createSurfaceControl_MovableInsulationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceControl:MovableInsulation,\n";
    ss << "\\memo Exterior or Interior Insulation on opaque surfaces\n";
    ss << "A1, \\field Insulation Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Outside\n";
    ss << "\\key Inside\n";
    ss << "A2, \\field Surface Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceNames\n";
    ss << "A3, \\field Material Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MaterialName\n";
    ss << "A4; \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::SurfaceControl_MovableInsulation);
    OptionalIddObject oObj = IddObject::load("SurfaceControl:MovableInsulation",
                                             "Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceControl_MovableInsulation);
  return object;
}

IddObject createSurfaceProperty_OtherSideCoefficientsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceProperty:OtherSideCoefficients,\n";
    ss << "\\memo This object sets the other side conditions for a surface in a variety of ways.\n";
    ss << "\\min-fields 8\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "N1, \\field Combined Convective/Radiative Film Coefficient\n";
    ss << "\\units W/m2-K\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note if>0, this field becomes the exterior convective/radiative film coefficient\n";
    ss << "\\note and the other fields are used to calculate the outdoor air temperature\n";
    ss << "\\note then exterior surface temperature based on outdoor air and specified coefficient\n";
    ss << "\\note if<=0, then remaining fields calculate the outside surface temperature\n";
    ss << "\\note The following fields are used in the equation:\n";
    ss << "\\note OtherSideTemp=N2*N3 + N4*OutdoorDry-bulb + N5*GroundTemp + N6*WindSpeed*OutdoorDry-bulb + N7*TempZone + N9*TempPrev\n";
    ss << "N2, \\field Constant Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "\\note This parameter will be overwritten by the values from the Constant Temperature Schedule Name (below) if one is present\n";
    ss << "N3, \\field Constant Temperature Coefficient\n";
    ss << "\\note This coefficient is used even with a Schedule.  It should normally be 1.0 in that case.\n";
    ss << "\\note This field is ignored if Sinusoidal Variation of Constant Temperature Coefficient = Yes.\n";
    ss << "\\default 1\n";
    ss << "N4, \\field External Dry-Bulb Temperature Coefficient\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N5, \\field Ground Temperature Coefficient\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N6, \\field Wind Speed Coefficient\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N7, \\field Zone Air Temperature Coefficient\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "A2, \\field Constant Temperature Schedule Name\n";
    ss << "\\note Name of schedule for values of constant temperature.\n";
    ss << "\\note Schedule values replace any value specified in the field Constant Temperature.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Sinusoidal Variation of Constant Temperature Coefficient\n";
    ss << "\\note Optionally used to vary Constant Temperature Coefficient with unitary sine wave\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N8, \\field Period of Sinusoidal Variation\n";
    ss << "\\note Use with sinusoidal variation to define the time period\n";
    ss << "\\type real\n";
    ss << "\\units hr\n";
    ss << "\\default 24\n";
    ss << "\\minimum> 0\n";
    ss << "N9, \\field Previous Other Side Temperature Coefficient\n";
    ss << "\\note This coefficient multiplies the other side temperature result from the\n";
    ss << "\\note previous zone timestep\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N10, \\field Minimum Other Side Temperature Limit\n";
    ss << "\\note This field specifies a lower limit for the other side temperature result.\n";
    ss << "\\note Blank indicates no limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N11; \\field Maximum Other Side Temperature Limit\n";
    ss << "\\note This field specifies an upper limit for the other side temperature result.\n";
    ss << "\\note Blank indicates no limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";

    IddObjectType objType(IddObjectType::SurfaceProperty_OtherSideCoefficients);
    OptionalIddObject oObj = IddObject::load("SurfaceProperty:OtherSideCoefficients",
                                             "Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceProperty_OtherSideCoefficients);
  return object;
}

IddObject createSurfaceProperty_OtherSideConditionsModelIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceProperty:OtherSideConditionsModel,\n";
    ss << "\\memo This object sets up modifying the other side conditions for a surface from other model results.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference OSCMNames\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "A2; \\field Type of Modeling\n";
    ss << "\\type choice\n";
    ss << "\\key GapConvectionRadiation\n";
    ss << "\\key UndergroundPipingSystemSurface\n";
    ss << "\\key GroundCoupledSurface\n";
    ss << "\\note GapConvectionRadiation provides boundary conditions for convection\n";
    ss << "\\note  and linearized thermal radiation across a gap or cavity\n";
    ss << "\\note  on the other side of the surface that are modeled separately.\n";
    ss << "\\note UndergroundPipingSystemSurface provides boundary conditions for\n";
    ss << "\\note  surfaces in contact with PipingSystem:Underground domains\n";
    ss << "\\note GroundCoupledSurface provides boundary conditions for surfaces\n";
    ss << "\\note  in contact with GroundDomain objects\n";
    ss << "\\default GapConvectionRadiation\n";

    IddObjectType objType(IddObjectType::SurfaceProperty_OtherSideConditionsModel);
    OptionalIddObject oObj = IddObject::load("SurfaceProperty:OtherSideConditionsModel",
                                             "Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceProperty_OtherSideConditionsModel);
  return object;
}

IddObject createSurfaceConvectionAlgorithm_Inside_AdaptiveModelSelectionsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceConvectionAlgorithm:Inside:AdaptiveModelSelections,\n";
    ss << "\\unique-object\n";
    ss << "\\memo Options to change the individual convection model equations for dynamic selection when using AdaptiveConvectiongAlgorithm\n";
    ss << "\\memo This object is only needed to make changes to the default model selections for any or all of the surface categories.\n";
    ss << "\\memo This object is for the inside face, the side of the surface facing a thermal zone.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Simple Buoyancy Vertical Wall Equation Source\n";
    ss << "\\note Applies to zone with no HVAC or when HVAC is off\n";
    ss << "\\note This is for vertical walls\n";
    ss << "\\type choice\n";
    ss << "\\default FohannoPolidoriVerticalWall\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key KhalifaEq3WallAwayFromHeat\n";
    ss << "\\key KhalifaEq6NonHeatedWalls\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key UserCurve\n";
    ss << "A3 , \\field Simple Buoyancy Vertical Wall User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A4 , \\field Simple Bouyancy Stable Horizontal Equation Source\n";
    ss << "\\note Applies to zone with no HVAC or when HVAC is off\n";
    ss << "\\note This is for horizontal surfaces with heat flow directed for stable thermal stratification\n";
    ss << "\\type choice\n";
    ss << "\\default AlamdariHammondStableHorizontal\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key UserCurve\n";
    ss << "A5 , \\field Simple Bouyancy Stable Horizontal Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A6 , \\field Simple Bouyancy Unstable Horizontal Equation Source\n";
    ss << "\\note Applies to zone with no HVAC or when HVAC is off\n";
    ss << "\\note This is for passive horizontal surfaces with heat flow for unstable thermal stratification\n";
    ss << "\\type choice\n";
    ss << "\\default AlamdariHammondUnstableHorizontal\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key UserCurve\n";
    ss << "A7 , \\field Simple Bouyancy Unstable Horizontal Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A8 , \\field Simple Bouyancy Stable Tilted Equation Source\n";
    ss << "\\note Applies to zone with no HVAC or when HVAC is off\n";
    ss << "\\note This is for tilted surfaces with heat flow for stable thermal stratification\n";
    ss << "\\type choice\n";
    ss << "\\default WaltonStableHorizontalOrTilt\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key UserCurve\n";
    ss << "A9 , \\field Simple Bouyancy Stable Tilted Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A10 , \\field Simple Bouyancy Unstable Tilted Equation Source\n";
    ss << "\\note Applies to zone with no HVAC or when HVAC is off\n";
    ss << "\\note This is for tilted surfaces with heat flow for unstable thermal stratification\n";
    ss << "\\type choice\n";
    ss << "\\default WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key UserCurve\n";
    ss << "A11, \\field Simple Bouyancy Unstable Tilted Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A12, \\field Simple Bouyancy Windows Equation Source\n";
    ss << "\\note Applies to zone with no HVAC or when HVAC is off\n";
    ss << "\\note This is for all window surfaces\n";
    ss << "\\type choice\n";
    ss << "\\default ISO15099Windows\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key KaradagChilledCeiling\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key UserCurve\n";
    ss << "A13, \\field Simple Bouyancy Windows Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A14, \\field Floor Heat Ceiling Cool Vertical Wall Equation Source\n";
    ss << "\\note Applies to zone with in-floor heating and/or in-ceiling cooling\n";
    ss << "\\note This is for vertical walls\n";
    ss << "\\type choice\n";
    ss << "\\default KhalifaEq3WallAwayFromHeat\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key KhalifaEq3WallAwayFromHeat\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key UserCurve\n";
    ss << "A15, \\field Floor Heat Ceiling Cool Vertical Wall Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A16, \\field Floor Heat Ceiling Cool Stable Horizontal Equation Source\n";
    ss << "\\note Applies to zone with in-floor heating and/or in-ceiling cooling\n";
    ss << "\\note This is for passive horizontal surfaces with heat flow for stable thermal stratification\n";
    ss << "\\type choice\n";
    ss << "\\default AlamdariHammondStableHorizontal\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key UserCurve\n";
    ss << "A17, \\field Floor Heat Ceiling Cool Stable Horizontal Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A18, \\field Floor Heat Ceiling Cool Unstable Horizontal Equation Source\n";
    ss << "\\note Applies to zone with in-floor heating and/or in-ceiling cooling\n";
    ss << "\\note This is for passive horizontal surfaces with heat flow for unstable thermal stratification\n";
    ss << "\\type choice\n";
    ss << "\\default KhalifaEq4CeilingAwayFromHeat\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key KhalifaEq4CeilingAwayFromHeat\n";
    ss << "\\key UserCurve\n";
    ss << "A19, \\field Floor Heat Ceiling Cool Unstable Horizontal Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A20, \\field Floor Heat Ceiling Cool Heated Floor Equation Source\n";
    ss << "\\note Applies to zone with in-floor heating and/or in-ceiling cooling\n";
    ss << "\\note This is for a floor with active heating elements\n";
    ss << "\\type choice\n";
    ss << "\\default AwbiHattonHeatedFloor\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key AwbiHattonHeatedFloor\n";
    ss << "\\key UserCurve\n";
    ss << "A21, \\field Floor Heat Ceiling Cool Heated Floor Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A22, \\field Floor Heat Ceiling Cool Chilled Ceiling Equation Source\n";
    ss << "\\note Applies to zone with in-floor heating and/or in-ceiling cooling\n";
    ss << "\\note This is for a ceiling with active cooling elements\n";
    ss << "\\type choice\n";
    ss << "\\default KaradagChilledCeiling\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key KaradagChilledCeiling\n";
    ss << "\\key UserCurve\n";
    ss << "A23, \\field Floor Heat Ceiling Cool Chilled Ceiling Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A24, \\field Floor Heat Ceiling Cool Stable Tilted Equation Source\n";
    ss << "\\note Applies to zone with in-floor heating and/or in-ceiling cooling\n";
    ss << "\\note This is for tilted surfaces with heat flow for stable thermal stratification\n";
    ss << "\\type choice\n";
    ss << "\\default WaltonStableHorizontalOrTilt\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key UserCurve\n";
    ss << "A25, \\field Floor Heat Ceiling Cool Stable Tilted Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A26, \\field Floor Heat Ceiling Cool Unstable Tilted Equation Source\n";
    ss << "\\note Applies to zone with in-floor heating and/or in-ceiling cooling\n";
    ss << "\\note This is for tilted surfaces with heat flow for unstable thermal stratification\n";
    ss << "\\type choice\n";
    ss << "\\default WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key UserCurve\n";
    ss << "A27, \\field Floor Heat Ceiling Cool Unstable Tilted Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A28, \\field Floor Heat Ceiling Cool Window Equation Source\n";
    ss << "\\note Applies to zone with in-floor heating and/or in-ceiling cooling\n";
    ss << "\\note This is for all window surfaces\n";
    ss << "\\type choice\n";
    ss << "\\default ISO15099Windows\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key UserCurve\n";
    ss << "A29, \\field Floor Heat Ceiling Cool Window Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A30, \\field Wall Panel Heating Vertical Wall Equation Source\n";
    ss << "\\note Applies to zone with in-wall panel heating\n";
    ss << "\\note This is for vertical walls that are not actively heated\n";
    ss << "\\type choice\n";
    ss << "\\default KhalifaEq6NonHeatedWalls\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key KhalifaEq6NonHeatedWalls\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key UserCurve\n";
    ss << "A31, \\field Wall Panel Heating Vertical Wall Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A32, \\field Wall Panel Heating Heated Wall Equation Source\n";
    ss << "\\note Applies to zone with in-wall panel heating\n";
    ss << "\\note This is for vertical walls that are being actively heated\n";
    ss << "\\type choice\n";
    ss << "\\default AwbiHattonHeatedWall\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key KhalifaEq5WallNearHeat\n";
    ss << "\\key AwbiHattonHeatedWall\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key UserCurve\n";
    ss << "A33, \\field Wall Panel Heating Heated Wall Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A34, \\field Wall Panel Heating Stable Horizontal Equation Source\n";
    ss << "\\note Applies to zone with in-wall panel heating\n";
    ss << "\\note This is for horizontal surfaces with heat flow directed for stable thermal stratification\n";
    ss << "\\type choice\n";
    ss << "\\default AlamdariHammondStableHorizontal\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key UserCurve\n";
    ss << "A35, \\field Wall Panel Heating Stable Horizontal Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A36, \\field Wall Panel Heating Unstable Horizontal Equation Source\n";
    ss << "\\note Applies to zone with in-wall panel heating\n";
    ss << "\\note This is for horizontal surfaces with heat flow directed for unstable thermal stratification\n";
    ss << "\\type choice\n";
    ss << "\\default KhalifaEq7Ceiling\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key KhalifaEq7Ceiling\n";
    ss << "\\key KaradagChilledCeiling\n";
    ss << "\\key UserCurve\n";
    ss << "A37, \\field Wall Panel Heating Unstable Horizontal Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A38, \\field Wall Panel Heating Stable Tilted Equation Source\n";
    ss << "\\note Applies to zone with in-wall panel heating\n";
    ss << "\\note This is for tilted surfaces with heat flow for stable thermal stratification\n";
    ss << "\\type choice\n";
    ss << "\\default WaltonStableHorizontalOrTilt\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key UserCurve\n";
    ss << "A39, \\field Wall Panel Heating Stable Tilted Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A40, \\field Wall Panel Heating Unstable Tilted Equation Source\n";
    ss << "\\note Applies to zone with in-wall panel heating\n";
    ss << "\\note This is for tilted surfaces with heat flow for unstable thermal stratification\n";
    ss << "\\type choice\n";
    ss << "\\default WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key UserCurve\n";
    ss << "A41, \\field Wall Panel Heating Unstable Tilted Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A42, \\field Wall Panel Heating Window Equation Source\n";
    ss << "\\note Applies to zone with in-wall panel heating\n";
    ss << "\\note This is for all window surfaces\n";
    ss << "\\type choice\n";
    ss << "\\default ISO15099Windows\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key UserCurve\n";
    ss << "A43, \\field Wall Panel Heating Window Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A44, \\field Convective Zone Heater Vertical Wall Equation Source\n";
    ss << "\\note Applies to zone with convective heater\n";
    ss << "\\note This is for vertical walls not directly affected by heater\n";
    ss << "\\type choice\n";
    ss << "\\default FohannoPolidoriVerticalWall\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key KhalifaEq3WallAwayFromHeat\n";
    ss << "\\key KhalifaEq6NonHeatedWalls\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key UserCurve\n";
    ss << "A45, \\field Convective Zone Heater Vertical Wall Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A46, \\field Convective Zone Heater Vertical Walls Near Heater Equation Source\n";
    ss << "\\note Applies to zone with convective heater\n";
    ss << "\\note This is for vertical walls that are directly affected by heater\n";
    ss << "\\note Walls are considered \"near\" when listed in field set for Fraction of Radiant Energy to Surface\n";
    ss << "\\type choice\n";
    ss << "\\default KhalifaEq5WallNearHeat\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key KhalifaEq5WallNearHeat\n";
    ss << "\\key AwbiHattonHeatedWall\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key UserCurve\n";
    ss << "A47, \\field Convective Zone Heater Vertical Walls Near Heater Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A48, \\field Convective Zone Heater Stable Horizontal Equation Source\n";
    ss << "\\note Applies to zone with convective heater\n";
    ss << "\\note This is for horizontal surfaces with heat flow directed for stable thermal stratification\n";
    ss << "\\type choice\n";
    ss << "\\default AlamdariHammondStableHorizontal\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key UserCurve\n";
    ss << "A49, \\field Convective Zone Heater Stable Horizontal Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A50, \\field Convective Zone Heater Unstable Horizontal Equation Source\n";
    ss << "\\note Applies to zone with convective heater\n";
    ss << "\\note This is for horizontal surfaces with heat flow directed for unstable thermal stratification\n";
    ss << "\\type choice\n";
    ss << "\\default KhalifaEq7Ceiling\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key KhalifaEq4CeilingAwayFromHeat\n";
    ss << "\\key KhalifaEq7Ceiling\n";
    ss << "\\key UserCurve\n";
    ss << "A51, \\field Convective Zone Heater Unstable Horizontal Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A52, \\field Convective Zone Heater Stable Tilted Equation Source\n";
    ss << "\\note Applies to zone with convective heater\n";
    ss << "\\note This is for tilted surfaces with heat flow for stable thermal stratification\n";
    ss << "\\type choice\n";
    ss << "\\default WaltonStableHorizontalOrTilt\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key UserCurve\n";
    ss << "A53, \\field Convective Zone Heater Stable Tilted Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A54, \\field Convective Zone Heater Unstable Tilted Equation Source\n";
    ss << "\\note Applies to zone with convective heater\n";
    ss << "\\note This is for tilted surfaces with heat flow for unstable thermal stratification\n";
    ss << "\\type choice\n";
    ss << "\\default WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key UserCurve\n";
    ss << "A55, \\field Convective Zone Heater Unstable Tilted Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A56, \\field Convective Zone Heater Windows Equation Source\n";
    ss << "\\note Applies to zone with convective heater\n";
    ss << "\\note This is for all window surfaces\n";
    ss << "\\type choice\n";
    ss << "\\default ISO15099Windows\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key KhalifaEq3WallAwayFromHeat\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key UserCurve\n";
    ss << "A57, \\field Convective Zone Heater Windows Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A58, \\field Central Air Diffuser Wall Equation Source\n";
    ss << "\\note Applies to zone with mechanical forced central air with diffusers\n";
    ss << "\\note This is for all wall surfaces\n";
    ss << "\\type choice\n";
    ss << "\\default GoldsteinNovoselacCeilingDiffuserWalls\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key FisherPedersenCeilingDiffuserWalls\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key BeausoleilMorrisonMixedAssistedWall\n";
    ss << "\\key BeausoleilMorrisonMixedOpposingWall\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWalls\n";
    ss << "\\key UserCurve\n";
    ss << "A59, \\field Central Air Diffuser Wall Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A60, \\field Central Air Diffuser Ceiling Equation Source\n";
    ss << "\\note Applies to zone with mechanical forced central air with diffusers\n";
    ss << "\\note This is for all ceiling surfaces\n";
    ss << "\\type choice\n";
    ss << "\\default FisherPedersenCeilingDiffuserCeiling\n";
    ss << "\\key FisherPedersenCeilingDiffuserCeiling\n";
    ss << "\\key BeausoleilMorrisonMixedStableCeiling\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableCeiling\n";
    ss << "\\key UserCurve\n";
    ss << "A61, \\field Central Air Diffuser Ceiling Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A62, \\field Central Air Diffuser Floor Equation Source\n";
    ss << "\\note Applies to zone with mechanical forced central air with diffusers\n";
    ss << "\\note This is for all floor surfaces\n";
    ss << "\\type choice\n";
    ss << "\\default GoldsteinNovoselacCeilingDiffuserFloor\n";
    ss << "\\key FisherPedersenCeilingDiffuserFloor\n";
    ss << "\\key BeausoleilMorrisonMixedStableFloor\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableFloor\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserFloor\n";
    ss << "\\key UserCurve\n";
    ss << "A63, \\field Central Air Diffuser Floor Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A64, \\field Central Air Diffuser Window Equation Source\n";
    ss << "\\note Applies to zone with mechanical forced central air with diffusers\n";
    ss << "\\note This is for all window surfaces\n";
    ss << "\\type choice\n";
    ss << "\\default GoldsteinNovoselacCeilingDiffuserWindow\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key FisherPedersenCeilingDiffuserWalls\n";
    ss << "\\key BeausoleilMorrisonMixedAssistedWall\n";
    ss << "\\key BeausoleilMorrisonMixedOpposingWall\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWindow\n";
    ss << "\\key UserCurve\n";
    ss << "A65, \\field Central Air Diffuser Window Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A66, \\field Mechanical Zone Fan Circulation Vertical Wall Equation Source\n";
    ss << "\\note reference choice fields\n";
    ss << "\\type choice\n";
    ss << "\\default KhalifaEq3WallAwayFromHeat\n";
    ss << "\\key KhalifaEq3WallAwayFromHeat\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key FisherPedersenCeilingDiffuserWalls\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key BeausoleilMorrisonMixedAssistedWall\n";
    ss << "\\key BeausoleilMorrisonMixedOpposingWall\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWalls\n";
    ss << "\\key UserCurve\n";
    ss << "A67, \\field Mechanical Zone Fan Circulation Vertical Wall Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A68, \\field Mechanical Zone Fan Circulation Stable Horizontal Equation Source\n";
    ss << "\\note reference choice fields\n";
    ss << "\\type choice\n";
    ss << "\\default AlamdariHammondStableHorizontal\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key UserCurve\n";
    ss << "A69, \\field Mechanical Zone Fan Circulation Stable Horizontal Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A70, \\field Mechanical Zone Fan Circulation Unstable Horizontal Equation Source\n";
    ss << "\\note reference choice fields\n";
    ss << "\\type choice\n";
    ss << "\\default KhalifaEq4CeilingAwayFromHeat\n";
    ss << "\\key KhalifaEq4CeilingAwayFromHeat\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key UserCurve\n";
    ss << "A71, \\field Mechanical Zone Fan Circulation Unstable Horizontal Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A72, \\field Mechanical Zone Fan Circulation Stable Tilted Equation Source\n";
    ss << "\\note reference choice fields\n";
    ss << "\\type choice\n";
    ss << "\\default WaltonStableHorizontalOrTilt\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key UserCurve\n";
    ss << "A73, \\field Mechanical Zone Fan Circulation Stable Tilted Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A74, \\field Mechanical Zone Fan Circulation Unstable Tilted Equation Source\n";
    ss << "\\note reference choice fields\n";
    ss << "\\type choice\n";
    ss << "\\default WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key UserCurve\n";
    ss << "A75, \\field Mechanical Zone Fan Circulation Unstable Tilted Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A76, \\field Mechanical Zone Fan Circulation Window Equation Source\n";
    ss << "\\note reference choice fields\n";
    ss << "\\type choice\n";
    ss << "\\default ISO15099Windows\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWindow\n";
    ss << "\\key UserCurve\n";
    ss << "A77, \\field Mechanical Zone Fan Circulation Window Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A78, \\field Mixed Regime Bouyancy Assisting Flow on Walls Equation Source\n";
    ss << "\\note reference choice fields\n";
    ss << "\\type choice\n";
    ss << "\\default BeausoleilMorrisonMixedAssistedWall\n";
    ss << "\\key BeausoleilMorrisonMixedAssistedWall\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key FisherPedersenCeilingDiffuserWalls\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWalls\n";
    ss << "\\key UserCurve\n";
    ss << "A79, \\field Mixed Regime Bouyancy Assisting Flow on Walls Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A80, \\field Mixed Regime Bouyancy Oppossing Flow on Walls Equation Source\n";
    ss << "\\note reference choice fields\n";
    ss << "\\type choice\n";
    ss << "\\default BeausoleilMorrisonMixedOpposingWall\n";
    ss << "\\key BeausoleilMorrisonMixedOpposingWall\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key FisherPedersenCeilingDiffuserWalls\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWalls\n";
    ss << "\\key UserCurve\n";
    ss << "A81, \\field Mixed Regime Bouyancy Oppossing Flow on Walls Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A82, \\field Mixed Regime Stable Floor Equation Source\n";
    ss << "\\note reference choice fields\n";
    ss << "\\type choice\n";
    ss << "\\default BeausoleilMorrisonMixedStableFloor\n";
    ss << "\\key BeausoleilMorrisonMixedStableFloor\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key UserCurve\n";
    ss << "A83, \\field Mixed Regime Stable Floor Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A84, \\field Mixed Regime Unstable Floor Equation Source\n";
    ss << "\\note reference choice fields\n";
    ss << "\\type choice\n";
    ss << "\\default BeausoleilMorrisonMixedUnstableFloor\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableFloor\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key UserCurve\n";
    ss << "A85, \\field Mixed Regime Unstable Floor Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A86, \\field Mixed Regime Stable Ceiling Equation Source\n";
    ss << "\\note reference choice fields\n";
    ss << "\\type choice\n";
    ss << "\\default BeausoleilMorrisonMixedStableCeiling\n";
    ss << "\\key BeausoleilMorrisonMixedStableCeiling\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key UserCurve\n";
    ss << "A87, \\field Mixed Regime Stable Ceiling Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A88, \\field Mixed Regime Unstable Ceiling Equation Source\n";
    ss << "\\note reference choice fields\n";
    ss << "\\type choice\n";
    ss << "\\default BeausoleilMorrisonMixedUnstableCeiling\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableCeiling\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key UserCurve\n";
    ss << "A89, \\field Mixed Regime Unstable Ceiling Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";
    ss << "A90, \\field Mixed Regime Window Equation Source\n";
    ss << "\\note reference choice fields\n";
    ss << "\\type choice\n";
    ss << "\\default GoldsteinNovoselacCeilingDiffuserWindow\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWindow\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key UserCurve\n";
    ss << "A91; \\field Mixed Regime Window Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Inside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionInsideModels\n";

    IddObjectType objType(IddObjectType::SurfaceConvectionAlgorithm_Inside_AdaptiveModelSelections);
    OptionalIddObject oObj = IddObject::load("SurfaceConvectionAlgorithm:Inside:AdaptiveModelSelections",
                                             "Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceConvectionAlgorithm_Inside_AdaptiveModelSelections);
  return object;
}

IddObject createSurfaceConvectionAlgorithm_Outside_AdaptiveModelSelectionsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceConvectionAlgorithm:Outside:AdaptiveModelSelections,\n";
    ss << "\\unique-object\n";
    ss << "\\memo Options to change the individual convection model equations for dynamic selection when using AdaptiveConvectiongAlgorithm\n";
    ss << "\\memo This object is only needed to make changes to the default model selections for any or all of the surface categories.\n";
    ss << "\\memo This object is for the outside face, the side of the surface facing away from the thermal zone.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Wind Convection Windward Vertical Wall Equation Source\n";
    ss << "\\type choice\n";
    ss << "\\default TARPWindward\n";
    ss << "\\key SimpleCombined\n";
    ss << "\\key TARPWindward\n";
    ss << "\\key MoWiTTWindward\n";
    ss << "\\key DOE2Windward\n";
    ss << "\\key NusseltJurges\n";
    ss << "\\key McAdams\n";
    ss << "\\key Mitchell\n";
    ss << "\\key BlockenWindward\n";
    ss << "\\key EmmelVertical\n";
    ss << "\\key UserCurve\n";
    ss << "A3 , \\field Wind Convection Windward Equation Vertical Wall User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Outside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionOutsideModels\n";
    ss << "A4 , \\field Wind Convection Leeward Vertical Wall Equation Source\n";
    ss << "\\type choice\n";
    ss << "\\default TARPLeeward\n";
    ss << "\\key SimpleCombined\n";
    ss << "\\key TARPLeeward\n";
    ss << "\\key MoWiTTLeeward\n";
    ss << "\\key DOE2Leeward\n";
    ss << "\\key EmmelVertical\n";
    ss << "\\key NusseltJurges\n";
    ss << "\\key McAdams\n";
    ss << "\\key Mitchell\n";
    ss << "\\key UserCurve\n";
    ss << "A5 , \\field Wind Convection Leeward Vertical Wall Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Outside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionOutsideModels\n";
    ss << "A6 , \\field Wind Convection Horizontal Roof Equation Source\n";
    ss << "\\type choice\n";
    ss << "\\default ClearRoof\n";
    ss << "\\key SimpleCombined\n";
    ss << "\\key TARPWindward\n";
    ss << "\\key MoWiTTWindward\n";
    ss << "\\key DOE2Windward\n";
    ss << "\\key NusseltJurges\n";
    ss << "\\key McAdams\n";
    ss << "\\key Mitchell\n";
    ss << "\\key BlockenWindward\n";
    ss << "\\key EmmelRoof\n";
    ss << "\\key ClearRoof\n";
    ss << "\\key UserCurve\n";
    ss << "A7 , \\field Wind Convection Horizontal Roof User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Outside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionOutsideModels\n";
    ss << "A8 , \\field Natural Convection Vertical Wall Equation Source\n";
    ss << "\\note This is for vertical walls\n";
    ss << "\\type choice\n";
    ss << "\\default ASHRAEVerticalWall\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key UserCurve\n";
    ss << "\\key None\n";
    ss << "A9 , \\field Natural Convection Vertical Wall Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Outside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionOutsideModels\n";
    ss << "A10, \\field Natural Convection Stable Horizontal Equation Source\n";
    ss << "\\note This is for horizontal surfaces with heat flow directed for stable thermal stratification\n";
    ss << "\\type choice\n";
    ss << "\\default WaltonStableHorizontalOrTilt\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key UserCurve\n";
    ss << "\\key None\n";
    ss << "A11, \\field Natural Convection Stable Horizontal Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Outside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionOutsideModels\n";
    ss << "A12, \\field Natural Convection Unstable Horizontal Equation Source\n";
    ss << "\\type choice\n";
    ss << "\\default WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key UserCurve\n";
    ss << "\\key None\n";
    ss << "A13; \\field Natural Convection Unstable Horizontal Equation User Curve Name\n";
    ss << "\\note The SurfaceConvectionAlgorithm:Outside:UserCurve named in this field is used when the previous field is set to UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionOutsideModels\n";

    IddObjectType objType(IddObjectType::SurfaceConvectionAlgorithm_Outside_AdaptiveModelSelections);
    OptionalIddObject oObj = IddObject::load("SurfaceConvectionAlgorithm:Outside:AdaptiveModelSelections",
                                             "Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceConvectionAlgorithm_Outside_AdaptiveModelSelections);
  return object;
}

IddObject createSurfaceConvectionAlgorithm_Inside_UserCurveIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceConvectionAlgorithm:Inside:UserCurve,\n";
    ss << "\\memo Used to describe a custom model equation for surface convection heat transfer coefficient\n";
    ss << "\\memo If more than one curve is referenced they are all used and added together.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\reference UserConvectionInsideModels\n";
    ss << "\\reference UserConvectionModels\n";
    ss << "A2 , \\field Reference Temperature for Convection Heat Transfer\n";
    ss << "\\note Controls which temperature is differenced from surface temperature when using the Hc value\n";
    ss << "\\type choice\n";
    ss << "\\key MeanAirTemperature\n";
    ss << "\\key AdjacentAirTemperature\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "A3 , \\field Hc Function of Temperature Difference Curve Name\n";
    ss << "\\note  Curve's \"x\" is absolute value of delta-T (Surface temperature minus reference temperature, (C))\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\object-list QuarticCurves\n";
    ss << "\\object-list ExponentCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A4 , \\field Hc Function of Temperature Difference Divided by Height Curve Name\n";
    ss << "\\note Curve's \"x\" is absolute value of delta-T/Height (Surface temp minus Air temp)/(vertical length scale), (C/m)\n";
    ss << "\\note when used for an inside face the vertical length scale is the zone's interior height\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\object-list QuarticCurves\n";
    ss << "\\object-list ExponentCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A5 , \\field Hc Function of Air Change Rate Curve Name\n";
    ss << "\\note Curve's \"x\" is mechanical ACH (Air Changes per hour from mechanical air system), (1/hr)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\object-list QuarticCurves\n";
    ss << "\\object-list ExponentCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A6 ; \\field Hc Function of Air System Volume Flow Rate Divided by Zone Perimeter Length Curve Name\n";
    ss << "\\note Curve's \"x\" is mechanical system air flow rate (m3/s) divided by zone's length along\n";
    ss << "\\note exterior walls (m).\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\object-list QuarticCurves\n";
    ss << "\\object-list ExponentCurves\n";
    ss << "\\object-list UniVariateTables\n";

    IddObjectType objType(IddObjectType::SurfaceConvectionAlgorithm_Inside_UserCurve);
    OptionalIddObject oObj = IddObject::load("SurfaceConvectionAlgorithm:Inside:UserCurve",
                                             "Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceConvectionAlgorithm_Inside_UserCurve);
  return object;
}

IddObject createSurfaceConvectionAlgorithm_Outside_UserCurveIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceConvectionAlgorithm:Outside:UserCurve,\n";
    ss << "\\memo Used to describe a custom model equation for surface convection heat transfer coefficient\n";
    ss << "\\memo If more than one curve is referenced they are all used and added together.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\reference UserConvectionOutsideModels\n";
    ss << "\\reference UserConvectionModels\n";
    ss << "A2 , \\field Wind Speed Type for Curve\n";
    ss << "\\type choice\n";
    ss << "\\key WeatherFile\n";
    ss << "\\key HeightAdjust\n";
    ss << "\\key ParallelComponent\n";
    ss << "\\key ParallelComponentHeightAdjust\n";
    ss << "\\default HeightAdjust\n";
    ss << "A3 , \\field Hf Function of Wind Speed Curve Name\n";
    ss << "\\note Curve's \"x\" is wind speed of the type determined in the previous field (m/s)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\object-list QuarticCurves\n";
    ss << "\\object-list ExponentCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A4 , \\field Hn Function of Temperature Difference Curve Name\n";
    ss << "\\note  Curve's \"x\" is absolute value of delta-T (Surface temperature minus air temperature, (C))\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\object-list QuarticCurves\n";
    ss << "\\object-list ExponentCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A5 ; \\field Hn Function of Temperature Difference Divided by Height Curve Name\n";
    ss << "\\note Curve's \"x\" is absolute value of delta-T/Height (Surface temp minus Air temp)/(vertical length scale), (C/m)\n";
    ss << "\\note when used for an outside face the vertical length scale is the exterior facade's overall height\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\object-list QuarticCurves\n";
    ss << "\\object-list ExponentCurves\n";
    ss << "\\object-list UniVariateTables\n";

    IddObjectType objType(IddObjectType::SurfaceConvectionAlgorithm_Outside_UserCurve);
    OptionalIddObject oObj = IddObject::load("SurfaceConvectionAlgorithm:Outside:UserCurve",
                                             "Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceConvectionAlgorithm_Outside_UserCurve);
  return object;
}

IddObject createSurfaceProperty_ConvectionCoefficientsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceProperty:ConvectionCoefficients,\n";
    ss << "\\memo Allow user settable interior and/or exterior convection coefficients.\n";
    ss << "\\memo Note that some other factors may limit the lower bounds for these values, such as\n";
    ss << "\\memo for windows, the interior convection coefficient must be >.28,\n";
    ss << "\\memo for trombe wall algorithm selection (zone), the interior convection coefficient must be >.1\n";
    ss << "\\memo for TARP interior convection, the lower limit is also .1\n";
    ss << "\\memo Minimum and maximum limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\memo Defaults in HeatBalanceAlgorithm object are [.1,1000].\n";
    ss << "A1, \\field Surface Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllHeatTranSurfNames\n";
    ss << "A2, \\field Convection Coefficient 1 Location\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Outside\n";
    ss << "\\key Inside\n";
    ss << "A3, \\field Convection Coefficient 1 Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Value\n";
    ss << "\\key Schedule\n";
    ss << "\\key UserCurve\n";
    ss << "\\key Simple\n";
    ss << "\\key SimpleCombined\n";
    ss << "\\key TARP\n";
    ss << "\\key DOE-2\n";
    ss << "\\key MoWitt\n";
    ss << "\\key AdaptiveConvectionAlgorithm\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key FisherPedersenCeilingDiffuserWalls\n";
    ss << "\\key FisherPedersenCeilingDiffuserCeiling\n";
    ss << "\\key FisherPedersenCeilingDiffuserFloor\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key KhalifaEq3WallAwayFromHeat\n";
    ss << "\\key KhalifaEq4CeilingAwayFromHeat\n";
    ss << "\\key KhalifaEq5WallNearHeat\n";
    ss << "\\key KhalifaEq6NonHeatedWalls\n";
    ss << "\\key KhalifaEq7Ceiling\n";
    ss << "\\key AwbiHattonHeatedFloor\n";
    ss << "\\key AwbiHattonHeatedWall\n";
    ss << "\\key BeausoleilMorrisonMixedAssistedWall\n";
    ss << "\\key BeausoleilMorrisonMixedOpposingWall\n";
    ss << "\\key BeausoleilMorrisonMixedStableFloor\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableFloor\n";
    ss << "\\key BeausoleilMorrisonMixedStableCeiling\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableCeiling\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key KaradagChilledCeiling\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWindow\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWalls\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserFloor\n";
    ss << "\\key NusseltJurges\n";
    ss << "\\key McAdams\n";
    ss << "\\key Mitchell\n";
    ss << "\\key EmmelVertical\n";
    ss << "\\key EmmelRoof\n";
    ss << "\\key ClearRoof\n";
    ss << "N1, \\field Convection Coefficient 1\n";
    ss << "\\note used if Convection Type=Value, min and max limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\note Default limits are Minimum >= 0.1 and Maximum <= 1000\n";
    ss << "\\units W/m2-K\n";
    ss << "A4, \\field Convection Coefficient 1 Schedule Name\n";
    ss << "\\note used if Convection Type=Schedule,  min and max limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\note Default limits are Minimum >= 0.1 and Maximum <= 1000\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5, \\field Convection Coefficient 1 User Curve Name\n";
    ss << "\\note used if Convection Type = UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionModels\n";
    ss << "A6, \\field Convection Coefficient 2 Location\n";
    ss << "\\type choice\n";
    ss << "\\key Outside\n";
    ss << "\\key Inside\n";
    ss << "A7, \\field Convection Coefficient 2 Type\n";
    ss << "\\type choice\n";
    ss << "\\key Value\n";
    ss << "\\key Schedule\n";
    ss << "\\key UserCurve\n";
    ss << "\\key Simple\n";
    ss << "\\key SimpleCombined\n";
    ss << "\\key TARP\n";
    ss << "\\key DOE-2\n";
    ss << "\\key MoWitt\n";
    ss << "\\key AdaptiveConvectionAlgorithm\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key FisherPedersenCeilingDiffuserWalls\n";
    ss << "\\key FisherPedersenCeilingDiffuserCeiling\n";
    ss << "\\key FisherPedersenCeilingDiffuserFloor\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key KhalifaEq3WallAwayFromHeat\n";
    ss << "\\key KhalifaEq4CeilingAwayFromHeat\n";
    ss << "\\key KhalifaEq5WallNearHeat\n";
    ss << "\\key KhalifaEq6NonHeatedWalls\n";
    ss << "\\key KhalifaEq7Ceiling\n";
    ss << "\\key AwbiHattonHeatedFloor\n";
    ss << "\\key AwbiHattonHeatedWall\n";
    ss << "\\key BeausoleilMorrisonMixedAssistedWall\n";
    ss << "\\key BeausoleilMorrisonMixedOpposingWall\n";
    ss << "\\key BeausoleilMorrisonMixedStableFloor\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableFloor\n";
    ss << "\\key BeausoleilMorrisonMixedStableCeiling\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableCeiling\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key KaradagChilledCeiling\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWindow\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWalls\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserFloor\n";
    ss << "\\key NusseltJurges\n";
    ss << "\\key McAdams\n";
    ss << "\\key Mitchell\n";
    ss << "\\key EmmelVertical\n";
    ss << "\\key EmmelRoof\n";
    ss << "\\key ClearRoof\n";
    ss << "N2, \\field Convection Coefficient 2\n";
    ss << "\\note used if Convection Type=Value, min and max limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\note Default limits are Minimum >= 0.1 and Maximum <= 1000\n";
    ss << "\\default .1\n";
    ss << "\\units W/m2-K\n";
    ss << "A8, \\field Convection Coefficient 2 Schedule Name\n";
    ss << "\\note used if Convection Type=Schedule,  min and max limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\note Default limits are Minimum >= 0.1 and Maximum <= 1000\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A9; \\field Convection Coefficient 2 User Curve Name\n";
    ss << "\\note used if Convection Type = UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionModels\n";

    IddObjectType objType(IddObjectType::SurfaceProperty_ConvectionCoefficients);
    OptionalIddObject oObj = IddObject::load("SurfaceProperty:ConvectionCoefficients",
                                             "Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceProperty_ConvectionCoefficients);
  return object;
}

IddObject createSurfaceProperty_ConvectionCoefficients_MultipleSurfaceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceProperty:ConvectionCoefficients:MultipleSurface,\n";
    ss << "\\memo Allow user settable interior and/or exterior convection coefficients.\n";
    ss << "\\memo Note that some other factors may limit the lower bounds for these values, such as\n";
    ss << "\\memo for windows, the interior convection coefficient must be >.28,\n";
    ss << "\\memo for trombe wall algorithm selection (zone), the interior convection coefficient must be >.1\n";
    ss << "\\memo for TARP interior convection, the lower limit is also .1\n";
    ss << "\\memo Minimum and maximum limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\memo Defaults in HeatBalanceAlgorithm object are [.1,1000].\n";
    ss << "A1, \\field Surface Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key AllExteriorSurfaces\n";
    ss << "\\key AllExteriorWindows\n";
    ss << "\\key AllExteriorWalls\n";
    ss << "\\key AllExteriorRoofs\n";
    ss << "\\key AllExteriorFloors\n";
    ss << "\\key AllInteriorSurfaces\n";
    ss << "\\key AllInteriorWalls\n";
    ss << "\\key AllInteriorWindows\n";
    ss << "\\key AllInteriorCeilings\n";
    ss << "\\key AllInteriorFloors\n";
    ss << "A2, \\field Convection Coefficient 1 Location\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Outside\n";
    ss << "\\key Inside\n";
    ss << "A3, \\field Convection Coefficient 1 Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Value\n";
    ss << "\\key Schedule\n";
    ss << "\\key Simple\n";
    ss << "\\key SimpleCombined\n";
    ss << "\\key TARP\n";
    ss << "\\key DOE-2\n";
    ss << "\\key MoWitt\n";
    ss << "\\key AdaptiveConvectionAlgorithm\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key FisherPedersenCeilingDiffuserWalls\n";
    ss << "\\key FisherPedersenCeilingDiffuserCeiling\n";
    ss << "\\key FisherPedersenCeilingDiffuserFloor\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key KhalifaEq3WallAwayFromHeat\n";
    ss << "\\key KhalifaEq4CeilingAwayFromHeat\n";
    ss << "\\key KhalifaEq5WallNearHeat\n";
    ss << "\\key KhalifaEq6NonHeatedWalls\n";
    ss << "\\key KhalifaEq7Ceiling\n";
    ss << "\\key AwbiHattonHeatedFloor\n";
    ss << "\\key AwbiHattonHeatedWall\n";
    ss << "\\key BeausoleilMorrisonMixedAssistedWall\n";
    ss << "\\key BeausoleilMorrisonMixedOpposingWall\n";
    ss << "\\key BeausoleilMorrisonMixedStableFloor\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableFloor\n";
    ss << "\\key BeausoleilMorrisonMixedStableCeiling\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableCeiling\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key KaradagChilledCeiling\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWindow\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWalls\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserFloor\n";
    ss << "\\key NusseltJurges\n";
    ss << "\\key McAdams\n";
    ss << "\\key Mitchell\n";
    ss << "\\key BlockenWindard\n";
    ss << "\\key EmmelVertical\n";
    ss << "\\key EmmelRoof\n";
    ss << "\\key ClearRoof\n";
    ss << "\\key UserCurve\n";
    ss << "N1, \\field Convection Coefficient 1\n";
    ss << "\\note used if Convection Type=Value, min and max limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\note Default limits are Minimum >= 0.1 and Maximum <= 1000\n";
    ss << "\\units W/m2-K\n";
    ss << "A4, \\field Convection Coefficient 1 Schedule Name\n";
    ss << "\\note used if Convection Type=Schedule,  min and max limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\note Default limits are Minimum >= 0.1 and Maximum <= 1000\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5, \\field Convection Coefficient 1 User Curve Name\n";
    ss << "\\note used if Convection Type = UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionModels\n";
    ss << "A6, \\field Convection Coefficient 2 Location\n";
    ss << "\\type choice\n";
    ss << "\\key Outside\n";
    ss << "\\key Inside\n";
    ss << "A7, \\field Convection Coefficient 2 Type\n";
    ss << "\\type choice\n";
    ss << "\\type choice\n";
    ss << "\\key Value\n";
    ss << "\\key Schedule\n";
    ss << "\\key Simple\n";
    ss << "\\key SimpleCombined\n";
    ss << "\\key TARP\n";
    ss << "\\key DOE-2\n";
    ss << "\\key MoWitt\n";
    ss << "\\key AdaptiveConvectionAlgorithm\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key FisherPedersenCeilingDiffuserWalls\n";
    ss << "\\key FisherPedersenCeilingDiffuserCeiling\n";
    ss << "\\key FisherPedersenCeilingDiffuserFloor\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key KhalifaEq3WallAwayFromHeat\n";
    ss << "\\key KhalifaEq4CeilingAwayFromHeat\n";
    ss << "\\key KhalifaEq5WallNearHeat\n";
    ss << "\\key KhalifaEq6NonHeatedWalls\n";
    ss << "\\key KhalifaEq7Ceiling\n";
    ss << "\\key AwbiHattonHeatedFloor\n";
    ss << "\\key AwbiHattonHeatedWall\n";
    ss << "\\key BeausoleilMorrisonMixedAssistedWall\n";
    ss << "\\key BeausoleilMorrisonMixedOpposingWall\n";
    ss << "\\key BeausoleilMorrisonMixedStableFloor\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableFloor\n";
    ss << "\\key BeausoleilMorrisonMixedStableCeiling\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableCeiling\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key KaradagChilledCeiling\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWindow\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWalls\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserFloor\n";
    ss << "\\key NusseltJurges\n";
    ss << "\\key McAdams\n";
    ss << "\\key Mitchell\n";
    ss << "\\key BlockenWindard\n";
    ss << "\\key EmmelVertical\n";
    ss << "\\key EmmelRoof\n";
    ss << "\\key ClearRoof\n";
    ss << "\\key UserCurve\n";
    ss << "N2, \\field Convection Coefficient 2\n";
    ss << "\\note used if Convection Type=Value, min and max limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\note Default limits are Minimum >= 0.1 and Maximum <= 1000\n";
    ss << "\\default .1\n";
    ss << "\\units W/m2-K\n";
    ss << "A8, \\field Convection Coefficient 2 Schedule Name\n";
    ss << "\\note used if Convection Type=Schedule,  min and max limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\note Default limits are Minimum >= 0.1 and Maximum <= 1000\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A9; \\field Convection Coefficient 2 User Curve Name\n";
    ss << "\\note used if Convection Type = UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionModels\n";

    IddObjectType objType(IddObjectType::SurfaceProperty_ConvectionCoefficients_MultipleSurface);
    OptionalIddObject oObj = IddObject::load("SurfaceProperty:ConvectionCoefficients:MultipleSurface",
                                             "Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceProperty_ConvectionCoefficients_MultipleSurface);
  return object;
}

IddObject createSurfaceProperties_VaporCoefficientsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceProperties:VaporCoefficients,\n";
    ss << "\\memo The interior and external vapor transfer coefficients.\n";
    ss << "\\memo Normally these value are calculated using the heat convection coefficient values.\n";
    ss << "\\memo Use this object to used fixed constant values.\n";
    ss << "\\memo Units are kg/Pa.s.m2\n";
    ss << "\\memo This will only work with the CombinedHeatAndMoistureFiniteElement algorithm for surfaces.\n";
    ss << "\\memo Other algorithms will ignore these coefficients\n";
    ss << "\\min-fields 4\n";
    ss << "A1, \\field Surface Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceNames\n";
    ss << "A2, \\field Constant External Vapor Transfer Coefficient\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N1, \\field External Vapor Coefficient Value\n";
    ss << "\\units kg/Pa-s-m2\n";
    ss << "\\default 0\n";
    ss << "\\minimum 0.0\n";
    ss << "A3, \\field Constant Internal vapor Transfer Coefficient\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N2; \\field Internal Vapor Coefficient Value\n";
    ss << "\\units kg/Pa-s-m2\n";
    ss << "\\default 0\n";
    ss << "\\minimum 0.0\n";

    IddObjectType objType(IddObjectType::SurfaceProperties_VaporCoefficients);
    OptionalIddObject oObj = IddObject::load("SurfaceProperties:VaporCoefficients",
                                             "Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceProperties_VaporCoefficients);
  return object;
}

IddObject createSurfaceProperty_ExteriorNaturalVentedCavityIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceProperty:ExteriorNaturalVentedCavity,\n";
    ss << "\\memo Used to describe the decoupled layer, or baffle, and the characteristics of the cavity\n";
    ss << "\\memo and openings for naturally ventilated exterior surfaces. This object is also used in\n";
    ss << "\\memo conjunction with the OtherSideConditionsModel.\n";
    ss << "\\extensible:1 - repeat last field, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\min-fields 12\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2,  \\field Boundary Conditions Model Name\n";
    ss << "\\note Enter the name of a SurfaceProperty:OtherSideConditionsModel object\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OSCMNames\n";
    ss << "N1,  \\field Area Fraction of Openings\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N2,  \\field Thermal Emissivity of Exterior Baffle Material\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\units dimensionless\n";
    ss << "N3,  \\field Solar Absorbtivity of Exterior Baffle\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\units dimensionless\n";
    ss << "N4, \\field Height Scale for Buoyancy-Driven Ventilation\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "N5,  \\field Effective Thickness of Cavity Behind Exterior Baffle\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.\n";
    ss << "\\units m\n";
    ss << "\\note if corrugated, use average depth\n";
    ss << "N6,  \\field Ratio of Actual Surface Area to Projected Surface Area\n";
    ss << "\\type real\n";
    ss << "\\note this parameter is used to help account for corrugations in the collector\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum 0.8\n";
    ss << "\\maximum 2.0\n";
    ss << "\\units dimensionless\n";
    ss << "A3,  \\field Roughness of Exterior Surface\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key VeryRough\n";
    ss << "\\key Rough\n";
    ss << "\\key MediumRough\n";
    ss << "\\key MediumSmooth\n";
    ss << "\\key Smooth\n";
    ss << "\\key VerySmooth\n";
    ss << "N7,  \\field Effectiveness for Perforations with Respect to Wind\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 0.25\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1.5\n";
    ss << "N8,  \\field Discharge Coefficient for Openings with Respect to Buoyancy Driven Flow\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 0.65\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.5\n";
    ss << "A4;  \\field Surface 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllShadingAndHTSurfNames\n";

    IddObjectType objType(IddObjectType::SurfaceProperty_ExteriorNaturalVentedCavity);
    OptionalIddObject oObj = IddObject::load("SurfaceProperty:ExteriorNaturalVentedCavity",
                                             "Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceProperty_ExteriorNaturalVentedCavity);
  return object;
}

IddObject createSurfaceProperty_SolarIncidentInsideIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceProperty:SolarIncidentInside,\n";
    ss << "\\memo Used to provide incident solar radiation on the inside of the surface. Reference surface-construction pair\n";
    ss << "\\memo and if that pair is used in a simulation, then program will use value provided in schedule instead of calculating it.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Surface Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceNames\n";
    ss << "A3,  \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A4;  \\field Inside Surface Incident Sun Solar Radiation Schedule Name\n";
    ss << "\\memo Values in schedule are expected to be in W/m2\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::SurfaceProperty_SolarIncidentInside);
    OptionalIddObject oObj = IddObject::load("SurfaceProperty:SolarIncidentInside",
                                             "Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceProperty_SolarIncidentInside);
  return object;
}

IddObject createComplexFenestrationProperty_SolarAbsorbedLayersIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ComplexFenestrationProperty:SolarAbsorbedLayers,\n";
    ss << "\\memo Used to provide solar radiation absorbed in fenestration layers. References surface-construction pair\n";
    ss << "\\memo and if that pair is used in a simulation, then program will use value provided in schedules instead of calculating it.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Fenestration Surface\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SubSurfNames\n";
    ss << "A3,  \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ComplexFenestrationStates\n";
    ss << "A4,  \\field Layer 1 Solar Radiation Absorbed Schedule Name\n";
    ss << "\\memo Values in schedule are expected to be in W/m2\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5,  \\field Layer 2 Solar Radiation Absorbed Schedule Name\n";
    ss << "\\memo Values in schedule are expected to be in W/m2\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6,  \\field Layer 3 Solar Radiation Absorbed Schedule Name\n";
    ss << "\\memo Values in schedule are expected to be in W/m2\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A7,  \\field Layer 4 Solar Radiation Absorbed Schedule Name\n";
    ss << "\\memo Values in schedule are expected to be in W/m2\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A8;  \\field Layer 5 Solar Radiation Absorbed Schedule Name\n";
    ss << "\\memo Values in schedule are expected to be in W/m2\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::ComplexFenestrationProperty_SolarAbsorbedLayers);
    OptionalIddObject oObj = IddObject::load("ComplexFenestrationProperty:SolarAbsorbedLayers",
                                             "Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ComplexFenestrationProperty_SolarAbsorbedLayers);
  return object;
}

IddObject createZoneProperty_UserViewFactors_bySurfaceNameIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneProperty:UserViewFactors:bySurfaceName,\n";
    ss << "\\memo View factors for Surface to Surface in a zone.\n";
    ss << "\\memo (Number of Surfaces)**2 must be entered.\n";
    ss << "\\extensible:3 - copy last three fields, remembering to remove ;\n";
    ss << "\\format ViewFactor\n";
    ss << "A1,  \\field Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A2,  \\field From Surface 1\n";
    ss << "\\begin-extensible\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllHeatTranSurfNames\n";
    ss << "A3,  \\field To Surface 1\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllHeatTranSurfNames\n";
    ss << "N1;  \\field View Factor 1\n";
    ss << "\\note This value is the view factor value From Surface => To Surface\n";
    ss << "\\type real\n";
    ss << "\\maximum 1.0\n";

    IddObjectType objType(IddObjectType::ZoneProperty_UserViewFactors_bySurfaceName);
    OptionalIddObject oObj = IddObject::load("ZoneProperty:UserViewFactors:bySurfaceName",
                                             "Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneProperty_UserViewFactors_bySurfaceName);
  return object;
}

IddObject createGroundHeatTransfer_ControlIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Control,\n";
    ss << "\\memo Object determines if the Slab and Basement preprocessors\n";
    ss << "\\memo are going to be executed.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\note This field is included for consistency.11\n";
    ss << "A2 , \\field Run Basement Preprocessor\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A3 ; \\field Run Slab Preprocessor\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Control);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Control",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Control);
  return object;
}

IddObject createGroundHeatTransfer_Slab_MaterialsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Slab:Materials,\n";
    ss << "\\memo Object gives an overall description of the slab ground heat transfer model.\n";
    ss << "N1, \\field NMAT: Number of materials\n";
    ss << "\\note This field specifies the number of different materials that will be used in the model.\n";
    ss << "\\note Typically only a ground material and a slab material are used. (2 materials)\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "N2, \\field ALBEDO: Surface Albedo: No Snow\n";
    ss << "\\note Two fields specify the albedo value of the surface: first for no snow coverage days;\n";
    ss << "\\note second for days with snow coverage. The albedo is the solar reflectivity of the surface,\n";
    ss << "\\note and can vary from 0.05 for blacktop to 0.95 for fresh snow.\n";
    ss << "\\note Typical values for North America reported by Bahnfleth range from 0.16 to 0.4.\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.16\n";
    ss << "N3, \\field ALBEDO: Surface Albedo: Snow\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.40\n";
    ss << "N4, \\field EPSLW: Surface Emissivity: No Snow\n";
    ss << "\\note EPSLW (No Snow and Snow) specifies the long wavelength (thermal) emissivity of the ground surface.\n";
    ss << "\\note primarily important for nighttime radiation to sky.\n";
    ss << "\\note typical value .95\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.94\n";
    ss << "N5, \\field EPSLW: Surface Emissivity: Snow\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.86\n";
    ss << "N6, \\field Z0: Surface Roughness: No Snow\n";
    ss << "\\note fields Z0 (No Snow and Snow) describe the height at which an experimentally velocity profile goes to zero.\n";
    ss << "\\note typical value= .75 cm\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default .75\n";
    ss << "\\units cm\n";
    ss << "N7, \\field Z0: Surface Roughness: Snow\n";
    ss << "\\note typical value= .05 cm\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.25\n";
    ss << "\\units cm\n";
    ss << "N8, \\field HIN: Indoor HConv: Downward Flow\n";
    ss << "\\note These fields specify the combined convective and radiative heat transfer coefficient between\n";
    ss << "\\note the slab top inside surface and the room air for the cases where heat is flowing downward,\n";
    ss << "\\note and upward. The program toggles between the two if the direction of the heat flux changes.\n";
    ss << "\\note Typical values can be found in the ASHRAE Handbook of Fundamentals, but should be\n";
    ss << "\\note about 6 W/(m2-K) for downward heat flow and 9 W/(m2-K) for upward heat flow.\n";
    ss << "\\note typical value= 4-10\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 6.13\n";
    ss << "N9; \\field HIN: Indoor HConv: Upward\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note typical value= 4-10\n";
    ss << "\\units W/m2-K\n";
    ss << "\\default 9.26\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Slab_Materials);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Slab:Materials",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Slab_Materials);
  return object;
}

IddObject createGroundHeatTransfer_Slab_MatlPropsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Slab:MatlProps,\n";
    ss << "\\memo This object contains the material properties for the materials\n";
    ss << "\\memo used in the model. The fields are mostly self explanatory.\n";
    ss << "N1,  \\field RHO: Slab Material density\n";
    ss << "\\note Density of Slab Material\n";
    ss << "\\note typical value= 2300.0\n";
    ss << "\\units kg/m3\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 2300\n";
    ss << "N2,  \\field RHO: Soil Density\n";
    ss << "\\note Density of Soil Material\n";
    ss << "\\note typical value= 1200.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1200\n";
    ss << "\\units kg/m3\n";
    ss << "N3,  \\field CP: Slab CP\n";
    ss << "\\note Specific Heat of Slab Material\n";
    ss << "\\note typical value=650.0\n";
    ss << "\\units J/kg-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 650\n";
    ss << "N4,  \\field CP: Soil CP\n";
    ss << "\\note Specific Heat of Soil Material\n";
    ss << "\\note typical value= 1200.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1200\n";
    ss << "\\units J/kg-K\n";
    ss << "N5,  \\field TCON: Slab k\n";
    ss << "\\note Conductivity of Slab Material\n";
    ss << "\\note typical value= .9\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W/m-K\n";
    ss << "\\default 0.9\n";
    ss << "N6;  \\field TCON: Soil k\n";
    ss << "\\note Conductivity of Soil Material\n";
    ss << "\\note typical value= 1.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W/m-K\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Slab_MatlProps);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Slab:MatlProps",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Slab_MatlProps);
  return object;
}

IddObject createGroundHeatTransfer_Slab_BoundCondsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Slab:BoundConds,\n";
    ss << "\\memo Supplies some of the boundary conditions used in the ground heat transfer calculations.\n";
    ss << "A1, \\field EVTR: Is surface evapotranspiration modeled\n";
    ss << "\\note This field specifies whether or not to use the evapotransporation model.\n";
    ss << "\\note The inclusion of evapotransporation in the calculation has the greatest\n";
    ss << "\\note effect in warm dry climates, primarily on the ground surface temperature.\n";
    ss << "\\note This field can be used to turn the evapotransporation off and on to check\n";
    ss << "\\note sensitivity to it.\n";
    ss << "\\type choice\n";
    ss << "\\key TRUE\n";
    ss << "\\key FALSE\n";
    ss << "\\required-field\n";
    ss << "A2, \\field FIXBC: is the lower boundary at a fixed temperature\n";
    ss << "\\note This field permits using a fixed temperature at the lower surface of the model\n";
    ss << "\\note instead of a zero heat flux condition. This change normally has a very small\n";
    ss << "\\note effect on the results.\n";
    ss << "\\note FALSE selects the zero flux lower boundary condition\n";
    ss << "\\type choice\n";
    ss << "\\key TRUE\n";
    ss << "\\key FALSE\n";
    ss << "\\required-field\n";
    ss << "N1, \\field TDEEPin\n";
    ss << "\\note User input lower boundary temperature if FIXBC is TRUE\n";
    ss << "\\note Blank for FIXBC FALSE or to use the calculated 1-D deep ground temperature.\n";
    ss << "\\units C\n";
    ss << "A3, \\field USRHflag: Is the ground surface h specified by the user?\n";
    ss << "\\note This field flags the use of a user specified heat transfer coefficient\n";
    ss << "\\note on the ground surface. This condition is used primarily for testing.\n";
    ss << "\\note For normal runs (USPHflag is FALSE) and the program calculates the heat\n";
    ss << "\\note transfer coefficient using the weather conditions.\n";
    ss << "\\type choice\n";
    ss << "\\key TRUE\n";
    ss << "\\key FALSE\n";
    ss << "\\required-field\n";
    ss << "N2; \\field USERH: User specified ground surface heat transfer coefficient\n";
    ss << "\\note Used only if USRHflag is TRUE and the heat transfer coefficient value is\n";
    ss << "\\note specified in this field.\n";
    ss << "\\units W/m2-K\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Slab_BoundConds);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Slab:BoundConds",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Slab_BoundConds);
  return object;
}

IddObject createGroundHeatTransfer_Slab_BldgPropsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Slab:BldgProps,\n";
    ss << "\\memo Object provides information about the building and its operating conditions\n";
    ss << "\\memo Monthly Average Temperature SetPoint fields\n";
    ss << "\\memo specify the average indoor building set point temperatures for each\n";
    ss << "\\memo month of the year. These fields are useful for simulating a building\n";
    ss << "\\memo that is not temperature controlled for some of the year.\n";
    ss << "\\memo In such a case, the average indoor set point temperatures\n";
    ss << "\\memo can be obtained by first running the model in EnergyPlus with an\n";
    ss << "\\memo insulated floor boundary condition, and then using the resulting\n";
    ss << "\\memo monthly average zone temperatures in these fields.\n";
    ss << "N1, \\field IYRS: Number of years to iterate\n";
    ss << "\\note This field specifies the number of years to iterate.\n";
    ss << "\\note Either the ground heat transfer calculations come to an\n";
    ss << "\\note an annual steady periodic condition by converging to a tolerance\n";
    ss << "\\note (see ConvTol field) or it runs for this number of years.\n";
    ss << "\\note A ten year maximum is usually sufficient.\n";
    ss << "\\default 10\n";
    ss << "\\minimum 1\n";
    ss << "N2, \\field Shape: Slab shape\n";
    ss << "\\note Use only the value 0 here. Only a rectangular shape is implemented.\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 0\n";
    ss << "N3, \\field HBLDG: Building height\n";
    ss << "\\note This field supplies the building height. This is used to calculate\n";
    ss << "\\note the building shadowing on the ground.\n";
    ss << "\\minimum 0\n";
    ss << "\\note typical value= 0-20\n";
    ss << "\\units m\n";
    ss << "N4, \\field TIN1: January Indoor Average Temperature Setpoint\n";
    ss << "\\note see memo on object for more information\n";
    ss << "\\default 22\n";
    ss << "\\units C\n";
    ss << "N5, \\field TIN2: February Indoor Average Temperature Setpoint\n";
    ss << "\\note see memo on object for more information\n";
    ss << "\\default 22\n";
    ss << "\\units C\n";
    ss << "N6, \\field TIN3: March Indoor Average Temperature Setpoint\n";
    ss << "\\note see memo on object for more information\n";
    ss << "\\default 22\n";
    ss << "\\units C\n";
    ss << "N7, \\field TIN4: April Indoor Average Temperature Setpoint\n";
    ss << "\\note see memo on object for more information\n";
    ss << "\\default 22\n";
    ss << "\\units C\n";
    ss << "N8, \\field TIN5: May Indoor Average Temperature Setpoint\n";
    ss << "\\note see memo on object for more information\n";
    ss << "\\default 22\n";
    ss << "\\units C\n";
    ss << "N9, \\field TIN6: June Indoor Average Temperature Setpoint\n";
    ss << "\\note see memo on object for more information\n";
    ss << "\\default 22\n";
    ss << "\\units C\n";
    ss << "N10,\\field TIN7: July Indoor Average Temperature Setpoint\n";
    ss << "\\note see memo on object for more information\n";
    ss << "\\default 22\n";
    ss << "\\units C\n";
    ss << "N11,\\field TIN8: August Indoor Average Temperature Setpoint\n";
    ss << "\\note see memo on object for more information\n";
    ss << "\\default 22\n";
    ss << "\\units C\n";
    ss << "N12,\\field TIN9: September Indoor Average Temperature Setpoint\n";
    ss << "\\note see memo on object for more information\n";
    ss << "\\default 22\n";
    ss << "\\units C\n";
    ss << "N13,\\field TIN10: October Indoor Average Temperature Setpoint\n";
    ss << "\\note see memo on object for more information\n";
    ss << "\\default 22\n";
    ss << "\\units C\n";
    ss << "N14,\\field TIN11: November Indoor Average Temperature Setpoint\n";
    ss << "\\note see memo on object for more information\n";
    ss << "\\default 22\n";
    ss << "\\units C\n";
    ss << "N15,\\field TIN12: December Indoor Average Temperature Setpoint\n";
    ss << "\\note see memo on object for more information\n";
    ss << "\\default 22\n";
    ss << "\\units C\n";
    ss << "N16,\\field TINAmp: Daily Indoor sine wave variation amplitude\n";
    ss << "\\note This field permits imposing a daily sinusoidal variation\n";
    ss << "\\note in the indoor setpoint temperature to simulate the effect\n";
    ss << "\\note of a setback profile.\n";
    ss << "\\note The value specified is the amplitude of the sine wave.\n";
    ss << "\\default 0\n";
    ss << "\\units deltaC\n";
    ss << "N17;\\field ConvTol: Convergence Tolerance\n";
    ss << "\\note This field specifies the convergence tolerance used to\n";
    ss << "\\note control the iteration. When the temperature change of all nodes\n";
    ss << "\\note is less than the convergence value, iteration ceases.\n";
    ss << "\\default 0.1\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Slab_BldgProps);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Slab:BldgProps",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Slab_BldgProps);
  return object;
}

IddObject createGroundHeatTransfer_Slab_InsulationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Slab:Insulation,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo This object supplies the information about insulation used around the slab.\n";
    ss << "\\memo There are two possible configurations: under the slab or vertical insulation\n";
    ss << "\\memo around the slab.\n";
    ss << "N1, \\field RINS: R value of under slab insulation\n";
    ss << "\\note This field provides the thermal resistance value\n";
    ss << "\\note of the under slab insulation. It should be zero\n";
    ss << "\\note if the vertical insulation configuration is selected.\n";
    ss << "\\note typical value= 0-2.0\n";
    ss << "\\units m2-K/W\n";
    ss << "\\default 0.0\n";
    ss << "N2, \\field DINS: Width of strip of under slab insulation\n";
    ss << "\\note This specifies the width of the perimeter strip of insulation\n";
    ss << "\\note under the slab. It should be zero if for the vertical insulation\n";
    ss << "\\note configuration is selected.\n";
    ss << "\\note typical value= 0-2.0\n";
    ss << "\\units m\n";
    ss << "\\default 0.0\n";
    ss << "N3, \\field RVINS: R value of vertical insulation\n";
    ss << "\\note This field specifies the thermal resistance of the vertical\n";
    ss << "\\note insulation. It should be zero if the under slab insulation\n";
    ss << "\\note configuration is selected.\n";
    ss << "\\note typical value= 0-3.0\n";
    ss << "\\units m2-K/W\n";
    ss << "\\default 0.0\n";
    ss << "N4, \\field ZVINS: Depth of vertical insulation\n";
    ss << "\\note This field specifies the depth of the vertical insulation\n";
    ss << "\\note into the ground in meters. It starts at the slab upper surface\n";
    ss << "\\note and extends into the ground.\n";
    ss << "\\note It should be zero if the under slab insulation\n";
    ss << "\\note configuration is selected.\n";
    ss << "\\note only use values= .2 .4 .6 .8 1.0 1.5 2.0 2.5 3.0\n";
    ss << "\\units m\n";
    ss << "\\default 0\n";
    ss << "N5; \\field IVINS: Flag: Is there vertical insulation\n";
    ss << "\\note Specifies if the vertical insulation configuration is being used.\n";
    ss << "\\note values: 1=yes vertical insulation 0=no under-slab insulation\n";
    ss << "\\type choice\n";
    ss << "\\key 0\n";
    ss << "\\key 1\n";
    ss << "\\default 0\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Slab_Insulation);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Slab:Insulation",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Slab_Insulation);
  return object;
}

IddObject createGroundHeatTransfer_Slab_EquivalentSlabIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Slab:EquivalentSlab,\n";
    ss << "\\memo Using an equivalent slab allows non-rectangular shapes to be modeled accurately.\n";
    ss << "\\memo Object uses the area - perimeter (area/perimeter) ratio to determine the\n";
    ss << "\\memo size of an equivalent rectangular slab.\n";
    ss << "\\memo EnergyPlus users normally use this option.\n";
    ss << "N1,  \\field APRatio: The area to perimeter ratio for this slab\n";
    ss << "\\note Equivalent square slab is simulated,  side is 4*APRatio.\n";
    ss << "\\units m\n";
    ss << "\\minimum 1.5\n";
    ss << "\\maximum 22\n";
    ss << "\\required-field\n";
    ss << "N2,  \\field SLABDEPTH: Thickness of slab on grade\n";
    ss << "\\note This field specifies the thickness of the slab. The slab top surface is level\n";
    ss << "\\note with the ground surface, so this is the depth into the ground.\n";
    ss << "\\note The slab depth has a significant effect on the temperature calculation,\n";
    ss << "\\note and it is also important for the auto-grid process.\n";
    ss << "\\note The finite difference grids are set in such a way that they use the slab thickness\n";
    ss << "\\note to determine the vertical grid spacing. Autogridding will fail if the slab thickness\n";
    ss << "\\note is specified larger than 0.25 meters.\n";
    ss << "\\default 0.1\n";
    ss << "\\units m\n";
    ss << "N3,  \\field CLEARANCE: Distance from edge of slab to domain edge\n";
    ss << "\\note This field specifies the distance from the slab to the edge of\n";
    ss << "\\note the area that will be modeled with the grid system. It is the basic size\n";
    ss << "\\note dimension that is used to set the horizontal extent of the domain.\n";
    ss << "\\note 15 meters is a reasonable value.\n";
    ss << "\\default 15.0\n";
    ss << "\\units m\n";
    ss << "N4;  \\field ZCLEARANCE: Distance from bottom of slab to domain bottom\n";
    ss << "\\note This field specifies the vertical distance from the slab to the\n";
    ss << "\\note bottom edge of the area that will be modeled with the grid system.\n";
    ss << "\\note 15 meters is a reasonable value.\n";
    ss << "\\default 15.0\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Slab_EquivalentSlab);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Slab:EquivalentSlab",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Slab_EquivalentSlab);
  return object;
}

IddObject createGroundHeatTransfer_Slab_AutoGridIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Slab:AutoGrid,\n";
    ss << "\\memo AutoGrid only necessary when EquivalentSlab option not chosen.\n";
    ss << "\\memo  Not normally needed by EnergyPlus users.\n";
    ss << "\\memo  This object permits user selection of rectangular slab dimensions.\n";
    ss << "\\memo  NO SLAB DIMENSIONS LESS THAN 6 m.\n";
    ss << "N1, \\field SLABX: X dimension of the building slab\n";
    ss << "\\minimum 6\n";
    ss << "\\note typical values= 6 to 60.0\n";
    ss << "\\units m\n";
    ss << "\\required-field\n";
    ss << "N2, \\field SLABY: Y dimension of the building slab\n";
    ss << "\\minimum 6\n";
    ss << "\\note typical values= 6 to 60.0\n";
    ss << "\\units m\n";
    ss << "\\required-field\n";
    ss << "N3, \\field SLABDEPTH: Thickness of slab on grade\n";
    ss << "\\default 0.1\n";
    ss << "\\units m\n";
    ss << "N4, \\field CLEARANCE: Distance from edge of slab to domain edge\n";
    ss << "\\default 15.0\n";
    ss << "\\units m\n";
    ss << "N5; \\field ZCLEARANCE: Distance from bottom of slab to domain bottom\n";
    ss << "\\default 15.0\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Slab_AutoGrid);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Slab:AutoGrid",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Slab_AutoGrid);
  return object;
}

IddObject createGroundHeatTransfer_Slab_ManualGridIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Slab:ManualGrid,\n";
    ss << "\\memo Manual Grid only necessary when using manual gridding (not recommended)\n";
    ss << "\\memo Used only in special cases when previous two objects are not used.\n";
    ss << "\\memo User must input complete gridding information.\n";
    ss << "N1, \\field NX: Number of cells in the X direction\n";
    ss << "\\minimum 1\n";
    ss << "\\required-field\n";
    ss << "N2, \\field NY: Number of cells in the Y direction\n";
    ss << "\\minimum 1\n";
    ss << "\\required-field\n";
    ss << "N3, \\field NZ: Number of cells in the Z direction\n";
    ss << "\\minimum 1\n";
    ss << "\\required-field\n";
    ss << "N4, \\field IBOX: X direction cell indicator of slab edge\n";
    ss << "\\note typical values= 1-10\n";
    ss << "\\required-field\n";
    ss << "N5; \\field JBOX: Y direction cell indicator of slab edge\n";
    ss << "\\note typical values= 1-10\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Slab_ManualGrid);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Slab:ManualGrid",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Slab_ManualGrid);
  return object;
}

IddObject createGroundHeatTransfer_Slab_XFACEIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Slab:XFACE,\n";
    ss << "\\memo This is only needed when using manual gridding (not recommended)\n";
    ss << "\\memo XFACE: X Direction cell face coordinates: m\n";
    ss << "N1, N2, N3, N4, N5, N6, N7, N8, N9, N10, N11, N12, N13, N14,                  \\note fields as indicated\n";
    ss << "N15, N16, N17, N18, N19, N20, N21, N22, N23, N24, N25, N26, N27, N28, N29,    \\note fields as indicated\n";
    ss << "N30, N31, N32, N33, N34, N35, N36, N37, N38, N39, N40;                        \\note fields as indicated\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Slab_XFACE);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Slab:XFACE",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Slab_XFACE);
  return object;
}

IddObject createGroundHeatTransfer_Slab_YFACEIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Slab:YFACE,\n";
    ss << "\\memo This is only needed when using manual gridding (not recommended)\n";
    ss << "\\memo YFACE: Y Direction cell face coordinates: m,\n";
    ss << "N1, N2, N3, N4, N5, N6, N7, N8, N9, N10, N11, N12, N13, N14,                  \\note fields as indicated\n";
    ss << "N15, N16, N17, N18, N19, N20, N21, N22, N23, N24, N25, N26, N27, N28, N29,    \\note fields as indicated\n";
    ss << "N30, N31, N32, N33, N34, N35, N36, N37, N38, N39, N40;                        \\note fields as indicated\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Slab_YFACE);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Slab:YFACE",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Slab_YFACE);
  return object;
}

IddObject createGroundHeatTransfer_Slab_ZFACEIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Slab:ZFACE,\n";
    ss << "\\memo This is only needed when using manual gridding (not recommended)\n";
    ss << "\\memo ZFACE: Z Direction cell face coordinates: m\n";
    ss << "N1, N2, N3, N4, N5, N6, N7, N8, N9, N10, N11, N12, N13, N14,                  \\note fields as indicated\n";
    ss << "N15, N16, N17, N18, N19, N20, N21, N22, N23, N24, N25;                        \\note fields as indicated\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Slab_ZFACE);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Slab:ZFACE",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Slab_ZFACE);
  return object;
}

IddObject createGroundHeatTransfer_Basement_SimParametersIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Basement:SimParameters,\n";
    ss << "\\memo Specifies certain parameters that control the Basement preprocessor ground heat\n";
    ss << "\\memo transfer simulation.\n";
    ss << "N1,  \\field F: Multiplier for the ADI solution\n";
    ss << "\\note 0<F<1.0,\n";
    ss << "\\note typically 0.1 (0.3 for high k soil - saturated sand is about 2.6 w/m-K)\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N2; \\field IYRS: Maximum number of yearly iterations:\n";
    ss << "\\note typically 15-30]\n";
    ss << "\\minimum 0\n";
    ss << "\\default 15\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Basement_SimParameters);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Basement:SimParameters",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Basement_SimParameters);
  return object;
}

IddObject createGroundHeatTransfer_Basement_MatlPropsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Basement:MatlProps,\n";
    ss << "\\memo Specifies the material properties for the Basement preprocessor ground heat\n";
    ss << "\\memo transfer simulation. Only the Foundation Wall, Floor Slab, Soil,\n";
    ss << "\\memo and Gravel properties are currently used.\n";
    ss << "N1, \\field NMAT: Number of materials in this domain\n";
    ss << "\\maximum 6\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Density for Foundation Wall\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 2243\n";
    ss << "\\units kg/m3\n";
    ss << "N3, \\field density for Floor Slab\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 2243\n";
    ss << "\\units kg/m3\n";
    ss << "N4, \\field density for Ceiling\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 311\n";
    ss << "\\units kg/m3\n";
    ss << "N5, \\field density for Soil\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1500\n";
    ss << "\\units kg/m3\n";
    ss << "N6, \\field density for Gravel\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 2000\n";
    ss << "\\units kg/m3\n";
    ss << "N7, \\field density for Wood\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 449\n";
    ss << "\\units kg/m3\n";
    ss << "N8,  \\field Specific heat for foundation wall\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 880\n";
    ss << "\\units J/kg-K\n";
    ss << "N9,  \\field Specific heat for floor slab\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 880\n";
    ss << "\\units J/kg-K\n";
    ss << "N10, \\field Specific heat for ceiling\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1530\n";
    ss << "\\units J/kg-K\n";
    ss << "N11, \\field Specific heat for soil\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 840\n";
    ss << "\\units J/kg-K\n";
    ss << "N12, \\field Specific heat for gravel\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 720\n";
    ss << "\\units J/kg-K\n";
    ss << "N13, \\field Specific heat for wood\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1530\n";
    ss << "\\units J/kg-K\n";
    ss << "N14, \\field Thermal conductivity for foundation wall\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.4\n";
    ss << "\\units W/m-K\n";
    ss << "N15, \\field Thermal conductivity for floor slab\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.4\n";
    ss << "\\units W/m-K\n";
    ss << "N16, \\field Thermal conductivity for ceiling\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.09\n";
    ss << "\\units W/m-K\n";
    ss << "N17, \\field thermal conductivity for soil\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.1\n";
    ss << "\\units W/m-K\n";
    ss << "N18, \\field thermal conductivity for gravel\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.9\n";
    ss << "\\units W/m-K\n";
    ss << "N19; \\field thermal conductivity for wood\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.12\n";
    ss << "\\units W/m-K\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Basement_MatlProps);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Basement:MatlProps",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Basement_MatlProps);
  return object;
}

IddObject createGroundHeatTransfer_Basement_InsulationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Basement:Insulation,\n";
    ss << "\\memo Describes the insulation used on an exterior basement wall for the Basement\n";
    ss << "\\memo preprocessor ground heat transfer simulation.\n";
    ss << "N1, \\field REXT: R Value of any exterior insulation\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m2-K/W\n";
    ss << "A1; \\field INSFULL: Flag: Is the wall fully insulated?\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key TRUE\n";
    ss << "\\key FALSE\n";
    ss << "\\note  True for full insulation\n";
    ss << "\\note  False for insulation half way down side wall from grade line\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Basement_Insulation);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Basement:Insulation",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Basement_Insulation);
  return object;
}

IddObject createGroundHeatTransfer_Basement_SurfacePropsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Basement:SurfaceProps,\n";
    ss << "\\memo Specifies the soil surface properties for the Basement preprocessor ground\n";
    ss << "\\memo heat transfer simulation.\n";
    ss << "\\min-fields 7\n";
    ss << "N1, \\field ALBEDO: Surface albedo for No snow conditions\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.16\n";
    ss << "N2, \\field ALBEDO: Surface albedo for snow conditions\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.40\n";
    ss << "N3, \\field EPSLN: Surface emissivity No Snow\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.94\n";
    ss << "N4, \\field EPSLN: Surface emissivity with Snow\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.86\n";
    ss << "N5, \\field VEGHT: Surface roughness No snow conditions\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 6.0\n";
    ss << "\\units cm\n";
    ss << "N6, \\field VEGHT: Surface roughness Snow conditions\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.25\n";
    ss << "\\units cm\n";
    ss << "A1; \\field PET: Flag, Potential evapotranspiration on?\n";
    ss << "\\note  Typically, PET is False\n";
    ss << "\\type choice\n";
    ss << "\\key TRUE\n";
    ss << "\\key FALSE\n";
    ss << "\\default FALSE\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Basement_SurfaceProps);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Basement:SurfaceProps",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Basement_SurfaceProps);
  return object;
}

IddObject createGroundHeatTransfer_Basement_BldgDataIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Basement:BldgData,\n";
    ss << "\\memo Specifies the surface and gravel thicknesses used for the Basement\n";
    ss << "\\memo preprocessor ground heat transfer simulation.\n";
    ss << "N1, \\field DWALL: Wall thickness\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.2\n";
    ss << "\\default 0.2\n";
    ss << "N2, \\field DSLAB: Floor slab thickness\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 0.25\n";
    ss << "\\default 0.1\n";
    ss << "N3, \\field DGRAVXY: Width of gravel pit beside basement wall\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units  m\n";
    ss << "\\default 0.3\n";
    ss << "N4, \\field DGRAVZN: Gravel depth extending above the floor slab\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m\n";
    ss << "\\default 0.2\n";
    ss << "N5; \\field DGRAVZP: Gravel depth below the floor slab\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m\n";
    ss << "\\default 0.1\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Basement_BldgData);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Basement:BldgData",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Basement_BldgData);
  return object;
}

IddObject createGroundHeatTransfer_Basement_InteriorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Basement:Interior,\n";
    ss << "\\memo Provides the information needed to simulate the inside boundary conditions for\n";
    ss << "\\memo the Basement preprocessor ground heat transfer simulation.\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field COND: Flag: Is the basement conditioned?\n";
    ss << "\\type choice\n";
    ss << "\\key TRUE\n";
    ss << "\\key FALSE\n";
    ss << "\\default TRUE\n";
    ss << "\\note for EnergyPlus this should be TRUE\n";
    ss << "N1, \\field HIN: Downward convection only heat transfer coefficient\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.92\n";
    ss << "N2, \\field HIN: Upward convection only heat transfer coefficient\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 4.04\n";
    ss << "N3, \\field HIN: Horizontal convection only heat transfer coefficient\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.08\n";
    ss << "N4, \\field HIN: Downward combined (convection and radiation) heat transfer coefficient\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 6.13\n";
    ss << "N5, \\field HIN: Upward combined (convection and radiation) heat transfer coefficient\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 9.26\n";
    ss << "N6; \\field HIN: Horizontal combined (convection and radiation) heat transfer coefficient\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 8.29\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Basement_Interior);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Basement:Interior",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Basement_Interior);
  return object;
}

IddObject createGroundHeatTransfer_Basement_ComBldgIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Basement:ComBldg,\n";
    ss << "\\memo ComBldg contains the monthly average temperatures (C) and possibility of daily variation amplitude\n";
    ss << "N1,  \\field January average temperature\n";
    ss << "\\units C\n";
    ss << "\\default 22\n";
    ss << "N2,  \\field February average temperature\n";
    ss << "\\units C\n";
    ss << "\\default 22\n";
    ss << "N3,  \\field March average temperature\n";
    ss << "\\units C\n";
    ss << "\\default 22\n";
    ss << "N4,  \\field April average temperature\n";
    ss << "\\units C\n";
    ss << "\\default 22\n";
    ss << "N5,  \\field May average temperature\n";
    ss << "\\units C\n";
    ss << "\\default 22\n";
    ss << "N6,  \\field June average temperature\n";
    ss << "\\units C\n";
    ss << "\\default 22\n";
    ss << "N7,  \\field July average temperature\n";
    ss << "\\units C\n";
    ss << "\\default 22\n";
    ss << "N8,  \\field August average temperature\n";
    ss << "\\units C\n";
    ss << "\\default 22\n";
    ss << "N9,  \\field September average temperature\n";
    ss << "\\units C\n";
    ss << "\\default 22\n";
    ss << "N10, \\field October average temperature\n";
    ss << "\\units C\n";
    ss << "\\default 22\n";
    ss << "N11, \\field November average temperature\n";
    ss << "\\units C\n";
    ss << "\\default 22\n";
    ss << "N12, \\field December average temperature\n";
    ss << "\\units C\n";
    ss << "\\default 22\n";
    ss << "N13; \\field Daily variation sine wave amplitude\n";
    ss << "\\units deltaC\n";
    ss << "\\default 0\n";
    ss << "\\note (Normally zero, just for checking)\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Basement_ComBldg);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Basement:ComBldg",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Basement_ComBldg);
  return object;
}

IddObject createGroundHeatTransfer_Basement_EquivSlabIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Basement:EquivSlab,  !  Supplies the EquivSizing Flag\n";
    ss << "\\memo Using an equivalent slab allows non-rectangular shapes to be\n";
    ss << "\\memo modeled accurately.\n";
    ss << "\\memo The simulation default should be EquivSizing=True\n";
    ss << "N1, \\field APRatio: The area to perimeter ratio for this slab\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m\n";
    ss << "\\required-field\n";
    ss << "A1; \\field EquivSizing: Flag\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key TRUE\n";
    ss << "\\key FALSE\n";
    ss << "\\note Will the dimensions of an equivalent slab be calculated (TRUE)\n";
    ss << "\\note or will the dimensions be input directly? (FALSE)]\n";
    ss << "\\note Only advanced special simulations should use FALSE.\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Basement_EquivSlab);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Basement:EquivSlab",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Basement_EquivSlab);
  return object;
}

IddObject createGroundHeatTransfer_Basement_EquivAutoGridIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Basement:EquivAutoGrid,\n";
    ss << "\\memo EquivAutoGrid necessary when EquivSizing=TRUE, TRUE is is the normal case.\n";
    ss << "N1, \\field CLEARANCE: Distance from outside of wall to edge of 3-D ground domain\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units m\n";
    ss << "\\default 15\n";
    ss << "N2, \\field SlabDepth: Thickness of the floor slab\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units m\n";
    ss << "\\default  0.1\n";
    ss << "N3; \\field BaseDepth: Depth of the basement wall below grade\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units  m\n";
    ss << "\\default 2\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Basement_EquivAutoGrid);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Basement:EquivAutoGrid",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Basement_EquivAutoGrid);
  return object;
}

IddObject createGroundHeatTransfer_Basement_AutoGridIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Basement:AutoGrid,\n";
    ss << "\\memo AutoGrid only necessary when EquivSizing is false\n";
    ss << "\\memo If the modeled building is not a rectangle or square, Equivalent\n";
    ss << "\\memo sizing MUST be used to get accurate results\n";
    ss << "N1, \\field CLEARANCE: Distance from outside of wall to edge,\n";
    ss << "\\minimum 0\n";
    ss << "\\units m\n";
    ss << "\\default 15\n";
    ss << "N2, \\field SLABX: X dimension of the building slab\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 60\n";
    ss << "N3, \\field SLABY: Y dimension of the building slab\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 60\n";
    ss << "N4, \\field ConcAGHeight: Height of the foundation wall above grade\n";
    ss << "\\units m\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N5, \\field SlabDepth: Thickness of the floor slab\n";
    ss << "\\units m\n";
    ss << "\\default 0.1\n";
    ss << "N6; \\field BaseDepth: Depth of the basement wall below grade\n";
    ss << "\\units m\n";
    ss << "\\minimum 0\n";
    ss << "\\default 2\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Basement_AutoGrid);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Basement:AutoGrid",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Basement_AutoGrid);
  return object;
}

IddObject createGroundHeatTransfer_Basement_ManualGridIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Basement:ManualGrid,\n";
    ss << "\\memo Manual Grid only necessary using manual gridding (not recommended)\n";
    ss << "N1, \\field NX: Number of cells in the X direction: 20]\n";
    ss << "\\minimum 1\n";
    ss << "\\required-field\n";
    ss << "N2, \\field NY: Number of cells in the Y direction: 20]\n";
    ss << "\\minimum 1\n";
    ss << "\\required-field\n";
    ss << "N3, \\field NZAG: Number of cells in the Z direction. above grade: 4 Always]\n";
    ss << "\\minimum 1\n";
    ss << "\\required-field\n";
    ss << "N4, \\field NZBG: Number of cells in Z direction. below grade: 10-35]\n";
    ss << "\\minimum 1\n";
    ss << "\\required-field\n";
    ss << "N5, \\field IBASE: X direction cell indicator of slab edge: 5-20]\n";
    ss << "\\required-field\n";
    ss << "N6, \\field JBASE: Y direction cell indicator of slab edge: 5-20]\n";
    ss << "\\required-field\n";
    ss << "N7; \\field KBASE: Z direction cell indicator of the top of the floor slab: 5-20]\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Basement_ManualGrid);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Basement:ManualGrid",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Basement_ManualGrid);
  return object;
}

IddObject createGroundHeatTransfer_Basement_XFACEIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Basement:XFACE,\n";
    ss << "\\memo This is only needed when using manual gridding (not recommended)\n";
    ss << "\\memo XFACE: X Direction cell face coordinates: m\n";
    ss << "N1, N2, N3, N4, N5, N6, N7, N8, N9, N10, N11, N12, N13, N14,  \\note fields as indicated\n";
    ss << "N15, N16, N17, N18, N19, N20, N21, N22, N23, N24, N25, N26,   \\note fields as indicated\n";
    ss << "N27, N28, N29, N30, N31, N32, N33, N34, N35, N36, N37, N38,   \\note fields as indicated\n";
    ss << "N39, N40, N41, N42, N43, N44;                                 \\note fields as indicated\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Basement_XFACE);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Basement:XFACE",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Basement_XFACE);
  return object;
}

IddObject createGroundHeatTransfer_Basement_YFACEIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Basement:YFACE,\n";
    ss << "\\memo This is only needed when using manual gridding (not recommended)\n";
    ss << "\\memo YFACE: Y Direction cell face coordinates: m\n";
    ss << "N1, N2, N3, N4, N5, N6, N7, N8, N9, N10, N11, N12, N13, N14,  \\note fields as indicated\n";
    ss << "N15, N16, N17, N18, N19, N20, N21, N22, N23, N24, N25, N26,   \\note fields as indicated\n";
    ss << "N27, N28, N29, N30, N31, N32, N33, N34, N35, N36, N37, N38,   \\note fields as indicated\n";
    ss << "N39, N40, N41, N42, N43, N44;                                 \\note fields as indicated\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Basement_YFACE);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Basement:YFACE",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Basement_YFACE);
  return object;
}

IddObject createGroundHeatTransfer_Basement_ZFACEIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatTransfer:Basement:ZFACE,\n";
    ss << "\\memo This is only needed when using manual gridding (not recommended)\n";
    ss << "\\memo ZFACE: Z Direction cell face coordinates: m\n";
    ss << "N1, N2, N3, N4, N5, N6, N7, N8, N9, N10, N11, N12, N13, N14,  \\note fields as indicated\n";
    ss << "N15, N16, N17, N18, N19, N20, N21, N22, N23, N24, N25, N26,   \\note fields as indicated\n";
    ss << "N27, N28, N29, N30, N31, N32, N33, N34, N35, N36, N37, N38,   \\note fields as indicated\n";
    ss << "N39, N40;                                                     \\note fields as indicated\n";

    IddObjectType objType(IddObjectType::GroundHeatTransfer_Basement_ZFACE);
    OptionalIddObject oObj = IddObject::load("GroundHeatTransfer:Basement:ZFACE",
                                             "Detailed Ground Heat Transfer",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatTransfer_Basement_ZFACE);
  return object;
}

IddObject createRoomAirModelTypeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RoomAirModelType,\n";
    ss << "\\memo Selects the type of room air model to be used in a given zone. If no RoomAirModelType\n";
    ss << "\\memo object is specified then the default Mixing model (all zone air at the same\n";
    ss << "\\memo temperature) will be used.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A3, \\field Room-Air Modeling Type\n";
    ss << "\\type choice\n";
    ss << "\\key Mixing\n";
    ss << "\\note Complete mixing air model\n";
    ss << "\\key UserDefined\n";
    ss << "\\note UserDefined Room Air Temperature Patterns\n";
    ss << "\\note needs RoomAir:TemperaturePattern:UserDefined object referencing this Zone\n";
    ss << "\\key OneNodeDisplacementVentilation\n";
    ss << "\\note Mundt roomair model for displacement ventilation with single floor air node\n";
    ss << "\\note needs RoomAirSettings:OneNodeDisplacementVentilation object referencing this Zone\n";
    ss << "\\key ThreeNodeDisplacementVentilation\n";
    ss << "\\note (ThreeNodeDisplacementVentilation = RoomAir modeling using UCSD three-node displacement ventilation model)\n";
    ss << "\\note needs RoomAirSettings:ThreeNodeDisplacementVentilation object referencing this Zone\n";
    ss << "\\key CrossVentilation\n";
    ss << "\\note (CrossVentilation = RoomAir modeling using UCSD two-zone cross ventilation model)\n";
    ss << "\\note needs RoomAirSettings:CrossVentilation object referencing this Zone\n";
    ss << "\\key UnderFloorAirDistributionInterior\n";
    ss << "\\note 2-Node UFAD model for interior zones\n";
    ss << "\\note needs RoomAirSettings:UnderFloorAirDistributionInterior object referencing this Zone\n";
    ss << "\\key UnderFloorAirDistributionExterior\n";
    ss << "\\note (UnderFloorAirDistributionExterior = RoomAir modeling using 2-Node UFAD model for exterior zones)\n";
    ss << "\\note needs RoomAirSettings:UnderFloorAirDistributionExterior object referencing this Zone\n";
    ss << "\\key AirflowNetwork\n";
    ss << "\\note (AirflowNetwork = RoomAir modeling using AirflowNetwork)\n";
    ss << "\\note needs RoomAirSettings:AirflowNetwork object referencing this Zone\n";
    ss << "\\default Mixing\n";
    ss << "A4; \\field Air Temperature Coupling Strategy\n";
    ss << "\\type choice\n";
    ss << "\\key Direct\n";
    ss << "\\key Indirect\n";
    ss << "\\default Direct\n";

    IddObjectType objType(IddObjectType::RoomAirModelType);
    OptionalIddObject oObj = IddObject::load("RoomAirModelType",
                                             "Room Air Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RoomAirModelType);
  return object;
}

IddObject createRoomAir_TemperaturePattern_UserDefinedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RoomAir:TemperaturePattern:UserDefined,\n";
    ss << "\\memo Used to explicitly define temperature patterns that are to be applied to the mean air\n";
    ss << "\\memo temperature within a thermal zone.  Used with RoomAirModelType = UserDefined.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A3 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this model. Schedule value > 0 means the model is\n";
    ss << "\\note active. Schedule value = 0 means the model is inactive and the zone will be modeled\n";
    ss << "\\note as fully mixed (Mixing). If this field is blank, the model is always active.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 ; \\field Pattern Control Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note The schedule should contain integer values that\n";
    ss << "\\note correspond to unique Control Integer fields in\n";
    ss << "\\note one of the RoomAir:TemperaturePattern:* objects.\n";

    IddObjectType objType(IddObjectType::RoomAir_TemperaturePattern_UserDefined);
    OptionalIddObject oObj = IddObject::load("RoomAir:TemperaturePattern:UserDefined",
                                             "Room Air Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RoomAir_TemperaturePattern_UserDefined);
  return object;
}

IddObject createRoomAir_TemperaturePattern_ConstantGradientIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RoomAir:TemperaturePattern:ConstantGradient,\n";
    ss << "\\memo Used to model room air with a fixed temperature gradient in the vertical direction.\n";
    ss << "\\memo Used in combination with RoomAir:TemperaturePattern:UserDefined.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "N1, \\field Control Integer for Pattern Control Schedule Name\n";
    ss << "\\note reference this entry in Schedule Name\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Thermostat Offset\n";
    ss << "\\note = (Temp at thermostat- Mean Air Temp)\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "N3, \\field Return Air Offset\n";
    ss << "\\note = (Tleaving - Mean Air Temp )\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "N4, \\field Exhaust Air Offset\n";
    ss << "\\note = (Texhaust - Mean Air Temp) deg C\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "N5; \\field Temperature Gradient\n";
    ss << "\\note Slope of temperature change in vertical direction\n";
    ss << "\\units K/m\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::RoomAir_TemperaturePattern_ConstantGradient);
    OptionalIddObject oObj = IddObject::load("RoomAir:TemperaturePattern:ConstantGradient",
                                             "Room Air Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RoomAir_TemperaturePattern_ConstantGradient);
  return object;
}

IddObject createRoomAir_TemperaturePattern_TwoGradientIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RoomAir:TemperaturePattern:TwoGradient,\n";
    ss << "\\memo Used to model room air with two temperature gradients in the vertical direction.\n";
    ss << "\\memo Used in combination with RoomAir:TemperaturePattern:UserDefined.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "N1, \\field Control Integer for Pattern Control Schedule Name\n";
    ss << "\\note reference this entry in Schedule Name\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Thermostat Height\n";
    ss << "\\note = Distance from floor of zone\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N3, \\field Return Air Height\n";
    ss << "\\note = Distance from floor of zone\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N4, \\field Exhaust Air Height\n";
    ss << "\\note = Distance from floor of zone\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N5, \\field Temperature Gradient Lower Bound\n";
    ss << "\\note Slope of temperature change in vertical direction\n";
    ss << "\\units K/m\n";
    ss << "\\type real\n";
    ss << "N6, \\field Temperature Gradient Upper  Bound\n";
    ss << "\\note Slope of temperature change in vertical direction\n";
    ss << "\\units K/m\n";
    ss << "\\type real\n";
    ss << "A2, \\field Gradient Interpolation Mode\n";
    ss << "\\type choice\n";
    ss << "\\key OutdoorDryBulbTemperature\n";
    ss << "\\key ZoneDryBulbTemperature\n";
    ss << "\\key ZoneAndOutdoorTemperatureDifference\n";
    ss << "\\key SensibleCoolingLoad\n";
    ss << "\\key SensibleHeatingLoad\n";
    ss << "N7, \\field Upper Temperature Bound\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "N8, \\field Lower Temperature Bound\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "N9, \\field Upper Heat Rate Bound\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "N10; \\field Lower Heat Rate Bound\n";
    ss << "\\units W\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::RoomAir_TemperaturePattern_TwoGradient);
    OptionalIddObject oObj = IddObject::load("RoomAir:TemperaturePattern:TwoGradient",
                                             "Room Air Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RoomAir_TemperaturePattern_TwoGradient);
  return object;
}

IddObject createRoomAir_TemperaturePattern_NondimensionalHeightIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RoomAir:TemperaturePattern:NondimensionalHeight,\n";
    ss << "\\memo Defines a distribution pattern for air temperatures relative to the current mean air\n";
    ss << "\\memo temperature as a function of height. The height, referred to as Zeta, is non-dimensional\n";
    ss << "\\memo by normalizing with the zone ceiling height.\n";
    ss << "\\memo Used in combination with RoomAir:TemperaturePattern:UserDefined.\n";
    ss << "\\extensible:2 - repeat last two fields remembering to remove ; from \"inner\" fields.\n";
    ss << "\\min-fields 9\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "N1, \\field Control Integer for Pattern Control Schedule Name\n";
    ss << "\\note this value should appear in as a schedule value\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Thermostat Offset\n";
    ss << "\\note = (Temp at thermostat- Mean Air Temp)\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "N3, \\field Return Air Offset\n";
    ss << "\\note = (Temp leaving - Mean Air Temp ) deg C\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "N4, \\field Exhaust Air Offset\n";
    ss << "\\note = (Temp exhaust - Mean Air Temp) deg C\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "\\note the remaining fields have pairs that describe the relative\n";
    ss << "\\note temperature pattern in the vertical direction of a zone\n";
    ss << "\\note Zeta is the nondimensional height (in z-direction). on [0..1]\n";
    ss << "\\note DeltaTai =  (Tai - MAT) in units of deg. C\n";
    ss << "\\note relative deg C on [-10.0 .. 20.0 ]\n";
    ss << "N5, \\field Pair 1 Zeta Nondimensional Height\n";
    ss << "\\begin-extensible\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N6; \\field Pair 1 Delta Adjacent Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum -10.0\n";
    ss << "\\maximum 20.0\n";

    IddObjectType objType(IddObjectType::RoomAir_TemperaturePattern_NondimensionalHeight);
    OptionalIddObject oObj = IddObject::load("RoomAir:TemperaturePattern:NondimensionalHeight",
                                             "Room Air Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RoomAir_TemperaturePattern_NondimensionalHeight);
  return object;
}

IddObject createRoomAir_TemperaturePattern_SurfaceMappingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RoomAir:TemperaturePattern:SurfaceMapping,\n";
    ss << "\\memo Defines a distribution pattern for the air temperatures adjacent to individual surfaces.\n";
    ss << "\\memo This allows controlling the adjacent air temperature on a surface-by-surface basis\n";
    ss << "\\memo rather than by height. This allows modeling different adjacent air temperatures on\n";
    ss << "\\memo the opposite sides of the zone. Used in combination with\n";
    ss << "\\memo RoomAir:TemperaturePattern:UserDefined.\n";
    ss << "\\extensible:2 - repeat last two fields remembering to remove ; from \"inner\" fields.\n";
    ss << "\\min-fields 7\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "N1, \\field Control Integer for Pattern Control Schedule Name\n";
    ss << "\\note reference this entry in schedule\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Thermostat Offset\n";
    ss << "\\note = (Temp at thermostat- Mean Air Temp)\n";
    ss << "\\units deltaC\n";
    ss << "N3, \\field Return Air Offset\n";
    ss << "\\note = (Tleaving - Mean Air Temp ) deg C\n";
    ss << "\\units deltaC\n";
    ss << "N4, \\field Exhaust Air Offset\n";
    ss << "\\note = (Texhaust - Mean Air Temp) deg C\n";
    ss << "\\units deltaC\n";
    ss << "A2, \\field Surface Name Pair 1\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllHeatTranSurfNames\n";
    ss << "N5; \\field Delta Adjacent Air Temperature Pair 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";

    IddObjectType objType(IddObjectType::RoomAir_TemperaturePattern_SurfaceMapping);
    OptionalIddObject oObj = IddObject::load("RoomAir:TemperaturePattern:SurfaceMapping",
                                             "Room Air Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RoomAir_TemperaturePattern_SurfaceMapping);
  return object;
}

IddObject createRoomAir_NodeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RoomAir:Node,\n";
    ss << "\\memo Define an air node for some types of nodal room air models\n";
    ss << "\\extensible:1\n";
    ss << "\\max-fields 25\n";
    ss << "A1, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\reference RoomAirNodes\n";
    ss << "A2, \\field Node Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Inlet\n";
    ss << "\\key Floor\n";
    ss << "\\key Control\n";
    ss << "\\key Ceiling\n";
    ss << "\\key MundtRoom\n";
    ss << "\\key Return\n";
    ss << "A3, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1, \\field Height of Nodal Control Volume Center\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "A4 ; \\field Surface 1 Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllHeatTranSurfNames\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::RoomAir_Node);
    OptionalIddObject oObj = IddObject::load("RoomAir:Node",
                                             "Room Air Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RoomAir_Node);
  return object;
}

IddObject createRoomAirSettings_OneNodeDisplacementVentilationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RoomAirSettings:OneNodeDisplacementVentilation,\n";
    ss << "\\memo The Mundt model for displacement ventilation\n";
    ss << "A1 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1 , \\field Fraction of Convective Internal Loads Added to Floor Air\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N2 ; \\field Fraction of Infiltration Internal Loads Added to Floor Air\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";

    IddObjectType objType(IddObjectType::RoomAirSettings_OneNodeDisplacementVentilation);
    OptionalIddObject oObj = IddObject::load("RoomAirSettings:OneNodeDisplacementVentilation",
                                             "Room Air Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RoomAirSettings_OneNodeDisplacementVentilation);
  return object;
}

IddObject createRoomAirSettings_ThreeNodeDisplacementVentilationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RoomAirSettings:ThreeNodeDisplacementVentilation,\n";
    ss << "\\memo The UCSD model for Displacement Ventilation\n";
    ss << "A1 , \\field Zone Name\n";
    ss << "\\note Name of Zone being described. Any existing zone name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A2 , \\field Gain Distribution Schedule Name\n";
    ss << "\\note Distribution of the convective heat gains between the occupied and mixed zones.\n";
    ss << "\\note 0<= Accepted Value <= 1.\n";
    ss << "\\note In the DV model 1 means all convective gains in the lower layer.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Number of Plumes per Occupant\n";
    ss << "\\note Used only in the UCSD displacement ventilation model.\n";
    ss << "\\note Effective number of separate plumes per occupant in the occupied zone.\n";
    ss << "\\note Plumes that merge together in the occupied zone count as one.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N2 , \\field Thermostat Height\n";
    ss << "\\note Height of thermostat/temperature control sensor above floor\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.1\n";
    ss << "N3 , \\field Comfort Height\n";
    ss << "\\note Height at which air temperature is calculated for comfort purposes\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.1\n";
    ss << "N4 ; \\field Temperature Difference Threshold for Reporting\n";
    ss << "\\note Minimum temperature difference between predicted upper and lower layer\n";
    ss << "\\note temperatures above which DV auxiliary outputs are calculated.\n";
    ss << "\\note These outputs are 'DV Transition Height', 'DV Fraction Min Recommended Flow Rate'\n";
    ss << "\\note 'DV Average Temp Gradient' and 'DV Maximum Temp Gradient'.  They\n";
    ss << "\\note are set to negative values when the temperature difference is less than the\n";
    ss << "\\note threshold and the output 'DV Zone Is Mixed' is set to 1\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.4\n";

    IddObjectType objType(IddObjectType::RoomAirSettings_ThreeNodeDisplacementVentilation);
    OptionalIddObject oObj = IddObject::load("RoomAirSettings:ThreeNodeDisplacementVentilation",
                                             "Room Air Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RoomAirSettings_ThreeNodeDisplacementVentilation);
  return object;
}

IddObject createRoomAirSettings_CrossVentilationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RoomAirSettings:CrossVentilation,\n";
    ss << "\\memo This UCSD Cross Ventilation Room Air Model provides a simple model for heat transfer\n";
    ss << "\\memo and vertical temperature profile prediction in cross ventilated rooms. The model\n";
    ss << "\\memo distinguishes two regions in the room, the main jet region and the recirculations,\n";
    ss << "\\memo and predicts characteristic airflow velocities and average air temperatures.\n";
    ss << "\\memo Used with RoomAirModelType = CrossVentilation.\n";
    ss << "A1 , \\field Zone Name\n";
    ss << "\\note Name of Zone being described. Any existing zone name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A2 , \\field Gain Distribution Schedule Name\n";
    ss << "\\note Distribution of the convective heat gains between the jet and recirculation zones.\n";
    ss << "\\note 0<= Accepted Value <= 1.\n";
    ss << "\\note In the CV model 1 means all convective gains in the jet region.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 ; \\field Airflow Region Used for Thermal Comfort Evaluation\n";
    ss << "\\note Required field whenever thermal comfort is predicted\n";
    ss << "\\note defines Air temperature and Airflow velocity that will be used in the Fanger model\n";
    ss << "\\note conditions must refer to one of the two regions: jet or recirculation\n";
    ss << "\\type choice\n";
    ss << "\\key Jet\n";
    ss << "\\key Recirculation\n";

    IddObjectType objType(IddObjectType::RoomAirSettings_CrossVentilation);
    OptionalIddObject oObj = IddObject::load("RoomAirSettings:CrossVentilation",
                                             "Room Air Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RoomAirSettings_CrossVentilation);
  return object;
}

IddObject createRoomAirSettings_UnderFloorAirDistributionInteriorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RoomAirSettings:UnderFloorAirDistributionInterior,\n";
    ss << "\\memo This Room Air Model is applicable to interior spaces that are served by an underfloor\n";
    ss << "\\memo air distribution system. The dominant sources of heat gain should be from people,\n";
    ss << "\\memo equipment, and other localized sources located in the occupied part of the room.\n";
    ss << "\\memo The model should be used with caution in zones which have large heat gains or losses\n";
    ss << "\\memo through exterior walls or windows or which have considerable direct solar gain.\n";
    ss << "\\memo Used with RoomAirModelType = UnderFloorAirDistributionInterior.\n";
    ss << "\\min-fields 15\n";
    ss << "A1 , \\field Zone Name\n";
    ss << "\\note Name of Zone with underfloor air distribution\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1 , \\field Number of Diffusers\n";
    ss << "\\note Total number of diffusers in this zone\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "N2 , \\field Power per Plume\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units W\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "N3 , \\field Design Effective Area of Diffuser\n";
    ss << "\\type real\n";
    ss << "\\units m2\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\default Autocalculate\n";
    ss << "N4 , \\field Diffuser Slot Angle from Vertical\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 90.\n";
    ss << "\\autocalculatable\n";
    ss << "\\default Autocalculate\n";
    ss << "N5 , \\field Thermostat Height\n";
    ss << "\\note Height of thermostat/temperature control sensor above floor\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.2\n";
    ss << "N6 , \\field Comfort Height\n";
    ss << "\\note Height at which air temperature is calculated for comfort purposes\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.1\n";
    ss << "N7 , \\field Temperature Difference Threshold for Reporting\n";
    ss << "\\note Minimum temperature difference between predicted upper and lower layer\n";
    ss << "\\note temperatures above which UFAD auxiliary outputs are calculated.\n";
    ss << "\\note These outputs are 'UF Transition Height' and 'UF Average Temp Gradient'.  They\n";
    ss << "\\note are set to zero values when the temperature difference is less than the\n";
    ss << "\\note threshold and the output 'UF Zone Is Mixed' is set to 1\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.4\n";
    ss << "A2 , \\field Floor Diffuser Type\n";
    ss << "\\type choice\n";
    ss << "\\key Custom\n";
    ss << "\\key Swirl\n";
    ss << "\\key VariableArea\n";
    ss << "\\key HorizontalSwirl\n";
    ss << "\\key LinearBarGrille\n";
    ss << "\\default Swirl\n";
    ss << "N8 , \\field Transition Height\n";
    ss << "\\note user-specified height above floor of boundary between occupied and upper subzones\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\default 1.7\n";
    ss << "N9,  \\field Coefficient A\n";
    ss << "\\note Coefficient A in Formula Kc = A*Gamma**B + C + D*Gamma + E*Gamma**2\n";
    ss << "\\note Kc is the fraction of the total zone load attributable to the lower subzone\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\default Autocalculate\n";
    ss << "N10, \\field Coefficient B\n";
    ss << "\\note Coefficient B in Formula Kc = A*Gamma**B + C + D*Gamma + E*Gamma**2\n";
    ss << "\\note Kc is the fraction of the total zone load attributable to the lower subzone\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\default Autocalculate\n";
    ss << "N11, \\field Coefficient C\n";
    ss << "\\note Coefficient C in Formula Kc = A*Gamma**B + C + D*Gamma + E*Gamma**2\n";
    ss << "\\note Kc is the fraction of the total zone load attributable to the lower subzone\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\default Autocalculate\n";
    ss << "N12, \\field Coefficient D\n";
    ss << "\\note Coefficient D in Formula Kc = A*Gamma**B + C + D*Gamma + E*Gamma**2\n";
    ss << "\\note Kc is the fraction of the total zone load attributable to the lower subzone\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\default Autocalculate\n";
    ss << "N13; \\field Coefficient E\n";
    ss << "\\note Coefficient E in Formula Kc = A*Gamma**B + C + D*Gamma + E*Gamma**2\n";
    ss << "\\note Kc is the fraction of the total zone load attributable to the lower subzone\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\default Autocalculate\n";

    IddObjectType objType(IddObjectType::RoomAirSettings_UnderFloorAirDistributionInterior);
    OptionalIddObject oObj = IddObject::load("RoomAirSettings:UnderFloorAirDistributionInterior",
                                             "Room Air Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RoomAirSettings_UnderFloorAirDistributionInterior);
  return object;
}

IddObject createRoomAirSettings_UnderFloorAirDistributionExteriorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RoomAirSettings:UnderFloorAirDistributionExterior,\n";
    ss << "\\memo Applicable to exterior spaces that are served by an underfloor air distribution system.\n";
    ss << "\\memo The dominant sources of heat gain should be from people, equipment, and other\n";
    ss << "\\memo localized sources located in the occupied part of the room, as well as convective gain\n";
    ss << "\\memo  coming from a warm window. Used with RoomAirModelType = CrossVentilation.\n";
    ss << "\\min-fields 15\n";
    ss << "A1 , \\field Zone Name\n";
    ss << "\\note Name of Zone being described. Any existing zone name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1 , \\field Number of Diffusers per Zone\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\default Autocalculate\n";
    ss << "N2 , \\field Power per Plume\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units W\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "N3 , \\field Design Effective Area of Diffuser\n";
    ss << "\\type real\n";
    ss << "\\units m2\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\default Autocalculate\n";
    ss << "N4 , \\field Diffuser Slot Angle from Vertical\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 90.\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "N5 , \\field Thermostat Height\n";
    ss << "\\note Height of thermostat/temperature control sensor above floor\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.2\n";
    ss << "N6 , \\field Comfort Height\n";
    ss << "\\note Height at which Air temperature is calculated for comfort purposes\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.1\n";
    ss << "N7 , \\field Temperature Difference Threshold for Reporting\n";
    ss << "\\note Minimum temperature difference between upper and lower layer\n";
    ss << "\\note temperatures above which UFAD auxiliary outputs are calculated.\n";
    ss << "\\note These outputs are 'UF Transition Height' and 'UF Average Temp Gradient'.  They\n";
    ss << "\\note are set to zero values when the temperature difference is less than the\n";
    ss << "\\note threshold and the output 'UF Zone Is Mixed' is set to 1\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.4\n";
    ss << "A2 , \\field Floor Diffuser Type\n";
    ss << "\\type choice\n";
    ss << "\\key Custom\n";
    ss << "\\key Swirl\n";
    ss << "\\key VariableArea\n";
    ss << "\\key HorizontalSwirl\n";
    ss << "\\key LinearBarGrille\n";
    ss << "\\default Swirl\n";
    ss << "N8 , \\field Transition Height\n";
    ss << "\\note User-specified height above floor of boundary between occupied and upper subzones\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\default 1.7\n";
    ss << "N9,  \\field Coefficient A in formula Kc = A*Gamma**B + C + D*Gamma + E*Gamma**2\n";
    ss << "\\note Kc is the fraction of the total zone load attributable to the lower subzone\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\default Autocalculate\n";
    ss << "N10, \\field Coefficient B in formula Kc = A*Gamma**B + C + D*Gamma + E*Gamma**2\n";
    ss << "\\note Kc is the fraction of the total zone load attributable to the lower subzone\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\default Autocalculate\n";
    ss << "N11, \\field Coefficient C in formula Kc = A*Gamma**B + C + D*Gamma + E*Gamma**2\n";
    ss << "\\note Kc is the fraction of the total zone load attributable to the lower subzone\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\default Autocalculate\n";
    ss << "N12, \\field Coefficient D in formula Kc = A*Gamma**B + C + D*Gamma + E*Gamma**2\n";
    ss << "\\note Kc is the fraction of the total zone load attributable to the lower subzone\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\default Autocalculate\n";
    ss << "N13; \\field Coefficient E in formula Kc = A*Gamma**B + C + D*Gamma + E*Gamma**2\n";
    ss << "\\note Kc is the fraction of the total zone load attributable to the lower subzone\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\default Autocalculate\n";

    IddObjectType objType(IddObjectType::RoomAirSettings_UnderFloorAirDistributionExterior);
    OptionalIddObject oObj = IddObject::load("RoomAirSettings:UnderFloorAirDistributionExterior",
                                             "Room Air Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RoomAirSettings_UnderFloorAirDistributionExterior);
  return object;
}

IddObject createRoomAir_Node_AirflowNetworkIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RoomAir:Node:AirflowNetwork,\n";
    ss << "\\memo define an air node for some types of nodal air models\n";
    ss << "A1, \\field Name\n";
    ss << "\\type Alpha\n";
    ss << "\\reference RoomAirflowNetworkNodes\n";
    ss << "A2, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1, \\field Fraction of Zone Air Volume\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A3, \\field RoomAir:Node:AirflowNetwork:AdjacentSurfaceList Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RoomAirNodeSurfaceLists\n";
    ss << "A4, \\field RoomAir:Node:AirflowNetwork:InternalGains Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RoomAirNodeGains\n";
    ss << "A5; \\field RoomAir:Node:AirflowNetwork:HVACEquipment Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RoomAirNodeHVACEquipment\n";

    IddObjectType objType(IddObjectType::RoomAir_Node_AirflowNetwork);
    OptionalIddObject oObj = IddObject::load("RoomAir:Node:AirflowNetwork",
                                             "Room Air Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RoomAir_Node_AirflowNetwork);
  return object;
}

IddObject createRoomAir_Node_AirflowNetwork_AdjacentSurfaceListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RoomAir:Node:AirflowNetwork:AdjacentSurfaceList,\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 2\n";
    ss << "A1,  \\field Name\n";
    ss << "\\type Alpha\n";
    ss << "\\reference RoomAirNodeSurfaceLists\n";
    ss << "A2;  \\field Surface Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllHeatTranSurfNames\n";

    IddObjectType objType(IddObjectType::RoomAir_Node_AirflowNetwork_AdjacentSurfaceList);
    OptionalIddObject oObj = IddObject::load("RoomAir:Node:AirflowNetwork:AdjacentSurfaceList",
                                             "Room Air Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RoomAir_Node_AirflowNetwork_AdjacentSurfaceList);
  return object;
}

IddObject createRoomAir_Node_AirflowNetwork_InternalGainsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RoomAir:Node:AirflowNetwork:InternalGains,\n";
    ss << "\\extensible:3\n";
    ss << "\\min-fields 4\n";
    ss << "\\memo define the internal gains that are associated with one particular RoomAir:Node\n";
    ss << "A1, \\field Name\n";
    ss << "\\type Alpha\n";
    ss << "\\reference RoomAirNodeGains\n";
    ss << "A2, \\field Internal Gain Object 1 Type\n";
    ss << "\\begin-extensible\n";
    ss << "\\type choice\n";
    ss << "\\key People\n";
    ss << "\\key Lights\n";
    ss << "\\key ElectricEquipment\n";
    ss << "\\key GasEquipment\n";
    ss << "\\key HotWaterEquipment\n";
    ss << "\\key SteamEquipment\n";
    ss << "\\key OtherEquipment\n";
    ss << "\\key ZoneBaseboard:OutdoorTemperatureControlled\n";
    ss << "\\key ZoneContaminantSourceAndSink:CarbonDioxide\n";
    ss << "\\key WaterUse:Equipment\n";
    ss << "\\key DaylightingDevice:Tubular\n";
    ss << "\\key WaterHeater:Mixed\n";
    ss << "\\key WaterHeater:Stratified\n";
    ss << "\\key ThermalStorage:ChilledWater:Mixed\n";
    ss << "\\key ThermalStorage:ChilledWater:Stratified\n";
    ss << "\\key Generator:FuelCell\n";
    ss << "\\key Generator:MicroCHP\n";
    ss << "\\key ElectricLoadCenter:Transformer\n";
    ss << "\\key ElectricLoadCenter:Inverter:Simple\n";
    ss << "\\key ElectricLoadCenter:Inverter:FunctionOfPower\n";
    ss << "\\key ElectricLoadCenter:Inverter:LookUpTable\n";
    ss << "\\key ElectricLoadCenter:Storage:Battery\n";
    ss << "\\key ElectricLoadCenter:Storage:Simple\n";
    ss << "\\key Pipe:Indoor\n";
    ss << "\\key Refrigeration:Case\n";
    ss << "\\key Refrigeration:CompressorRack\n";
    ss << "\\key Refrigeration:System:Condenser:AirCooled\n";
    ss << "\\key Refrigeration:TranscriticalSystem:GasCooler:AirCooled\n";
    ss << "\\key Refrigeration:System:SuctionPipe\n";
    ss << "\\key Refrigeration:TranscriticalSystem:SuctionPipeMT\n";
    ss << "\\key Refrigeration:TranscriticalSystem:SuctionPipeLT\n";
    ss << "\\key Refrigeration:SecondarySystem:Receiver\n";
    ss << "\\key Refrigeration:SecondarySystem:Pipe\n";
    ss << "\\key Refrigeration:WalkIn\n";
    ss << "\\key Pump:VariableSpeed\n";
    ss << "\\key Pump:ConstantSpeed\n";
    ss << "\\key Pump:VariableSpeed:Condensate\n";
    ss << "\\key HeaderedPumps:VariableSpeed\n";
    ss << "\\key HeaderedPumps:ConstantSpeed\n";
    ss << "\\key ZoneContaminantSourceAndSink:GenericContaminant\n";
    ss << "\\key PlantComponent:UserDefined\n";
    ss << "\\key Coil:UserDefined\n";
    ss << "\\key ZoneHVAC:ForcedAir:UserDefined\n";
    ss << "\\key AirTerminal:SingleDuct:UserDefined\n";
    ss << "A3, \\field Internal Gain Object 1 Name\n";
    ss << "\\type alpha\n";
    ss << "N1; \\field Fraction of Gains to Node 1\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note fraction applies to sensible, latent, carbon dioxide, and generic contaminant gains or losses\n";

    IddObjectType objType(IddObjectType::RoomAir_Node_AirflowNetwork_InternalGains);
    OptionalIddObject oObj = IddObject::load("RoomAir:Node:AirflowNetwork:InternalGains",
                                             "Room Air Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RoomAir_Node_AirflowNetwork_InternalGains);
  return object;
}

IddObject createRoomAir_Node_AirflowNetwork_HVACEquipmentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RoomAir:Node:AirflowNetwork:HVACEquipment,\n";
    ss << "\\extensible:4\n";
    ss << "\\memo define the zone equipment associated with one particular RoomAir:Node\n";
    ss << "A1, \\field Name\n";
    ss << "\\type Alpha\n";
    ss << "\\reference RoomAirNodeHVACEquipment\n";
    ss << "A2, \\field ZoneHVAC or Air Terminal Equipment Object Type 1\n";
    ss << "\\begin-extensible\n";
    ss << "\\type choice\n";
    ss << "\\key ZoneHVAC:TerminalUnit:VariableRefrigerantFlow\n";
    ss << "\\key ZoneHVAC:EnergyRecoveryVentilator\n";
    ss << "\\key ZoneHVAC:FourPipeFanCoil\n";
    ss << "\\key ZoneHVAC:OutdoorAirUnit\n";
    ss << "\\key ZoneHVAC:PackagedTerminalAirConditioner\n";
    ss << "\\key ZoneHVAC:PackagedTerminalHeatPump\n";
    ss << "\\key ZoneHVAC:UnitHeater\n";
    ss << "\\key ZoneHVAC:UnitVentilator\n";
    ss << "\\key ZoneHVAC:VentilatedSlab\n";
    ss << "\\key ZoneHVAC:WaterToAirHeatPump\n";
    ss << "\\key ZoneHVAC:WindowAirConditioner\n";
    ss << "\\key ZoneHVAC:Baseboard:RadiantConvective:Electric\n";
    ss << "\\key ZoneHVAC:Baseboard:RadiantConvective:Water\n";
    ss << "\\key ZoneHVAC:Baseboard:RadiantConvective:Steam\n";
    ss << "\\key ZoneHVAC:Baseboard:Convective:Electric\n";
    ss << "\\key ZoneHVAC:Baseboard:Convective:Water\n";
    ss << "\\key ZoneHVAC:HighTemperatureRadiant\n";
    ss << "\\key ZoneHVAC:Dehumidifier:DX\n";
    ss << "\\key ZoneHVAC:IdealLoadsAirSystem\n";
    ss << "\\key ZoneHVAC:RefrigerationChillerSet\n";
    ss << "\\key Fan:ZoneExhaust\n";
    ss << "\\key WaterHeater:HeatPump\n";
    ss << "\\key AirTerminal:SingleDuct:Uncontrolled\n";
    ss << "\\key AirTerminal:DualDuct:ConstantVolume\n";
    ss << "\\key AirTerminal:DualDuct:VAV\n";
    ss << "\\key AirTerminal:SingleDuct:ConstantVolume:Reheat\n";
    ss << "\\key AirTerminal:SingleDuct:VAV:Reheat\n";
    ss << "\\key AirTerminal:SingleDuct:VAV:NoReheat\n";
    ss << "\\key AirTerminal:SingleDuct:SeriesPIU:Reheat\n";
    ss << "\\key AirTerminal:SingleDuct:ParallelPIU:Reheat\n";
    ss << "\\key AirTerminal:SingleDuct:ConstantVolume:FourPipeInduction\n";
    ss << "\\key AirTerminal:SingleDuct:VAV:Reheat:VariableSpeedFan\n";
    ss << "\\key AirTerminal:SingleDuct:VAV:HeatAndCool:Reheat\n";
    ss << "\\key AirTerminal:SingleDuct:VAV:HeatAndCool:NoReheat\n";
    ss << "\\key AirTerminal:SingleDuct:ConstantVolume:CooledBeam\n";
    ss << "\\key AirTerminal:DualDuct:VAV:OutdoorAir\n";
    ss << "\\key AirLoopHVACReturnAir\n";
    ss << "A3, \\field ZoneHVAC or Air Terminal Equipment Object Name 1\n";
    ss << "\\type alpha\n";
    ss << "\\note for object type AirLoopHVACReturnAir, then enter zone return air node name\n";
    ss << "N1, \\field Fraction of Output or Supply Air from HVAC Equipment 1\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N2; \\field Fraction of Input or Return Air to HVAC Equipment 1\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";

    IddObjectType objType(IddObjectType::RoomAir_Node_AirflowNetwork_HVACEquipment);
    OptionalIddObject oObj = IddObject::load("RoomAir:Node:AirflowNetwork:HVACEquipment",
                                             "Room Air Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RoomAir_Node_AirflowNetwork_HVACEquipment);
  return object;
}

IddObject createRoomAirSettings_AirflowNetworkIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "RoomAirSettings:AirflowNetwork,\n";
    ss << "\\extensible:1\n";
    ss << "\\memo RoomAir modeling using Airflow pressure network solver\n";
    ss << "\\min-fields 5\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Zone Name\n";
    ss << "\\note Name of Zone being described. Any existing zone name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A3 , \\field Control Point RoomAirflowNetwork:Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RoomAirflowNetworkNodes\n";
    ss << "A4 ; \\field RoomAirflowNetwork:Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RoomAirflowNetworkNodes\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::RoomAirSettings_AirflowNetwork);
    OptionalIddObject oObj = IddObject::load("RoomAirSettings:AirflowNetwork",
                                             "Room Air Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::RoomAirSettings_AirflowNetwork);
  return object;
}

IddObject createPeopleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "People,\n";
    ss << "\\memo Sets internal gains and contaminant rates for occupants in the zone.\n";
    ss << "\\memo If you use a ZoneList in the Zone or ZoneList name field then this definition applies\n";
    ss << "\\memo to all the zones in the ZoneList.\n";
    ss << "\\extensible:1\n";
    ss << "\\max-fields 24\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference PeopleNames\n";
    ss << "A2 , \\field Zone or ZoneList Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneAndZoneListNames\n";
    ss << "A3 , \\field Number of People Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\note units in schedule should be fraction applied to number of people (0.0 - 1.0)\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Number of People Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum number of people\n";
    ss << "\\note for this set of attributes (i.e. sensible fraction, schedule, etc)\n";
    ss << "\\note Choices: People -- simply enter number of occupants.\n";
    ss << "\\note People per Zone Floor Area -- enter the number to apply.  Value * Floor Area = Number of people\n";
    ss << "\\note Zone Floor Area per Person -- enter the number to apply.  Floor Area / Value = Number of people\n";
    ss << "\\type choice\n";
    ss << "\\key People\n";
    ss << "\\key People/Area\n";
    ss << "\\key Area/Person\n";
    ss << "\\default People\n";
    ss << "N1 , \\field Number of People\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N2 , \\field People per Zone Floor Area\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units person/m2\n";
    ss << "N3 , \\field Zone Floor Area per Person\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units m2/person\n";
    ss << "N4 , \\field Fraction Radiant\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N5,  \\field Sensible Heat Fraction\n";
    ss << "\\note if input, overrides program calculated sensible/latent split\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A5 , \\field Activity Level Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\note Note that W has to be converted to mets in TC routine\n";
    ss << "\\type object-list\n";
    ss << "\\note units in schedule are W/person\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N6 , \\field Carbon Dioxide Generation Rate\n";
    ss << "\\note CO2 generation rate per unit of activity level.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-W\n";
    ss << "\\default 3.82E-8\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 3.82E-7\n";
    ss << "\\note The default value is obtained from ASHRAE Std 62.1 at 0.0084 cfm/met/person over\n";
    ss << "\\note the general adult population.\n";
    ss << "A6 , \\field Enable ASHRAE 55 Comfort Warnings\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A7 , \\field Mean Radiant Temperature Calculation Type\n";
    ss << "\\note optional (only required for thermal comfort runs)\n";
    ss << "\\type choice\n";
    ss << "\\key ZoneAveraged\n";
    ss << "\\key SurfaceWeighted\n";
    ss << "\\key AngleFactor\n";
    ss << "\\default ZoneAveraged\n";
    ss << "A8 , \\field Surface Name/Angle Factor List Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllHeatTranAngFacNames\n";
    ss << "\\note optional (only required for thermal comfort runs)\n";
    ss << "A9 , \\field Work Efficiency Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note units in schedule are 0.0 to 1.0\n";
    ss << "\\note optional (only required for thermal comfort runs)\n";
    ss << "A10, \\field Clothing Insulation Calculation Method\n";
    ss << "\\type choice\n";
    ss << "\\key ClothingInsulationSchedule\n";
    ss << "\\key DynamicClothingModelASHRAE55\n";
    ss << "\\key CalculationMethodSchedule\n";
    ss << "\\default ClothingInsulationSchedule\n";
    ss << "A11, \\field Clothing Insulation Calculation Method Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note a schedule value of 1 for the Scheduled method, and 2 for the DynamicClothingModelASHRAE55 method\n";
    ss << "A12, \\field Clothing Insulation Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note use \"Clo\" from ASHRAE or Thermal Comfort guides\n";
    ss << "\\note optional (only required for thermal comfort runs)\n";
    ss << "A13, \\field Air Velocity Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note units in the schedule are m/s\n";
    ss << "\\note optional (only required for thermal comfort runs)\n";
    ss << "A14; \\field Thermal Comfort Model 1 Type\n";
    ss << "\\type choice\n";
    ss << "\\key Fanger\n";
    ss << "\\key Pierce\n";
    ss << "\\key KSU\n";
    ss << "\\key AdaptiveASH55\n";
    ss << "\\key AdaptiveCEN15251\n";
    ss << "\\note optional (only needed for people thermal comfort results reporting)\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::People);
    OptionalIddObject oObj = IddObject::load("People",
                                             "Internal Gains",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::People);
  return object;
}

IddObject createComfortViewFactorAnglesIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ComfortViewFactorAngles,\n";
    ss << "\\memo Used to specify radiant view factors for thermal comfort calculations.\n";
    ss << "\\extensible:2\n";
    ss << "\\max-fields 42\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "A2 , \\field Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A3 , \\field Surface 1 Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllHeatTranSurfNames\n";
    ss << "\\begin-extensible\n";
    ss << "N1 ; \\field Angle Factor 1\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";

    IddObjectType objType(IddObjectType::ComfortViewFactorAngles);
    OptionalIddObject oObj = IddObject::load("ComfortViewFactorAngles",
                                             "Internal Gains",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ComfortViewFactorAngles);
  return object;
}

IddObject createLightsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Lights,\n";
    ss << "\\memo Sets internal gains for lights in the zone.\n";
    ss << "\\memo If you use a ZoneList in the Zone or ZoneList name field then this definition applies\n";
    ss << "\\memo to all the zones in the ZoneList.\n";
    ss << "\\min-fields 10\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference LightsNames\n";
    ss << "A2 , \\field Zone or ZoneList Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneAndZoneListNames\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note units in schedule should be fraction applied to design level of lights, generally (0.0 - 1.0)\n";
    ss << "A4 , \\field Design Level Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum amount of lights\n";
    ss << "\\note for this set of attributes\n";
    ss << "\\note Choices: LightingLevel => Lighting Level -- simply enter watts of lights\n";
    ss << "\\note Watts/Area => Watts per Zone Floor Area -- enter the number to apply.  Value * Floor Area = Lights\n";
    ss << "\\note Watts/Person => Watts per Person -- enter the number to apply.  Value * Occupants = Lights\n";
    ss << "\\type choice\n";
    ss << "\\key LightingLevel\n";
    ss << "\\key Watts/Area\n";
    ss << "\\key Watts/Person\n";
    ss << "\\default LightingLevel\n";
    ss << "N1 , \\field Lighting Level\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\ip-units W\n";
    ss << "N2 , \\field Watts per Zone Floor Area\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units W/m2\n";
    ss << "\\ip-units W/ft2\n";
    ss << "N3 , \\field Watts per Person\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units W/person\n";
    ss << "\\ip-units W/person\n";
    ss << "N4 , \\field Return Air Fraction\n";
    ss << "\\note Used only for sizing calculation if return-air-fraction\n";
    ss << "\\note coefficients are specified.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "N5 , \\field Fraction Radiant\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "N6 , \\field Fraction Visible\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "N7 , \\field Fraction Replaceable\n";
    ss << "\\note For Daylighting:Controls and Daylighting:DElight:Controls,\n";
    ss << "\\note must be 0 or 1:  0 = no dimming control, 1 = full dimming control\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A5 , \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";
    ss << "A6 , \\field Return Air Fraction Calculated from Plenum Temperature\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N8 , \\field Return Air Fraction Function of Plenum Temperature Coefficient 1\n";
    ss << "\\note Used only if Return Air Fraction Is Calculated from Plenum Temperature = Yes\n";
    ss << "\\note Equation is Return Air Fraction = Coefficient#1 - Coefficient#2 X PlenumTemp(degC)\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N9 ; \\field Return Air Fraction Function of Plenum Temperature Coefficient 2\n";
    ss << "\\note Used only if Return Air Fraction Is Calculated from Plenum Temperature = Yes\n";
    ss << "\\note Equation is Return Air Fraction = Coefficient#1 - Coefficient#2 X PlenumTemp(degC)\n";
    ss << "\\type real\n";
    ss << "\\units 1/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::Lights);
    OptionalIddObject oObj = IddObject::load("Lights",
                                             "Internal Gains",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Lights);
  return object;
}

IddObject createElectricEquipmentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ElectricEquipment,\n";
    ss << "\\memo Sets internal gains for electric equipment in the zone.\n";
    ss << "\\memo If you use a ZoneList in the Zone or ZoneList name field then this definition applies\n";
    ss << "\\memo to all the zones in the ZoneList.\n";
    ss << "\\min-fields 10\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ElectricEquipmentNames\n";
    ss << "A2 , \\field Zone or ZoneList Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneAndZoneListNames\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note units in schedule should be fraction applied to design level of electric equipment, generally (0.0 - 1.0)\n";
    ss << "A4 , \\field Design Level Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum amount of electric equipment\n";
    ss << "\\note for this set of attributes\n";
    ss << "\\note Choices: EquipmentLevel => Equipment Level -- simply enter watts of equipment\n";
    ss << "\\note Watts/Area => Watts per Zone Floor Area -- enter the number to apply.  Value * Floor Area = Equipment Level\n";
    ss << "\\note Watts/Person => Watts per Person -- enter the number to apply.  Value * Occupants = Equipment Level\n";
    ss << "\\type choice\n";
    ss << "\\key EquipmentLevel\n";
    ss << "\\key Watts/Area\n";
    ss << "\\key Watts/Person\n";
    ss << "\\default EquipmentLevel\n";
    ss << "N1 , \\field Design Level\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\ip-units W\n";
    ss << "N2 , \\field Watts per Zone Floor Area\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units W/m2\n";
    ss << "\\ip-units W/ft2\n";
    ss << "N3 , \\field Watts per Person\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units W/person\n";
    ss << "\\ip-units W/person\n";
    ss << "N4 , \\field Fraction Latent\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "N5 , \\field Fraction Radiant\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "N6 , \\field Fraction Lost\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "A5 ; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::ElectricEquipment);
    OptionalIddObject oObj = IddObject::load("ElectricEquipment",
                                             "Internal Gains",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ElectricEquipment);
  return object;
}

IddObject createGasEquipmentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GasEquipment,\n";
    ss << "\\memo Sets internal gains and contaminant rates for gas equipment in the zone.\n";
    ss << "\\memo If you use a ZoneList in the Zone name field then this definition applies to all those zones.\n";
    ss << "\\min-fields 10\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Zone or ZoneList Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneAndZoneListNames\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note units in Schedule should be fraction applied to design level of gas equipment, generally (0.0 - 1.0)\n";
    ss << "A4 , \\field Design Level Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum amount of gas equipment\n";
    ss << "\\note for this set of attributes\n";
    ss << "\\note Choices: EquipmentLevel => Design Level -- simply enter power input of equipment\n";
    ss << "\\note Watts/Area or Power/Area => Power per Zone Floor Area -- enter the number to apply.  Value * Floor Area = Equipment Level\n";
    ss << "\\note Watts/Person or Power/Person => Power per Person -- enter the number to apply.  Value * Occupants = Equipment Level\n";
    ss << "\\type choice\n";
    ss << "\\key EquipmentLevel\n";
    ss << "\\key Watts/Area\n";
    ss << "\\key Watts/Person\n";
    ss << "\\key Power/Area\n";
    ss << "\\key Power/Person\n";
    ss << "\\default EquipmentLevel\n";
    ss << "N1 , \\field Design Level\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\ip-units Btu/h\n";
    ss << "N2 , \\field Power per Zone Floor Area\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units W/m2\n";
    ss << "\\ip-units Btu/h-ft2\n";
    ss << "N3 , \\field Power per Person\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units W/Person\n";
    ss << "\\ip-units Btu/h-person\n";
    ss << "N4 , \\field Fraction Latent\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "N5 , \\field Fraction Radiant\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "N6 , \\field Fraction Lost\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "N7 , \\field Carbon Dioxide Generation Rate\n";
    ss << "\\note CO2 generation rate per unit of power input\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-W\n";
    ss << "\\ip-units (ft3/min)/(Btu/h)\n";
    ss << "\\default 0.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 4.0E-7\n";
    ss << "\\note The default value assumes the equipment is fully vented.\n";
    ss << "\\note For unvented equipment, a suggested value is 3.45E-8 m3/s-W. This value is\n";
    ss << "\\note converted from a natural gas CO2 emission rate of 117 lbs CO2 per million Btu.\n";
    ss << "\\note The maximum value assumes to be 10 times of the recommended value.\n";
    ss << "A5 ; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::GasEquipment);
    OptionalIddObject oObj = IddObject::load("GasEquipment",
                                             "Internal Gains",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GasEquipment);
  return object;
}

IddObject createHotWaterEquipmentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HotWaterEquipment,\n";
    ss << "\\memo Sets internal gains for hot water equipment in the zone.\n";
    ss << "\\memo If you use a ZoneList in the Zone name field then this definition applies to all those zones.\n";
    ss << "\\min-fields 10\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Zone or ZoneList Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneAndZoneListNames\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note units in Schedule should be fraction applied to design level of hot water equipment, generally (0.0 - 1.0)\n";
    ss << "A4 , \\field Design Level Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum amount of hot water equipment\n";
    ss << "\\note for this set of attributes\n";
    ss << "\\note Choices: EquipmentLevel => Design Level -- simply enter power input of equipment\n";
    ss << "\\note Watts/Area or Power/Area => Power per Zone Floor Area -- enter the number to apply.  Value * Floor Area = Equipment Level\n";
    ss << "\\note Watts/Person or Power/Person => Power per Person -- enter the number to apply.  Value * Occupants = Equipment Level\n";
    ss << "\\type choice\n";
    ss << "\\key EquipmentLevel\n";
    ss << "\\key Watts/Area\n";
    ss << "\\key Watts/Person\n";
    ss << "\\key Power/Area\n";
    ss << "\\key Power/Person\n";
    ss << "\\default EquipmentLevel\n";
    ss << "N1 , \\field Design Level\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\ip-units Btu/h\n";
    ss << "N2 , \\field Power per Zone Floor Area\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units W/m2\n";
    ss << "\\ip-units Btu/h-ft2\n";
    ss << "N3 , \\field Power per Person\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units W/Person\n";
    ss << "\\ip-units Btu/h-person\n";
    ss << "N4 , \\field Fraction Latent\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "N5 , \\field Fraction Radiant\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "N6 , \\field Fraction Lost\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "A5 ; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::HotWaterEquipment);
    OptionalIddObject oObj = IddObject::load("HotWaterEquipment",
                                             "Internal Gains",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HotWaterEquipment);
  return object;
}

IddObject createSteamEquipmentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SteamEquipment,\n";
    ss << "\\memo Sets internal gains for steam equipment in the zone.\n";
    ss << "\\min-fields 10\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Zone or ZoneList Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneAndZoneListNames\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note units in Schedule should be fraction applied to design level of steam equipment, generally (0.0 - 1.0)\n";
    ss << "A4 , \\field Design Level Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum amount of steam equipment\n";
    ss << "\\note for this set of attributes\n";
    ss << "\\note Choices: EquipmentLevel => Design Level -- simply enter power input of equipment\n";
    ss << "\\note Watts/Area or Power/Area => Power per Zone Floor Area -- enter the number to apply.  Value * Floor Area = Equipment Level\n";
    ss << "\\note Watts/Person or Power/Person => Power per Person -- enter the number to apply.  Value * Occupants = Equipment Level\n";
    ss << "\\type choice\n";
    ss << "\\key EquipmentLevel\n";
    ss << "\\key Watts/Area\n";
    ss << "\\key Watts/Person\n";
    ss << "\\key Power/Area\n";
    ss << "\\key Power/Person\n";
    ss << "\\default EquipmentLevel\n";
    ss << "N1 , \\field Design Level\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\ip-units Btu/h\n";
    ss << "N2 , \\field Power per Zone Floor Area\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units W/m2\n";
    ss << "\\ip-units Btu/h-ft2\n";
    ss << "N3 , \\field Power per Person\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units W/Person\n";
    ss << "\\ip-units Btu/h-person\n";
    ss << "N4 , \\field Fraction Latent\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "N5 , \\field Fraction Radiant\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "N6 , \\field Fraction Lost\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "A5 ; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::SteamEquipment);
    OptionalIddObject oObj = IddObject::load("SteamEquipment",
                                             "Internal Gains",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SteamEquipment);
  return object;
}

IddObject createOtherEquipmentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OtherEquipment,\n";
    ss << "\\memo Sets internal gains or losses for \"other\" equipment in the zone.\n";
    ss << "\\min-fields 10\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Zone or ZoneList Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneAndZoneListNames\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note units in Schedule should be fraction applied to design level of other equipment, generally (0.0 - 1.0)\n";
    ss << "A4 , \\field Design Level Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum amount of other equipment.\n";
    ss << "\\note to set a loss, use a negative value in the following fields.\n";
    ss << "\\note for this set of attributes\n";
    ss << "\\note Choices: EquipmentLevel => Design Level -- simply enter power input of equipment\n";
    ss << "\\note Watts/Area or Power/Area => Power per Zone Floor Area -- enter the number to apply.  Value * Floor Area = Equipment Level\n";
    ss << "\\note Watts/Person or Power/Person => Power per Person -- enter the number to apply.  Value * Occupants = Equipment Level\n";
    ss << "\\type choice\n";
    ss << "\\key EquipmentLevel\n";
    ss << "\\key Watts/Area\n";
    ss << "\\key Watts/Person\n";
    ss << "\\key Power/Area\n";
    ss << "\\key Power/Person\n";
    ss << "\\default EquipmentLevel\n";
    ss << "N1 , \\field Design Level\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\ip-units Btu/h\n";
    ss << "N2 , \\field Power per Zone Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\ip-units Btu/h-ft2\n";
    ss << "N3 , \\field Power per Person\n";
    ss << "\\type real\n";
    ss << "\\units W/Person\n";
    ss << "\\ip-units Btu/h-person\n";
    ss << "N4 , \\field Fraction Latent\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "N5 , \\field Fraction Radiant\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "N6 ; \\field Fraction Lost\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";

    IddObjectType objType(IddObjectType::OtherEquipment);
    OptionalIddObject oObj = IddObject::load("OtherEquipment",
                                             "Internal Gains",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OtherEquipment);
  return object;
}

IddObject createElectricEquipment_ITE_AirCooledIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ElectricEquipment:ITE:AirCooled,\n";
    ss << "\\memo This object describes air-cooled electric information technology equipment (ITE) which has\n";
    ss << "\\memo variable power consumption as a function of loading and temperature.\n";
    ss << "\\min-fields 27\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A3 , \\field Design Power Input Calculation Method\n";
    ss << "\\note The entered calculation method is used to specify the design power input\n";
    ss << "\\note Watts/Unit => Watts per Unit -- Design Power = Watts per Unit * Number of Units\n";
    ss << "\\note Watts/Area => Watts per Zone Floor Area -- Design Power = Watts per Zone Floor Area * Floor Area\n";
    ss << "\\type choice\n";
    ss << "\\key Watts/Unit\n";
    ss << "\\key Watts/Area\n";
    ss << "\\default Watts/Unit\n";
    ss << "N1 , \\field Watts per Unit\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\ip-units W\n";
    ss << "N2 , \\field Number of Units\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 1\n";
    ss << "N3 , \\field Watts per Zone Floor Area\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units W/m2\n";
    ss << "\\ip-units W/ft2\n";
    ss << "A4 , \\field Design Power Input Schedule Name\n";
    ss << "\\note Operating schedule for this equipment, fraction applied to the design power input,\n";
    ss << "\\note generally (0.0 - 1.0)\n";
    ss << "\\note If this field is blank, the schedule is assumed to always be 1.0.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5 , \\field CPU Loading  Schedule Name\n";
    ss << "\\note CPU loading schedule for this equipment as a fraction from 0.0 (idle) to 1.0 (full load).\n";
    ss << "\\note If this field is blank, the schedule is assumed to always be 1.0.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6 , \\field CPU Power Input Function of Loading and Air Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiVariateCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note The name of a two-variable curve or table lookup object which modifies the CPU power\n";
    ss << "\\note input as a function of CPU loading (x) and air inlet node temperature (y).\n";
    ss << "\\note This curve (table) should equal 1.0 at design conditions (CPU loading = 1.0 and\n";
    ss << "\\note Design Entering Air Temperature).\n";
    ss << "N4 , \\field Design Fan Power Input Fraction\n";
    ss << "\\note The fraction of the total power input at design conditions which is for the cooling fan(s)\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N5,  \\field Design Fan Air Flow Rate per Power Input\n";
    ss << "\\note The cooling fan air flow rate per total electric power input at design conditions\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-W\n";
    ss << "\\minimum 0.0\n";
    ss << "A7 , \\field Air Flow Function of Loading and Air Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiVariateCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note The name of a two-variable curve or table lookup object which modifies the cooling\n";
    ss << "\\note air flow rate as a function of CPU loading (x) and air inlet node temperature (y).\n";
    ss << "\\note This curve (table) should equal 1.0 at design conditions (CPU loading = 1.0 and\n";
    ss << "\\note Design Entering Air Temperature).\n";
    ss << "A8 , \\field Fan Power Input Function of Flow Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note The name of a single-variable curve or table lookup object which modifies the cooling\n";
    ss << "\\note fan power as a function of flow fraction (x).\n";
    ss << "\\note This curve (table) should equal 1.0 at a flow fraction of 1.0.\n";
    ss << "N6,  \\field Design Entering Air Temperature\n";
    ss << "\\note The entering air temperature at design conditions.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 15.0\n";
    ss << "A9,  \\field Environmental Class\n";
    ss << "\\note Specifies the allowable operating conditions for the air inlet conditions.\n";
    ss << "\\note Used for reporting time outside allowable conditions.\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key A1\n";
    ss << "\\key A2\n";
    ss << "\\key A3\n";
    ss << "\\key A4\n";
    ss << "\\key B\n";
    ss << "\\key C\n";
    ss << "\\default None\n";
    ss << "A10, \\field Air Inlet Connection Type\n";
    ss << "\\note Specifies the type of connection between the zone and the ITE air inlet node.\n";
    ss << "\\note AdjustedSupply = ITE inlet temperature will be the current Supply Air Node temperature\n";
    ss << "\\note adjusted by the current recirculation fraction.\n";
    ss << "\\note All heat output is added to the zone air heat balance as a convective gain.\n";
    ss << "\\note ZoneAirNode = ITE air inlet condition is  the average zone condition.\n";
    ss << "\\note All heat output is added to the zone air heat balance as a convective gain.\n";
    ss << "\\note RoomAirModel = ITE air inlet and outlet are connected to room air model nodes.\n";
    ss << "\\type choice\n";
    ss << "\\key AdjustedSupply\n";
    ss << "\\key ZoneAirNode\n";
    ss << "\\key RoomAirModel\n";
    ss << "\\default AdjustedSupply\n";
    ss << "A11, \\field Air Inlet Room Air Model Node Name\n";
    ss << "\\note Name of a RoomAir:Node object which is connected to the ITE air inlet.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RoomAirNodes\n";
    ss << "A12, \\field Air Outlet Room Air Model Node Name\n";
    ss << "\\note Name of a RoomAir:Node object which is connected to the ITE air outlet.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RoomAirNodes\n";
    ss << "A13, \\field Supply Air Node Name\n";
    ss << "\\note Name of the supply air inlet node serving this ITE. Required if the\n";
    ss << "\\note Air Node Connection Type = AdjustedSupply. Also required if reporting of\n";
    ss << "\\note Supply Heat Index is desired.\n";
    ss << "\\type node\n";
    ss << "N7,  \\field Design Recirculation Fraction\n";
    ss << "\\note The recirculation fraction for this equipment at design conditions. This field is used only\n";
    ss << "\\note if the Air Node Connection Type = AdjustedSupply. The default is 0.0 (no recirculation).\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.0\n";
    ss << "A14, \\field Recirculation Function of Loading and Supply Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiVariateCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note The name of a two-variable curve or table lookup object which modifies the recirculation\n";
    ss << "\\note fractionas a function of CPU loading (x) and supply air node temperature (y).\n";
    ss << "\\note This curve (table) should equal 1.0 at design conditions (CPU loading = 1.0 and\n";
    ss << "\\note Design Entering Air Temperature).This field is used only if the\n";
    ss << "\\note Air Node Connection Type = AdjustedSupply. If this curve is left blank, then the curve\n";
    ss << "\\note is assumed to always equal 1.0.\n";
    ss << "N8 , \\field Design Electric Power Supply Efficiency\n";
    ss << "\\note The efficiency of the power supply system serving this ITE\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A15, \\field Electric Power Supply Efficiency Function of Part Load Ratio Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note The name of a single-variable curve or table lookup object which modifies the electric\n";
    ss << "\\note power supply efficiency as a function of part-load ratio (x).\n";
    ss << "\\note This curve (table) should equal 1.0 at full load (PLR = 1.0).\n";
    ss << "\\note If this curve is left blank, then the curve is assumed to always equal 1.0.\n";
    ss << "N9 , \\field Fraction of Electric Power Supply Losses to Zone\n";
    ss << "\\note Fraction of the electric power supply losses which are a heat gain to the zone\n";
    ss << "\\note If this field is <1.0, the remainder of the losses are assumed to be lost to the outdoors.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A16, \\field CPU End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default ITE-CPU\n";
    ss << "A17, \\field Fan End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default ITE-Fans\n";
    ss << "A18; \\field Electric Power Supply End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default ITE-UPS\n";

    IddObjectType objType(IddObjectType::ElectricEquipment_ITE_AirCooled);
    OptionalIddObject oObj = IddObject::load("ElectricEquipment:ITE:AirCooled",
                                             "Internal Gains",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ElectricEquipment_ITE_AirCooled);
  return object;
}

IddObject createZoneBaseboard_OutdoorTemperatureControlledIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneBaseboard:OutdoorTemperatureControlled,\n";
    ss << "\\memo Specifies outside temperature-controlled electric baseboard heating.\n";
    ss << "\\min-fields 8\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note units in Schedule should be fraction applied to capacity of the baseboard heat equipment, generally (0.0 - 1.0)\n";
    ss << "N1 , \\field Capacity at Low Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "N2 , \\field Low Temperature\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Capacity at High Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "N4 , \\field High Temperature\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "N5 , \\field Fraction Radiant\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "A4 ; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::ZoneBaseboard_OutdoorTemperatureControlled);
    OptionalIddObject oObj = IddObject::load("ZoneBaseboard:OutdoorTemperatureControlled",
                                             "Internal Gains",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneBaseboard_OutdoorTemperatureControlled);
  return object;
}

IddObject createSwimmingPool_IndoorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SwimmingPool:Indoor,\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2,  \\field Surface Name\n";
    ss << "\\required-field\n";
    ss << "\\note Name of the floor surface where the pool is located.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FloorSurfaceNames\n";
    ss << "N1,  \\field Average Depth\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "A3,  \\field Activity Factor Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4,  \\field Make-up Water Supply Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5,  \\field Cover Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N2,  \\field Cover Evaporation Factor\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N3,  \\field Cover Convection Factor\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N4,  \\field Cover Short-Wavelength Radiation Factor\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N5,  \\field Cover Long-Wavelength Radiation Factor\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "A6,  \\field Pool Water Inlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7,  \\field Pool Water Outlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N6,  \\field Pool Heating System Maximum Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "N7,  \\field Pool Miscellaneous Equipment Power\n";
    ss << "\\note Power input per pool water flow rate\n";
    ss << "\\units W/(m3/s)\n";
    ss << "\\ip-units W/(gal/min)\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "A8,  \\field Setpoint Temperature Schedule\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N8,  \\field Maximum Number of People\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0.0\n";
    ss << "A9,  \\field People Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A10; \\field People Heat Gain Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::SwimmingPool_Indoor);
    OptionalIddObject oObj = IddObject::load("SwimmingPool:Indoor",
                                             "Internal Gains",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SwimmingPool_Indoor);
  return object;
}

IddObject createZoneContaminantSourceAndSink_CarbonDioxideIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneContaminantSourceAndSink:CarbonDioxide,\n";
    ss << "\\memo Represents internal CO2 gains and sinks in the zone.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1 , \\field Design Generation Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\note Positive values represent sources and negative values represent sinks.\n";
    ss << "A3 ; \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Value in this schedule should be a fraction (generally 0.0 - 1.0) applied to the Design Generation Rate\n";

    IddObjectType objType(IddObjectType::ZoneContaminantSourceAndSink_CarbonDioxide);
    OptionalIddObject oObj = IddObject::load("ZoneContaminantSourceAndSink:CarbonDioxide",
                                             "Internal Gains",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneContaminantSourceAndSink_CarbonDioxide);
  return object;
}

IddObject createZoneContaminantSourceAndSink_Generic_ConstantIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneContaminantSourceAndSink:Generic:Constant,\n";
    ss << "\\memo Sets internal generic contaminant gains and sinks in a zone with constant values.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1 , \\field Design Generation Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note The values represent source.\n";
    ss << "A3 , \\field Generation Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Value in this schedule should be a fraction (generally 0.0 - 1.0) applied to the Design Generation Rate\n";
    ss << "N2 , \\field Design Removal Coefficient\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note The value represent sink.\n";
    ss << "A4 ; \\field Removal Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Value in this schedule should be a fraction (generally 0.0 - 1.0) applied to the\n";
    ss << "\\note Design removal Coefficient\n";

    IddObjectType objType(IddObjectType::ZoneContaminantSourceAndSink_Generic_Constant);
    OptionalIddObject oObj = IddObject::load("ZoneContaminantSourceAndSink:Generic:Constant",
                                             "Internal Gains",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneContaminantSourceAndSink_Generic_Constant);
  return object;
}

IddObject createSurfaceContaminantSourceAndSink_Generic_PressureDrivenIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceContaminantSourceAndSink:Generic:PressureDriven,\n";
    ss << "\\memo Simulate generic contaminant source driven by the pressure difference across a surface.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Surface Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfAndSubSurfNames\n";
    ss << "N1 , \\field Design Generation Rate Coefficient\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "A3 , \\field Generation Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Value in this schedule should be a fraction (generally 0.0 - 1.0) applied to the\n";
    ss << "\\note Design Generation Rate Coefficient\n";
    ss << "N2 ; \\field Generation Exponent\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";

    IddObjectType objType(IddObjectType::SurfaceContaminantSourceAndSink_Generic_PressureDriven);
    OptionalIddObject oObj = IddObject::load("SurfaceContaminantSourceAndSink:Generic:PressureDriven",
                                             "Internal Gains",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceContaminantSourceAndSink_Generic_PressureDriven);
  return object;
}

IddObject createZoneContaminantSourceAndSink_Generic_CutoffModelIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneContaminantSourceAndSink:Generic:CutoffModel,\n";
    ss << "\\memo Simulate generic contaminant source driven by the cutoff concentration model.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference GenericContaminantGenerationNames\n";
    ss << "A2 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1 , \\field Design Generation Rate Coefficient\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Value in this schedule should be a fraction (generally 0.0 - 1.0) applied to the\n";
    ss << "\\note Design Generation Rate Coefficient\n";
    ss << "N2 ; \\field Cutoff Generic Contaminant at which Emission Ceases\n";
    ss << "\\units ppm\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note When the zone concentration level is greater than the cutoff level, emission stops,\n";
    ss << "\\note and the source level is zero.\n";

    IddObjectType objType(IddObjectType::ZoneContaminantSourceAndSink_Generic_CutoffModel);
    OptionalIddObject oObj = IddObject::load("ZoneContaminantSourceAndSink:Generic:CutoffModel",
                                             "Internal Gains",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneContaminantSourceAndSink_Generic_CutoffModel);
  return object;
}

IddObject createZoneContaminantSourceAndSink_Generic_DecaySourceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneContaminantSourceAndSink:Generic:DecaySource,\n";
    ss << "\\memo Simulate generic contaminant source driven by the cutoff concentration model.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1 , \\field Initial Emission Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Value in this schedule should be a fraction (generally 0.0 - 1.0) applied to the\n";
    ss << "\\note Initial Emission Rate. When the value is equal to 1.0, the time will be reset to\n";
    ss << "\\note zero.\n";
    ss << "N2 ; \\field Delay Time Constant\n";
    ss << "\\units s\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";

    IddObjectType objType(IddObjectType::ZoneContaminantSourceAndSink_Generic_DecaySource);
    OptionalIddObject oObj = IddObject::load("ZoneContaminantSourceAndSink:Generic:DecaySource",
                                             "Internal Gains",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneContaminantSourceAndSink_Generic_DecaySource);
  return object;
}

IddObject createSurfaceContaminantSourceAndSink_Generic_BoundaryLayerDiffusionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceContaminantSourceAndSink:Generic:BoundaryLayerDiffusion,\n";
    ss << "\\memo Simulate generic contaminant source driven by the boundary layer diffusion controlled model.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Surface Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceNames\n";
    ss << "N1 , \\field Mass Transfer Coefficient\n";
    ss << "\\units m/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Value in this schedule should be a fraction (generally 0.0 - 1.0) applied to the\n";
    ss << "\\note Initial Emission Rate. When the value is equal to 1.0, the time will be reset to\n";
    ss << "\\note zero.\n";
    ss << "N2 ; \\field Henry adsorption constant or partition coefficient\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";

    IddObjectType objType(IddObjectType::SurfaceContaminantSourceAndSink_Generic_BoundaryLayerDiffusion);
    OptionalIddObject oObj = IddObject::load("SurfaceContaminantSourceAndSink:Generic:BoundaryLayerDiffusion",
                                             "Internal Gains",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceContaminantSourceAndSink_Generic_BoundaryLayerDiffusion);
  return object;
}

IddObject createSurfaceContaminantSourceAndSink_Generic_DepositionVelocitySinkIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SurfaceContaminantSourceAndSink:Generic:DepositionVelocitySink,\n";
    ss << "\\memo Simulate generic contaminant source driven by the boundary layer diffusion controlled model.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Surface Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceNames\n";
    ss << "N1 , \\field Deposition Velocity\n";
    ss << "\\units m/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "A3 ; \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Value in this schedule should be a fraction (generally 0.0 - 1.0) applied to the\n";
    ss << "\\note Initial Emission Rate. When the value is equal to 1.0, the time will be reset to\n";
    ss << "\\note zero.\n";

    IddObjectType objType(IddObjectType::SurfaceContaminantSourceAndSink_Generic_DepositionVelocitySink);
    OptionalIddObject oObj = IddObject::load("SurfaceContaminantSourceAndSink:Generic:DepositionVelocitySink",
                                             "Internal Gains",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SurfaceContaminantSourceAndSink_Generic_DepositionVelocitySink);
  return object;
}

IddObject createZoneContaminantSourceAndSink_Generic_DepositionRateSinkIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneContaminantSourceAndSink:Generic:DepositionRateSink,\n";
    ss << "\\memo Simulate generic contaminant source driven by the boundary layer diffusion controlled model.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1 , \\field Deposition Rate\n";
    ss << "\\units m/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "A3 ; \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Value in this schedule should be a fraction (generally 0.0 - 1.0) applied to the\n";
    ss << "\\note Initial Emission Rate. When the value is equal to 1.0, the time will be reset to\n";
    ss << "\\note zero.\n";

    IddObjectType objType(IddObjectType::ZoneContaminantSourceAndSink_Generic_DepositionRateSink);
    OptionalIddObject oObj = IddObject::load("ZoneContaminantSourceAndSink:Generic:DepositionRateSink",
                                             "Internal Gains",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneContaminantSourceAndSink_Generic_DepositionRateSink);
  return object;
}

IddObject createDaylighting_ControlsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Daylighting:Controls,\n";
    ss << "\\min-fields 19\n";
    ss << "\\memo Dimming of overhead electric lighting is determined from\n";
    ss << "\\memo interior daylight illuminance calculated at one or two reference points.\n";
    ss << "\\memo reference points are given in coordinates specified in the GlobalGeometryRules object\n";
    ss << "\\memo Daylighting Reference Point CoordinateSystem field\n";
    ss << "\\memo Glare from daylighting is also calculated.\n";
    ss << "A1 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1 , \\field Total Daylighting Reference Points\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 2\n";
    ss << "\\default 1\n";
    ss << "N2 , \\field X-Coordinate of First Reference Point\n";
    ss << "\\units m\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Y-Coordinate of First Reference Point\n";
    ss << "\\units m\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Z-Coordinate of First Reference Point\n";
    ss << "\\units m\n";
    ss << "\\default 0.8\n";
    ss << "\\type real\n";
    ss << "N5 , \\field X-Coordinate of Second Reference Point\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\note Required if Total Daylighting Reference Points = 2\n";
    ss << "N6 , \\field Y-Coordinate of Second Reference Point\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\note Required if Total Daylighting Reference Points = 2\n";
    ss << "N7 , \\field Z-Coordinate of Second Reference Point\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\default 0.8\n";
    ss << "N8 , \\field Fraction of Zone Controlled by First Reference Point\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "N9 , \\field Fraction of Zone Controlled by Second Reference Point\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N10, \\field Illuminance Setpoint at First Reference Point\n";
    ss << "\\units lux\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 500\n";
    ss << "N11, \\field Illuminance Setpoint at Second Reference Point\n";
    ss << "\\units lux\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 500\n";
    ss << "N12, \\field Lighting Control Type\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 3\n";
    ss << "\\note 1=continuous,2=stepped,3=continuous/off\n";
    ss << "\\default 1\n";
    ss << "N13, \\field Glare Calculation Azimuth Angle of View Direction Clockwise from Zone y-Axis\n";
    ss << "\\required-field\n";
    ss << "\\units deg\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 360\n";
    ss << "N14, \\field Maximum Allowable Discomfort Glare Index\n";
    ss << "\\type real\n";
    ss << "\\minimum 1\n";
    ss << "\\note The default is for general office work\n";
    ss << "\\default 22\n";
    ss << "N15, \\field Minimum Input Power Fraction for Continuous Dimming Control\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.6\n";
    ss << "\\default 0.3\n";
    ss << "N16, \\field Minimum Light Output Fraction for Continuous Dimming Control\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.6\n";
    ss << "\\default 0.2\n";
    ss << "N17, \\field Number of Stepped Control Steps\n";
    ss << "\\note for Lighting Control Type=2, this field cannot be zero.\n";
    ss << "\\type integer\n";
    ss << "\\default 1\n";
    ss << "N18, \\field Probability Lighting will be Reset When Needed in Manual Stepped Control\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A2 ; \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::Daylighting_Controls);
    OptionalIddObject oObj = IddObject::load("Daylighting:Controls",
                                             "Daylighting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Daylighting_Controls);
  return object;
}

IddObject createDaylighting_DELight_ControlsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Daylighting:DELight:Controls,\n";
    ss << "\\min-fields 8\n";
    ss << "\\memo Dimming of overhead electric lighting is determined from\n";
    ss << "\\memo DElight calculated interior daylight illuminance at one or more reference points.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference DElightZoneNames\n";
    ss << "A2 , \\field Zone Name\n";
    ss << "\\note Name of Thermal Zone hosting the given DElight Zone\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1 , \\field Lighting Control Type\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 3\n";
    ss << "\\note 1=continuous,2=stepped,3=continuous/off\n";
    ss << "\\default 1\n";
    ss << "N2 , \\field Minimum Input Power Fraction for Continuous Dimming Control\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.6\n";
    ss << "\\default 0.3\n";
    ss << "N3 , \\field Minimum Light Output Fraction for Continuous Dimming Control\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.6\n";
    ss << "\\default 0.2\n";
    ss << "N4 , \\field Number of Stepped Control Steps\n";
    ss << "\\type integer\n";
    ss << "\\note for Lighting Control Type=2, this field cannot be zero.\n";
    ss << "\\default 1\n";
    ss << "N5 , \\field Probability Lighting will be Reset When Needed in Manual Stepped Control\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N6;  \\field Gridding Resolution\n";
    ss << "\\units m2\n";
    ss << "\\type real\n";
    ss << "\\note Maximum surface area for nodes in gridding all surfaces in the DElight zone.\n";
    ss << "\\note All reflective and transmitting surfaces will be subdivided\n";
    ss << "\\note into approximately square nodes that do not exceed this maximum.\n";
    ss << "\\note Higher resolution subdivisions require greater calculation times,\n";
    ss << "\\note but generally produce more accurate results.\n";
    ss << "\\minimum> 0.0\n";

    IddObjectType objType(IddObjectType::Daylighting_DELight_Controls);
    OptionalIddObject oObj = IddObject::load("Daylighting:DELight:Controls",
                                             "Daylighting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Daylighting_DELight_Controls);
  return object;
}

IddObject createDaylighting_DELight_ReferencePointIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Daylighting:DELight:ReferencePoint,\n";
    ss << "\\min-fields 7\n";
    ss << "\\memo DElight reference point for illuminance calculation and electric lighting dimming.\n";
    ss << "\\memo reference points are given in coordinates specified in the GlobalGeometryRules object\n";
    ss << "\\memo Daylighting Reference Point CoordinateSystem field\n";
    ss << "\\memo There is a maximum number of 100 reference points per DElight daylighting zone.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field DElight Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DElightZoneNames\n";
    ss << "N1 , \\field X-coordinate of Reference Point\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N2,  \\field Y-coordinate of Reference Point\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N3,  \\field Z-coordinate of Reference Point\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Fraction of Zone Controlled by Reference Point\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "N5;  \\field Illuminance Setpoint at Reference Point\n";
    ss << "\\units lux\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 500\n";

    IddObjectType objType(IddObjectType::Daylighting_DELight_ReferencePoint);
    OptionalIddObject oObj = IddObject::load("Daylighting:DELight:ReferencePoint",
                                             "Daylighting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Daylighting_DELight_ReferencePoint);
  return object;
}

IddObject createDaylighting_DELight_ComplexFenestrationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Daylighting:DELight:ComplexFenestration,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo Used for DElight Complex Fenestration of all types\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\note Only used for user reference\n";
    ss << "\\type alpha\n";
    ss << "A2,  \\field Complex Fenestration Type\n";
    ss << "\\required-field\n";
    ss << "\\note Used to select the appropriate Complex Fenestration BTDF data\n";
    ss << "\\type alpha\n";
    ss << "A3,  \\field Building Surface Name\n";
    ss << "\\required-field\n";
    ss << "\\note This is a reference to a valid surface object (such as BuildingSurface:Detailed) hosting\n";
    ss << "\\note this complex fenestration, analogous to the base surface Name\n";
    ss << "\\note field for subsurfaces such as Windows.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceNames\n";
    ss << "A4,  \\field Window Name\n";
    ss << "\\required-field\n";
    ss << "\\note This is a reference to a valid FenestrationSurface:Detailed window object\n";
    ss << "\\note used to account for the geometry, and the solar and thermal gains/losses,\n";
    ss << "\\note of the Complex Fenestration\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SubSurfNames\n";
    ss << "N1;  \\field Fenestration Rotation\n";
    ss << "\\units deg\n";
    ss << "\\type real\n";
    ss << "\\note In-plane counter-clockwise rotation angle of the Complex Fenestration\n";
    ss << "\\note optical reference direction and the base edge of the Complex Fenestration.\n";
    ss << "\\note The Rotation will typically be zero when the host and CFS surfaces\n";
    ss << "\\note are rectangular and height and width edges are aligned.\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::Daylighting_DELight_ComplexFenestration);
    OptionalIddObject oObj = IddObject::load("Daylighting:DELight:ComplexFenestration",
                                             "Daylighting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Daylighting_DELight_ComplexFenestration);
  return object;
}

IddObject createDaylightingDevice_TubularIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "DaylightingDevice:Tubular,\n";
    ss << "\\memo Defines a tubular daylighting device (TDD) consisting of three components:\n";
    ss << "\\memo a dome, a pipe, and a diffuser. The dome and diffuser are defined separately using the\n";
    ss << "\\memo FenestrationSurface:Detailed object.\n";
    ss << "\\extensible:2 Duplicate the last two fields Transition Zone Name and Transition Zone Length\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Dome Name\n";
    ss << "\\note This must refer to a subsurface object of type TubularDaylightDome\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SubSurfNames\n";
    ss << "A3 , \\field Diffuser Name\n";
    ss << "\\note This must refer to a subsurface object of type TubularDaylightDiffuser\n";
    ss << "\\note Delivery zone is specified in the diffuser object\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SubSurfNames\n";
    ss << "A4 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "N1 , \\field Diameter\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "N2 , \\field Total Length\n";
    ss << "\\note The exterior exposed length is the difference between total and sum of zone lengths\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "N3 , \\field Effective Thermal Resistance\n";
    ss << "\\note R value between TubularDaylightDome and TubularDaylightDiffuser\n";
    ss << "\\units m2-K/W\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.28\n";
    ss << "A5 , \\field Transition Zone 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N4 ; \\field Transition Zone 1 Length\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";

    IddObjectType objType(IddObjectType::DaylightingDevice_Tubular);
    OptionalIddObject oObj = IddObject::load("DaylightingDevice:Tubular",
                                             "Daylighting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::DaylightingDevice_Tubular);
  return object;
}

IddObject createDaylightingDevice_ShelfIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "DaylightingDevice:Shelf,\n";
    ss << "\\memo Defines a daylighting which can have an inside shelf, an outside shelf, or both.\n";
    ss << "\\memo The inside shelf is defined as a building surface and the outside shelf is defined\n";
    ss << "\\memo as a shading surface.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Window Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SubSurfNames\n";
    ss << "A3 , \\field Inside Shelf Name\n";
    ss << "\\note This must refer to a BuildingSurface:Detailed or equivalent object\n";
    ss << "\\note This surface must be its own Surface for other side boundary conditions.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceNames\n";
    ss << "A4 , \\field Outside Shelf Name\n";
    ss << "\\note This must refer to a Shading:Zone:Detailed object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AttachedShadingSurfNames\n";
    ss << "A5 , \\field Outside Shelf Construction Name\n";
    ss << "\\note Required if outside shelf is specified\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "N1 ; \\field View Factor to Outside Shelf\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";

    IddObjectType objType(IddObjectType::DaylightingDevice_Shelf);
    OptionalIddObject oObj = IddObject::load("DaylightingDevice:Shelf",
                                             "Daylighting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::DaylightingDevice_Shelf);
  return object;
}

IddObject createDaylightingDevice_LightWellIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "DaylightingDevice:LightWell,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo Applies only to exterior windows in daylighting-controlled zones or\n";
    ss << "\\memo in zones that share an interior window with a daylighting-controlled  zone.\n";
    ss << "\\memo Generally used with skylights.\n";
    ss << "A1,  \\field Exterior Window Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SubSurfNames\n";
    ss << "N1,  \\field Height of Well\n";
    ss << "\\note Distance from Bottom of Window to Bottom of Well\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "N2,  \\field Perimeter of Bottom of Well\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3,  \\field Area of Bottom of Well\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m2\n";
    ss << "\\minimum> 0.0\n";
    ss << "N4;  \\field Visible Reflectance of Well Walls\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";

    IddObjectType objType(IddObjectType::DaylightingDevice_LightWell);
    OptionalIddObject oObj = IddObject::load("DaylightingDevice:LightWell",
                                             "Daylighting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::DaylightingDevice_LightWell);
  return object;
}

IddObject createOutput_DaylightFactorsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:DaylightFactors,\n";
    ss << "\\memo Reports hourly daylight factors for each exterior window for four sky types\n";
    ss << "\\memo (clear, turbid clear, intermediate, and overcast).\n";
    ss << "\\format singleLine\n";
    ss << "A1;  \\field Reporting Days\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key SizingDays\n";
    ss << "\\key AllShadowCalculationDays\n";

    IddObjectType objType(IddObjectType::Output_DaylightFactors);
    OptionalIddObject oObj = IddObject::load("Output:DaylightFactors",
                                             "Daylighting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_DaylightFactors);
  return object;
}

IddObject createOutput_IlluminanceMapIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:IlluminanceMap,\n";
    ss << "\\min-fields 9\n";
    ss << "\\memo reference points are given in coordinates specified in the GlobalGeometryRules object\n";
    ss << "\\memo Daylighting Reference Point CoordinateSystem field\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1 , \\field Z height\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "N2 , \\field X Minimum Coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "N3 , \\field X Maximum Coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "N4 , \\field Number of X Grid Points\n";
    ss << "\\note Maximum number of total grid points must be <= 2500 (X*Y)\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 2\n";
    ss << "N5 , \\field Y Minimum Coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "N6 , \\field Y Maximum Coordinate\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "N7 ; \\field Number of Y Grid Points\n";
    ss << "\\note Maximum number of total grid points must be <= 2500 (X*Y)\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 2\n";

    IddObjectType objType(IddObjectType::Output_IlluminanceMap);
    OptionalIddObject oObj = IddObject::load("Output:IlluminanceMap",
                                             "Daylighting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_IlluminanceMap);
  return object;
}

IddObject createOutputControl_IlluminanceMap_StyleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OutputControl:IlluminanceMap:Style,\n";
    ss << "\\memo default style for the Daylighting Illuminance Map is comma -- this works well for\n";
    ss << "\\memo importing into spreadsheet programs such as Excel(tm) but not so well for word\n";
    ss << "\\memo processing programs -- there tab may be a better choice.  fixed puts spaces between\n";
    ss << "\\memo the \"columns\"\n";
    ss << "\\unique-object\n";
    ss << "A1; \\field Column Separator\n";
    ss << "\\type choice\n";
    ss << "\\key Comma\n";
    ss << "\\key Tab\n";
    ss << "\\key Fixed\n";
    ss << "\\default Comma\n";

    IddObjectType objType(IddObjectType::OutputControl_IlluminanceMap_Style);
    OptionalIddObject oObj = IddObject::load("OutputControl:IlluminanceMap:Style",
                                             "Daylighting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OutputControl_IlluminanceMap_Style);
  return object;
}

IddObject createZoneInfiltration_DesignFlowRateIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneInfiltration:DesignFlowRate,\n";
    ss << "\\memo  Infiltration is specified as a design level which is modified by a Schedule fraction, temperature difference and wind speed:\n";
    ss << "\\memo  Infiltration=Idesign * FSchedule * (A + B*|(Tzone-Todb)| + C*WindSpd + D * WindSpd**2)\n";
    ss << "\\memo If you use a ZoneList in the Zone or ZoneList name field then this definition applies\n";
    ss << "\\memo to all the zones in the ZoneList.\n";
    ss << "\\min-fields 12\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Zone or ZoneList Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneAndZoneListNames\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Design Flow Rate Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum amount of infiltration\n";
    ss << "\\note for this set of attributes\n";
    ss << "\\note Choices: Flow/Zone => Design Flow Rate -- simply enter Design Flow Rate\n";
    ss << "\\note Flow/Area => Flow per Zone Floor Area - Value * Floor Area (zone) = Design Flow Rate\n";
    ss << "\\note Flow/ExteriorArea => Flow per Exterior Surface Area - Value * Exterior Surface Area (zone) = Design Flow Rate\n";
    ss << "\\note Flow/ExteriorWallArea => Flow per Exterior Surface Area - Value * Exterior Wall Surface Area (zone) = Design Flow Rate\n";
    ss << "\\note AirChanges/Hour => Air Changes per Hour - Value * Floor Volume (zone) adjusted for m3/s = Design Volume Flow Rate\n";
    ss << "\\note  \"Idesign\" in Equation is the result.\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Flow/ExteriorArea\n";
    ss << "\\key Flow/ExteriorWallArea\n";
    ss << "\\key AirChanges/Hour\n";
    ss << "\\default Flow/Zone\n";
    ss << "N1 , \\field Design Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\ip-units ft3/min\n";
    ss << "N2 , \\field Flow per Zone Floor Area\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units m3/s-m2\n";
    ss << "N3 , \\field Flow per Exterior Surface Area\n";
    ss << "\\note use key Flow/ExteriorArea for all exterior surface area\n";
    ss << "\\note use key Flow/ExteriorWallArea to include only exterior wall area\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N4 , \\field Air Changes per Hour\n";
    ss << "\\units 1/hr\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N5 , \\field Constant Term Coefficient\n";
    ss << "\\note  \"A\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\default 1\n";
    ss << "N6 , \\field Temperature Term Coefficient\n";
    ss << "\\note  \"B\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N7 , \\field Velocity Term Coefficient\n";
    ss << "\\note  \"C\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N8 ; \\field Velocity Squared Term Coefficient\n";
    ss << "\\note  \"D\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";

    IddObjectType objType(IddObjectType::ZoneInfiltration_DesignFlowRate);
    OptionalIddObject oObj = IddObject::load("ZoneInfiltration:DesignFlowRate",
                                             "Zone Airflow",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneInfiltration_DesignFlowRate);
  return object;
}

IddObject createZoneInfiltration_EffectiveLeakageAreaIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneInfiltration:EffectiveLeakageArea,\n";
    ss << "\\min-fields 6\n";
    ss << "\\memo  Infiltration is specified as effective leakage area at 4 Pa, schedule fraction, stack and wind coefficients, and\n";
    ss << "\\memo  is a function of temperature difference and wind speed:\n";
    ss << "\\memo  Infiltration=FSchedule * (AL /1000) SQRT(Cs*|(Tzone-Todb)| +  Cw*WindSpd**2 )\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Effective Air Leakage Area\n";
    ss << "\\units cm2\n";
    ss << "\\note \"AL\" in Equation\n";
    ss << "\\note units are cm2 (square centimeters)\n";
    ss << "\\minimum> 0\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N2 , \\field Stack Coefficient\n";
    ss << "\\note \"Cs\" in Equation\n";
    ss << "\\minimum> 0\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N3 ; \\field Wind Coefficient\n";
    ss << "\\note \"Cw\" in Equation\n";
    ss << "\\minimum> 0\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::ZoneInfiltration_EffectiveLeakageArea);
    OptionalIddObject oObj = IddObject::load("ZoneInfiltration:EffectiveLeakageArea",
                                             "Zone Airflow",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneInfiltration_EffectiveLeakageArea);
  return object;
}

IddObject createZoneInfiltration_FlowCoefficientIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneInfiltration:FlowCoefficient,\n";
    ss << "\\min-fields 8\n";
    ss << "\\memo  Infiltration is specified as flow coefficient, schedule fraction, stack and wind coefficients, and\n";
    ss << "\\memo  is a function of temperature difference and wind speed:\n";
    ss << "\\memo  Infiltration=FSchedule * SQRT( (c * Cs*|(Tzone-Todb)|**n)**2 + (c* Cw*(s * WindSpd)**2n)**2 )\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Flow Coefficient\n";
    ss << "\\note \"c\" in Equation\n";
    ss << "\\minimum> 0\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N2 , \\field Stack Coefficient\n";
    ss << "\\note \"Cs\" in Equation\n";
    ss << "\\minimum> 0\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field Pressure Exponent\n";
    ss << "\\note \"n\" in Equation\n";
    ss << "\\minimum> 0\n";
    ss << "\\type real\n";
    ss << "\\default 0.67\n";
    ss << "N4 , \\field Wind Coefficient\n";
    ss << "\\note \"Cw\" in Equation\n";
    ss << "\\minimum> 0\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N5 ; \\field Shelter Factor\n";
    ss << "\\note \"s\" in Equation\n";
    ss << "\\minimum> 0\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::ZoneInfiltration_FlowCoefficient);
    OptionalIddObject oObj = IddObject::load("ZoneInfiltration:FlowCoefficient",
                                             "Zone Airflow",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneInfiltration_FlowCoefficient);
  return object;
}

IddObject createZoneVentilation_DesignFlowRateIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneVentilation:DesignFlowRate,\n";
    ss << "\\memo  Ventilation is specified as a design level which is modified by a schedule fraction, temperature difference and wind speed:\n";
    ss << "\\memo  Ventilation=Vdesign * Fschedule * (A + B*|(Tzone-Todb)| + C*WindSpd + D * WindSpd**2)\n";
    ss << "\\memo If you use a ZoneList in the Zone or ZoneList name field then this definition applies\n";
    ss << "\\memo to all the zones in the ZoneList.\n";
    ss << "\\min-fields 15\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference VentilationNames\n";
    ss << "A2 , \\field Zone or ZoneList Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneAndZoneListNames\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Design Flow Rate Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum amount of ventilation\n";
    ss << "\\note for this set of attributes\n";
    ss << "\\note Choices: Flow/Zone => Design Flow Rate -- simply enter Design Flow Rate\n";
    ss << "\\note Flow/Area => Flow Rate per Zone Floor Area - Value * Floor Area (zone) = Design Flow Rate\n";
    ss << "\\note Flow/Person => Flow Rate per Person - Value * #people = Design Flow Rate\n";
    ss << "\\note AirChanges/Hour => Air Changes per Hour - Value * Floor Volume (zone) adjusted for m3/s = Design Volume Flow Rate\n";
    ss << "\\note  \"Vdesign\" in Equation is the result.\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Flow/Person\n";
    ss << "\\key AirChanges/Hour\n";
    ss << "\\default Flow/Zone\n";
    ss << "N1 , \\field Design Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N2 , \\field Flow Rate per Zone Floor Area\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units m3/s-m2\n";
    ss << "N3 , \\field Flow Rate per Person\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units m3/s-person\n";
    ss << "N4 , \\field Air Changes per Hour\n";
    ss << "\\units 1/hr\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "A5 , \\field Ventilation Type\n";
    ss << "\\type choice\n";
    ss << "\\key Natural\n";
    ss << "\\key Intake\n";
    ss << "\\key Exhaust\n";
    ss << "\\key Balanced\n";
    ss << "\\default Natural\n";
    ss << "N5 , \\field Fan Pressure Rise\n";
    ss << "\\note pressure rise across the fan\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N6 , \\field Fan Total Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1\n";
    ss << "N7 , \\field Constant Term Coefficient\n";
    ss << "\\note  \"A\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\default 1\n";
    ss << "N8 , \\field Temperature Term Coefficient\n";
    ss << "\\note  \"B\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N9 , \\field Velocity Term Coefficient\n";
    ss << "\\note  \"C\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N10, \\field Velocity Squared Term Coefficient\n";
    ss << "\\note  \"D\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N11, \\field Minimum Indoor Temperature\n";
    ss << "\\note this is the indoor temperature below which ventilation is shutoff\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\default -100\n";
    ss << "A6 , \\field Minimum Indoor Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the indoor temperature versus time below which\n";
    ss << "\\note ventilation is shutoff.\n";
    ss << "N12, \\field Maximum Indoor Temperature\n";
    ss << "\\note this is the indoor temperature above which ventilation is shutoff\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\default 100\n";
    ss << "A7 , \\field Maximum Indoor Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the indoor temperature versus time above which\n";
    ss << "\\note ventilation is shutoff.\n";
    ss << "N13, \\field Delta Temperature\n";
    ss << "\\note This is the temperature differential between indoor and outdoor below which ventilation is shutoff.\n";
    ss << "\\note If ((IndoorTemp - OutdoorTemp) < DeltaTemperature) then ventilation is not allowed.\n";
    ss << "\\note For example, if delta temperature is 2C, ventilation is assumed to be available if the outside air temperature\n";
    ss << "\\note is at least 2C cooler than the zone air temperature. The values for this field can include negative numbers.\n";
    ss << "\\note This allows ventilation to occur even if the outdoor temperature is above the indoor temperature.\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\default -100\n";
    ss << "A8 , \\field Delta Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the temperature differential between indoor and outdoor\n";
    ss << "\\note versus time below which ventilation is shutoff.\n";
    ss << "N14, \\field Minimum Outdoor Temperature\n";
    ss << "\\note this is the outdoor temperature below which ventilation is shutoff\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\default -100\n";
    ss << "A9 , \\field Minimum Outdoor Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the outdoor temperature versus time below which\n";
    ss << "\\note ventilation is shutoff.\n";
    ss << "N15, \\field Maximum Outdoor Temperature\n";
    ss << "\\note this is the outdoor temperature above which ventilation is shutoff\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\default 100\n";
    ss << "A10, \\field Maximum Outdoor Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the outdoor temperature versus time above which\n";
    ss << "\\note ventilation is shutoff.\n";
    ss << "N16; \\field Maximum Wind Speed\n";
    ss << "\\note this is the outdoor wind speed above which ventilation is shutoff\n";
    ss << "\\units m/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 40\n";
    ss << "\\default 40\n";

    IddObjectType objType(IddObjectType::ZoneVentilation_DesignFlowRate);
    OptionalIddObject oObj = IddObject::load("ZoneVentilation:DesignFlowRate",
                                             "Zone Airflow",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneVentilation_DesignFlowRate);
  return object;
}

IddObject createZoneVentilation_WindandStackOpenAreaIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneVentilation:WindandStackOpenArea,\n";
    ss << "\\min-fields 8\n";
    ss << "\\memo This object is specified as natural ventilation driven by wind and stack effect only:\n";
    ss << "\\memo Ventilation Wind = Cw * Opening Area * Schedule * WindSpd\n";
    ss << "\\memo Ventilation Stack = Cd * Opening Area * Schedule * SQRT(2*g*DH*(|(Tzone-Todb)|/Tzone))\n";
    ss << "\\memo Total Ventilation = SQRT((Ventilation Wind)^2 + (Ventilation Stack)^2)\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference VentilationNames\n";
    ss << "A2 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1 , \\field Opening Area\n";
    ss << "\\note This is the opening area used to calculate stack effect and wind driven ventilation.\n";
    ss << "\\units m2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "A3 , \\field Opening Area Fraction Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the fraction values applied to the opening area given in the previous\n";
    ss << "\\note input field (0.0 - 1.0).\n";
    ss << "N2 , \\field Opening Effectiveness\n";
    ss << "\\note This field is used to calculate wind driven ventilation.\n";
    ss << "\\note  \"Cw\" in the wind-driven equation and the maximum value is 1.0.\n";
    ss << "\\note When the input is Autocalculate, the program calculates Cw based on an angle between\n";
    ss << "\\note wind direction and effective angle\n";
    ss << "\\note Cw = 0.55 at angle = 0, and Cw = 0.3 at angle=180\n";
    ss << "\\note Linear interpolation is used to calculate Cw based on the above two values.\n";
    ss << "\\units dimensionless\n";
    ss << "\\autocalculatable\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default Autocalculate\n";
    ss << "N3 , \\field Effective Angle\n";
    ss << "\\note This field is defined as normal angle of the opening area and is used when input\n";
    ss << "\\note field Opening Effectiveness = Autocalculate.\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum< 360.0\n";
    ss << "\\default 0\n";
    ss << "N4 , \\field Height Difference\n";
    ss << "\\note This is the height difference between the midpoint of an opening and\n";
    ss << "\\note the neutral pressure level.\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note  \"DH\" in the stack equation.\n";
    ss << "N5 , \\field Discharge Coefficient for Opening\n";
    ss << "\\note This is the discharge coefficient used to calculate stack effect.\n";
    ss << "\\note  \"Cd\" in the stack equation and the maximum value is 1.0.\n";
    ss << "\\note When the input is Autocalculate, the following equation is used to calculate the\n";
    ss << "\\note coefficient:\n";
    ss << "\\note Cd = 0.4 + 0.0045*|(Tzone-Todb)|\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default Autocalculate\n";
    ss << "N6 , \\field Minimum Indoor Temperature\n";
    ss << "\\note This is the indoor temperature below which ventilation is shutoff.\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\default -100\n";
    ss << "A4 , \\field Minimum Indoor Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the indoor temperature versus time below which\n";
    ss << "\\note ventilation is shutoff.\n";
    ss << "N7 , \\field Maximum Indoor Temperature\n";
    ss << "\\note This is the indoor temperature above which ventilation is shutoff.\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\default 100\n";
    ss << "A5 , \\field Maximum Indoor Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the indoor temperature versus time above which\n";
    ss << "\\note ventilation is shutoff.\n";
    ss << "N8 , \\field Delta Temperature\n";
    ss << "\\note This is the temperature differential between indoor and outdoor below\n";
    ss << "\\note which ventilation is shutoff.\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\default -100\n";
    ss << "A6 , \\field Delta Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the temperature differential between indoor and outdoor\n";
    ss << "\\note versus time below which ventilation is shutoff.\n";
    ss << "N9 , \\field Minimum Outdoor Temperature\n";
    ss << "\\note This is the outdoor temperature below which ventilation is shutoff.\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\default -100\n";
    ss << "A7 , \\field Minimum Outdoor Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the outdoor temperature versus time below which\n";
    ss << "\\note ventilation is shutoff.\n";
    ss << "N10, \\field Maximum Outdoor Temperature\n";
    ss << "\\note This is the outdoor temperature above which ventilation is shutoff.\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\default 100\n";
    ss << "A8 , \\field Maximum Outdoor Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the outdoor temperature versus time above which\n";
    ss << "\\note ventilation is shutoff.\n";
    ss << "N11; \\field Maximum Wind Speed\n";
    ss << "\\note This is the outdoor wind speed above which ventilation is shutoff.\n";
    ss << "\\units m/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 40\n";
    ss << "\\default 40\n";

    IddObjectType objType(IddObjectType::ZoneVentilation_WindandStackOpenArea);
    OptionalIddObject oObj = IddObject::load("ZoneVentilation:WindandStackOpenArea",
                                             "Zone Airflow",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneVentilation_WindandStackOpenArea);
  return object;
}

IddObject createZoneAirBalance_OutdoorAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneAirBalance:OutdoorAir,\n";
    ss << "\\memo Provide a combined zone outdoor air flow by including interactions between\n";
    ss << "\\memo mechanical ventilation, infiltration and duct leakage.\n";
    ss << "\\memo This object will combine outdoor flows from all ZoneInfiltration and\n";
    ss << "\\memo ZoneVentilation objects in the same zone. Balanced flows will be summed, while\n";
    ss << "\\memo unbalanced flows will be added in quadrature.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A3 , \\field Air Balance Method\n";
    ss << "\\type choice\n";
    ss << "\\key Quadrature\n";
    ss << "\\key None\n";
    ss << "\\default Quadrature\n";
    ss << "\\note None: Only perform simple calculations without using a combined zone outdoor air.\n";
    ss << "\\note Quadrature: A combined outdoor air is used in the quadrature sum.\n";
    ss << "N1 , \\field Induced Outdoor Air Due to Unbalanced Duct Leakage\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "A4 ; \\field Induced Outdoor Air Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the fraction values applied to the Induced Outdoor Air given in the\n";
    ss << "\\note previous input field (0.0 - 1.0).\n";

    IddObjectType objType(IddObjectType::ZoneAirBalance_OutdoorAir);
    OptionalIddObject oObj = IddObject::load("ZoneAirBalance:OutdoorAir",
                                             "Zone Airflow",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneAirBalance_OutdoorAir);
  return object;
}

IddObject createZoneMixingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneMixing,\n";
    ss << "\\memo ZoneMixing is a simple air exchange from one zone to another. Note that this statement\n";
    ss << "\\memo only affects the energy balance of the \"receiving\" zone and will not produce\n";
    ss << "\\memo any effect on the \"source\" zone. Mixing statements can be complementary and include\n";
    ss << "\\memo multiple zones, but the balancing of flows between zones is left to the user's\n";
    ss << "\\memo discretion.\n";
    ss << "\\min-fields 9\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Design Flow Rate Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum amount of ventilation\n";
    ss << "\\note for this set of attributes\n";
    ss << "\\note Choices: Flow/Zone => Design Flow Rate -- simply enter Design Flow Rate\n";
    ss << "\\note Flow/Area => Flow Rate per Zone Floor Area - Value * Floor Area (zone) = Design Flow Rate\n";
    ss << "\\note Flow/Person => Flow Rate per Person - Value * #people = Design Flow Rate\n";
    ss << "\\note AirChanges/Hour => Air Changes per Hour - Value * Floor Volume (zone) adjusted for m3/s = Design Volume Flow Rate\n";
    ss << "\\note  \"Vdesign\" in Equation is the result.\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Flow/Person\n";
    ss << "\\key AirChanges/Hour\n";
    ss << "\\default Flow/Zone\n";
    ss << "N1 , \\field Design Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N2 , \\field Flow Rate per Zone Floor Area\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units m3/s-m2\n";
    ss << "N3 , \\field Flow Rate per Person\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units m3/s-person\n";
    ss << "N4 , \\field Air Changes per Hour\n";
    ss << "\\units 1/hr\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "A5 , \\field Source Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N5 , \\field Delta Temperature\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "\\note This field contains the constant temperature differential between source and\n";
    ss << "\\note receiving zones below which mixing is shutoff.\n";
    ss << "A6 , \\field Delta Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the temperature differential between source and receiving\n";
    ss << "\\note zones versus time below which mixing is shutoff.\n";
    ss << "A7 , \\field Minimum Zone Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the zone dry-bulb temperature versus time below which\n";
    ss << "\\note mixing is shutoff.\n";
    ss << "A8 , \\field Maximum Zone Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the zone dry-bulb temperature versus time above which\n";
    ss << "\\note mixing is shutoff.\n";
    ss << "A9 , \\field Minimum Source Zone Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the source zone dry-bulb temperature versus time below\n";
    ss << "\\note which mixing is shutoff.\n";
    ss << "A10, \\field Maximum Source Zone Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the source zone dry-bulb temperature versus time above\n";
    ss << "\\note which mixing is shutoff.\n";
    ss << "A11, \\field Minimum Outdoor Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the outdoor temperature versus time below which\n";
    ss << "\\note mixing is shutoff.\n";
    ss << "A12; \\field Maximum Outdoor Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the outdoor temperature versus time above which\n";
    ss << "\\note mixing is shutoff.\n";

    IddObjectType objType(IddObjectType::ZoneMixing);
    OptionalIddObject oObj = IddObject::load("ZoneMixing",
                                             "Zone Airflow",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneMixing);
  return object;
}

IddObject createZoneCrossMixingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneCrossMixing,\n";
    ss << "\\memo ZoneCrossMixing exchanges an equal amount of air between two zones. Note that this\n";
    ss << "\\memo statement affects the energy balance of both zones.\n";
    ss << "\\min-fields 9\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Design Flow Rate Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum amount of ventilation\n";
    ss << "\\note for this set of attributes\n";
    ss << "\\note Choices: Flow/Zone => Design Flow Rate -- simply enter Design Flow Rate\n";
    ss << "\\note Flow/Area => Flow Rate per Zone Floor Area - Value * Floor Area (zone) = Design Flow Rate\n";
    ss << "\\note Flow/Person => Flow Rate per Person - Value * #people = Design Flow Rate\n";
    ss << "\\note AirChanges/Hour => Air Changes per Hour - Value * Floor Volume (zone) adjusted for m3/s = Design Volume Flow Rate\n";
    ss << "\\note  \"Vdesign\" in Equation is the result.\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key Flow/Person\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key AirChanges/Hour\n";
    ss << "\\default Flow/Zone\n";
    ss << "N1 , \\field Design Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N2 , \\field Flow Rate per Zone Floor Area\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units m3/s-m2\n";
    ss << "N3 , \\field Flow Rate per Person\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units m3/s-person\n";
    ss << "N4 , \\field Air Changes per Hour\n";
    ss << "\\units 1/hr\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "A5 , \\field Source Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N5 , \\field Delta Temperature\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "\\note This field contains the constant temperature differential between source and\n";
    ss << "\\note receiving zones below which cross mixing is shutoff. This value must be greater\n";
    ss << "\\note than or equal to zero.\n";
    ss << "A6 , \\field Delta Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the temperature differential between source and receiving\n";
    ss << "\\note zones versus time below which cross mixing is shutoff.\n";
    ss << "A7 , \\field Minimum Zone Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the indoor temperature versus time below which\n";
    ss << "\\note cross mixing is shutoff.\n";
    ss << "A8 , \\field Maximum Zone Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the indoor temperature versus time above which\n";
    ss << "\\note cross mixing is shutoff.\n";
    ss << "A9 , \\field Minimum Source Zone Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the source zone dry-bulb temperature versus time below\n";
    ss << "\\note which cross mixing is shutoff.\n";
    ss << "A10, \\field Maximum Source Zone Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the source zone dry-bulb temperature versus time above\n";
    ss << "\\note which cross mixing is shutoff.\n";
    ss << "A11, \\field Minimum Outdoor Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the outdoor temperature versus time below which\n";
    ss << "\\note cross mixing is shutoff.\n";
    ss << "A12; \\field Maximum Outdoor Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the outdoor temperature versus time above which\n";
    ss << "\\note cross mixing is shutoff.\n";

    IddObjectType objType(IddObjectType::ZoneCrossMixing);
    OptionalIddObject oObj = IddObject::load("ZoneCrossMixing",
                                             "Zone Airflow",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneCrossMixing);
  return object;
}

IddObject createZoneRefrigerationDoorMixingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneRefrigerationDoorMixing,\n";
    ss << "\\min-fields 4\n";
    ss << "\\memo Refrigeration Door Mixing is used for an opening between two zones that are at the\n";
    ss << "\\memo   same elevation but have different air temperatures.  In this case, the mixing air flow\n";
    ss << "\\memo   between the two zones is determined by the density difference between the two zones.\n";
    ss << "\\memo   This would typically be used between two zones in a refrigerated warehouse that are\n";
    ss << "\\memo   controlled at different temperatures.  It could also be used to model a door to a walk-in\n";
    ss << "\\memo   refrigerated space if that space were modeled as a zone instead of using the object Refrigeration:WalkIn.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Zone 1 Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A3 , \\field Zone 2 Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A4 , \\field Schedule Name\n";
    ss << "\\note This schedule defines the fraction of the time the refrigeration door is open\n";
    ss << "\\note  For example, if the warehouse is closed at night and there are no door openings\n";
    ss << "\\note   between two zones, the value for that time period would be 0.\n";
    ss << "\\note   If doors were propped open, the value  over that time period would be 1.0\n";
    ss << "\\note   If the doors were open about 20% of the time, the value over that period would be 0.2\n";
    ss << "\\note   Schedule values must lie between 0 and 1.0\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Door Height\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 50.\n";
    ss << "\\default 3.0\n";
    ss << "N2 , \\field Door Area\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 400.\n";
    ss << "\\default 9.\n";
    ss << "\\units m2\n";
    ss << "A5;  \\field Door Protection Type\n";
    ss << "\\note Door protection can reduce the air flow through a refrigeration door\n";
    ss << "\\note The default value is \"None\"\n";
    ss << "\\note Choices: \"None\", \"AirCurtain\", and \"StripCurtain\"\n";
    ss << "\\note A strip curtain reduces the air flow more than an air curtain\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key AirCurtain\n";
    ss << "\\key StripCurtain\n";
    ss << "\\default None\n";

    IddObjectType objType(IddObjectType::ZoneRefrigerationDoorMixing);
    OptionalIddObject oObj = IddObject::load("ZoneRefrigerationDoorMixing",
                                             "Zone Airflow",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneRefrigerationDoorMixing);
  return object;
}

IddObject createZoneEarthtubeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneEarthtube,\n";
    ss << "\\min-fields 22\n";
    ss << "\\memo  Earth Tube is specified as a design level which is modified by a Schedule fraction, temperature difference and wind speed:\n";
    ss << "\\memo  Earthtube=Edesign * Fschedule * (A + B*|(Tzone-Todb)| + C*WindSpd + D * WindSpd**2)\n";
    ss << "A1, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A2, \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Design Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\note  \"Edesign\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N2, \\field Minimum Zone Temperature when Cooling\n";
    ss << "\\required-field\n";
    ss << "\\note this is the indoor temperature below which the earth tube is shut off\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "N3, \\field Maximum Zone Temperature when Heating\n";
    ss << "\\required-field\n";
    ss << "\\note this is the indoor temperature above which the earth tube is shut off\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "N4, \\field Delta Temperature\n";
    ss << "\\required-field\n";
    ss << "\\note This is the temperature difference between indoor and outdoor below which the earth tube is shut off\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "A3, \\field Earthtube Type\n";
    ss << "\\type choice\n";
    ss << "\\key Natural\n";
    ss << "\\key Intake\n";
    ss << "\\key Exhaust\n";
    ss << "\\default Natural\n";
    ss << "N5, \\field Fan Pressure Rise\n";
    ss << "\\note pressure rise across the fan\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N6, \\field Fan Total Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1\n";
    ss << "N7, \\field Pipe Radius\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1\n";
    ss << "N8, \\field Pipe Thickness\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.2\n";
    ss << "N9, \\field Pipe Length\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 15\n";
    ss << "N10, \\field Pipe Thermal Conductivity\n";
    ss << "\\units W/m-K\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 200\n";
    ss << "N11, \\field Pipe Depth Under Ground Surface\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 3\n";
    ss << "A4, \\field Soil Condition\n";
    ss << "\\type choice\n";
    ss << "\\key HeavyAndSaturated\n";
    ss << "\\key HeavyAndDamp\n";
    ss << "\\key HeavyAndDry\n";
    ss << "\\key LightAndDry\n";
    ss << "\\default HeavyAndDamp\n";
    ss << "N12, \\field Average Soil Surface Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N13, \\field Amplitude of Soil Surface Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N14, \\field Phase Constant of Soil Surface Temperature\n";
    ss << "\\units days\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N15, \\field Constant Term Flow Coefficient\n";
    ss << "\\note  \"A\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\default 1\n";
    ss << "N16, \\field Temperature Term Flow Coefficient\n";
    ss << "\\note  \"B\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N17, \\field Velocity Term Flow Coefficient\n";
    ss << "\\note  \"C\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N18; \\field Velocity Squared Term Flow Coefficient\n";
    ss << "\\note  \"D\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";

    IddObjectType objType(IddObjectType::ZoneEarthtube);
    OptionalIddObject oObj = IddObject::load("ZoneEarthtube",
                                             "Zone Airflow",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneEarthtube);
  return object;
}

IddObject createZoneCoolTower_ShowerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneCoolTower:Shower,\n";
    ss << "\\memo A cooltower (sometimes referred to as a wind tower or a shower cooling tower)\n";
    ss << "\\memo models passive downdraught evaporative cooling (PDEC) that is designed to capture the\n";
    ss << "\\memo wind at the top of a tower and cool the outdoor air using water evaporation before\n";
    ss << "\\memo delivering it to a space.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A4, \\field Water Supply Storage Tank Name\n";
    ss << "\\note In case of stand alone tank or underground water, leave this input blank\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A5, \\field Flow Control Type\n";
    ss << "\\note Water flow schedule should be selected when the water flow rate is known.\n";
    ss << "\\note Wind-driven flow should be selected when the water flow rate is unknown.\n";
    ss << "\\type choice\n";
    ss << "\\key WaterFlowSchedule\n";
    ss << "\\key WindDrivenFlow\n";
    ss << "\\default WindDrivenFlow\n";
    ss << "A6, \\field Pump Flow Rate Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Maximum Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\type real\n";
    ss << "N2, \\field Effective Tower Height\n";
    ss << "\\note This field is from either the spray or the wet pad to the top of the outlet.\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "N3, \\field Airflow Outlet Area\n";
    ss << "\\note User have to specify effective area when outlet area is relatively bigger than the cross sectional area\n";
    ss << "\\note of cooltower. If the number of outlet is more than one, assume the air passes through only one.\n";
    ss << "\\required-field\n";
    ss << "\\units m2\n";
    ss << "\\type real\n";
    ss << "N4, \\field Maximum Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N5, \\field Minimum Indoor Temperature\n";
    ss << "\\required-field\n";
    ss << "\\note This field is to specify the indoor temperature below which cooltower is shutoff.\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "N6, \\field Fraction of Water Loss\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "N7, \\field Fraction of Flow Schedule\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "N8; \\field Rated Power Consumption\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::ZoneCoolTower_Shower);
    OptionalIddObject oObj = IddObject::load("ZoneCoolTower:Shower",
                                             "Zone Airflow",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneCoolTower_Shower);
  return object;
}

IddObject createZoneThermalChimneyIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneThermalChimney,\n";
    ss << "\\memo A thermal chimney is a vertical shaft utilizing solar radiation to enhance natural\n";
    ss << "\\memo ventilation. It consists of an absorber wall, air gap and glass cover with high solar\n";
    ss << "\\memo transmissivity.\n";
    ss << "\\min-fields 10\n";
    ss << "\\extensible:4\n";
    ss << "\\max-fields 86\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Zone Name\n";
    ss << "\\note Name of zone that is the thermal chimney\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Width of the Absorber Wall\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N2, \\field Cross Sectional Area of Air Channel Outlet\n";
    ss << "\\required-field\n";
    ss << "\\units m2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N3, \\field Discharge Coefficient\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.8\n";
    ss << "A4, \\field Zone 1 Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\begin-extensible\n";
    ss << "N4, \\field Distance from Top of Thermal Chimney to Inlet 1\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N5, \\field Relative Ratios of Air Flow Rates Passing through Zone 1\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 1.0\n";
    ss << "N6; \\field Cross Sectional Areas of Air Channel Inlet 1\n";
    ss << "\\required-field\n";
    ss << "\\units m2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";

    IddObjectType objType(IddObjectType::ZoneThermalChimney);
    OptionalIddObject oObj = IddObject::load("ZoneThermalChimney",
                                             "Zone Airflow",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneThermalChimney);
  return object;
}

IddObject createAirflowNetwork_SimulationControlIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:SimulationControl,\n";
    ss << "\\min-fields 13\n";
    ss << "\\unique-object\n";
    ss << "\\memo This object defines the global parameters used in an Airflow Network simulation.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\note Enter a unique name for this object.\n";
    ss << "A2 , \\field AirflowNetwork Control\n";
    ss << "\\type choice\n";
    ss << "\\key MultizoneWithDistribution\n";
    ss << "\\key MultizoneWithoutDistribution\n";
    ss << "\\key MultizoneWithDistributionOnlyDuringFanOperation\n";
    ss << "\\key NoMultizoneOrDistribution\n";
    ss << "\\default NoMultizoneOrDistribution\n";
    ss << "\\note NoMultizoneOrDistribution: Only perform Simple calculations (objects ZoneInfiltration:*,\n";
    ss << "\\note ZoneVentilation:*, ZoneMixing, ZoneCrossMixing, ZoneRefrigerationDoorMixing,\n";
    ss << "\\note ZoneAirBalance:OutdoorAir, ZoneEarthtube, ZoneThermalChimney, and ZoneCoolTower:Shower);\n";
    ss << "\\note MultizoneWithoutDistribution: Use AirflowNetwork objects to simulate multizone\n";
    ss << "\\note Airflows driven by wind during simulation time,\n";
    ss << "\\note and objects of ZoneInfiltration:*, ZoneVentilation:*, ZoneMixing, ZoneCrossMixing\n";
    ss << "\\note ZoneRefrigerationDoorMixing, ZoneAirBalance:OutdoorAir, ZoneEarthtube,\n";
    ss << "\\note ZoneThermalChimney, and ZoneCoolTower:Shower are ignored;\n";
    ss << "\\note MultizoneWithDistributionOnlyDuringFanOperation: Perform distribution system\n";
    ss << "\\note calculations during system fan on time\n";
    ss << "\\note and Simple calculations during system Fan off time;\n";
    ss << "\\note MultizoneWithDistribution: Perform distribution system calculations during system\n";
    ss << "\\note fan on time and multizone Airflow driven by wind during system fan off time.\n";
    ss << "A3 , \\field Wind Pressure Coefficient Type\n";
    ss << "\\type choice\n";
    ss << "\\key Input\n";
    ss << "\\key SurfaceAverageCalculation\n";
    ss << "\\default SurfaceAverageCalculation\n";
    ss << "\\note Input: User must enter AirflowNetwork:MultiZone:WindPressureCoefficientArray,\n";
    ss << "\\note AirflowNetwork:MultiZone:ExternalNode, and\n";
    ss << "\\note AirflowNetwork:MultiZone:WindPressureCoefficientValues objects.\n";
    ss << "\\note SurfaceAverageCalculation: used only for rectangular buildings.\n";
    ss << "\\note If SurfaceAverageCalculation is selected,\n";
    ss << "\\note AirflowNetwork:MultiZone:WindPressureCoefficientArray, AirflowNetwork:MultiZone:ExternalNode,\n";
    ss << "\\note and AirflowNetwork:MultiZone:WindPressureCoefficientValues objects are not used.\n";
    ss << "A4 , \\field AirflowNetwork Wind Pressure Coefficient Array Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WPCSetNames\n";
    ss << "\\note Used only if Wind Pressure Coefficient Type = Input, otherwise this field may be left blank.\n";
    ss << "A5 , \\field Height Selection for Local Wind Pressure Calculation\n";
    ss << "\\type choice\n";
    ss << "\\key ExternalNode\n";
    ss << "\\key OpeningHeight\n";
    ss << "\\default OpeningHeight\n";
    ss << "\\note If ExternalNode is selected, the height given in the\n";
    ss << "\\note AirflowNetwork:MultiZone:ExternalNode object will be used.\n";
    ss << "\\note If OpeningHeight is selected, the surface opening height (centroid) will be used to\n";
    ss << "\\note calculate local wind pressure\n";
    ss << "\\note This field is ignored when the choice of the Wind Pressure Coefficient Type field is\n";
    ss << "\\note SurfaceAverageCalculation.\n";
    ss << "A6 , \\field Building Type\n";
    ss << "\\note Used only if Wind Pressure Coefficient Type = SurfaceAverageCalculation,\n";
    ss << "\\note otherwise this field may be left blank.\n";
    ss << "\\type choice\n";
    ss << "\\key LowRise\n";
    ss << "\\key HighRise\n";
    ss << "\\default LowRise\n";
    ss << "N1 , \\field Maximum Number of Iterations\n";
    ss << "\\type integer\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 500\n";
    ss << "\\minimum> 10\n";
    ss << "\\maximum 30000\n";
    ss << "\\note Determines the maximum number of iterations used to converge on a solution. If this limit\n";
    ss << "\\note is exceeded, the program terminates.\n";
    ss << "A7 , \\field Initialization Type\n";
    ss << "\\type choice\n";
    ss << "\\key LinearInitializationMethod\n";
    ss << "\\key ZeroNodePressures\n";
    ss << "\\default ZeroNodePressures\n";
    ss << "N2 , \\field Relative Airflow Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 1.E-4\n";
    ss << "\\minimum> 0\n";
    ss << "\\note This tolerance is defined as the absolute value of the sum of the mass Flow Rates\n";
    ss << "\\note divided by the sum of the absolute value of the mass Flow Rates. The mass Flow Rates\n";
    ss << "\\note described here refer to the mass Flow Rates at all Nodes in the AirflowNetwork model.\n";
    ss << "\\note The solution converges when both this tolerance and the tolerance in the next field\n";
    ss << "\\note (Absolute Airflow Convergence Tolerance) are satisfied.\n";
    ss << "N3 , \\field Absolute Airflow Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\units kg/s\n";
    ss << "\\default 1.E-6\n";
    ss << "\\minimum> 0\n";
    ss << "\\note This tolerance is defined as the absolute value of the sum of the mass flow rates. The mass\n";
    ss << "\\note flow rates described here refer to the mass flow rates at all nodes in the AirflowNetwork\n";
    ss << "\\note model. The solution converges when both this tolerance and the tolerance in the previous\n";
    ss << "\\note field (Relative Airflow Convergence Tolerance) are satisfied.\n";
    ss << "N4 , \\field Convergence Acceleration Limit\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Used only for AirflowNetwork:SimulationControl\n";
    ss << "\\minimum -1\n";
    ss << "\\maximum 1\n";
    ss << "\\default -0.5\n";
    ss << "N5 , \\field Azimuth Angle of Long Axis of Building\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 180.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Degrees clockwise from true North.\n";
    ss << "\\note Used only if Wind Pressure Coefficient Type = SurfaceAverageCalculation.\n";
    ss << "N6 , \\field Ratio of Building Width Along Short Axis to Width Along Long Axis\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Used only if Wind Pressure Coefficient Type = SurfaceAverageCalculation.\n";
    ss << "A8 ; \\field Height Dependence of External Node Temperature\n";
    ss << "\\note If Yes, external node temperature is height dependent.\n";
    ss << "\\note If No, external node temperature is based on zero height.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_SimulationControl);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:SimulationControl",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_SimulationControl);
  return object;
}

IddObject createAirflowNetwork_MultiZone_ZoneIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:MultiZone:Zone,\n";
    ss << "\\min-fields 8\n";
    ss << "\\memo This object is used to simultaneously control a thermal zone's window and door openings,\n";
    ss << "\\memo both exterior and interior.\n";
    ss << "A1, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\reference AirFlowNetworkMultizoneZones\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note Enter the zone name where ventilation control is required.\n";
    ss << "A2, \\field Ventilation Control Mode\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\key Enthalpy\n";
    ss << "\\key Constant\n";
    ss << "\\key ASHRAE55Adaptive\n";
    ss << "\\key CEN15251Adaptive\n";
    ss << "\\key NoVent\n";
    ss << "\\default NoVent\n";
    ss << "\\note When Ventilation Control Mode = Temperature or Enthalpy, the following\n";
    ss << "\\note fields are used to modulate the Ventilation Open Factor for all\n";
    ss << "\\note window and door openings in the zone according to the zone's\n";
    ss << "\\note indoor-outdoor temperature or enthalpy difference.\n";
    ss << "\\note Constant: controlled by field Venting Schedule Name.\n";
    ss << "\\note NoVent: control will not open window or door during simulation (Ventilation Open Factor = 0).\n";
    ss << "A3, \\field Ventilation Control Zone Temperature Setpoint Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Used only if Ventilation Control Mode = Temperature or Enthalpy.\n";
    ss << "N1, \\field Minimum Venting Open Factor\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Used only if Ventilation Control Mode = Temperature or Enthalpy.\n";
    ss << "N2, \\field Indoor and Outdoor Temperature Difference Lower Limit For Maximum Venting Open Factor\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum< 100.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Applicable only if Ventilation Control Mode = Temperature.\n";
    ss << "\\note This value must be less than the corresponding upper value (next field).\n";
    ss << "N3, \\field Indoor and Outdoor Temperature Difference Upper Limit for Minimum Venting Open Factor\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 100.0\n";
    ss << "\\note Applicable only if Ventilation Control Mode = Temperature.\n";
    ss << "\\note This value must be greater than the corresponding lower value (previous field).\n";
    ss << "N4, \\field Indoor and Outdoor Enthalpy Difference Lower Limit For Maximum Venting Open Factor\n";
    ss << "\\type real\n";
    ss << "\\units deltaJ/kg\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum< 300000.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Applicable only if Ventilation Control Mode = Enthalpy.\n";
    ss << "\\note This value must be less than the corresponding upper value (next field).\n";
    ss << "N5, \\field Indoor and Outdoor Enthalpy Difference Upper Limit for Minimum Venting Open Factor\n";
    ss << "\\type real\n";
    ss << "\\units deltaJ/kg\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 300000.0\n";
    ss << "\\note Applicable only if Ventilation Control Mode = Enthalpy.\n";
    ss << "\\note This value must be greater than the corresponding lower value (previous field).\n";
    ss << "A4, \\field Venting Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Non-zero Schedule value means venting is allowed if other venting control conditions are\n";
    ss << "\\note satisfied. A zero (or negative) Schedule value means venting is not allowed under any\n";
    ss << "\\note The Schedule values should be greater than or equal to 0 and less than or equal to 1.\n";
    ss << "\\note circumstances. If this Schedule is not specified then venting is allowed if\n";
    ss << "\\note other venting control conditions are satisfied.\n";
    ss << "\\note Not used if Ventilation Control Mode = NoVent.\n";
    ss << "A5, \\field Single Sided Wind Pressure Coefficient Algorithm\n";
    ss << "\\type choice\n";
    ss << "\\key Advanced\n";
    ss << "\\key Standard\n";
    ss << "\\default Standard\n";
    ss << "\\note Selecting Advanced results in EnergyPlus calculating modified Wind Pressure Coefficients\n";
    ss << "\\note to account for wind direction and turbulence effects on single sided ventilation rates.\n";
    ss << "\\note Model is only valid for zones with 2 openings, both of which are on a single facade.\n";
    ss << "N6, \\field Facade Width\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 10.0\n";
    ss << "\\note This is the whole building width along the direction of the facade of this zone.\n";
    ss << "A6; \\field Occupant Ventilation Control Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirflowNetworkOccupantVentilationControlNames\n";
    ss << "\\note Enter the name where Occupancy Ventilation Control is required.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_MultiZone_Zone);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:MultiZone:Zone",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_MultiZone_Zone);
  return object;
}

IddObject createAirflowNetwork_MultiZone_SurfaceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:MultiZone:Surface,\n";
    ss << "\\min-fields 4\n";
    ss << "\\memo This object specifies the properties of a surface linkage through which air flows.\n";
    ss << "\\memo Airflow Report: Node 1 as an inside face zone;\n";
    ss << "\\memo Node 2 as an outside face zone or external node.\n";
    ss << "A1, \\field Surface Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfAndSubSurfNames\n";
    ss << "\\note Enter the name of a heat transfer surface.\n";
    ss << "A2, \\field Leakage Component Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceAirflowLeakageNames\n";
    ss << "\\note Enter the name of an Airflow Network leakage component. A leakage component is\n";
    ss << "\\note one of the following AirflowNetwork:Multizone objects:\n";
    ss << "\\note AirflowNetwork:MultiZone:Component:DetailedOpening,\n";
    ss << "\\note AirflowNetwork:MultiZone:Component:SimpleOpening,\n";
    ss << "\\note AirflowNetwork:MultiZone:Surface:Crack,\n";
    ss << "\\note AirflowNetwork:MultiZone:Surface:EffectiveLeakageArea,\n";
    ss << "\\note AirflowNetwork:MultiZone:Component:HorizontalOpening, or\n";
    ss << "\\note AirflowNetwork:MultiZone:Component:ZoneExhaustFan.\n";
    ss << "\\note When the zone exhaust fan name is entered, any surface control fields below A3 are\n";
    ss << "\\note ignored when the zone exhaust fan turns on.\n";
    ss << "A3, \\field External Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ExternalNodeNames\n";
    ss << "\\note Used if Wind Pressure Coefficient Type = Input in the AirflowNetwork:SimulationControl object,\n";
    ss << "\\note otherwise this field may be left blank.\n";
    ss << "N1, \\field Window/Door Opening Factor, or Crack Factor\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note This field specifies a multiplier for a crack, window, or door.\n";
    ss << "A4, \\field Ventilation Control Mode\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\key Enthalpy\n";
    ss << "\\key Constant\n";
    ss << "\\key ASHRAE55Adaptive\n";
    ss << "\\key CEN15251Adaptive\n";
    ss << "\\key NoVent\n";
    ss << "\\key ZoneLevel\n";
    ss << "\\key AdjacentTemperature\n";
    ss << "\\key AdjacentEnthalpy\n";
    ss << "\\default ZoneLevel\n";
    ss << "\\note When Ventilation Control Mode = Temperature or Enthalpy, the following\n";
    ss << "\\note fields are used to modulate the Ventilation Open Factor for a\n";
    ss << "\\note window or door opening according to the parent zone's\n";
    ss << "\\note indoor-outdoor temperature or enthalpy difference.\n";
    ss << "\\note When Ventilation Control Mode = AdjacentTemperature or AdjacentEnthalpy, the following\n";
    ss << "\\note fields are used to modulate the Ventilation Open Factor for an interior\n";
    ss << "\\note window or door opening according to temperature or enthalpy difference\n";
    ss << "\\note between the parent zone and the adjacent zone.\n";
    ss << "\\note Constant: controlled by field Venting Schedule Name.\n";
    ss << "\\note NoVent: control will not open window or door during simulation (Ventilation Open Factor = 0).\n";
    ss << "\\note ZoneLevel: control will be controlled by AirflowNetwork:MultiZone:Zone\n";
    ss << "\\note Mode.\n";
    ss << "A5, \\field Ventilation Control Zone Temperature Setpoint Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Used only if Ventilation Control Mode = Temperature or Enthalpy.\n";
    ss << "N2, \\field Minimum Venting Open Factor\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Used only if Ventilation Control Mode = Temperature or Enthalpy.\n";
    ss << "N3, \\field Indoor and Outdoor Temperature Difference Lower Limit For Maximum Venting Open Factor\n";
    ss << "\\note Applicable only if Ventilation Control Mode = Temperature\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum< 100\n";
    ss << "\\default 0.0\n";
    ss << "N4, \\field Indoor and Outdoor Temperature Difference Upper Limit for Minimum Venting Open Factor\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 100.0\n";
    ss << "\\note Applicable only if Ventilation Control Mode = Temperature.\n";
    ss << "\\note This value must be greater than the corresponding lower value (previous field).\n";
    ss << "N5, \\field Indoor and Outdoor Enthalpy Difference Lower Limit For Maximum Venting Open Factor\n";
    ss << "\\type real\n";
    ss << "\\units deltaJ/kg\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum< 300000.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Applicable only if Ventilation Control Mode = Enthalpy.\n";
    ss << "\\note This value must be less than the corresponding upper value (next field).\n";
    ss << "N6, \\field Indoor and Outdoor Enthalpy Difference Upper Limit for Minimum Venting Open Factor\n";
    ss << "\\type real\n";
    ss << "\\units deltaJ/kg\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 300000.0\n";
    ss << "\\note Applicable only if Ventilation Control Mode = Enthalpy.\n";
    ss << "\\note This value must be greater than the corresponding lower value (previous field).\n";
    ss << "A6, \\field Venting Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Non-zero schedule value means venting is allowed if other venting control conditions are\n";
    ss << "\\note satisfied. A zero (or negative) schedule value means venting is not allowed under any\n";
    ss << "\\note circumstances. The schedule values should be greater than or equal to 0 and less than or\n";
    ss << "\\note equal to 1. If this schedule is not specified then venting is allowed if\n";
    ss << "\\note other venting control conditions are satisfied.\n";
    ss << "\\note Not used if Ventilation Control Mode = NoVent or ZoneLevel.\n";
    ss << "A7; \\field Occupant Ventilation Control Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirflowNetworkOccupantVentilationControlNames\n";
    ss << "\\note Enter the name where Occupancy Ventilation Control is required.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_MultiZone_Surface);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:MultiZone:Surface",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_MultiZone_Surface);
  return object;
}

IddObject createAirflowNetwork_MultiZone_ReferenceCrackConditionsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:MultiZone:ReferenceCrackConditions,\n";
    ss << "\\min-fields 4\n";
    ss << "\\memo This object specifies the conditions under which the air mass flow coefficient was measured.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ReferenceCrackConditions\n";
    ss << "\\note Enter a unique name for this object.\n";
    ss << "N1 , \\field Reference Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 20\n";
    ss << "\\note Enter the reference temperature under which the surface crack data were obtained.\n";
    ss << "N2 , \\field Reference Barometric Pressure\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\default 101325\n";
    ss << "\\minimum 31000\n";
    ss << "\\maximum 120000\n";
    ss << "\\type real\n";
    ss << "\\ip-units inHg\n";
    ss << "\\note Enter the reference barometric pressure under which the surface crack data were obtained.\n";
    ss << "N3 ; \\field Reference Humidity Ratio\n";
    ss << "\\type real\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\default 0\n";
    ss << "\\note Enter the reference humidity ratio under which the surface crack data were obtained.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_MultiZone_ReferenceCrackConditions);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:MultiZone:ReferenceCrackConditions",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_MultiZone_ReferenceCrackConditions);
  return object;
}

IddObject createAirflowNetwork_MultiZone_Surface_CrackIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:MultiZone:Surface:Crack,\n";
    ss << "\\min-fields 3\n";
    ss << "\\memo This object specifies the properties of airflow through a crack.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SurfaceAirflowLeakageNames\n";
    ss << "\\note Enter a unique name for this object.\n";
    ss << "N1 , \\field Air Mass Flow Coefficient at Reference Conditions\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units kg/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the air mass flow coefficient at the conditions defined\n";
    ss << "\\note in the Reference Crack Conditions object.\n";
    ss << "\\note Defined at 1 Pa pressure difference across this crack.\n";
    ss << "N2 , \\field Air Mass Flow Exponent\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.65\n";
    ss << "\\note Enter the air mass flow exponent for the surface crack.\n";
    ss << "A2 ; \\field Reference Crack Conditions\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ReferenceCrackConditions\n";
    ss << "\\note Select a AirflowNetwork:MultiZone:ReferenceCrackConditions name associated with\n";
    ss << "\\note the air mass flow coefficient entered above.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_MultiZone_Surface_Crack);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:MultiZone:Surface:Crack",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_MultiZone_Surface_Crack);
  return object;
}

IddObject createAirflowNetwork_MultiZone_Surface_EffectiveLeakageAreaIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:MultiZone:Surface:EffectiveLeakageArea,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo This object is used to define surface air leakage.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SurfaceAirflowLeakageNames\n";
    ss << "\\note Enter a unique name for this object.\n";
    ss << "N1 , \\field Effective Leakage Area\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m2\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the effective leakage area.\n";
    ss << "N2 , \\field Discharge Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Enter the coefficient used in the air mass flow equation.\n";
    ss << "N3 , \\field Reference Pressure Difference\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 4.0\n";
    ss << "\\note Enter the pressure difference used to define the air mass flow coefficient and exponent.\n";
    ss << "N4 ; \\field Air Mass Flow Exponent\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\default .65\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note Enter the exponent used in the air mass flow equation.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_MultiZone_Surface_EffectiveLeakageArea);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:MultiZone:Surface:EffectiveLeakageArea",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_MultiZone_Surface_EffectiveLeakageArea);
  return object;
}

IddObject createAirflowNetwork_MultiZone_Component_DetailedOpeningIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:MultiZone:Component:DetailedOpening,\n";
    ss << "\\min-fields 16\n";
    ss << "\\memo This object specifies the properties of airflow through windows and doors (window, door and\n";
    ss << "\\memo glass door heat transfer subsurfaces) when they are closed or open.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SurfaceAirflowLeakageNames\n";
    ss << "\\note Enter a unique name for this object.\n";
    ss << "N1 , \\field Air Mass Flow Coefficient When Opening is Closed\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kg/s-m\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Defined at 1 Pa per meter of crack length. Enter the coefficient used in the following\n";
    ss << "\\note equation:\n";
    ss << "\\note Mass Flow Rate = Air Mass Flow Coefficient * (dP)^Air Mass Flow Exponent.\n";
    ss << "\\note Used only when opening (window or door) is closed.\n";
    ss << "N2 , \\field Air Mass Flow Exponent When Opening is Closed\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.65\n";
    ss << "\\note Enter the exponent used in the following equation:\n";
    ss << "\\note Mass Flow Rate = Air Mass Flow Coefficient * (dP)^Air Mass Flow Exponent.\n";
    ss << "\\note Used only when opening (window or door) is closed.\n";
    ss << "A2 , \\field Type of Rectangular Large Vertical Opening (LVO)\n";
    ss << "\\type choice\n";
    ss << "\\key NonPivoted\n";
    ss << "\\key HorizontallyPivoted\n";
    ss << "\\note Select the type of vertical opening: Non-pivoted opening or Horizontally pivoted opening.\n";
    ss << "\\default NonPivoted\n";
    ss << "N3 , \\field Extra Crack Length or Height of Pivoting Axis\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note Extra crack length is used for LVO Non-pivoted type with multiple openable parts.\n";
    ss << "\\note Height of pivoting axis is used for LVO Horizontally pivoted type.\n";
    ss << "\\note Specifies window or door characteristics that depend on the LVO type.\n";
    ss << "\\note For Non-pivoted Type (rectangular windows and doors), this field is the extra crack length\n";
    ss << "\\note in meters due to multiple openable parts, if present.  Extra here means in addition\n";
    ss << "\\note to the length of the cracks on the top, bottom and sides of the window/door.\n";
    ss << "\\note For Horizontally pivoted Type, this field gives the height of the\n";
    ss << "\\note pivoting axis measured from the bottom of the glazed part of the window (m).\n";
    ss << "N4 , \\field Number of Sets of Opening Factor Data\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 2\n";
    ss << "\\maximum 4\n";
    ss << "\\note Enter the number of the following sets of data for opening factor,\n";
    ss << "\\note discharge coefficient, width factor, height factor, and start height factor.\n";
    ss << "N5 , \\field Opening Factor 1\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 0\n";
    ss << "\\default 0\n";
    ss << "\\note This value must be specified as 0.\n";
    ss << "N6 , \\field Discharge Coefficient for Opening Factor 1\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.001\n";
    ss << "\\note The Discharge Coefficient indicates the fractional effectiveness\n";
    ss << "\\note for air flow through a window or door at that Opening Factor.\n";
    ss << "N7 , \\field Width Factor for Opening Factor 1\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "\\note The Width Factor is the opening width divided by the window or door width.\n";
    ss << "N8 , \\field Height Factor for Opening Factor 1\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "\\note The Height Factor is the opening height divided by the window or door height.\n";
    ss << "N9 , \\field Start Height Factor for Opening Factor 1\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "\\note The Start Height Factor is the Start Height divided by the window or door height.\n";
    ss << "\\note Start Height is the distance between the bottom of the window or door and the\n";
    ss << "\\note bottom of the window or door opening. The sum of the Height Factor and the Start Height\n";
    ss << "\\note Factor must be less than 1.0 in order to have the opening within the window or door\n";
    ss << "\\note dimensions.\n";
    ss << "N10, \\field Opening Factor 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "\\note If Number of Sets of Opening Factor Data = 2, this value must be 1.0.\n";
    ss << "\\note If Number of Sets of Opening Factor Data = 3, this value must be less than 1.0.\n";
    ss << "\\note If Number of Sets of Opening Factor Data = 4, this value must be less than the\n";
    ss << "\\note value entered for Opening factor 3 and greater than the value entered\n";
    ss << "\\note for Opening factor 1.\n";
    ss << "N11, \\field Discharge Coefficient for Opening Factor 2\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 1\n";
    ss << "\\note The Discharge Coefficient indicates the fractional effectiveness\n";
    ss << "\\note for air flow through a window or door at that Opening Factor.\n";
    ss << "N12, \\field Width Factor for Opening Factor 2\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 1\n";
    ss << "\\note The Width Factor is the opening width divided by the window or door width.\n";
    ss << "N13, \\field Height Factor for Opening Factor 2\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 1\n";
    ss << "\\note The Height Factor is the opening height divided by the window or door height.\n";
    ss << "N14, \\field Start Height Factor for Opening Factor 2\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "\\default 0\n";
    ss << "\\note The Start Height Factor is the Start Height divided by the window or door height.\n";
    ss << "\\note Start Height is the distance between the bottom of the window or door and the\n";
    ss << "\\note bottom of the window or door opening. The sum of the Height Factor and the Start Height\n";
    ss << "\\note Factor must be less than 1.0 in order to have the opening within the window or door\n";
    ss << "\\note dimensions.\n";
    ss << "N15, \\field Opening Factor 3\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\note If Number of Sets of Opening Factor Data = 3, this value must be 1.0.\n";
    ss << "\\note If Number of Sets of Opening Factor Data = 4, this value must be less than 1.0,\n";
    ss << "\\note and greater than value entered for Opening factor 2.\n";
    ss << "N16, \\field Discharge Coefficient for Opening Factor 3\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "\\note The Discharge Coefficient indicates the fractional effectiveness\n";
    ss << "\\note for air flow through a window or door at that Opening Factor.\n";
    ss << "N17, \\field Width Factor for Opening Factor 3\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "\\note The Width Factor is the opening width divided by the window or door width.\n";
    ss << "N18, \\field Height Factor for Opening Factor 3\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "\\note The Height Factor is the opening height divided by the window or door height.\n";
    ss << "N19, \\field Start Height Factor for Opening Factor 3\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "\\note The Start Height Factor is the Start Height divided by the window or door height.\n";
    ss << "\\note Start Height is the distance between the bottom of the window or door and the\n";
    ss << "\\note bottom of the window or door opening. The sum of the Height Factor and the Start Height\n";
    ss << "\\note Factor must be less than 1.0 in order to have the opening within the window or door\n";
    ss << "\\note dimensions.\n";
    ss << "N20, \\field Opening Factor 4\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\note If Number of Sets of Opening Factor Data = 4, this value must be 1.0\n";
    ss << "N21, \\field Discharge Coefficient for Opening Factor 4\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "\\note The Discharge Coefficient indicates the fractional effectiveness\n";
    ss << "\\note for air flow through a window or door at that Opening Factor.\n";
    ss << "N22, \\field Width Factor for Opening Factor 4\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "\\note The Width Factor is the opening width divided by the window or door width.\n";
    ss << "N23, \\field Height Factor for Opening Factor 4\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "\\note The Height Factor is the opening height divided by the window or door height.\n";
    ss << "N24; \\field Start Height Factor for Opening Factor 4\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "\\note The Start Height Factor is the Start Height divided by the window or door height.\n";
    ss << "\\note Start Height is the distance between the bottom of the window or door and the\n";
    ss << "\\note bottom of the window or door opening. The sum of the Height Factor and the Start Height\n";
    ss << "\\note Factor must be less than 1.0 in order to have the opening within the window or door\n";
    ss << "\\note dimensions.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_MultiZone_Component_DetailedOpening);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:MultiZone:Component:DetailedOpening",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_MultiZone_Component_DetailedOpening);
  return object;
}

IddObject createAirflowNetwork_MultiZone_Component_SimpleOpeningIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:MultiZone:Component:SimpleOpening,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo This object specifies the properties of air flow through windows and doors (window, door and\n";
    ss << "\\memo glass door heat transfer subsurfaces) when they are closed or open.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SurfaceAirflowLeakageNames\n";
    ss << "\\note Enter a unique name for this object.\n";
    ss << "N1 , \\field Air Mass Flow Coefficient When Opening is Closed\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\units kg/s-m\n";
    ss << "\\note Defined at 1 Pa pressure difference. Enter the coefficient used in the following equation:\n";
    ss << "\\note Mass Flow Rate = Air Mass Flow Coefficient * (dP)^Air Mass Flow Exponent.\n";
    ss << "\\note Used only when opening (window or door) is closed.\n";
    ss << "N2 , \\field Air Mass Flow Exponent When Opening is Closed\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\default .65\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note Enter the exponent used in the following equation:\n";
    ss << "\\note Mass Flow Rate = Air Mass Flow Coefficient * (dP)^Air Mass Flow Exponent.\n";
    ss << "\\note Used only when opening (window or door) is closed.\n";
    ss << "N3 , \\field Minimum Density Difference for Two-Way Flow\n";
    ss << "\\required-field\n";
    ss << "\\units kg/m3\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the minimum density difference above which two-way flow may occur due to stack effect.\n";
    ss << "N4 ; \\field Discharge Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\note The Discharge Coefficient indicates the fractional effectiveness\n";
    ss << "\\note for air flow through a window or door at that Opening Factor.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_MultiZone_Component_SimpleOpening);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:MultiZone:Component:SimpleOpening",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_MultiZone_Component_SimpleOpening);
  return object;
}

IddObject createAirflowNetwork_MultiZone_Component_HorizontalOpeningIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:MultiZone:Component:HorizontalOpening,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo This object specifies the properties of air flow through a horizontal opening\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SurfaceAirflowLeakageNames\n";
    ss << "\\note Enter a unique name for this object.\n";
    ss << "N1 , \\field Air Mass Flow Coefficient When Opening is Closed\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\units kg/s-m\n";
    ss << "\\note Defined at 1 Pa pressure difference. Enter the coefficient used in the following equation:\n";
    ss << "\\note Mass flow rate = Air Mass Flow Coefficient * (dP)^Air Mass Flow Exponent.\n";
    ss << "\\note Used only when opening is closed.\n";
    ss << "N2 , \\field Air Mass Flow Exponent When Opening is Closed\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\default .65\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note Enter the exponent used in the following equation:\n";
    ss << "\\note Mass flow rate = Air Mass Flow Coefficient * (dP)^Air Mass Flow Exponent.\n";
    ss << "\\note Used only when opening is closed.\n";
    ss << "N3 , \\field Sloping Plane Angle\n";
    ss << "\\units deg\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 90\n";
    ss << "\\default 90\n";
    ss << "\\note Sloping plane angle = 90 is equivalent to fully open.\n";
    ss << "N4 ; \\field Discharge Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\note The Discharge Coefficient indicates the fractional effectiveness\n";
    ss << "\\note for air flow through the opening at that Opening Factor.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_MultiZone_Component_HorizontalOpening);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:MultiZone:Component:HorizontalOpening",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_MultiZone_Component_HorizontalOpening);
  return object;
}

IddObject createAirflowNetwork_MultiZone_Component_ZoneExhaustFanIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:MultiZone:Component:ZoneExhaustFan,\n";
    ss << "\\min-fields 3\n";
    ss << "\\memo This object specifies the additional properties for a zone exhaust fan\n";
    ss << "\\memo to perform multizone airflow calculations.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansZoneExhaust\n";
    ss << "\\note Enter the name of a Fan:ZoneExhaust object.\n";
    ss << "N1 , \\field Air Mass Flow Coefficient When the Zone Exhaust Fan is Off at Reference Conditions\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kg/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the air mass flow coefficient at the conditions defined\n";
    ss << "\\note in the Reference Crack Conditions object.\n";
    ss << "\\note Defined at 1 Pa pressure difference. Enter the coefficient used in the following\n";
    ss << "\\note equation:\n";
    ss << "\\note Mass Flow Rate = Air Mass Flow Coefficient * (dP)^Air Mass Flow Exponent.\n";
    ss << "\\note Used only when the fan is off.\n";
    ss << "N2 , \\field Air Mass Flow Exponent When the Zone Exhaust Fan is Off\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.65\n";
    ss << "\\note Enter the exponent used in the following equation:\n";
    ss << "\\note Mass Flow Rate = Air Mass Flow Coefficient * (dP)^Air Mass Flow Exponent.\n";
    ss << "\\note Used only when the fan is off.\n";
    ss << "A2 ; \\field Reference Crack Conditions\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ReferenceCrackConditions\n";
    ss << "\\note Select a AirflowNetwork:MultiZone:ReferenceCrackConditions name associated with\n";
    ss << "\\note the air mass flow coefficient entered above.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_MultiZone_Component_ZoneExhaustFan);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:MultiZone:Component:ZoneExhaustFan",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_MultiZone_Component_ZoneExhaustFan);
  return object;
}

IddObject createAirflowNetwork_MultiZone_ExternalNodeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:MultiZone:ExternalNode,\n";
    ss << "\\min-fields 3\n";
    ss << "\\memo This object defines outdoor environmental conditions outside of the building.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ExternalNodeNames\n";
    ss << "\\note Enter a unique name for this object.\n";
    ss << "\\note This node name will be referenced by a particular building facade.\n";
    ss << "N1 , \\field External Node Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0.0\n";
    ss << "\\note Designates the reference height used to calculate relative pressure.\n";
    ss << "A2 ; \\field Wind Pressure Coefficient Values Object Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WPCValueNames\n";
    ss << "\\note Enter the name of the AirflowNetwork:MultiZone:WindPressureCoefficientValues object.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_MultiZone_ExternalNode);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:MultiZone:ExternalNode",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_MultiZone_ExternalNode);
  return object;
}

IddObject createAirflowNetwork_MultiZone_WindPressureCoefficientArrayIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:MultiZone:WindPressureCoefficientArray,\n";
    ss << "\\min-fields 3\n";
    ss << "\\max-fields 37\n";
    ss << "\\extensible:1\n";
    ss << "\\memo Used only if Wind Pressure Coefficient (WPC) Type = Input in the AirflowNetwork:SimulationControl\n";
    ss << "\\memo object. Number of WPC Values in the corresponding AirflowNetwork:MultiZone:WindPressureCoefficientValues\n";
    ss << "\\memo object must be the same as the number of wind directions specified for\n";
    ss << "\\memo this AirflowNetwork:MultiZone:WindPressureCoefficientArray object.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference WPCSetNames\n";
    ss << "\\type alpha\n";
    ss << "\\note Enter a unique name for the object.\n";
    ss << "N1 ; \\field Wind Direction 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 360.0\n";
    ss << "\\begin-extensible\n";
    ss << "\\note Enter the wind direction corresponding to the 1st WPC Array value.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_MultiZone_WindPressureCoefficientArray);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:MultiZone:WindPressureCoefficientArray",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_MultiZone_WindPressureCoefficientArray);
  return object;
}

IddObject createAirflowNetwork_MultiZone_WindPressureCoefficientValuesIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:MultiZone:WindPressureCoefficientValues,\n";
    ss << "\\min-fields 4\n";
    ss << "\\max-fields 38\n";
    ss << "\\extensible:1\n";
    ss << "\\memo Used only if Wind Pressure Coefficient (WPC) Type = INPUT in the AirflowNetwork:SimulationControl\n";
    ss << "\\memo object. The number of WPC numeric inputs must correspond to the number of wind direction\n";
    ss << "\\memo inputs in the AirflowNetwork:Multizone:WindPressureCoefficientArray object.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WPCValueNames\n";
    ss << "\\note Enter a unique name for this object.\n";
    ss << "A2 , \\field AirflowNetwork:MultiZone:WindPressureCoefficientArray Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WPCSetNames\n";
    ss << "\\note Enter the name of the AirflowNetwork:Multizone:WindPressureCoefficientArray object.\n";
    ss << "N1 ; \\field Wind Pressure Coefficient Value 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Enter the WPC Value corresponding to the 1st wind direction.\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_MultiZone_WindPressureCoefficientValues);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:MultiZone:WindPressureCoefficientValues",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_MultiZone_WindPressureCoefficientValues);
  return object;
}

IddObject createAirflowNetwork_Distribution_NodeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:Distribution:Node,\n";
    ss << "\\min-fields 4\n";
    ss << "\\memo This object represents an air distribution node in the AirflowNetwork model.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AirflowNetworkNodeAndZoneNames\n";
    ss << "\\note Enter a unique name for this object.\n";
    ss << "A2 , \\field Component Name or Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\note Designates node names defined in another object. The node name may occur in air branches.\n";
    ss << "\\note Enter a node name to represent a node already defined in an air loop.\n";
    ss << "\\note Leave this field blank if the Node or Object Type field below is entered as\n";
    ss << "\\note AirLoopHVAC:ZoneMixer, AirLoopHVAC:ZoneSplitter, AirLoopHVAC:OutdoorAirSystem, or Other.\n";
    ss << "A3 , \\field Component Object Type or Node Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirLoopHVAC:ZoneMixer\n";
    ss << "\\key AirLoopHVAC:ZoneSplitter\n";
    ss << "\\key AirLoopHVAC:OutdoorAirSystem\n";
    ss << "\\key OAMixerOutdoorAirStreamNode\n";
    ss << "\\key OutdoorAir:NodeList\n";
    ss << "\\key OutdoorAir:Node\n";
    ss << "\\key Other\n";
    ss << "\\default Other\n";
    ss << "\\note Designates Node type for the Node or Component Name defined in the field above.\n";
    ss << "\\note AirLoopHVAC:ZoneMixer -- Represents a AirLoopHVAC:ZoneMixer object.\n";
    ss << "\\note AirLoopHVAC:ZoneSplitter -- Represents a AirLoopHVAC:ZoneSplitter object.\n";
    ss << "\\note AirLoopHVAC:OutdoorAirSystem -- Represents an AirLoopHVAC:OutdoorAirSystem object.\n";
    ss << "\\note OAMixerOutdoorAirStreamNode -- Represents an external node used in the OutdoorAir:Mixer\n";
    ss << "\\note OutdoorAir:NodeList -- Represents an external node when a heat exchanger is used before\n";
    ss << "\\note the OutdoorAir:Mixer\n";
    ss << "\\note OutdoorAir:Node -- Represents an external node when a heat exchanger is used before\n";
    ss << "\\note the OutdoorAir:Mixer\n";
    ss << "\\note Other -- none of the above, the Node name already defined in the previous field is part\n";
    ss << "\\note of an air loop.\n";
    ss << "N1 ; \\field Node Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0.0\n";
    ss << "\\note Enter the reference height used to calculate the relative pressure.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_Distribution_Node);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:Distribution:Node",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_Distribution_Node);
  return object;
}

IddObject createAirflowNetwork_Distribution_Component_LeakIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:Distribution:Component:Leak,\n";
    ss << "\\min-fields 3\n";
    ss << "\\memo This object defines the characteristics of a supply or return air leak.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AirflowNetworkComponentNames\n";
    ss << "\\note Enter a unique name for this object.\n";
    ss << "N1 , \\field Air Mass Flow Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kg/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Defined at 1 Pa pressure difference across this component.\n";
    ss << "\\note Enter the coefficient used in the following equation:\n";
    ss << "\\note Mass Flow Rate = Air Mass Flow Coefficient * (dP)^Air Mass Flow Exponent\n";
    ss << "N2 ; \\field Air Mass Flow Exponent\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.65\n";
    ss << "\\note Enter the exponent used in the following equation:\n";
    ss << "\\note Mass Flow Rate = Air Mass Flow Coefficient * (dP)^Air Mass Flow Exponent\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_Distribution_Component_Leak);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:Distribution:Component:Leak",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_Distribution_Component_Leak);
  return object;
}

IddObject createAirflowNetwork_Distribution_Component_LeakageRatioIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:Distribution:Component:LeakageRatio,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo This object is used to define supply and return air leaks with respect to the fan's maximum\n";
    ss << "\\memo air flow rate.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AirflowNetworkComponentNames\n";
    ss << "\\note Enter a unique name for this object.\n";
    ss << "N1 , \\field Effective Leakage Ratio\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note Defined as a ratio of leak flow rate to the maximum flow rate.\n";
    ss << "N2 , \\field Maximum Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Enter the maximum air flow rate in this air loop.\n";
    ss << "N3 , \\field Reference Pressure Difference\n";
    ss << "\\required-field\n";
    ss << "\\units Pa\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Enter the pressure corresponding to the Effective leakage ratio entered above.\n";
    ss << "N4 ; \\field Air Mass Flow Exponent\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\default 0.65\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note Enter the exponent used in the air mass flow equation.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_Distribution_Component_LeakageRatio);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:Distribution:Component:LeakageRatio",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_Distribution_Component_LeakageRatio);
  return object;
}

IddObject createAirflowNetwork_Distribution_Component_DuctIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:Distribution:Component:Duct,\n";
    ss << "\\min-fields 8\n";
    ss << "\\memo This object defines the relationship between pressure and air flow through the duct.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AirflowNetworkComponentNames\n";
    ss << "\\note Enter a unique name for this object.\n";
    ss << "N1 , \\field Duct Length\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Enter the length of the duct.\n";
    ss << "N2 , \\field Hydraulic Diameter\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Enter the hydraulic diameter of the duct.\n";
    ss << "\\note Hydraulic diameter is defined as 4 multiplied by cross section area divided by perimeter\n";
    ss << "N3 , \\field Cross Section Area\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m2\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Enter the cross section area of the duct.\n";
    ss << "N4 , \\field Surface Roughness\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0.0009\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Enter the inside surface roughness of the duct.\n";
    ss << "N5 , \\field Coefficient for Local Dynamic Loss Due to Fitting\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 0.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the coefficient used to calculate dynamic losses of fittings (e.g. elbows).\n";
    ss << "N6 , \\field Overall Heat Transmittance Coefficient (U-Factor) from Air to Air\n";
    ss << "\\note including film coefficients at both surfaces\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.772\n";
    ss << "\\note Enter the overall U-value for this duct.\n";
    ss << "\\note Default value of 0.772 is equivalent to 1.06 m2-K/W (R6) duct insulation with\n";
    ss << "\\note film coefficients for outside and inside equal to 5 and 25 W/m2-K, respectively.\n";
    ss << "N7 ; \\field Overall Moisture Transmittance Coefficient from Air to Air\n";
    ss << "\\type real\n";
    ss << "\\units kg/m2\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "\\note Enter the overall moisture transmittance coefficient\n";
    ss << "\\note including moisture film coefficients at both surfaces.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_Distribution_Component_Duct);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:Distribution:Component:Duct",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_Distribution_Component_Duct);
  return object;
}

IddObject createAirflowNetwork_Distribution_Component_FanIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:Distribution:Component:Fan,\n";
    ss << "\\min-fields 2\n";
    ss << "\\memo This object defines the name of the constant volume supply Air Fan used in an Air loop.\n";
    ss << "A1 , \\field Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOff\n";
    ss << "\\reference AirflowNetworkComponentNames\n";
    ss << "\\note Enter the name of the constant volume fan in the primary air loop.\n";
    ss << "A2 ; \\field Supply Fan Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "\\key Fan:VariableVolume\n";
    ss << "\\default Fan:ConstantVolume\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_Distribution_Component_Fan);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:Distribution:Component:Fan",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_Distribution_Component_Fan);
  return object;
}

IddObject createAirflowNetwork_Distribution_Component_CoilIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:Distribution:Component:Coil,\n";
    ss << "\\min-fields 4\n";
    ss << "\\memo This object defines the name of a coil used in an air loop.\n";
    ss << "A1 , \\field Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\reference AirflowNetworkComponentNames\n";
    ss << "\\object-list AFNCoilNames\n";
    ss << "\\note Enter the name of a cooling or heating coil in the primary Air loop.\n";
    ss << "A2 , \\field Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:DX:SingleSpeed\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:DX:SingleSpeed\n";
    ss << "\\key Coil:Cooling:Water\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Cooling:Water:DetailedGeometry\n";
    ss << "\\key Coil:Cooling:DX:TwoStageWithHumidityControlMode\n";
    ss << "\\key Coil:Cooling:DX:MultiSpeed\n";
    ss << "\\key Coil:Heating:DX:MultiSpeed\n";
    ss << "\\key Coil:Heating:Desuperheater\n";
    ss << "\\note Select the type of coil corresponding to the name entered in the field above.\n";
    ss << "N1 , \\field Air Path Length\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the air path length (depth) for the coil.\n";
    ss << "N2 ; \\field Air Path Hydraulic Diameter\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the hydraulic diameter of this coil. The hydraulic diameter is\n";
    ss << "\\note defined as 4 multiplied by the cross section area divided by perimeter.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_Distribution_Component_Coil);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:Distribution:Component:Coil",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_Distribution_Component_Coil);
  return object;
}

IddObject createAirflowNetwork_Distribution_Component_HeatExchangerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:Distribution:Component:HeatExchanger,\n";
    ss << "\\min-fields 4\n";
    ss << "\\memo This object defines the name of an air-to-air heat exchanger used in an air loop.\n";
    ss << "A1 , \\field HeatExchanger Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AFNHeatExchangerNames\n";
    ss << "\\reference AirflowNetworkComponentNames\n";
    ss << "\\note Enter the name of an air-to-air heat exchanger in the primary Air loop.\n";
    ss << "A2 , \\field HeatExchanger Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key HeatExchanger:AirToAir:FlatPlate\n";
    ss << "\\key HeatExchanger:AirToAir:SensibleAndLatent\n";
    ss << "\\key HeatExchanger:Desiccant:BalancedFlow\n";
    ss << "\\note Select the type of heat exchanger corresponding to the name entered in the field above.\n";
    ss << "N1 , \\field Air Path Length\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the air path length (depth) for the heat exchanger.\n";
    ss << "N2 ; \\field Air Path Hydraulic Diameter\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the hydraulic diameter of this heat exchanger. The hydraulic diameter is\n";
    ss << "\\note defined as 4 multiplied by the cross section area divided by perimeter.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_Distribution_Component_HeatExchanger);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:Distribution:Component:HeatExchanger",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_Distribution_Component_HeatExchanger);
  return object;
}

IddObject createAirflowNetwork_Distribution_Component_TerminalUnitIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:Distribution:Component:TerminalUnit,\n";
    ss << "\\min-fields 4\n";
    ss << "\\memo This object defines the name of a terminal unit in an air loop.\n";
    ss << "A1 , \\field Terminal Unit Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\reference AirflowNetworkComponentNames\n";
    ss << "\\object-list AFNTerminalUnitNames\n";
    ss << "\\note Enter the name of a terminal unit in the AirLoopHVAC.\n";
    ss << "A2 , \\field Terminal Unit Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key AirTerminal:SingleDuct:ConstantVolume:Reheat\n";
    ss << "\\key AirTerminal:SingleDuct:VAV:Reheat\n";
    ss << "\\note Select the type of terminal unit corresponding to the name entered in the field above.\n";
    ss << "N1 , \\field Air Path Length\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the air path length (depth) for the terminal unit.\n";
    ss << "N2 ; \\field Air Path Hydraulic Diameter\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the hydraulic diameter of this terminal unit. The hydraulic diameter is\n";
    ss << "\\note defined as 4 multiplied by the cross section area divided by perimeter.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_Distribution_Component_TerminalUnit);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:Distribution:Component:TerminalUnit",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_Distribution_Component_TerminalUnit);
  return object;
}

IddObject createAirflowNetwork_Distribution_Component_ConstantPressureDropIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:Distribution:Component:ConstantPressureDrop,\n";
    ss << "\\min-fields 2\n";
    ss << "\\memo This object defines the characteristics of a constant pressure drop component (e.g. filter).\n";
    ss << "\\memo Each node connected to this object can not be a node of mixer, splitter, a node of air primary\n";
    ss << "\\memo loop, or zone equipment loop. It is recommended to connect to a duct component at both ends.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AirflowNetworkComponentNames\n";
    ss << "\\note Enter a unique name for this object.\n";
    ss << "N1 ; \\field Pressure Difference Across the Component\n";
    ss << "\\required-field\n";
    ss << "\\units Pa\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Enter the pressure drop across this component.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_Distribution_Component_ConstantPressureDrop);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:Distribution:Component:ConstantPressureDrop",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_Distribution_Component_ConstantPressureDrop);
  return object;
}

IddObject createAirflowNetwork_Distribution_LinkageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:Distribution:Linkage,\n";
    ss << "\\min-fields 4\n";
    ss << "\\memo This object defines the connection between two nodes and a component.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note Enter a unique name for this object.\n";
    ss << "A2 , \\field Node 1 Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirflowNetworkNodeAndZoneNames\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note Enter the name of zone or AirflowNetwork Node.\n";
    ss << "A3 , \\field Node 2 Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirflowNetworkNodeAndZoneNames\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note Enter the name of zone or AirflowNetwork Node.\n";
    ss << "A4 , \\field Component Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirflowNetworkComponentNames\n";
    ss << "\\note Enter the name of an AirflowNetwork component. A component is one of the\n";
    ss << "\\note following AirflowNetwork:Distribution:Component objects: Leak, LeakageRatio,\n";
    ss << "\\note Duct, ConstantVolumeFan, Coil, TerminalUnit, ConstantPressureDrop, or HeatExchanger.\n";
    ss << "A5 ; \\field Thermal Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note Only used if component = AirflowNetwork:Distribution:Component:Duct\n";
    ss << "\\note The zone name is where AirflowNetwork:Distribution:Component:Duct is exposed. Leave this field blank if the duct\n";
    ss << "\\note conduction loss is ignored.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_Distribution_Linkage);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:Distribution:Linkage",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_Distribution_Linkage);
  return object;
}

IddObject createAirflowNetwork_OccupantVentilationControlIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:OccupantVentilationControl,\n";
    ss << "\\memo This object is used to provide advanced thermal comfort control of window opening and closing\n";
    ss << "\\memo for both exterior and interior windows.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AirflowNetworkOccupantVentilationControlNames\n";
    ss << "\\note Enter the name where the advanced thermal comfort control is required.\n";
    ss << "N1, \\field Minimum Opening Time\n";
    ss << "\\type real\n";
    ss << "\\units minutes\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N2, \\field Minimum Closing Time\n";
    ss << "\\type real\n";
    ss << "\\units minutes\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "A2, \\field Thermal Comfort Low Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Enter a curve name that represents thermal comfort temperature as a\n";
    ss << "\\note function of outdoor dry-bulb temperature. Up to two curves are allowed if the\n";
    ss << "\\note performance cannot be represented by a single curve.\n";
    ss << "\\note The following two fields are used if two curves are required.\n";
    ss << "N3, \\field Thermal Comfort Temperature Boundary Point\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 10.0\n";
    ss << "\\note This point is used to allow separate low and high thermal comfort temperature\n";
    ss << "\\note curves. If a single performance curve is used, leave this field blank.\n";
    ss << "A3, \\field Thermal Comfort High Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Enter a curve name that represents thermal comfort temperature as a\n";
    ss << "\\note function of outdoor dry-bulb temperature. Up to two curves are allowed if the\n";
    ss << "\\note performance cannot be represented by a single curve.\n";
    ss << "\\note If a single performance curve is used, leave this field blank.\n";
    ss << "N4, \\field Maximum Threshold for Persons Dissatisfied PPD\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 100\n";
    ss << "\\default 10.0\n";
    ss << "A4, \\field Occupancy Check\n";
    ss << "\\note If Yes, occupancy check will be performed as part of the opening probability check.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A5, \\field Opening Probability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note If this field is blank, the opening probability check is bypassed and opening is true.\n";
    ss << "A6; \\field Closing Probability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note If this field is blank, the closing probability check is bypassed and closing is true.\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_OccupantVentilationControl);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:OccupantVentilationControl",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_OccupantVentilationControl);
  return object;
}

IddObject createAirflowNetwork_IntraZone_LinkageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirflowNetwork:IntraZone:Linkage,\n";
    ss << "\\min-fields 4\n";
    ss << "\\memo This object defines the connection between two nodes and a component used\n";
    ss << "\\memo in the combination of RoomAir and AirflowNetwork model.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note Enter a unique name for this object.\n";
    ss << "\\reference AirflowNetwork LinkageNames\n";
    ss << "A2 , \\field Node 1 Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\object-list AirflowNetworkNodeNames\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note Enter the name of zone or AirflowNetwork Node.\n";
    ss << "A3 , \\field Node 2 Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\object-list AirflowNetworkNodeNames\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note Enter the name of zone or AirflowNetwork Node.\n";
    ss << "A4 , \\field Component Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirflowNetworkComponentNames\n";
    ss << "\\note Enter the name of an AirflowNetwork component. A component is one of the\n";
    ss << "\\note following AirflowNetwork:Multizone:Component objects:\n";
    ss << "\\note AirflowNetwork:MultiZone:Surface:Crack,\n";
    ss << "\\note AirflowNetwork:MultiZone:Surface:EffectiveLeakageArea,\n";
    ss << "\\note If the next field is specified, this field can be either blank or ignored.\n";
    ss << "A5 ; \\field AirflowNetwork:MultiZone:Surface Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfAndSubSurfNames\n";
    ss << "\\note Only used when one of two nodes defined above are not located in the same zone, and\n";
    ss << "\\note the input of the Component Name field in this object is ignored\n";

    IddObjectType objType(IddObjectType::AirflowNetwork_IntraZone_Linkage);
    OptionalIddObject oObj = IddObject::load("AirflowNetwork:IntraZone:Linkage",
                                             "Natural Ventilation and Duct Leakage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirflowNetwork_IntraZone_Linkage);
  return object;
}

IddObject createExterior_LightsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Exterior:Lights,\n";
    ss << "\\memo only used for Meter type reporting, does not affect building loads\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ExteriorLightsNames\n";
    ss << "A2 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note units in schedule should be fraction applied to capacity of the exterior lights equipment, generally (0.0 - 1.0)\n";
    ss << "N1 , \\field Design Level\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\ip-units W\n";
    ss << "A3,  \\field Control Option\n";
    ss << "\\note Astronomical Clock option overrides schedule to turn lights off when sun is up\n";
    ss << "\\type choice\n";
    ss << "\\key ScheduleNameOnly\n";
    ss << "\\key AstronomicalClock\n";
    ss << "A4 ; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::Exterior_Lights);
    OptionalIddObject oObj = IddObject::load("Exterior:Lights",
                                             "Exterior Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Exterior_Lights);
  return object;
}

IddObject createExterior_FuelEquipmentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Exterior:FuelEquipment,\n";
    ss << "\\memo only used for Meter type reporting, does not affect building loads\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Fuel Use Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key Coal\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\key Steam\n";
    ss << "\\key DistrictHeating\n";
    ss << "\\key DistrictCooling\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note units in schedule should be fraction applied to capacity of the exterior fuel equipment, generally (0.0 - 1.0)\n";
    ss << "N1 , \\field Design Level\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\ip-units W\n";
    ss << "A4 ; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::Exterior_FuelEquipment);
    OptionalIddObject oObj = IddObject::load("Exterior:FuelEquipment",
                                             "Exterior Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Exterior_FuelEquipment);
  return object;
}

IddObject createExterior_WaterEquipmentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Exterior:WaterEquipment,\n";
    ss << "\\memo only used for Meter type reporting, does not affect building loads\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Fuel Use Type\n";
    ss << "\\type choice\n";
    ss << "\\key Water\n";
    ss << "\\default Water\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note units in Schedule should be fraction applied to capacity of the exterior water equipment, generally (0.0 - 1.0)\n";
    ss << "N1 , \\field Design Level\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "A4 ; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::Exterior_WaterEquipment);
    OptionalIddObject oObj = IddObject::load("Exterior:WaterEquipment",
                                             "Exterior Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Exterior_WaterEquipment);
  return object;
}

IddObject createHVACTemplate_ThermostatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Thermostat,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo Zone thermostat control.  Referenced schedules must be\n";
    ss << "\\memo defined elsewhere in the idf.  Thermostat control type is\n";
    ss << "\\memo dual setpoint with deadband.  It is not necessary to create\n";
    ss << "\\memo a thermostat object for every zone, only for each unique\n";
    ss << "\\memo set of setpoint schedules.  For example, an office building\n";
    ss << "\\memo may have two thermostat objects, one for \"Office\" and one\n";
    ss << "\\memo for \"Storage\".\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\note This name is referenced by HVACTemplate:Zone:* objects\n";
    ss << "\\reference CompactHVACThermostats\n";
    ss << "A2, \\field Heating Setpoint Schedule Name\n";
    ss << "\\note  Leave blank if constant setpoint specified below, must enter schedule or constant setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Constant Heating Setpoint\n";
    ss << "\\note  Ignored if schedule specified above, must enter schedule or constant setpoint\n";
    ss << "\\units C\n";
    ss << "A3, \\field Cooling Setpoint Schedule Name\n";
    ss << "\\note  Leave blank if constant setpoint specified below, must enter schedule or constant setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N2; \\field Constant Cooling Setpoint\n";
    ss << "\\note  Ignored if schedule specified above, must enter schedule or constant setpoint\n";
    ss << "\\units C\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Thermostat);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Thermostat",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Thermostat);
  return object;
}

IddObject createHVACTemplate_Zone_IdealLoadsAirSystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Zone:IdealLoadsAirSystem,\n";
    ss << "\\min-fields 26\n";
    ss << "\\memo Zone with ideal air system that meets heating or cooling loads\n";
    ss << "A1,  \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone name must match a building zone name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A2,  \\field Template Thermostat Name\n";
    ss << "\\note Enter the name of a HVACTemplate:Thermostat object.\n";
    ss << "\\note If blank, then it is assumed that standard thermostat objects\n";
    ss << "\\note have been defined for this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACThermostats\n";
    ss << "A3, \\field System Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1,  \\field Maximum Heating Supply Air Temperature\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum< 100\n";
    ss << "\\default 50\n";
    ss << "N2,  \\field Minimum Cooling Supply Air Temperature\n";
    ss << "\\units C\n";
    ss << "\\minimum> -100\n";
    ss << "\\maximum< 50\n";
    ss << "\\default 13\n";
    ss << "N3,  \\field Maximum Heating Supply Air Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.0156\n";
    ss << "N4,  \\field Minimum Cooling Supply Air Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.0077\n";
    ss << "A4,  \\field Heating Limit\n";
    ss << "\\type choice\n";
    ss << "\\key NoLimit\n";
    ss << "\\key LimitFlowRate\n";
    ss << "\\key LimitCapacity\n";
    ss << "\\key LimitFlowRateAndCapacity\n";
    ss << "\\default NoLimit\n";
    ss << "N5,  \\field Maximum Heating Air Flow Rate\n";
    ss << "\\note This field is ignored if Heating Limit = NoLimit\n";
    ss << "\\note If this field is blank, there is no limit.\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N6,  \\field Maximum Sensible Heating Capacity\n";
    ss << "\\note This field is ignored if Heating Limit = NoLimit\n";
    ss << "\\note If this field is blank, there is no limit.\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "A5,  \\field Cooling Limit\n";
    ss << "\\type choice\n";
    ss << "\\key NoLimit\n";
    ss << "\\key LimitFlowRate\n";
    ss << "\\key LimitCapacity\n";
    ss << "\\key LimitFlowRateAndCapacity\n";
    ss << "\\default NoLimit\n";
    ss << "N7,  \\field Maximum Cooling Air Flow Rate\n";
    ss << "\\note This field is ignored if Cooling Limit = NoLimit\n";
    ss << "\\note This field is required if Outdoor Air Economizer Type is anything other than NoEconomizer.\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N8,  \\field Maximum Total Cooling Capacity\n";
    ss << "\\note This field is ignored if Cooling Limit = NoLimit\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "A6,  \\field Heating Availability Schedule Name\n";
    ss << "\\note If blank, heating is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A7,  \\field Cooling Availability Schedule Name\n";
    ss << "\\note If blank, cooling is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A8,  \\field Dehumidification Control Type\n";
    ss << "\\note ConstantSensibleHeatRatio means that the ideal loads system\n";
    ss << "\\note will be controlled to meet the sensible cooling load, and the\n";
    ss << "\\note latent cooling rate will be computed using a constant\n";
    ss << "\\note sensible heat ratio (SHR)\n";
    ss << "\\note Humidistat means that there is a ZoneControl:Humidistat for this\n";
    ss << "\\note zone and the ideal loads system will attempt to satisfy the humidistat.\n";
    ss << "\\note None means that there is no dehumidification.\n";
    ss << "\\note ConstantSupplyHumidityRatio means that during cooling the supply air\n";
    ss << "\\note will always be at the Minimum Cooling Supply Humidity Ratio.\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantSensibleHeatRatio\n";
    ss << "\\key Humidistat\n";
    ss << "\\key None\n";
    ss << "\\key ConstantSupplyHumidityRatio\n";
    ss << "\\default ConstantSensibleHeatRatio\n";
    ss << "N9,  \\field Cooling Sensible Heat Ratio\n";
    ss << "\\note This field is applicable only when Dehumidification Control Type is ConstantSensibleHeatRatio\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N10, \\field Dehumidification Setpoint\n";
    ss << "\\note Zone relative humidity setpoint in percent (0 to 100)\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\default 60.0\n";
    ss << "\\units percent\n";
    ss << "A9,  \\field Humidification Control Type\n";
    ss << "\\note None means that there is no humidification.\n";
    ss << "\\note Humidistat means that there is a ZoneControl:Humidistat for this\n";
    ss << "\\note zone and the ideal loads system will attempt to satisfy the humidistat.\n";
    ss << "\\note ConstantSupplyHumidityRatio means that during heating the supply air\n";
    ss << "\\note will always be at the Maximum Heating Supply Humidity Ratio.\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Humidistat\n";
    ss << "\\key ConstantSupplyHumidityRatio\n";
    ss << "\\default None\n";
    ss << "N11, \\field Humidification Setpoint\n";
    ss << "\\note Zone relative humidity setpoint in percent (0 to 100)\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\default 30.0\n";
    ss << "\\units percent\n";
    ss << "A10, \\field Outdoor Air Method\n";
    ss << "\\note None means there is no outdoor air and all related fields will be ignored\n";
    ss << "\\note Flow/Person, Flow/Zone, Flow/Area, Sum, and Maximum use the values in the next three\n";
    ss << "\\note fields: Outdoor Air Flow Rate per Person, Outdoor Air Flow Rate per Zone Floor Area,\n";
    ss << "\\note and Outdoor Air Flow Rate per Zone.\n";
    ss << "\\note DetailedSpecification ignores these three Outdoor Air Flow Rate fields and instead\n";
    ss << "\\note references design specification objects named in the fields\n";
    ss << "\\note Design Specification Outdoor Air Object Name and Design Specification Zone Air\n";
    ss << "\\note Distribution Object Name.\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Flow/Person\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Sum\n";
    ss << "\\key Maximum\n";
    ss << "\\key DetailedSpecification\n";
    ss << "\\default None\n";
    ss << "N12, \\field Outdoor Air Flow Rate per Person\n";
    ss << "\\units m3/s\n";
    ss << "\\note Default 0.00944 is 20 cfm per person\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Person, Sum, or Maximum\n";
    ss << "\\default 0.00944\n";
    ss << "N13, \\field Outdoor Air Flow Rate per Zone Floor Area\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Area, Sum, or Maximum\n";
    ss << "N14, \\field Outdoor Air Flow Rate per Zone\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Zone, Sum, or Maximum\n";
    ss << "A11, \\field Design Specification Outdoor Air Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "\\note When the name of a DesignSpecification:OutdoorAir object is entered, the minimum\n";
    ss << "\\note outdoor air flow rate will be computed using these specifications. The outdoor air\n";
    ss << "\\note flow rate will also be affected by the next two fields.\n";
    ss << "\\note If this field is blank, there will be no outdoor air and the remaining fields will\n";
    ss << "\\note be ignored.\n";
    ss << "A12, \\field Demand Controlled Ventilation Type\n";
    ss << "\\note This field controls how the minimum outdoor air flow rate is calculated.\n";
    ss << "\\note None means that design occupancy will be used to compute the minimum outdoor air flow rate\n";
    ss << "\\note OccupancySchedule means that current occupancy level will be used.\n";
    ss << "\\note CO2Setpoint means that the design occupancy will be used to compute the minimum outdoor air flow\n";
    ss << "\\note rate and the outdoor air flow rate may be increased if necessary to maintain the indoor air carbon\n";
    ss << "\\note dioxide setpoint defined in a ZoneControl:ContaminantController object.\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key OccupancySchedule\n";
    ss << "\\key CO2Setpoint\n";
    ss << "\\default None\n";
    ss << "A13, \\field Outdoor Air Economizer Type\n";
    ss << "\\note DifferentialDryBulb and DifferentialEnthalpy will increase the outdoor air flow rate\n";
    ss << "\\note when there is a cooling load and the outdoor air temperature or enthalpy\n";
    ss << "\\note is below the zone exhaust air temperature or enthalpy.\n";
    ss << "\\type choice\n";
    ss << "\\key NoEconomizer\n";
    ss << "\\key DifferentialDryBulb\n";
    ss << "\\key DifferentialEnthalpy\n";
    ss << "\\default NoEconomizer\n";
    ss << "A14, \\field Heat Recovery Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Sensible\n";
    ss << "\\key Enthalpy\n";
    ss << "\\default None\n";
    ss << "N15, \\field Sensible Heat Recovery Effectiveness\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.70\n";
    ss << "N16; \\field Latent Heat Recovery Effectiveness\n";
    ss << "\\note Applicable only if Heat Recovery Type is Enthalpy.\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.65\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Zone_IdealLoadsAirSystem);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Zone:IdealLoadsAirSystem",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Zone_IdealLoadsAirSystem);
  return object;
}

IddObject createHVACTemplate_Zone_BaseboardHeatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Zone:BaseboardHeat,\n";
    ss << "\\min-fields 11\n";
    ss << "\\memo Zone baseboard heating system.\n";
    ss << "A1, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone name must match a building zone name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A2, \\field Template Thermostat Name\n";
    ss << "\\note Enter the name of a HVACTemplate:Thermostat object.\n";
    ss << "\\note If blank, then it is assumed that standard thermostat objects\n";
    ss << "\\note have been defined for this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACThermostats\n";
    ss << "N1, \\field Zone Heating Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "A3, \\field Baseboard Heating Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\default HotWater\n";
    ss << "A4, \\field Baseboard Heating Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N2, \\field Baseboard Heating Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "A5, \\field Dedicated Outdoor Air System Name\n";
    ss << "\\note Enter the name of an HVACTemplate:System:DedicatedOutdoorAir object if this\n";
    ss << "\\note zone is served by a separate dedicated outdoor air system (DOAS).\n";
    ss << "\\note Leave field blank if no DOAS serves this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HVACTemplateDOASSystems\n";
    ss << "A6, \\field Outdoor Air Method\n";
    ss << "\\note Flow/Person, Flow/Zone, Flow/Area, Sum, and Maximum use the values in the next three\n";
    ss << "\\note fields: Outdoor Air Flow Rate per Person, Outdoor Air Flow Rate per Zone Floor Area,\n";
    ss << "\\note and Outdoor Air Flow Rate per Zone.\n";
    ss << "\\note DetailedSpecification ignores these three Outdoor Air Flow Rate fields and instead\n";
    ss << "\\note references design specification objects named in the fields\n";
    ss << "\\note Design Specification Outdoor Air Object Name and Design Specification Zone Air\n";
    ss << "\\note Distribution Object Name.\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Person\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Sum\n";
    ss << "\\key Maximum\n";
    ss << "\\key DetailedSpecification\n";
    ss << "\\default Flow/Person\n";
    ss << "N3, \\field Outdoor Air Flow Rate per Person\n";
    ss << "\\units m3/s\n";
    ss << "\\note Default 0.00944 is 20 cfm per person\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Person, Sum, or Maximum\n";
    ss << "\\default 0.00944\n";
    ss << "N4, \\field Outdoor Air Flow Rate per Zone Floor Area\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Area, Sum, or Maximum\n";
    ss << "N5, \\field Outdoor Air Flow Rate per Zone\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Zone, Sum, or Maximum\n";
    ss << "A7, \\field Design Specification Outdoor Air Object name\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "A8; \\field Design Specification Zone Air Distribution Object Name\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneAirDistributionNames\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Zone_BaseboardHeat);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Zone:BaseboardHeat",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Zone_BaseboardHeat);
  return object;
}

IddObject createHVACTemplate_Zone_FanCoilIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Zone:FanCoil,\n";
    ss << "\\min-fields 34\n";
    ss << "\\memo 4 pipe fan coil unit with optional outdoor air.\n";
    ss << "A1, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone name must match a building zone name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A2, \\field Template Thermostat Name\n";
    ss << "\\note Enter the name of a HVACTemplate:Thermostat object.\n";
    ss << "\\note If blank, then it is assumed that standard thermostat objects\n";
    ss << "\\note have been defined for this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACThermostats\n";
    ss << "N1, \\field Supply Air Maximum Flow Rate\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will be\n";
    ss << "\\note multiplied by the Supply Air Sizing Factor and by zone multipliers.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "N2, \\field Zone Heating Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "N3, \\field Zone Cooling Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "A3, \\field Outdoor Air Method\n";
    ss << "\\note Flow/Person, Flow/Zone, Flow/Area, Sum, and Maximum use the values in the next three\n";
    ss << "\\note fields: Outdoor Air Flow Rate per Person, Outdoor Air Flow Rate per Zone Floor Area,\n";
    ss << "\\note and Outdoor Air Flow Rate per Zone.\n";
    ss << "\\note DetailedSpecification ignores these three Outdoor Air Flow Rate fields and instead\n";
    ss << "\\note references design specification objects named in the fields\n";
    ss << "\\note Design Specification Outdoor Air Object Name and Design Specification Zone Air\n";
    ss << "\\note Distribution Object Name.\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Person\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Sum\n";
    ss << "\\key Maximum\n";
    ss << "\\key DetailedSpecification\n";
    ss << "\\default Flow/Person\n";
    ss << "N4, \\field Outdoor Air Flow Rate per Person\n";
    ss << "\\units m3/s\n";
    ss << "\\note Default 0.00944 is 20 cfm per person\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Person, Sum, or Maximum\n";
    ss << "\\default 0.00944\n";
    ss << "N5, \\field Outdoor Air Flow Rate per Zone Floor Area\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Area, Sum, or Maximum\n";
    ss << "N6, \\field Outdoor Air Flow Rate per Zone\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Zone, Sum, or Maximum\n";
    ss << "A4, \\field System Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N7, \\field Supply Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N8, \\field Supply Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 75\n";
    ss << "N9, \\field Supply Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N10, \\field Supply Fan Motor in Air Stream Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A5, \\field Cooling Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  ChilledWater\n";
    ss << "\\key  ChilledWaterDetailedFlatModel\n";
    ss << "\\default  ChilledWater\n";
    ss << "A6, \\field Cooling Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N11, \\field Cooling Coil Design Setpoint\n";
    ss << "\\note Used for sizing when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "\\default 14.0\n";
    ss << "\\units C\n";
    ss << "A7, \\field Heating Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\default HotWater\n";
    ss << "A8, \\field Heating Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N12, \\field Heating Coil Design Setpoint\n";
    ss << "\\note Used for sizing when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "\\default 50.0\n";
    ss << "\\units C\n";
    ss << "A9, \\field Dedicated Outdoor Air System Name\n";
    ss << "\\note Enter the name of an HVACTemplate:System:DedicatedOutdoorAir object if this\n";
    ss << "\\note zone is served by a separate dedicated outdoor air system (DOAS).\n";
    ss << "\\note Leave field blank if no DOAS serves this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HVACTemplateDOASSystems\n";
    ss << "A10, \\field Zone Cooling Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Cooling Coil Design Setpoint (above)\n";
    ss << "\\note TemperatureDifference = use the value from Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\default SupplyAirTemperature\n";
    ss << "N13, \\field Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 11.11\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be subtracted from the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Cooling Design Supply Air Temperature.\n";
    ss << "A11, \\field Zone Heating Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Heating Coil Design Setpoint (above)\n";
    ss << "\\note TemperatureDifference = use the value from Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\default SupplyAirTemperature\n";
    ss << "N14, \\field Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 30.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be added to the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Heating Design Supply Air Temperature.\n";
    ss << "A12, \\field Design Specification Outdoor Air Object Name\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "A13, \\field Design Specification Zone Air Distribution Object Name\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneAirDistributionNames\n";
    ss << "A14, \\field Capacity Control Method\n";
    ss << "\\note If this field is left blank, it will default to CyclingFan if a Dedicated Outdoor Air\n";
    ss << "\\note System is specified (see above), otherwise it will default to ConstantFanVariableFlow.\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantFanVariableFlow\n";
    ss << "\\key CyclingFan\n";
    ss << "\\key VariableFanVariableFlow\n";
    ss << "\\key VariableFanConstantFlow\n";
    ss << "N15, \\field Low Speed Supply Air Flow Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.33\n";
    ss << "N16, \\field Medium Speed Supply Air Flow Ratio\n";
    ss << "\\note Medium Speed Supply Air Flow Ratio should be greater\n";
    ss << "\\note than Low Speed Supply Air Flow Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.66\n";
    ss << "A15, \\field Outdoor Air Schedule Name\n";
    ss << "\\note Value of schedule multiplies maximum outdoor air flow rate\n";
    ss << "\\note This schedule is ignored if this zone is served by an HVACTemplate dedicated outdoor\n";
    ss << "\\note air system.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A16, \\field Baseboard Heating Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A17, \\field Baseboard Heating Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N17; \\field Baseboard Heating Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Zone_FanCoil);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Zone:FanCoil",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Zone_FanCoil);
  return object;
}

IddObject createHVACTemplate_Zone_PTACIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Zone:PTAC,\n";
    ss << "\\min-fields 39\n";
    ss << "\\memo Packaged Terminal Air Conditioner\n";
    ss << "A1, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone name must match a building zone name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A2, \\field Template Thermostat Name\n";
    ss << "\\note Enter the name of a HVACTemplate:Thermostat object.\n";
    ss << "\\note If blank, then it is assumed that standard thermostat objects\n";
    ss << "\\note have been defined for this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACThermostats\n";
    ss << "N1, \\field Cooling Supply Air Flow Rate\n";
    ss << "\\note Supply air flow rate during cooling operation\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will be\n";
    ss << "\\note multiplied by the Supply Air Sizing Factor and by zone multipliers.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "N2, \\field Heating Supply Air Flow Rate\n";
    ss << "\\note Supply air flow rate during heating operation\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will be\n";
    ss << "\\note multiplied by the Supply Air Sizing Factor and by zone multipliers.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "N3, \\field No Load Supply Air Flow Rate\n";
    ss << "\\note Supply air flow rate when no cooling or heating is needed\n";
    ss << "\\note Only used when heat pump fan operating mode is continuous. This air flow rate\n";
    ss << "\\note is used when no heating or cooling is required and the DX coil compressor is off.\n";
    ss << "\\note If this field is left blank or zero, the supply air flow rate from the previous on cycle\n";
    ss << "\\note (either cooling or heating) is used.\n";
    ss << "\\note A value entered in this field will *not* be multiplied by the sizing factor or\n";
    ss << "\\note by zone multipliers.  It is best to autosize or leave blank when using zone multipliers.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "N4, \\field Zone Heating Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "N5, \\field Zone Cooling Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "A3, \\field Outdoor Air Method\n";
    ss << "\\note Flow/Person, Flow/Zone, Flow/Area, Sum, and Maximum use the values in the next three\n";
    ss << "\\note fields: Outdoor Air Flow Rate per Person, Outdoor Air Flow Rate per Zone Floor Area,\n";
    ss << "\\note and Outdoor Air Flow Rate per Zone.\n";
    ss << "\\note DetailedSpecification ignores these three Outdoor Air Flow Rate fields and instead\n";
    ss << "\\note references design specification objects named in the fields\n";
    ss << "\\note Design Specification Outdoor Air Object Name and Design Specification Zone Air\n";
    ss << "\\note Distribution Object Name.\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Person\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Sum\n";
    ss << "\\key Maximum\n";
    ss << "\\key DetailedSpecification\n";
    ss << "\\default Flow/Person\n";
    ss << "N6, \\field Outdoor Air Flow Rate per Person\n";
    ss << "\\units m3/s\n";
    ss << "\\note Default 0.00944 is 20 cfm per person\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Person, Sum, or Maximum\n";
    ss << "\\default 0.00944\n";
    ss << "N7, \\field Outdoor Air Flow Rate per Zone Floor Area\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Area, Sum, or Maximum\n";
    ss << "N8, \\field Outdoor Air Flow Rate per Zone\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Zone, Sum, or Maximum\n";
    ss << "A4, \\field System Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5, \\field Supply Fan Operating Mode Schedule Name\n";
    ss << "\\note Refers to a schedule to specify unitary supply fan operating mode.\n";
    ss << "\\note Schedule Name values of 0 indicate cycling fan (auto)\n";
    ss << "\\note Schedule values of 1 indicate continuous fan (on)\n";
    ss << "\\note If this field is left blank, a schedule of always zero (cycling fan) will be used.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6, \\field Supply Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default DrawThrough\n";
    ss << "N9, \\field Supply Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N10, \\field Supply Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 75\n";
    ss << "N11, \\field Supply Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "A7, \\field Cooling Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  SingleSpeedDX\n";
    ss << "\\default SingleSpeedDX\n";
    ss << "A8, \\field Cooling Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N12, \\field Cooling Coil Gross Rated Total Capacity\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\note Rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N13, \\field Cooling Coil Gross Rated Sensible Heat Ratio\n";
    ss << "\\note Rated sensible heat ratio (gross sensible capacity/gross total capacity)\n";
    ss << "\\note Sensible and total capacities do not include effect of supply fan heat\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default autosize\n";
    ss << "N14, \\field Cooling Coil Gross Rated Cooling COP\n";
    ss << "\\note Gross cooling capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply fan heat or supply fan electrical energy input\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.0\n";
    ss << "A9, \\field Heating Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  Electric\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Gas\n";
    ss << "\\default Electric\n";
    ss << "A10, \\field Heating Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N15, \\field Heating Coil Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N16, \\field Gas Heating Coil Efficiency\n";
    ss << "\\note Applies only if Heating Coil Type is Gas\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.8\n";
    ss << "N17, \\field Gas Heating Coil Parasitic Electric Load\n";
    ss << "\\note Applies only if Heating Coil Type is Gas\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "A11, \\field Dedicated Outdoor Air System Name\n";
    ss << "\\note Enter the name of an HVACTemplate:System:DedicatedOutdoorAir object if this\n";
    ss << "\\note zone is served by a separate dedicated outdoor air system (DOAS).\n";
    ss << "\\note Leave field blank if no DOAS serves this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HVACTemplateDOASSystems\n";
    ss << "A12, \\field Zone Cooling Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Cooling Design Supply Air Temperature\n";
    ss << "\\note TemperatureDifference = use the value from Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\default SupplyAirTemperature\n";
    ss << "N18, \\field Zone Cooling Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 14.0\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N19, \\field Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 11.11\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be subtracted from the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Cooling Design Supply Air Temperature.\n";
    ss << "A13, \\field Zone Heating Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Heating Design Supply Air Temperature\n";
    ss << "\\note TemperatureDifference = use the value from Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\default SupplyAirTemperature\n";
    ss << "N20, \\field Zone Heating Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 50.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N21, \\field Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 30.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be added to the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Heating Design Supply Air Temperature.\n";
    ss << "A14, \\field Design Specification Outdoor Air Object Name\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "A15, \\field Design Specification Zone Air Distribution Object Name\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneAirDistributionNames\n";
    ss << "A16, \\field Baseboard Heating Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A17, \\field Baseboard Heating Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N22; \\field Baseboard Heating Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Zone_PTAC);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Zone:PTAC",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Zone_PTAC);
  return object;
}

IddObject createHVACTemplate_Zone_PTHPIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Zone:PTHP,\n";
    ss << "\\min-fields 49\n";
    ss << "\\memo Packaged Terminal Heat Pump\n";
    ss << "A1, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone name must match a building zone name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A2, \\field Template Thermostat Name\n";
    ss << "\\note Enter the name of a HVACTemplate:Thermostat object.\n";
    ss << "\\note If blank, then it is assumed that standard thermostat objects\n";
    ss << "\\note have been defined for this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACThermostats\n";
    ss << "N1, \\field Cooling Supply Air Flow Rate\n";
    ss << "\\note Supply air flow rate during cooling operation\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will be\n";
    ss << "\\note multiplied by the Supply Air Sizing Factor and by zone multipliers.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "N2, \\field Heating Supply Air Flow Rate\n";
    ss << "\\note Supply air flow rate during heating operation\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will be\n";
    ss << "\\note multiplied by the Supply Air Sizing Factor and by zone multipliers.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "N3, \\field No Load Supply Air Flow Rate\n";
    ss << "\\note Supply air flow rate when no cooling or heating is needed\n";
    ss << "\\note Only used when heat pump fan operating mode is continuous. This air flow rate\n";
    ss << "\\note is used when no heating or cooling is required and the DX coil compressor is off.\n";
    ss << "\\note If this field is left blank or zero, the supply air flow rate from the previous on cycle\n";
    ss << "\\note (either cooling or heating) is used.\n";
    ss << "\\note A value entered in this field will *not* be multiplied by the sizing factor or\n";
    ss << "\\note by zone multipliers.  It is best to autosize or leave blank when using zone multipliers.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "N4, \\field Zone Heating Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "N5, \\field Zone Cooling Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "A3, \\field Outdoor Air Method\n";
    ss << "\\note Flow/Person, Flow/Zone, Flow/Area, Sum, and Maximum use the values in the next three\n";
    ss << "\\note fields: Outdoor Air Flow Rate per Person, Outdoor Air Flow Rate per Zone Floor Area,\n";
    ss << "\\note and Outdoor Air Flow Rate per Zone.\n";
    ss << "\\note DetailedSpecification ignores these three Outdoor Air Flow Rate fields and instead\n";
    ss << "\\note references design specification objects named in the fields\n";
    ss << "\\note Design Specification Outdoor Air Object Name and Design Specification Zone Air\n";
    ss << "\\note Distribution Object Name.\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Person\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Sum\n";
    ss << "\\key Maximum\n";
    ss << "\\key DetailedSpecification\n";
    ss << "\\default Flow/Person\n";
    ss << "N6, \\field Outdoor Air Flow Rate per Person\n";
    ss << "\\units m3/s\n";
    ss << "\\note Default 0.00944 is 20 cfm per person\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Person, Sum, or Maximum\n";
    ss << "\\default 0.00944\n";
    ss << "N7, \\field Outdoor Air Flow Rate per Zone Floor Area\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Area, Sum, or Maximum\n";
    ss << "N8, \\field Outdoor Air Flow Rate per Zone\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Zone, Sum, or Maximum\n";
    ss << "A4, \\field System Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5, \\field Supply Fan Operating Mode Schedule Name\n";
    ss << "\\note Refers to a schedule to specify unitary supply fan operating mode.\n";
    ss << "\\note Schedule values of 0 indicate cycling fan (auto)\n";
    ss << "\\note Schedule values of 1 indicate continuous fan (on)\n";
    ss << "\\note If this field is left blank, a schedule of always zero (cycling fan) will be used.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6, \\field Supply Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default DrawThrough\n";
    ss << "N9, \\field Supply Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N10, \\field Supply Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 75\n";
    ss << "N11, \\field Supply Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "A7, \\field Cooling Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  SingleSpeedDX\n";
    ss << "\\default SingleSpeedDX\n";
    ss << "A8, \\field Cooling Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N12, \\field Cooling Coil Gross Rated Total Capacity\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\note Rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N13, \\field Cooling Coil Gross Rated Sensible Heat Ratio\n";
    ss << "\\note Rated sensible heat ratio (gross sensible capacity/gross total capacity)\n";
    ss << "\\note Sensible and total capacities do not include effect of supply fan heat\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default autosize\n";
    ss << "N14, \\field Cooling Coil Gross Rated COP\n";
    ss << "\\note Gross cooling capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply fan heat or supply fan electrical energy input\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.0\n";
    ss << "A9, \\field Heat Pump Heating Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  SingleSpeedDXHeatPump\n";
    ss << "\\default SingleSpeedDXHeatPump\n";
    ss << "A10, \\field Heat Pump Heating Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N15, \\field Heat Pump Heating Coil Gross Rated Capacity\n";
    ss << "\\note Capacity excluding supply air fan heat\n";
    ss << "\\note Rating point outdoor dry-bulb temp 8.33 C, outdoor wet-bulb temp 6.11 C\n";
    ss << "\\note Rating point heating coil entering air dry-bulb 21.11 C, coil entering wet-bulb 15.55 C\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N16, \\field Heat Pump Heating Coil Gross Rated COP\n";
    ss << "\\note Heat Pump Heating Coil Rated Capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note Does not include supply air fan heat or supply air fan electrical energy\n";
    ss << "\\note Rating point outdoor dry-bulb temp 8.33 C, outdoor wet-bulb temp 6.11 C\n";
    ss << "\\note Rating point heating coil entering air dry-bulb 21.11 C, coil entering wet-bulb 15.55 C\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 2.75\n";
    ss << "N17, \\field Heat Pump Heating Minimum Outdoor Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\minimum -20.0\n";
    ss << "\\default -8.0\n";
    ss << "\\units C\n";
    ss << "N18, \\field Heat Pump Defrost Maximum Outdoor Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 7.22\n";
    ss << "\\default 5.0\n";
    ss << "\\units C\n";
    ss << "A11, \\field Heat Pump Defrost Strategy\n";
    ss << "\\type choice\n";
    ss << "\\key ReverseCycle\n";
    ss << "\\key Resistive\n";
    ss << "\\default ReverseCycle\n";
    ss << "A12, \\field Heat Pump Defrost Control\n";
    ss << "\\type choice\n";
    ss << "\\key Timed\n";
    ss << "\\key OnDemand\n";
    ss << "\\default Timed\n";
    ss << "N19, \\field Heat Pump Defrost Time Period Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.058333\n";
    ss << "\\note Fraction of time in defrost mode\n";
    ss << "\\note only applicable if Timed defrost control is specified\n";
    ss << "A13, \\field Supplemental Heating Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  Electric\n";
    ss << "\\key  Gas\n";
    ss << "\\key  HotWater\n";
    ss << "\\default Electric\n";
    ss << "A14, \\field Supplemental Heating Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N20, \\field Supplemental Heating Coil Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N21, \\field Supplemental Heating Coil Maximum Outdoor Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\maximum 21.0\n";
    ss << "\\default 21.0\n";
    ss << "\\units C\n";
    ss << "\\note Supplemental heater will not operate when outdoor temperature exceeds this value.\n";
    ss << "N22, \\field Supplemental Gas Heating Coil Efficiency\n";
    ss << "\\note Applies only if Supplemental Heating Coil Type is Gas\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.8\n";
    ss << "N23, \\field Supplemental Gas Heating Coil Parasitic Electric Load\n";
    ss << "\\note Applies only if Supplemental Heating Coil Type is Gas\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "A15, \\field Dedicated Outdoor Air System Name\n";
    ss << "\\note Enter the name of an HVACTemplate:System:DedicatedOutdoorAir object if this\n";
    ss << "\\note zone is served by a separate dedicated outdoor air system (DOAS).\n";
    ss << "\\note Leave field blank if no DOAS serves this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HVACTemplateDOASSystems\n";
    ss << "A16, \\field Zone Cooling Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Cooling Design Supply Air Temperature\n";
    ss << "\\note TemperatureDifference = use the value from Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\default SupplyAirTemperature\n";
    ss << "N24, \\field Zone Cooling Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 14.0\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N25, \\field Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 11.11\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be subtracted from the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Cooling Design Supply Air Temperature.\n";
    ss << "A17, \\field Zone Heating Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Heating Design Supply Air Temperature\n";
    ss << "\\note TemperatureDifference = use the value from Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\default SupplyAirTemperature\n";
    ss << "N26, \\field Zone Heating Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 50.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N27, \\field Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 30.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be added to the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Heating Design Supply Air Temperature.\n";
    ss << "A18, \\field Design Specification Outdoor Air Object Name\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "A19, \\field Design Specification Zone Air Distribution Object Name\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneAirDistributionNames\n";
    ss << "A20, \\field Baseboard Heating Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A21, \\field Baseboard Heating Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N28; \\field Baseboard Heating Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Zone_PTHP);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Zone:PTHP",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Zone_PTHP);
  return object;
}

IddObject createHVACTemplate_Zone_WaterToAirHeatPumpIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Zone:WaterToAirHeatPump,\n";
    ss << "\\min-fields 44\n";
    ss << "\\memo Water to Air Heat Pump to be used with HVACTemplate:Plant:MixedWaterLoop\n";
    ss << "A1, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone name must match a building zone name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A2, \\field Template Thermostat Name\n";
    ss << "\\note Enter the name of a HVACTemplate:Thermostat object.\n";
    ss << "\\note If blank, then it is assumed that standard thermostat objects\n";
    ss << "\\note have been defined for this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACThermostats\n";
    ss << "N1, \\field Cooling Supply Air Flow Rate\n";
    ss << "\\note Supply air flow rate during cooling operation\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will be\n";
    ss << "\\note multiplied by the Supply Air Sizing Factor and by zone multipliers.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "N2, \\field Heating Supply Air Flow Rate\n";
    ss << "\\note Supply air flow rate during heating operation\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will be\n";
    ss << "\\note multiplied by the Supply Air Sizing Factor and by zone multipliers.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "N3, \\field No Load Supply Air Flow Rate\n";
    ss << "\\note Supply air flow rate when no cooling or heating is needed\n";
    ss << "\\note Only used when heat pump fan operating mode is continuous. This air flow rate\n";
    ss << "\\note is used when no heating or cooling is required.\n";
    ss << "\\note If this field is left blank or zero, the supply air flow rate from the previous on cycle\n";
    ss << "\\note (either cooling or heating) is used.\n";
    ss << "\\note A value entered in this field will *not* be multiplied by the sizing factor or\n";
    ss << "\\note by zone multipliers.  It is best to autosize or leave blank when using zone multipliers.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "N4, \\field Zone Heating Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "N5, \\field Zone Cooling Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "A3, \\field Outdoor Air Method\n";
    ss << "\\note Flow/Person, Flow/Zone, Flow/Area, Sum, and Maximum use the values in the next three\n";
    ss << "\\note fields: Outdoor Air Flow Rate per Person, Outdoor Air Flow Rate per Zone Floor Area,\n";
    ss << "\\note and Outdoor Air Flow Rate per Zone.\n";
    ss << "\\note DetailedSpecification ignores these three Outdoor Air Flow Rate fields and instead\n";
    ss << "\\note references design specification objects named in the fields\n";
    ss << "\\note Design Specification Outdoor Air Object Name and Design Specification Zone Air\n";
    ss << "\\note Distribution Object Name.\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Person\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Sum\n";
    ss << "\\key Maximum\n";
    ss << "\\key DetailedSpecification\n";
    ss << "\\default Flow/Person\n";
    ss << "N6, \\field Outdoor Air Flow Rate per Person\n";
    ss << "\\units m3/s\n";
    ss << "\\note Default 0.00944 is 20 cfm per person\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Person, Sum, or Maximum\n";
    ss << "\\default 0.00944\n";
    ss << "N7, \\field Outdoor Air Flow Rate per Zone Floor Area\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Area, Sum, or Maximum\n";
    ss << "N8, \\field Outdoor Air Flow Rate per Zone\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Zone, Sum, or Maximum\n";
    ss << "A4, \\field System Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5, \\field Supply Fan Operating Mode Schedule Name\n";
    ss << "\\note Refers to a schedule to specify unitary supply fan operating mode.\n";
    ss << "\\note Schedule values of 0 indicate cycling fan (auto)\n";
    ss << "\\note Schedule values of 1 indicate continuous fan (on)\n";
    ss << "\\note If this field is left blank, a schedule of always zero (cycling fan) will be used.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6, \\field Supply Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default DrawThrough\n";
    ss << "N9, \\field Supply Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N10, \\field Supply Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 75\n";
    ss << "N11, \\field Supply Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "A7, \\field Cooling Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  Coil:Cooling:WaterToAirHeatPump:EquationFit\n";
    ss << "\\default Coil:Cooling:WaterToAirHeatPump:EquationFit\n";
    ss << "N12, \\field Cooling Coil Gross Rated Total Capacity\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N13, \\field Cooling Coil Gross Rated Sensible Heat Ratio\n";
    ss << "\\note Rated sensible heat ratio (gross sensible capacity/gross total capacity)\n";
    ss << "\\note Sensible and total capacities do not include effect of supply fan heat\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default autosize\n";
    ss << "N14, \\field Cooling Coil Gross Rated COP\n";
    ss << "\\note Gross cooling capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply fan heat or supply fan electric power input\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.5\n";
    ss << "A8, \\field Heat Pump Heating Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  Coil:Heating:WaterToAirHeatPump:EquationFit\n";
    ss << "\\default Coil:Heating:WaterToAirHeatPump:EquationFit\n";
    ss << "N15, \\field Heat Pump Heating Coil Gross Rated Capacity\n";
    ss << "\\note Capacity excluding supply air fan heat\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N16, \\field Heat Pump Heating Coil Gross Rated COP\n";
    ss << "\\note Heat Pump Heating Coil Rated Capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply air fan heat or supply air fan electric power input\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 4.2\n";
    ss << "A9, \\field Supplemental Heating Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N17, \\field Supplemental Heating Coil Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N18, \\field Maximum Cycling Rate\n";
    ss << "\\type real\n";
    ss << "\\units cycles/hr\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 5.0\n";
    ss << "\\default 2.5\n";
    ss << "\\note The maximum on-off cycling rate for the compressor\n";
    ss << "\\note Suggested value is 2.5 for a typical heat pump\n";
    ss << "N19, \\field Heat Pump Time Constant\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 500.0\n";
    ss << "\\default 60.0\n";
    ss << "\\note Time constant for the cooling coil's capacity to reach steady state after startup\n";
    ss << "\\note Suggested value is 60 for a typical heat pump\n";
    ss << "N20, \\field Fraction of On-Cycle Power Use\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.05\n";
    ss << "\\default 0.01\n";
    ss << "\\note The fraction of on-cycle power use to adjust the part load fraction based on\n";
    ss << "\\note the off-cycle power consumption due to crankcase heaters, controls, fans, and etc.\n";
    ss << "\\note Suggested value is 0.01 for a typical heat pump\n";
    ss << "N21, \\field Heat Pump Fan Delay Time\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 60\n";
    ss << "\\note Programmed time delay for heat pump fan to shut off after compressor cycle off.\n";
    ss << "\\note Only required when fan operating mode is cycling\n";
    ss << "\\note Enter 0 when fan operating mode is continuous\n";
    ss << "A10, \\field Dedicated Outdoor Air System Name\n";
    ss << "\\note Enter the name of an HVACTemplate:System:DedicatedOutdoorAir object if this\n";
    ss << "\\note zone is served by a separate dedicated outdoor air system (DOAS).\n";
    ss << "\\note Leave field blank if no DOAS serves this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HVACTemplateDOASSystems\n";
    ss << "A11, \\field Supplemental Heating Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  Electric\n";
    ss << "\\key  HotWater\n";
    ss << "\\default Electric\n";
    ss << "A12, \\field Zone Cooling Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Cooling Design Supply Air Temperature\n";
    ss << "\\note TemperatureDifference = use the value from Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\default SupplyAirTemperature\n";
    ss << "N22, \\field Zone Cooling Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 14.0\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N23, \\field Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 11.11\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be subtracted from the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Cooling Design Supply Air Temperature.\n";
    ss << "A13, \\field Zone Heating Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Heating Design Supply Air Temperature\n";
    ss << "\\note TemperatureDifference = use the value from Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\default SupplyAirTemperature\n";
    ss << "N24, \\field Zone Heating Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 50.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N25, \\field Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 30.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be added to the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Heating Design Supply Air Temperature.\n";
    ss << "A14, \\field Heat Pump Coil Water Flow Mode\n";
    ss << "\\type choice\n";
    ss << "\\key Constant\n";
    ss << "\\key Cycling\n";
    ss << "\\key ConstantOnDemand\n";
    ss << "\\default Cycling\n";
    ss << "\\note used only when the heat pump coils are of the type WaterToAirHeatPump:EquationFit\n";
    ss << "\\note Constant results in 100% water flow regardless of compressor PLR\n";
    ss << "\\note Cycling results in water flow that matches compressor PLR\n";
    ss << "\\note ConstantOnDemand results in 100% water flow whenever the coil is on, but is 0% whenever the coil has no load\n";
    ss << "A15, \\field Design Specification Outdoor Air Object Name\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "A16, \\field Design Specification Zone Air Distribution Object Name\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneAirDistributionNames\n";
    ss << "A17, \\field Baseboard Heating Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A18, \\field Baseboard Heating Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N26; \\field Baseboard Heating Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Zone_WaterToAirHeatPump);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Zone:WaterToAirHeatPump",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Zone_WaterToAirHeatPump);
  return object;
}

IddObject createHVACTemplate_Zone_VRFIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Zone:VRF,\n";
    ss << "\\memo Zone terminal unit with variable refrigerant flow (VRF) DX cooling and heating coils\n";
    ss << "\\memo (air-to-air or water-to-air heat pump). The VRF terminal units are served by an\n";
    ss << "\\memo HVACTemplate:System:VRF system.\n";
    ss << "\\min-fields 44\n";
    ss << "A1, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone name must match a building zone name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A2, \\field Template VRF System Name\n";
    ss << "\\required-field\n";
    ss << "\\note Name of a HVACTemplate:System:VRF object serving this zone\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACSystemVRF\n";
    ss << "A3, \\field Template Thermostat Name\n";
    ss << "\\note Enter the name of a HVACTemplate:Thermostat object.\n";
    ss << "\\note If blank, then it is assumed that standard thermostat objects\n";
    ss << "\\note have been defined for this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACThermostats\n";
    ss << "N1, \\field Zone Heating Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "N2, \\field Zone Cooling Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "N3, \\field Rated Total Heating Capacity Sizing Ratio\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note If this terminal unit's heating coil is autosized, the heating capacity is sized\n";
    ss << "\\note to be equal to the cooling capacity multiplied by this sizing ratio.\n";
    ss << "\\note This input applies to the terminal unit heating coil and overrides the sizing\n";
    ss << "\\note ratio entered in the HVACTemplate:System:VRF object.\n";
    ss << "N4, \\field Cooling Supply Air Flow Rate\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will be\n";
    ss << "\\note multiplied by the Supply Air Sizing Factor and by zone multipliers.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N5, \\field No Cooling Supply Air Flow Rate\n";
    ss << "\\note This flow rate is used when the terminal is not cooling and the previous mode was cooling.\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will be\n";
    ss << "\\note multiplied by the Supply Air Sizing Factor and by zone multipliers.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N6, \\field Heating Supply Air Flow Rate\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will be\n";
    ss << "\\note multiplied by the Supply Air Sizing Factor and by zone multipliers.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N7, \\field No Heating Supply Air Flow Rate\n";
    ss << "\\note This flow rate is used when the terminal is not heating and the previous mode was heating.\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will be\n";
    ss << "\\note multiplied by the Supply Air Sizing Factor and by zone multipliers.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N8, \\field Cooling Outdoor Air Flow Rate\n";
    ss << "\\note If this field is set to autosize it will be sized based on the outdoor air inputs below,\n";
    ss << "\\note unless a dedicated outdoor air system is specified for this zone and then it will be\n";
    ss << "\\note set to zero.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N9, \\field Heating Outdoor Air Flow Rate\n";
    ss << "\\note If this field is set to autosize it will be sized based on the outdoor air inputs below,\n";
    ss << "\\note unless a dedicated outdoor air system is specified for this zone and then it will be\n";
    ss << "\\note set to zero.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N10, \\field No Load Outdoor Air Flow Rate\n";
    ss << "\\note If this field is set to autosize it will be sized based on the outdoor air inputs below,\n";
    ss << "\\note unless a dedicated outdoor air system is specified for this zone and then it will be\n";
    ss << "\\note set to zero.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "A4, \\field Outdoor Air Method\n";
    ss << "\\note Flow/Person, Flow/Zone, Flow/Area, Sum, and Maximum use the values in the next three\n";
    ss << "\\note fields: Outdoor Air Flow Rate per Person, Outdoor Air Flow Rate per Zone Floor Area,\n";
    ss << "\\note and Outdoor Air Flow Rate per Zone.\n";
    ss << "\\note DetailedSpecification ignores these three Outdoor Air Flow Rate fields and instead\n";
    ss << "\\note references design specification objects named in the fields\n";
    ss << "\\note Design Specification Outdoor Air Object Name and Design Specification Zone Air\n";
    ss << "\\note Distribution Object Name.\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Person\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Sum\n";
    ss << "\\key Maximum\n";
    ss << "\\key DetailedSpecification\n";
    ss << "\\default Flow/Person\n";
    ss << "N11, \\field Outdoor Air Flow Rate per Person\n";
    ss << "\\units m3/s\n";
    ss << "\\note Default 0.00944 is 20 cfm per person\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Person, Sum, or Maximum\n";
    ss << "\\default 0.00944\n";
    ss << "N12, \\field Outdoor Air Flow Rate per Zone Floor Area\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Area, Sum, or Maximum\n";
    ss << "N13, \\field Outdoor Air Flow Rate per Zone\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Zone, Sum, or Maximum\n";
    ss << "A5, \\field Design Specification Outdoor Air Object Name\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "A6, \\field Design Specification Zone Air Distribution Object Name\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneAirDistributionNames\n";
    ss << "A7, \\field System Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A8, \\field Supply Fan Operating Mode Schedule Name\n";
    ss << "\\note Refers to a schedule to specify unitary supply fan operating mode.\n";
    ss << "\\note Schedule values of 0 indicate cycling fan (auto)\n";
    ss << "\\note Schedule values of 1 indicate continuous fan (on)\n";
    ss << "\\note If this field is left blank, a schedule of always zero (cycling fan) will be used.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A9, \\field Supply Air Fan placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default BlowThrough\n";
    ss << "\\note Select fan placement as either blow through or draw through.\n";
    ss << "N14, \\field Supply Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N15, \\field Supply Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 75\n";
    ss << "N16, \\field Supply Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "A10, \\field Cooling Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key VariableRefrigerantFlowDX\n";
    ss << "\\key None\n";
    ss << "\\default VariableRefrigerantFlowDX\n";
    ss << "A11, \\field Cooling Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N17, \\field Cooling Coil Gross Rated Total Capacity\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\note Rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N18, \\field Cooling Coil Gross Rated Sensible Heat Ratio\n";
    ss << "\\note Rated sensible heat ratio (gross sensible capacity/gross total capacity)\n";
    ss << "\\note Sensible and total capacities do not include effect of supply fan heat\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default autosize\n";
    ss << "A12, \\field Heat Pump Heating Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key VariableRefrigerantFlowDX\n";
    ss << "\\key None\n";
    ss << "\\default VariableRefrigerantFlowDX\n";
    ss << "A13, \\field Heat Pump Heating Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N19, \\field Heat Pump Heating Coil Gross Rated Capacity\n";
    ss << "\\note Capacity excluding supply air fan heat\n";
    ss << "\\note Rating point outdoor dry-bulb temp 8.33 C, outdoor wet-bulb temp 6.11 C\n";
    ss << "\\note Rating point heating coil entering air dry-bulb 21.11 C, coil entering wet-bulb 15.55 C\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N20, \\field Zone Terminal Unit On Parasitic Electric Energy Use\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N21, \\field Zone Terminal Unit Off Parasitic Electric Energy Use\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "A14, \\field Dedicated Outdoor Air System Name\n";
    ss << "\\note Enter the name of an HVACTemplate:System:DedicatedOutdoorAir object if this\n";
    ss << "\\note zone is served by a separate dedicated outdoor air system (DOAS).\n";
    ss << "\\note Leave field blank if no DOAS serves this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HVACTemplateDOASSystems\n";
    ss << "A15, \\field Zone Cooling Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Cooling Design Supply Air Temperature\n";
    ss << "\\note TemperatureDifference = use the value from Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\default SupplyAirTemperature\n";
    ss << "N22, \\field Zone Cooling Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 14.0\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N23, \\field Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 11.11\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be subtracted from the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Cooling Design Supply Air Temperature.\n";
    ss << "A16, \\field Zone Heating Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Heating Design Supply Air Temperature\n";
    ss << "\\note TemperatureDifference = use the value from Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\default SupplyAirTemperature\n";
    ss << "N24, \\field Zone Heating Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 50.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N25, \\field Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 30.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be added to the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Heating Design Supply Air Temperature.\n";
    ss << "A17, \\field Baseboard Heating Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A18, \\field Baseboard Heating Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N26; \\field Baseboard Heating Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Zone_VRF);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Zone:VRF",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Zone_VRF);
  return object;
}

IddObject createHVACTemplate_Zone_UnitaryIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Zone:Unitary,\n";
    ss << "\\min-fields 21\n";
    ss << "\\memo Zone terminal unit, constant volume, no controls.\n";
    ss << "A1, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone name must match a building zone name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A2, \\field Template Unitary System Name\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the name of an HVACTemplate:System:Unitary, HVACTemplate:System:UnitaryHeatPump:AirTtoAir,\n";
    ss << "\\note or HVACTemplate:System:UnitarySystem object serving this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACSystemUnitary\n";
    ss << "A3, \\field Template Thermostat Name\n";
    ss << "\\note Enter the name of a HVACTemplate:Thermostat object.\n";
    ss << "\\note If blank, then it is assumed that standard thermostat objects\n";
    ss << "\\note have been defined for this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACThermostats\n";
    ss << "N1, \\field Supply Air Maximum Flow Rate\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will be\n";
    ss << "\\note multiplied by the Supply Air Sizing Factor and by zone multipliers.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "N2, \\field Zone Heating Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "N3, \\field Zone Cooling Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "A4, \\field Outdoor Air Method\n";
    ss << "\\note Flow/Person, Flow/Zone, Flow/Area, Sum, and Maximum use the values in the next three\n";
    ss << "\\note fields: Outdoor Air Flow Rate per Person, Outdoor Air Flow Rate per Zone Floor Area,\n";
    ss << "\\note and Outdoor Air Flow Rate per Zone.\n";
    ss << "\\note DetailedSpecification ignores these three Outdoor Air Flow Rate fields and instead\n";
    ss << "\\note references design specification objects named in the fields\n";
    ss << "\\note Design Specification Outdoor Air Object Name and Design Specification Zone Air\n";
    ss << "\\note Distribution Object Name.\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Person\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Sum\n";
    ss << "\\key Maximum\n";
    ss << "\\key DetailedSpecification\n";
    ss << "\\default Flow/Person\n";
    ss << "N4, \\field Outdoor Air Flow Rate per Person\n";
    ss << "\\units m3/s\n";
    ss << "\\note Default 0.00944 is 20 cfm per person\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Person, Sum, or Maximum\n";
    ss << "\\default 0.00944\n";
    ss << "N5, \\field Outdoor Air Flow Rate per Zone Floor Area\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Area, Sum, or Maximum\n";
    ss << "N6, \\field Outdoor Air Flow Rate per Zone\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Zone, Sum, or Maximum\n";
    ss << "A5, \\field Supply Plenum Name\n";
    ss << "\\note Plenum zone name.  Supply plenum runs through only this zone.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A6, \\field Return Plenum Name\n";
    ss << "\\note Plenum zone name.  Return plenum runs through only this zone.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A7, \\field Baseboard Heating Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A8, \\field Baseboard Heating Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N7, \\field Baseboard Heating Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "A9, \\field Zone Cooling Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Cooling Design Supply Air Temperature\n";
    ss << "\\note TemperatureDifference = use the value from Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\note SystemSupplyAirTemperature = use the value from HVACTemplate:System:Unitary or HVACTemplate:System:UnitaryHeatPump:AirToAir\n";
    ss << "\\note Cooling Design Supply Air Temperature\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\key SystemSupplyAirTemperature\n";
    ss << "\\default SystemSupplyAirTemperature\n";
    ss << "N8, \\field Zone Cooling Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 12.8\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N9, \\field Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 11.11\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be subtracted from the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Cooling Design Supply Air Temperature.\n";
    ss << "A10, \\field Zone Heating Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Heating Design Supply Air Temperature\n";
    ss << "\\note TemperatureDifference = use the value from Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\note SystemSupplyAirTemperature = use the value from HVACTemplate:System:Unitary or HVACTemplate:System:UnitaryHeatPump:AirToAir\n";
    ss << "\\note Heating Design Supply Air Temperature\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\key SystemSupplyAirTemperature\n";
    ss << "\\default SystemSupplyAirTemperature\n";
    ss << "N10, \\field Zone Heating Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 50.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N11, \\field Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 30.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be added to the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Heating Design Supply Air Temperature.\n";
    ss << "A11, \\field Design Specification Outdoor Air Object Name\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "A12; \\field Design Specification Zone Air Distribution Object Name\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneAirDistributionNames\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Zone_Unitary);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Zone:Unitary",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Zone_Unitary);
  return object;
}

IddObject createHVACTemplate_Zone_VAVIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Zone:VAV,\n";
    ss << "\\min-fields 32\n";
    ss << "\\memo Zone terminal unit, variable volume, reheat optional.\n";
    ss << "\\memo For heating, this unit activates reheat coil first, then increases airflow (if reverse\n";
    ss << "\\memo action specified).\n";
    ss << "A1, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone name must match a building zone name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A2, \\field Template VAV System Name\n";
    ss << "\\required-field\n";
    ss << "\\note Name of a HVACTemplate:System:VAV or HVACTemplate:System:PackagedVAV\n";
    ss << "\\note object serving this zone\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACSystemVAV\n";
    ss << "A3, \\field Template Thermostat Name\n";
    ss << "\\note Enter the name of a HVACTemplate:Thermostat object.\n";
    ss << "\\note If blank, then it is assumed that standard thermostat objects\n";
    ss << "\\note have been defined for this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACThermostats\n";
    ss << "N1, \\field Supply Air Maximum Flow Rate\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will be\n";
    ss << "\\note multiplied by the Supply Air Sizing Factor and by zone multipliers.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "N2, \\field Zone Heating Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "N3, \\field Zone Cooling Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "A4, \\field Zone Minimum Air Flow Input Method\n";
    ss << "\\type choice\n";
    ss << "\\key Constant\n";
    ss << "\\key FixedFlowRate\n";
    ss << "\\key Scheduled\n";
    ss << "\\default Constant\n";
    ss << "\\note Constant = Constant Minimum Air Flow Fraction (a fraction of Maximum Air Flow Rate)\n";
    ss << "\\note FixedFlowRate = Fixed Minimum Air Flow Rate (a fixed minimum air volume flow rate)\n";
    ss << "\\note Scheduled = Scheduled Minimum Air Flow Fraction (a fraction of Maximum Air Flow\n";
    ss << "N4, \\field Constant Minimum Air Flow Fraction\n";
    ss << "\\note This field is used if the field Zone Minimum Air Flow Input Method is Constant\n";
    ss << "\\note If the field Zone Minimum Air Flow Input Method is Scheduled, then this field\n";
    ss << "\\note is optional. If a value is entered, then it is used for sizing normal-action reheat coils.\n";
    ss << "\\note If both this field and the following field are entered, the larger result is used.\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.2\n";
    ss << "N5, \\field Fixed Minimum Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\note This field is used if the field Zone Minimum Air Flow Input Method is FixedFlowRate.\n";
    ss << "\\note If the field Zone Minimum Air Flow Input Method is Scheduled, then this field\n";
    ss << "\\note is optional. If a value is entered, then it is used for sizing normal-action reheat coils.\n";
    ss << "\\note If both this field and the previous field are entered, the larger result is used.\n";
    ss << "A5, \\field Minimum Air Flow Fraction Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field is used if the field Zone Minimum Air Flow Input Method is Scheduled\n";
    ss << "\\note Schedule values are fractions, 0.0 to 1.0.\n";
    ss << "\\note If the field Constant Minimum Air Flow Fraction is blank, then the average of the\n";
    ss << "\\note minimum and maximum schedule values is used for sizing normal-action reheat coils.\n";
    ss << "A6, \\field Outdoor Air Method\n";
    ss << "\\note Flow/Person, Flow/Zone, Flow/Area, Sum, and Maximum use the values in the next three\n";
    ss << "\\note fields: Outdoor Air Flow Rate per Person, Outdoor Air Flow Rate per Zone Floor Area,\n";
    ss << "\\note and Outdoor Air Flow Rate per Zone.\n";
    ss << "\\note DetailedSpecification ignores these three Outdoor Air Flow Rate fields and instead\n";
    ss << "\\note references design specification objects named in the fields\n";
    ss << "\\note Design Specification Outdoor Air Object Name and Design Specification Zone Air\n";
    ss << "\\note Distribution Object Name.\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Person\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Sum\n";
    ss << "\\key Maximum\n";
    ss << "\\key DetailedSpecification\n";
    ss << "\\default Flow/Person\n";
    ss << "N6, \\field Outdoor Air Flow Rate per Person\n";
    ss << "\\units m3/s\n";
    ss << "\\note Default 0.00944 is 20 cfm per person\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Person, Sum, or Maximum\n";
    ss << "\\default 0.00944\n";
    ss << "N7, \\field Outdoor Air Flow Rate per Zone Floor Area\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Area, Sum, or Maximum\n";
    ss << "N8, \\field Outdoor Air Flow Rate per Zone\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Zone, Sum, or Maximum\n";
    ss << "A7, \\field Reheat Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  Gas\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A8, \\field Reheat Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A9, \\field Damper Heating Action\n";
    ss << "\\type choice\n";
    ss << "\\key Normal\n";
    ss << "\\key Reverse\n";
    ss << "\\default Reverse\n";
    ss << "N9, \\field Maximum Flow per Zone Floor Area During Reheat\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Used only when Reheat Coil Object Type = Coil:Heating:Water and Damper Heating Action = Reverse\n";
    ss << "\\note When autocalculating, the maximum flow per zone is set to 0.002032 m3/s-m2 (0.4 cfm/sqft)\n";
    ss << "\\note This optional field limits the maximum flow allowed in reheat mode.\n";
    ss << "\\note If this field and the following field are left blank, the maximum flow will not be limited.\n";
    ss << "\\note At no time will the maximum flow rate calculated here exceed the value of\n";
    ss << "\\note Maximum Air Flow Rate.\n";
    ss << "N10, \\field Maximum Flow Fraction During Reheat\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Used only when Reheat Coil Object Type = Coil:Heating:Water and Damper Heating Action = Reverse\n";
    ss << "\\note When autocalculating, the maximum flow fraction is set to the ratio of\n";
    ss << "\\note 0.002032 m3/s-m2 (0.4 cfm/sqft) multiplied by the zone floor area and the\n";
    ss << "\\note Maximum Air Flow Rate.\n";
    ss << "\\note This optional field limits the maximum flow allowed in reheat mode.\n";
    ss << "\\note If this field and the previous field are left blank, the maximum flow will not be limited.\n";
    ss << "\\note At no time will the maximum flow rate calculated here exceed the value of\n";
    ss << "\\note Maximum Air Flow Rate.\n";
    ss << "N11, \\field Maximum Reheat Air Temperature\n";
    ss << "\\note Specifies the maximum allowable supply air temperature leaving the reheat coil.\n";
    ss << "\\note If left blank, there is no limit and no default. If unknown, 35C (95F) is recommended.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "A10, \\field Design Specification Outdoor Air Object Name for Control\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "\\note When the name of a DesignSpecification:OutdoorAir object is entered, the terminal\n";
    ss << "\\note unit will increase flow as needed to meet this outdoor air requirement.\n";
    ss << "\\note If Outdoor Air Flow per Person is non-zero, then the outdoor air requirement will\n";
    ss << "\\note be computed based on the current number of occupants in the zone.\n";
    ss << "\\note At no time will the supply air flow rate exceed the value for Maximum Air Flow Rate.\n";
    ss << "\\note If this field is blank, then the terminal unit will not be controlled for outdoor air flow.\n";
    ss << "\\note Note that this field is used only for specifying the design outdoor air flow rate used\n";
    ss << "\\note for control. The field Design Specification Outdoor Air Object Name for Sizing\n";
    ss << "\\note (see below) is used to specify the design outdoor air flow rate.\n";
    ss << "A11, \\field Supply Plenum Name\n";
    ss << "\\note Plenum zone name.  Supply plenum runs through only this zone.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A12, \\field Return Plenum Name\n";
    ss << "\\note Plenum zone name.  Return plenum runs through only this zone.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A13, \\field Baseboard Heating Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A14, \\field Baseboard Heating Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N12, \\field Baseboard Heating Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "A15, \\field Zone Cooling Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Cooling Design Supply Air Temperature\n";
    ss << "\\note TemperatureDifference = use the value from Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\note SystemSupplyAirTemperature = use the value from HVACTemplate:System:VAV Cooling Coil Design Setpoint\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\key SystemSupplyAirTemperature\n";
    ss << "\\default SystemSupplyAirTemperature\n";
    ss << "N13, \\field Zone Cooling Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 12.8\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N14, \\field Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 11.11\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be subtracted from the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Cooling Design Supply Air Temperature.\n";
    ss << "A16, \\field Zone Heating Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Heating Design Supply Air Temperature\n";
    ss << "\\note TemperatureDifference = use the value from Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\default SupplyAirTemperature\n";
    ss << "N15, \\field Zone Heating Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 50.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N16, \\field Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 30.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be added to the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Heating Design Supply Air Temperature.\n";
    ss << "A17, \\field Design Specification Outdoor Air Object Name for Sizing\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\note Note that this field is used only for specifying the design outdoor air flow rate used\n";
    ss << "\\note for sizing. The field Design Specification Outdoor Air Object Name for Control\n";
    ss << "\\note (see above) is used to actively control the VAV terminal air flow rate.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "A18; \\field Design Specification Zone Air Distribution Object Name\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneAirDistributionNames\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Zone_VAV);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Zone:VAV",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Zone_VAV);
  return object;
}

IddObject createHVACTemplate_Zone_VAV_FanPoweredIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Zone:VAV:FanPowered,\n";
    ss << "\\min-fields 31\n";
    ss << "\\memo Zone terminal unit, fan powered variable volume, reheat optional.\n";
    ss << "\\memo Referenced schedules must be defined elsewhere in the idf.\n";
    ss << "A1, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone Name must match a building zone name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A2, \\field Template VAV System Name\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the name of a HVACTemplate:System:VAV or HVACTemplate:System:PackagedVAV\n";
    ss << "\\note object serving this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACSystemVAV\n";
    ss << "A3, \\field Template Thermostat Name\n";
    ss << "\\note Enter the name of a HVACTemplate:Thermostat object.\n";
    ss << "\\note If blank, then it is assumed that standard thermostat objects\n";
    ss << "\\note have been defined for this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACThermostats\n";
    ss << "N1, \\field Primary Supply Air Maximum Flow Rate\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will be\n";
    ss << "\\note multiplied by the Supply Air Sizing Factor and by zone multipliers.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "N2, \\field Zone Heating Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "N3, \\field Zone Cooling Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "N4, \\field Primary Supply Air Minimum Flow Fraction\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N5, \\field Secondary Supply Air Maximum Flow Rate\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will be\n";
    ss << "\\note multiplied by the Supply Air Sizing Factor and by zone multipliers.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "A4, \\field Flow Type\n";
    ss << "\\type choice\n";
    ss << "\\key  Series\n";
    ss << "\\key  Parallel\n";
    ss << "\\key  SeriesFromPlenum\n";
    ss << "\\key  ParallelFromPlenum\n";
    ss << "\\default Parallel\n";
    ss << "N6, \\field Parallel Fan On Flow Fraction\n";
    ss << "\\note The fraction of the primary air flow at which fan turns on\n";
    ss << "\\note Applicable only to Parallel Flow Type\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "A5, \\field Outdoor Air Method\n";
    ss << "\\note Flow/Person, Flow/Zone, Flow/Area, Sum, and Maximum use the values in the next three\n";
    ss << "\\note fields: Outdoor Air Flow Rate per Person, Outdoor Air Flow Rate per Zone Floor Area,\n";
    ss << "\\note and Outdoor Air Flow Rate per Zone.\n";
    ss << "\\note DetailedSpecification ignores these three Outdoor Air Flow Rate fields and instead\n";
    ss << "\\note references design specification objects named in the fields\n";
    ss << "\\note Design Specification Outdoor Air Object Name and Design Specification Zone Air\n";
    ss << "\\note Distribution Object Name.\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Person\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Sum\n";
    ss << "\\key Maximum\n";
    ss << "\\key DetailedSpecification\n";
    ss << "\\default Flow/Person\n";
    ss << "N7, \\field Outdoor Air Flow Rate per Person\n";
    ss << "\\units m3/s\n";
    ss << "\\note Default 0.00944 is 20 cfm per person\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Person, Sum, or Maximum\n";
    ss << "\\default 0.00944\n";
    ss << "N8, \\field Outdoor Air Flow Rate per Zone Floor Area\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/area, Sum, or Maximum\n";
    ss << "N9, \\field Outdoor Air Flow Rate per Zone\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Zone, Sum, or Maximum\n";
    ss << "A6, \\field Reheat Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  Gas\n";
    ss << "\\default Electric\n";
    ss << "A7, \\field Reheat Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N10, \\field Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N11, \\field Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 1000\n";
    ss << "N12, \\field Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "A8, \\field Supply Plenum Name\n";
    ss << "\\note Plenum zone name.  Supply plenum runs through only this zone.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A9, \\field Return Plenum Name\n";
    ss << "\\note Plenum zone name.  Return plenum runs through only this zone.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A10, \\field Baseboard Heating Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A11, \\field Baseboard Heating Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N13, \\field Baseboard Heating Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "A12, \\field Zone Cooling Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Cooling Design Supply Air Temperature\n";
    ss << "\\note TemperatureDifference = use the value from Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\note SystemSupplyAirTemperature = use the value from HVACTemplate:System:VAV Cooling Coil Design Setpoint\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\key SystemSupplyAirTemperature\n";
    ss << "\\default SystemSupplyAirTemperature\n";
    ss << "N14, \\field Zone Cooling Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 12.8\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N15, \\field Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 11.11\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be subtracted from the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Cooling Design Supply Air Temperature.\n";
    ss << "A13, \\field Zone Heating Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Heating Design Supply Air Temperature\n";
    ss << "\\note TemperatureDifference = use the value from Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\default SupplyAirTemperature\n";
    ss << "N16, \\field Zone Heating Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 50.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N17, \\field Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 30.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be added to the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Heating Design Supply Air Temperature.\n";
    ss << "A14, \\field Zone PIU Fan Schedule Name\n";
    ss << "\\note This is the operating schedule for the zone PIU fan.\n";
    ss << "\\note For a parallel PIU, the fan operates only when the primary air flow is below the\n";
    ss << "\\note Parallel Fan On Flow Fraction and the Zone PIU Fan Schedule is on, or it is\n";
    ss << "\\note activated by an availability manager.\n";
    ss << "\\note For a series PIU, the zone fan operates whenever the Zone PIU Fan Schedule is on, or it\n";
    ss << "\\note is activated by an availability manager.\n";
    ss << "\\note If this field is left blank, the System Availability Schedule for the\n";
    ss << "\\note HVACTemplate:System serving this zone will be used.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A15, \\field Design Specification Outdoor Air Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "A16; \\field Design Specification Zone Air Distribution Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneAirDistributionNames\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Zone_VAV_FanPowered);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Zone:VAV:FanPowered",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Zone_VAV_FanPowered);
  return object;
}

IddObject createHVACTemplate_Zone_VAV_HeatAndCoolIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Zone:VAV:HeatAndCool,\n";
    ss << "\\min-fields 27\n";
    ss << "\\memo VAV system with VAV for both heating and cooling and optional reheat coil.\n";
    ss << "\\memo For heating, this unit increases airflow first, then activates reheat coil.\n";
    ss << "A1, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone name must match a building zone name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A2, \\field Template VAV System Name\n";
    ss << "\\required-field\n";
    ss << "\\note Name of a HVACTemplate:System:VAV or HVACTemplate:System:PackagedVAV\n";
    ss << "\\note object serving this zone\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACSystemVAV\n";
    ss << "A3, \\field Template Thermostat Name\n";
    ss << "\\note Enter the name of a HVACTemplate:Thermostat object.\n";
    ss << "\\note If blank, then it is assumed that standard thermostat objects\n";
    ss << "\\note have been defined for this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACThermostats\n";
    ss << "N1, \\field Supply Air Maximum Flow Rate\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will be\n";
    ss << "\\note multiplied by the Supply Air Sizing Factor and by zone multipliers.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "N2, \\field Zone Heating Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "N3, \\field Zone Cooling Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "N4, \\field Constant Minimum Air Flow Fraction\n";
    ss << "\\note This field is used if the field Zone Minimum Air Flow Input Method is Constant\n";
    ss << "\\note If the field Zone Minimum Air Flow Input Method is Scheduled, then this field\n";
    ss << "\\note is optional. If a value is entered, then it is used for sizing normal-action reheat coils.\n";
    ss << "\\note If both this field and the following field are entered, the larger result is used.\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.2\n";
    ss << "A4, \\field Outdoor Air Method\n";
    ss << "\\note Flow/Person, Flow/Zone, Flow/Area, Sum, and Maximum use the values in the next three\n";
    ss << "\\note fields: Outdoor Air Flow Rate per Person, Outdoor Air Flow Rate per Zone Floor Area,\n";
    ss << "\\note and Outdoor Air Flow Rate per Zone.\n";
    ss << "\\note DetailedSpecification ignores these three Outdoor Air Flow Rate fields and instead\n";
    ss << "\\note references design specification objects named in the fields\n";
    ss << "\\note Design Specification Outdoor Air Object Name and Design Specification Zone Air\n";
    ss << "\\note Distribution Object Name.\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Person\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Sum\n";
    ss << "\\key Maximum\n";
    ss << "\\key DetailedSpecification\n";
    ss << "\\default Flow/Person\n";
    ss << "N5, \\field Outdoor Air Flow Rate per Person\n";
    ss << "\\units m3/s\n";
    ss << "\\note Default 0.00944 is 20 cfm per person\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Person, Sum, or Maximum\n";
    ss << "\\default 0.00944\n";
    ss << "N6, \\field Outdoor Air Flow Rate per Zone Floor Area\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Area, Sum, or Maximum\n";
    ss << "N7, \\field Outdoor Air Flow Rate per Zone\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Zone, Sum, or Maximum\n";
    ss << "A5, \\field Design Specification Outdoor Air Object Name for Sizing\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\note Note that this field is used only for specifying the design outdoor air flow rate used\n";
    ss << "\\note for sizing. The field Design Specification Outdoor Air Object Name for Control\n";
    ss << "\\note (see above) is used to actively control the VAV terminal air flow rate.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "A6, \\field Design Specification Zone Air Distribution Object Name\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneAirDistributionNames\n";
    ss << "A7, \\field Reheat Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  Gas\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A8, \\field Reheat Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N8, \\field Maximum Reheat Air Temperature\n";
    ss << "\\note Specifies the maximum allowable supply air temperature leaving the reheat coil.\n";
    ss << "\\note If left blank, there is no limit and no default. If unknown, 35C (95F) is recommended.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "A9, \\field Supply Plenum Name\n";
    ss << "\\note Plenum zone name.  Supply plenum runs through only this zone.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A10, \\field Return Plenum Name\n";
    ss << "\\note Plenum zone name.  Return plenum runs through only this zone.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A11, \\field Baseboard Heating Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A12, \\field Baseboard Heating Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N9, \\field Baseboard Heating Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "A13, \\field Zone Cooling Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Cooling Design Supply Air Temperature\n";
    ss << "\\note TemperatureDifference = use the value from Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\note SystemSupplyAirTemperature = use the value from HVACTemplate:System:VAV Cooling Coil Design Setpoint\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\key SystemSupplyAirTemperature\n";
    ss << "\\default SystemSupplyAirTemperature\n";
    ss << "N10, \\field Zone Cooling Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 12.8\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N11, \\field Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 11.11\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be subtracted from the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Cooling Design Supply Air Temperature.\n";
    ss << "A14, \\field Zone Heating Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Heating Design Supply Air Temperature\n";
    ss << "\\note SystemSupplyAirTemperature = use the value from HVACTemplate:System:VAV Heating Coil Design Setpoint\n";
    ss << "\\note TemperatureDifference = use the value from Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\default SupplyAirTemperature\n";
    ss << "N12, \\field Zone Heating Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 50.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N13; \\field Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 30.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be added to the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Heating Design Supply Air Temperature.\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Zone_VAV_HeatAndCool);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Zone:VAV:HeatAndCool",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Zone_VAV_HeatAndCool);
  return object;
}

IddObject createHVACTemplate_Zone_ConstantVolumeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Zone:ConstantVolume,\n";
    ss << "\\min-fields 24\n";
    ss << "\\memo Zone terminal unit, constant volume, reheat optional.\n";
    ss << "\\memo Referenced schedules must be defined elsewhere in the idf.\n";
    ss << "A1, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone name must match a building zone name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\reference HVACTemplateConstantVolumeZones\n";
    ss << "A2, \\field Template Constant Volume System Name\n";
    ss << "\\required-field\n";
    ss << "\\note Name of a HVACTemplate:System:ConstantVolume object serving this zone\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACSystemConstantVolume\n";
    ss << "A3, \\field Template Thermostat Name\n";
    ss << "\\note Enter the name of a HVACTemplate:Thermostat object.\n";
    ss << "\\note If blank, then it is assumed that standard thermostat objects\n";
    ss << "\\note have been defined for this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACThermostats\n";
    ss << "N1, \\field Supply Air Maximum Flow Rate\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will be\n";
    ss << "\\note multiplied by the Supply Air Sizing Factor and by zone multipliers.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "N2, \\field Zone Heating Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "N3, \\field Zone Cooling Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "A4, \\field Outdoor Air Method\n";
    ss << "\\note Flow/Person, Flow/Zone, Flow/Area, Sum, and Maximum use the values in the next three\n";
    ss << "\\note fields: Outdoor Air Flow Rate per Person, Outdoor Air Flow Rate per Zone Floor Area,\n";
    ss << "\\note and Outdoor Air Flow Rate per Zone.\n";
    ss << "\\note DetailedSpecification ignores these three Outdoor Air Flow Rate fields and instead\n";
    ss << "\\note references design specification objects named in the fields\n";
    ss << "\\note Design Specification Outdoor Air Object Name and Design Specification Zone Air\n";
    ss << "\\note Distribution Object Name.\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Person\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Sum\n";
    ss << "\\key Maximum\n";
    ss << "\\key DetailedSpecification\n";
    ss << "\\default Flow/Person\n";
    ss << "N4, \\field Outdoor Air Flow Rate per Person\n";
    ss << "\\units m3/s\n";
    ss << "\\note Default 0.00944 is 20 cfm per person\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Person, Sum, or Maximum\n";
    ss << "\\default 0.00944\n";
    ss << "N5, \\field Outdoor Air Flow Rate per Zone Floor Area\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Area, Sum, or Maximum\n";
    ss << "N6, \\field Outdoor Air Flow Rate per Zone\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Zone, Sum, or Maximum\n";
    ss << "A5, \\field Design Specification Outdoor Air Object name\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "A6, \\field Design Specification Zone Air Distribution Object Name\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneAirDistributionNames\n";
    ss << "A7, \\field Reheat Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  Gas\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A8, \\field Reheat Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N7, \\field Maximum Reheat Air Temperature\n";
    ss << "\\note Specifies the maximum allowable supply air temperature leaving the reheat coil.\n";
    ss << "\\note If left blank, there is no limit and no default. If unknown, 35C (95F) is recommended.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "A9, \\field Supply Plenum Name\n";
    ss << "\\note Plenum zone name.  Supply plenum runs through only this zone.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A10, \\field Return Plenum Name\n";
    ss << "\\note Plenum zone name.  Return plenum runs through only this zone.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A11, \\field Baseboard Heating Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A12, \\field Baseboard Heating Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N8, \\field Baseboard Heating Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "A13, \\field Zone Cooling Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Cooling Design Supply Air Temperature\n";
    ss << "\\note TemperatureDifference = use the value from Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\note SystemSupplyAirTemperature = use the value from HVACTemplate:System:VAV Cooling Coil Design Setpoint\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\key SystemSupplyAirTemperature\n";
    ss << "\\default SystemSupplyAirTemperature\n";
    ss << "N9, \\field Zone Cooling Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 12.8\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N10, \\field Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 11.11\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be subtracted from the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Cooling Design Supply Air Temperature.\n";
    ss << "A14, \\field Zone Heating Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Heating Design Supply Air Temperature\n";
    ss << "\\note TemperatureDifference = use the value from Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\default SupplyAirTemperature\n";
    ss << "N11, \\field Zone Heating Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 50.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N12; \\field Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 30.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be added to the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Heating Design Supply Air Temperature\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Zone_ConstantVolume);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Zone:ConstantVolume",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Zone_ConstantVolume);
  return object;
}

IddObject createHVACTemplate_Zone_DualDuctIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Zone:DualDuct,\n";
    ss << "\\min-fields 26\n";
    ss << "\\memo Zone terminal unit, dual-duct, constant or variable volume.\n";
    ss << "A1, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note Zone name must match a building zone name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A2, \\field Template Dual Duct System Name\n";
    ss << "\\required-field\n";
    ss << "\\note Name of a HVACTemplate:System:DualDuct object serving this zone\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACSystemDualDuct\n";
    ss << "A3, \\field Template Thermostat Name\n";
    ss << "\\note Enter the name of a HVACTemplate:Thermostat object.\n";
    ss << "\\note If blank, then it is assumed that standard thermostat objects\n";
    ss << "\\note have been defined for this zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CompactHVACThermostats\n";
    ss << "N1, \\field Supply Air Maximum Flow Rate\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will be\n";
    ss << "\\note multiplied by the Supply Air Sizing Factor and by zone multipliers.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "N2, \\field Zone Heating Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "N3, \\field Zone Cooling Sizing Factor\n";
    ss << "\\note If blank, value from Sizing:Parameters will be used.\n";
    ss << "\\minimum 0\n";
    ss << "N4 ,\\field Zone Minimum Air Flow Fraction\n";
    ss << "\\note This field is the Zone Minimum Air Flow Fraction specified as a fraction of the\n";
    ss << "\\note maximum air flow rate. This field is ignored if the system serving this zone is\n";
    ss << "\\note constant volume.\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.2\n";
    ss << "A4, \\field Outdoor Air Method\n";
    ss << "\\note Flow/Person, Flow/Zone, Flow/Area, Sum, and Maximum use the values in the next three\n";
    ss << "\\note fields: Outdoor Air Flow Rate per Person, Outdoor Air Flow Rate per Zone Floor Area,\n";
    ss << "\\note and Outdoor Air Flow Rate per Zone.\n";
    ss << "\\note DetailedSpecification ignores these three Outdoor Air Flow Rate fields and instead\n";
    ss << "\\note references design specification objects named in the fields\n";
    ss << "\\note Design Specification Outdoor Air Object Name and Design Specification Zone Air\n";
    ss << "\\note Distribution Object Name.\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Person\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Sum\n";
    ss << "\\key Maximum\n";
    ss << "\\key DetailedSpecification\n";
    ss << "\\default Flow/Person\n";
    ss << "N5, \\field Outdoor Air Flow Rate per Person\n";
    ss << "\\units m3/s\n";
    ss << "\\note Default 0.00944 is 20 cfm per person\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Person, Sum, or Maximum\n";
    ss << "\\default 0.00944\n";
    ss << "N6, \\field Outdoor Air Flow Rate per Zone Floor Area\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Area, Sum, or Maximum\n";
    ss << "N7, \\field Outdoor Air Flow Rate per Zone\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0.0\n";
    ss << "\\note This input is used if the field Outdoor Air Method is\n";
    ss << "\\note Flow/Zone, Sum, or Maximum\n";
    ss << "A5, \\field Design Specification Outdoor Air Object Name for Sizing\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\note Note that this field is used only for specifying the design outdoor air flow rate used\n";
    ss << "\\note for sizing. The field Design Specification Outdoor Air Object Name for Control\n";
    ss << "\\note (see above) is used to actively control the VAV terminal air flow rate.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "A6, \\field Design Specification Zone Air Distribution Object Name\n";
    ss << "\\note This field is used only when Outdoor Air Method=DetailedSpecification.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneAirDistributionNames\n";
    ss << "A7, \\field Design Specification Outdoor Air Object Name for Control\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "\\note When the name of a DesignSpecification:OutdoorAir object is entered, the terminal\n";
    ss << "\\note unit will increase flow as needed to meet this outdoor air requirement.\n";
    ss << "\\note If Outdoor Air Flow per Person is non-zero, then the outdoor air requirement will\n";
    ss << "\\note be computed based on the current number of occupants in the zone.\n";
    ss << "\\note At no time will the supply air flow rate exceed the value for Maximum Air Flow Rate.\n";
    ss << "\\note If this field is blank, then the terminal unit will not be controlled for outdoor air flow.\n";
    ss << "\\note Note that this field is used only for specifying the design outdoor air flow rate used\n";
    ss << "\\note for control. The field Design Specification Outdoor Air Object Name for Sizing\n";
    ss << "\\note (see below) is used to specify the design outdoor air flow rate.\n";
    ss << "A8, \\field Cold Supply Plenum Name\n";
    ss << "\\note Plenum zone name.  Cold supply plenum that serves only this zone.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A9, \\field Hot Supply Plenum Name\n";
    ss << "\\note Plenum zone name.  Hot supply plenum that serves only this zone.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A10, \\field Return Plenum Name\n";
    ss << "\\note Plenum zone name.  Return plenum that serves only this zone.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A11, \\field Baseboard Heating Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A12, \\field Baseboard Heating Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N8, \\field Baseboard Heating Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "A13, \\field Zone Cooling Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Cooling Design Supply Air Temperature\n";
    ss << "\\note TemperatureDifference = use the value from Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\note SystemSupplyAirTemperature = use the value from HVACTemplate:System:DualDuct Cooling Coil Design Setpoint\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\key SystemSupplyAirTemperature\n";
    ss << "\\default SystemSupplyAirTemperature\n";
    ss << "N9, \\field Zone Cooling Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 12.8\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N10, \\field Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 11.11\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be subtracted from the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Cooling Design Supply Air Temperature.\n";
    ss << "A14, \\field Zone Heating Design Supply Air Temperature Input Method\n";
    ss << "\\note SupplyAirTemperature = use the value from Zone Heating Design Supply Air Temperature\n";
    ss << "\\note TemperatureDifference = use the value from Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\note SystemSupplyAirTemperature = use the value from HVACTemplate:System:DualDuct Heating Coil Design Setpoint\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\key SystemSupplyAirTemperature\n";
    ss << "\\default SystemSupplyAirTemperature\n";
    ss << "N11, \\field Zone Heating Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 50.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N12; \\field Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 30.0\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be added to the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Heating Design Supply Air Temperature.\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Zone_DualDuct);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Zone:DualDuct",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Zone_DualDuct);
  return object;
}

IddObject createHVACTemplate_System_VRFIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:System:VRF,\n";
    ss << "\\memo Variable refrigerant flow (VRF) heat pump condensing unit. Serves one or more VRF zone\n";
    ss << "\\memo terminal units (HVACTemplate:Zone:VRF).\n";
    ss << "\\min-fields 39\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CompactHVACSystemVRF\n";
    ss << "\\reference HVACTemplateSystems\n";
    ss << "A2, \\field System Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Gross Rated Total Cooling Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\note Enter the total cooling capacity in watts at rated conditions or set to autosize.\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "N2, \\field Gross Rated Cooling COP\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.3\n";
    ss << "\\note Enter the coefficient of performance at rated conditions or leave blank to use default.\n";
    ss << "\\note COP includes compressor and condenser fan electrical energy input\n";
    ss << "\\note COP does not include supply fan heat or supply fan electric power input\n";
    ss << "N3, \\field Minimum Outdoor Temperature in Cooling Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default -6.0\n";
    ss << "\\note Enter the minimum outdoor temperature allowed for cooling operation.\n";
    ss << "\\note Cooling is disabled below this temperature.\n";
    ss << "N4, \\field Maximum Outdoor Temperature in Cooling Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 43.0\n";
    ss << "\\note Enter the maximum outdoor temperature allowed for cooling operation.\n";
    ss << "\\note Cooling is disabled above this temperature.\n";
    ss << "N5, \\field Gross Rated Heating Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\note Enter the heating capacity in watts at rated conditions or set to autosize.\n";
    ss << "\\note Heating capacity not accounting for the effect of supply air fan heat\n";
    ss << "N6, \\field Rated Heating Capacity Sizing Ratio\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note If the Gross Rated Heating Capacity is autosized, the heating capacity is sized\n";
    ss << "\\note to be equal to the cooling capacity multiplied by this sizing ratio. The zone\n";
    ss << "\\note terminal unit heating coils are also sized using this ratio unless the sizing\n";
    ss << "\\note ratio input in the ZoneHVAC:TerminalUnit:VariableRefrigerantFlow object is entered.\n";
    ss << "N7, \\field Gross Rated Heating COP\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\note COP includes compressor and condenser fan electrical energy input\n";
    ss << "\\note COP does not include supply fan heat or supply fan electrical energy input\n";
    ss << "\\default 3.4\n";
    ss << "N8, \\field Minimum Outdoor Temperature in Heating Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default -20.0\n";
    ss << "\\note Enter the minimum outdoor temperature allowed for heating operation.\n";
    ss << "N9, \\field Maximum Outdoor Temperature in Heating Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 16.0\n";
    ss << "\\note Enter the maximum outdoor temperature allowed for heating operation.\n";
    ss << "N10, \\field Minimum Heat Pump Part-Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Enter the minimum heat pump part-load ratio (PLR). When the cooling or heating PLR is\n";
    ss << "\\note below this value, the heat pump compressor will cycle to meet the cooling or heating\n";
    ss << "\\note demand.\n";
    ss << "\\default 0.15\n";
    ss << "A3, \\field Zone Name for Master Thermostat Location\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note Enter the name of the zone where the master thermostat is located.\n";
    ss << "A4, \\field Master Thermostat Priority Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key LoadPriority\n";
    ss << "\\key ZonePriority\n";
    ss << "\\key ThermostatOffsetPriority\n";
    ss << "\\key MasterThermostatPriority\n";
    ss << "\\key Scheduled\n";
    ss << "\\default MasterThermostatPriority\n";
    ss << "\\note Choose a thermostat control logic scheme. If these control types fail to control zone\n";
    ss << "\\note temperature within a reasonable limit, consider using multiple VRF systems\n";
    ss << "A5, \\field Thermostat Priority Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note this field is required if Master Thermostat Priority Control Type is Scheduled.\n";
    ss << "\\note Schedule values of 0 denote cooling, 1 for heating, and all other values disable the system.\n";
    ss << "A6, \\field Heat Pump Waste Heat Recovery\n";
    ss << "\\type choice\n";
    ss << "\\key No\n";
    ss << "\\key Yes\n";
    ss << "\\default No\n";
    ss << "\\note This field is reserved for future use. The only valid choice is No.\n";
    ss << "N11, \\field Equivalent Piping Length used for Piping Correction Factor in Cooling Mode\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 30.0\n";
    ss << "\\note Enter the equivalent length of the farthest terminal unit from the condenser\n";
    ss << "N12, \\field Vertical Height used for Piping Correction Factor\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 10.0\n";
    ss << "\\note Enter the height difference between the highest and lowest terminal unit\n";
    ss << "N13, \\field Equivalent Piping Length used for Piping Correction Factor in Heating Mode\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 30.0\n";
    ss << "\\note Enter the equivalent length of the farthest terminal unit from the condenser\n";
    ss << "N14, \\field Crankcase Heater Power per Compressor\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\default 33.0\n";
    ss << "\\note Enter the value of the resistive heater located in the compressor(s). This heater\n";
    ss << "\\note is used to warm the refrigerant and oil when the compressor is off.\n";
    ss << "N15, \\field Number of Compressors\n";
    ss << "\\type integer\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 2\n";
    ss << "\\note Enter the total number of compressor. This input is used only for crankcase\n";
    ss << "\\note heater calculations.\n";
    ss << "N16, \\field Ratio of Compressor Size to Total Compressor Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\default 0.5\n";
    ss << "\\note Enter the ratio of the first stage compressor to total compressor capacity.\n";
    ss << "\\note All other compressors are assumed to be equally sized. This inputs is used\n";
    ss << "\\note only for crankcase heater calculations.\n";
    ss << "N17, \\field Maximum Outdoor Dry-bulb Temperature for Crankcase Heater\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 5.0\n";
    ss << "\\note Enter the maximum outdoor temperature above which the crankcase heaters are disabled.\n";
    ss << "A7, \\field Defrost Strategy\n";
    ss << "\\type choice\n";
    ss << "\\key ReverseCycle\n";
    ss << "\\key Resistive\n";
    ss << "\\default Resistive\n";
    ss << "\\note Select a defrost strategy. Reverse cycle reverses the operating mode from heating to cooling\n";
    ss << "\\note to melt frost formation on the condenser coil. The resistive strategy uses a resistive heater\n";
    ss << "\\note to melt the frost.\n";
    ss << "A8, \\field Defrost Control\n";
    ss << "\\type choice\n";
    ss << "\\key Timed\n";
    ss << "\\key OnDemand\n";
    ss << "\\default Timed\n";
    ss << "\\note Choose a defrost control type. Either use a fixed Timed defrost period or select\n";
    ss << "\\note OnDemand to defrost only when necessary.\n";
    ss << "N18, \\field Defrost Time Period Fraction\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.058333\n";
    ss << "\\note Fraction of time in defrost mode.\n";
    ss << "\\note Only applicable if timed defrost control is specified.\n";
    ss << "N19, \\field Resistive Defrost Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default autosize\n";
    ss << "\\autosizable\n";
    ss << "\\note Enter the size of the resistive defrost heating element.\n";
    ss << "\\note Only applicable if resistive defrost strategy is specified\n";
    ss << "\\ip-units W\n";
    ss << "N20, \\field Maximum Outdoor Dry-bulb Temperature for Defrost Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 5.0\n";
    ss << "\\note Enter the maximum outdoor temperature above which the crankcase heaters are disabled.\n";
    ss << "A9, \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "\\key WaterCooled\n";
    ss << "\\default AirCooled\n";
    ss << "\\note Select either an air cooled or evaporatively cooled condenser.\n";
    ss << "N21, \\field Water Condenser Volume Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\note Only used when Condenser Type = WaterCooled.\n";
    ss << "N22, \\field Evaporative Condenser Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "\\note Enter the effectiveness of the evaporatively cooled condenser.\n";
    ss << "\\note This field is only used when the Condenser Type = EvaporativelyCooled.\n";
    ss << "N23, \\field Evaporative Condenser Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\note Used to calculate evaporative condenser water use.\n";
    ss << "\\note This field is only used when the Condenser Type = EvaporativelyCooled.\n";
    ss << "N24, \\field Evaporative Condenser Pump Rated Power Consumption\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Rated power consumed by the evaporative condenser's water pump.\n";
    ss << "\\note This field is only used when the Condenser Type = EvaporativelyCooled.\n";
    ss << "N25, \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled and for periods\n";
    ss << "\\note when the basin heater is available (field Basin Heater Operating Schedule Name).\n";
    ss << "\\note For this situation, the heater maintains the basin water temperature at the basin heater\n";
    ss << "\\note setpoint temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when the DX coil is off.\n";
    ss << "N26, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on.\n";
    ss << "A10, \\field Basin Heater Operating Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";
    ss << "A11, \\field Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\default Electricity\n";
    ss << "N27, \\field Minimum Outdoor Temperature in Heat Recovery Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note The minimum outdoor temperature below which heat\n";
    ss << "\\note recovery mode will not operate.\n";
    ss << "\\default -15\n";
    ss << "N28; \\field Maximum Outdoor Temperature in Heat Recovery Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note The maximum outdoor temperature above which heat\n";
    ss << "\\note recovery mode will not operate.\n";
    ss << "\\default 45\n";

    IddObjectType objType(IddObjectType::HVACTemplate_System_VRF);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:System:VRF",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_System_VRF);
  return object;
}

IddObject createHVACTemplate_System_UnitaryIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:System:Unitary,\n";
    ss << "\\min-fields 52\n";
    ss << "\\memo Unitary furnace with air conditioner\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CompactHVACSystemUnitary\n";
    ss << "\\reference HVACTemplateSystems\n";
    ss << "A2, \\field System Availability Schedule Name\n";
    ss << "\\note If blank, always on; Unitary System always on.  Schedule is used in availability manager\n";
    ss << "\\note and fan scheduling.\n";
    ss << "\\note Also see \"Night Cycle Control\" field.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Control Zone or Thermostat Location Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1, \\field Supply Fan Maximum Flow Rate\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will *not* be\n";
    ss << "\\note multiplied by any sizing factor or by zone multipliers.  If using zone multipliers\n";
    ss << "\\note a value entered here must be large enough to serve the multiplied zones.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "A4, \\field Supply Fan Operating Mode Schedule Name\n";
    ss << "\\note Refers to a schedule to specify unitary supply fan operating mode.\n";
    ss << "\\note Schedule values of 0 indicate cycling fan (auto)\n";
    ss << "\\note Schedule values of 1 indicate continuous fan (on)\n";
    ss << "\\note If this field is left blank, a schedule of always zero (cycling fan) will be used.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N2, \\field Supply Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N3, \\field Supply Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 600\n";
    ss << "N4, \\field Supply Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N5, \\field Supply Fan Motor in Air Stream Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A5, \\field Cooling Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  SingleSpeedDX\n";
    ss << "\\key  None\n";
    ss << "\\default SingleSpeedDX\n";
    ss << "A6, \\field Cooling Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N6, \\field Cooling Design Supply Air Temperature\n";
    ss << "\\note Used for sizing.\n";
    ss << "\\default 12.8\n";
    ss << "\\units C\n";
    ss << "N7, \\field Cooling Coil Gross Rated Total Capacity\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N8, \\field Cooling Coil Gross Rated Sensible Heat Ratio\n";
    ss << "\\note Gross SHR\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default autosize\n";
    ss << "N9, \\field Cooling Coil Gross Rated COP\n";
    ss << "\\note Gross cooling capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply air fan heat or supply air fan electric power\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.0\n";
    ss << "A7, \\field Heating Coil Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key  Electric\n";
    ss << "\\key  Gas\n";
    ss << "\\key  HotWater\n";
    ss << "A8, \\field Heating Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N10, \\field Heating Design Supply Air Temperature\n";
    ss << "\\note Used for sizing.\n";
    ss << "\\default 50.0\n";
    ss << "\\units C\n";
    ss << "N11, \\field Heating Coil Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N12, \\field Gas Heating Coil Efficiency\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.8\n";
    ss << "N13, \\field Gas Heating Coil Parasitic Electric Load\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N14, \\field Maximum Outdoor Air Flow Rate\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "N15, \\field Minimum Outdoor Air Flow Rate\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "A9, \\field Minimum Outdoor Air Schedule Name\n";
    ss << "\\note Schedule values multiply the minimum outdoor air flow rate\n";
    ss << "\\note If blank, always one\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A10, \\field Economizer Type\n";
    ss << "\\type choice\n";
    ss << "\\key FixedDryBulb\n";
    ss << "\\key FixedEnthalpy\n";
    ss << "\\key DifferentialDryBulb\n";
    ss << "\\key DifferentialEnthalpy\n";
    ss << "\\key FixedDewPointAndDryBulb\n";
    ss << "\\key ElectronicEnthalpy\n";
    ss << "\\key DifferentialDryBulbAndEnthalpy\n";
    ss << "\\key NoEconomizer\n";
    ss << "\\default NoEconomizer\n";
    ss << "A11, \\field Economizer Lockout\n";
    ss << "\\type choice\n";
    ss << "\\key NoLockout\n";
    ss << "\\key LockoutWithHeating\n";
    ss << "\\key LockoutWithCompressor\n";
    ss << "\\default NoLockout\n";
    ss << "N16, \\field Economizer Upper Temperature Limit\n";
    ss << "\\note Outdoor temperature above which economizer is disabled and\n";
    ss << "\\note heat recovery is enabled (if available).\n";
    ss << "\\note Blank means no limit.\n";
    ss << "\\units C\n";
    ss << "N17, \\field Economizer Lower Temperature Limit\n";
    ss << "\\note Outdoor temperature below which economizer is disabled and\n";
    ss << "\\note heat recovery is enabled (if available).\n";
    ss << "\\note Blank means no limit.\n";
    ss << "\\units C\n";
    ss << "N18, \\field Economizer Upper Enthalpy Limit\n";
    ss << "\\note Outdoor enthalpy above which economizer is disabled and\n";
    ss << "\\note heat recovery is enabled (if available).\n";
    ss << "\\note Blank means no limit.\n";
    ss << "\\units J/kg\n";
    ss << "N19, \\field Economizer Maximum Limit Dewpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the maximum outdoor dewpoint temperature limit for FixedDewPointAndDryBulb\n";
    ss << "\\note economizer control type. No input or blank input means this limit is not operative.\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "A12, \\field Supply Plenum Name\n";
    ss << "\\note Plenum zone name.  Supply plenum serves all zones on this system.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A13, \\field Return Plenum Name\n";
    ss << "\\note Plenum zone name.  Return plenum serves all zones on this system.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A14, \\field Supply Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default BlowThrough\n";
    ss << "A15, \\field Night Cycle Control\n";
    ss << "\\type choice\n";
    ss << "\\key StayOff\n";
    ss << "\\key CycleOnAny\n";
    ss << "\\key CycleOnControlZone\n";
    ss << "\\default StayOff\n";
    ss << "A16, \\field Night Cycle Control Zone Name\n";
    ss << "\\note Applicable only if Night Cycle Control is Cycle On Control Zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A17, \\field Heat Recovery Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Sensible\n";
    ss << "\\key Enthalpy\n";
    ss << "\\default None\n";
    ss << "N20, \\field Sensible Heat Recovery Effectiveness\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.70\n";
    ss << "N21, \\field Latent Heat Recovery Effectiveness\n";
    ss << "\\note Applicable only if Heat Recovery Type is Enthalpy.\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.65\n";
    ss << "A18, \\field Dehumidification Control Type\n";
    ss << "\\note None = meet sensible cooling load only\n";
    ss << "\\note CoolReheatHeatingCoil = cool beyond the dry-bulb setpoint\n";
    ss << "\\note as required to meet the humidity setpoint, reheat with main heating coil.\n";
    ss << "\\note CoolReheatDesuperheater = cool beyond the dry-bulb setpoint\n";
    ss << "\\note as required to meet the humidity setpoint, reheat with desuperheater coil.\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key CoolReheatHeatingCoil\n";
    ss << "\\key CoolReheatDesuperheater\n";
    ss << "\\default None\n";
    ss << "A19, \\field Dehumidification Control Zone Name\n";
    ss << "\\note This field is not currently used - the thermostat control zone is also the dehumidification control zone\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N22, \\field Dehumidification Setpoint\n";
    ss << "\\note Zone relative humidity setpoint in percent (0 to 100)\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\default 60.0\n";
    ss << "\\units percent\n";
    ss << "A20, \\field Humidifier Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key ElectricSteam\n";
    ss << "\\default None\n";
    ss << "A21, \\field Humidifier Availability Schedule Name\n";
    ss << "\\note If blank, always available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N23, \\field Humidifier Rated Capacity\n";
    ss << "\\note Moisture output rate at full rated power input.\n";
    ss << "\\note The humidifier does not currently autosize, so the default is very large\n";
    ss << "\\note to allow for adequate capacity.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.000001\n";
    ss << "\\ip-units gal/min\n";
    ss << "N24, \\field Humidifier Rated Electric Power\n";
    ss << "\\note Electric power input at rated capacity moisture output.\n";
    ss << "\\note Power consumption is proportional to moisture output with no part-load penalty.\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\ip-units W\n";
    ss << "A22, \\field Humidifier Control Zone Name\n";
    ss << "\\note Zone name where humidistat is located\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N25, \\field Humidifier Setpoint\n";
    ss << "\\note Zone relative humidity setpoint in percent (0 to 100)\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\default 30.0\n";
    ss << "\\units percent\n";
    ss << "A23, \\field Return Fan\n";
    ss << "\\note Specifies if the system has a return fan.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N26, \\field Return Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N27, \\field Return Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 500\n";
    ss << "N28, \\field Return Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N29; \\field Return Fan Motor in Air Stream Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::HVACTemplate_System_Unitary);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:System:Unitary",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_System_Unitary);
  return object;
}

IddObject createHVACTemplate_System_UnitaryHeatPump_AirToAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:System:UnitaryHeatPump:AirToAir,\n";
    ss << "\\min-fields 61\n";
    ss << "\\memo Unitary furnace with electric air-to-air heat pump\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CompactHVACSystemUnitary\n";
    ss << "\\reference HVACTemplateSystems\n";
    ss << "A2, \\field System Availability Schedule Name\n";
    ss << "\\note If blank, always on; Unitary System always on.  Schedule is used in availability manager\n";
    ss << "\\note and fan scheduling.\n";
    ss << "\\note Also see \"Night Cycle Control\" field.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Control Zone or Thermostat Location Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1, \\field Cooling Supply Air Flow Rate\n";
    ss << "\\note Supply air flow rate during cooling operation\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will *not* be\n";
    ss << "\\note multiplied by any sizing factor or by zone multipliers.  If using zone multipliers\n";
    ss << "\\note a value entered here must be large enough to serve the multiplied zones.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "N2, \\field Heating Supply Air Flow Rate\n";
    ss << "\\note Supply air flow rate during heating operation\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will *not* be\n";
    ss << "\\note multiplied by any sizing factor or by zone multipliers.  If using zone multipliers\n";
    ss << "\\note a value entered here must be large enough to serve the multiplied zones.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "N3, \\field No Load Supply Air Flow Rate\n";
    ss << "\\note Supply air flow rate when no cooling or heating is needed\n";
    ss << "\\note Only used when heat pump fan operating mode is Continuous. This air flow rate\n";
    ss << "\\note is used when no heating or cooling is required and the DX coil compressor is off.\n";
    ss << "\\note If this field is left blank or zero, the supply air flow rate from the previous on cycle\n";
    ss << "\\note (either cooling or heating) is used.\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will *not* be\n";
    ss << "\\note multiplied by any sizing factor or by zone multipliers.  If using zone multipliers\n";
    ss << "\\note a value entered here must be large enough to serve the multiplied zones.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default autosize\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "A4, \\field Supply Fan Operating Mode Schedule Name\n";
    ss << "\\note Refers to a schedule to specify unitary supply fan operating mode.\n";
    ss << "\\note Schedule values of 0 indicate cycling fan (auto)\n";
    ss << "\\note Schedule values of 1 indicate continuous fan (on)\n";
    ss << "\\note If this field is left blank, a schedule of always zero (cycling fan) will be used.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5, \\field Supply Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default BlowThrough\n";
    ss << "N4, \\field Supply Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N5, \\field Supply Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 600\n";
    ss << "N6, \\field Supply Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N7, \\field Supply Fan Motor in Air Stream Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A6, \\field Cooling Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  SingleSpeedDX\n";
    ss << "\\default SingleSpeedDX\n";
    ss << "A7, \\field Cooling Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N8, \\field Cooling Design Supply Air Temperature\n";
    ss << "\\note Used for sizing.\n";
    ss << "\\default 12.8\n";
    ss << "\\units C\n";
    ss << "N9, \\field Cooling Coil Gross Rated Total Capacity\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\note Rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N10, \\field Cooling Coil Gross Rated Sensible Heat Ratio\n";
    ss << "\\note Rated sensible heat ratio (gross sensible capacity/gross total capacity)\n";
    ss << "\\note Sensible and total capacities do not include effect of supply fan heat\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default autosize\n";
    ss << "N11, \\field Cooling Coil Gross Rated COP\n";
    ss << "\\note Gross cooling capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply fan heat or supply fan electric power input\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.0\n";
    ss << "A8, \\field Heat Pump Heating Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  SingleSpeedDXHeatPump\n";
    ss << "\\default SingleSpeedDXHeatPump\n";
    ss << "A9, \\field Heat Pump Heating Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N12, \\field Heating Design Supply Air Temperature\n";
    ss << "\\note Used for sizing.\n";
    ss << "\\default 50.0\n";
    ss << "\\units C\n";
    ss << "N13, \\field Heat Pump Heating Coil Gross Rated Capacity\n";
    ss << "\\note Rated heating capacity excluding the effect of supply air fan heat\n";
    ss << "\\note Rating point outdoor dry-bulb temp 8.33 C, outdoor wet-bulb temp 6.11 C\n";
    ss << "\\note Rating point heating coil entering air dry-bulb 21.11 C, coil entering wet-bulb 15.55 C\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N14, \\field Heat Pump Heating Coil Rated COP\n";
    ss << "\\note Heat Pump Heating Coil Rated Capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply air fan heat or supply air fan electrical energy.\n";
    ss << "\\note Rating point outdoor dry-bulb temp 8.33 C, outdoor wet-bulb temp 6.11 C\n";
    ss << "\\note Rating point heating coil entering air dry-bulb 21.11 C, coil entering wet-bulb 15.55 C\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 2.75\n";
    ss << "N15, \\field Heat Pump Heating Minimum Outdoor Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\minimum -20.0\n";
    ss << "\\default -8.0\n";
    ss << "\\units C\n";
    ss << "N16, \\field Heat Pump Defrost Maximum Outdoor Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 7.22\n";
    ss << "\\default 5.0\n";
    ss << "\\units C\n";
    ss << "A10, \\field Heat Pump Defrost Strategy\n";
    ss << "\\type choice\n";
    ss << "\\key ReverseCycle\n";
    ss << "\\key Resistive\n";
    ss << "\\default ReverseCycle\n";
    ss << "A11, \\field Heat Pump Defrost Control\n";
    ss << "\\type choice\n";
    ss << "\\key Timed\n";
    ss << "\\key OnDemand\n";
    ss << "\\default Timed\n";
    ss << "N17, \\field Heat Pump Defrost Time Period Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.058333\n";
    ss << "\\note Fraction of time in defrost mode\n";
    ss << "\\note only applicable if Timed defrost control is specified\n";
    ss << "A12, \\field Supplemental Heating Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  Electric\n";
    ss << "\\key  Gas\n";
    ss << "\\key  HotWater\n";
    ss << "\\default Electric\n";
    ss << "A13, \\field Supplemental Heating Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N18, \\field Supplemental Heating Coil Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N19, \\field Supplemental Heating Coil Maximum Outdoor Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\maximum 21.0\n";
    ss << "\\default 21.0\n";
    ss << "\\units C\n";
    ss << "\\note Supplemental heater will not operate when outdoor temperature exceeds this value.\n";
    ss << "N20, \\field Supplemental Gas Heating Coil Efficiency\n";
    ss << "\\note Applies only if Supplemental Heating Coil Type is Gas\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.8\n";
    ss << "N21, \\field Supplemental Gas Heating Coil Parasitic Electric Load\n";
    ss << "\\note Applies only if Supplemental Heating Coil Type is Gas\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N22, \\field Maximum Outdoor Air Flow Rate\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "N23, \\field Minimum Outdoor Air Flow Rate\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "A14, \\field Minimum Outdoor Air Schedule Name\n";
    ss << "\\note Schedule values multiply the minimum outdoor air flow rate\n";
    ss << "\\note If blank, multiplier is always one\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A15, \\field Economizer Type\n";
    ss << "\\type choice\n";
    ss << "\\key FixedDryBulb\n";
    ss << "\\key FixedEnthalpy\n";
    ss << "\\key DifferentialDryBulb\n";
    ss << "\\key DifferentialEnthalpy\n";
    ss << "\\key FixedDewPointAndDryBulb\n";
    ss << "\\key ElectronicEnthalpy\n";
    ss << "\\key DifferentialDryBulbAndEnthalpy\n";
    ss << "\\key NoEconomizer\n";
    ss << "\\default NoEconomizer\n";
    ss << "A16, \\field Economizer Lockout\n";
    ss << "\\type choice\n";
    ss << "\\key NoLockout\n";
    ss << "\\key LockoutWithHeating\n";
    ss << "\\key LockoutWithCompressor\n";
    ss << "\\default NoLockout\n";
    ss << "N24, \\field Economizer Maximum Limit Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the maximum outdoor dry-bulb temperature limit for FixedDryBulb\n";
    ss << "\\note economizer control type. No input or blank input means this limit is\n";
    ss << "\\note not operative. Limit is applied regardless of economizer control type.\n";
    ss << "N25, \\field Economizer Maximum Limit Enthalpy\n";
    ss << "\\type real\n";
    ss << "\\units J/kg\n";
    ss << "\\note Enter the maximum outdoor enthalpy limit for FixedEnthalpy economizer control type.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "N26, \\field Economizer Maximum Limit Dewpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the maximum outdoor dewpoint temperature limit for FixedDewPointAndDryBulb\n";
    ss << "\\note economizer control type. No input or blank input means this limit is not operative.\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "N27, \\field Economizer Minimum Limit Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the minimum outdoor dry-bulb temperature limit for economizer control.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "A17, \\field Supply Plenum Name\n";
    ss << "\\note Plenum zone name.  Supply plenum serves all zones on this system.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A18, \\field Return Plenum Name\n";
    ss << "\\note Plenum zone name.  Return plenum serves all zones on this system.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A19, \\field Night Cycle Control\n";
    ss << "\\type choice\n";
    ss << "\\key StayOff\n";
    ss << "\\key CycleOnAny\n";
    ss << "\\key CycleOnControlZone\n";
    ss << "\\default StayOff\n";
    ss << "A20, \\field Night Cycle Control Zone Name\n";
    ss << "\\note Applicable only if Night Cycle Control is Cycle On Control Zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A21, \\field Heat Recovery Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Sensible\n";
    ss << "\\key Enthalpy\n";
    ss << "\\default None\n";
    ss << "N28, \\field Sensible Heat Recovery Effectiveness\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.70\n";
    ss << "N29, \\field Latent Heat Recovery Effectiveness\n";
    ss << "\\note Applicable only if Heat Recovery Type is Enthalpy.\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.65\n";
    ss << "A22, \\field Humidifier Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key ElectricSteam\n";
    ss << "\\default None\n";
    ss << "A23, \\field Humidifier Availability Schedule Name\n";
    ss << "\\note If blank, always available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N30, \\field Humidifier Rated Capacity\n";
    ss << "\\note Moisture output rate at full rated power input.\n";
    ss << "\\note The humidifier does not currently autosize, so the default is very large\n";
    ss << "\\note to allow for adequate capacity.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.000001\n";
    ss << "\\ip-units gal/min\n";
    ss << "N31, \\field Humidifier Rated Electric Power\n";
    ss << "\\note Electric power input at rated capacity moisture output.\n";
    ss << "\\note Power consumption is proportional to moisture output with no part-load penalty.\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\ip-units W\n";
    ss << "A24, \\field Humidifier Control Zone Name\n";
    ss << "\\note Zone name where humidistat is located\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N32, \\field Humidifier Setpoint\n";
    ss << "\\note Zone relative humidity setpoint in percent (0 to 100)\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\default 30.0\n";
    ss << "\\units percent\n";
    ss << "A25, \\field Return Fan\n";
    ss << "\\note Specifies if the system has a return fan.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N33, \\field Return Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N34, \\field Return Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 500\n";
    ss << "N35, \\field Return Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N36; \\field Return Fan Motor in Air Stream Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::HVACTemplate_System_UnitaryHeatPump_AirToAir);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:System:UnitaryHeatPump:AirToAir",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_System_UnitaryHeatPump_AirToAir);
  return object;
}

IddObject createHVACTemplate_System_UnitarySystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:System:UnitarySystem,\n";
    ss << "\\min-fields 72\n";
    ss << "\\memo Unitary HVAC system with optional cooling and heating. Supports DX and chilled water,\n";
    ss << "\\memo cooling, gas, electric, and hot water heating, air-to-air and water-to-air heat pumps.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CompactHVACSystemUnitary\n";
    ss << "\\reference HVACTemplateSystems\n";
    ss << "A2, \\field System Availability Schedule Name\n";
    ss << "\\note If blank, always available. Also see Supply Fan Operating Mode Schedule Name field.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3,  \\field Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Load\n";
    ss << "\\key SetPoint\n";
    ss << "\\default Load\n";
    ss << "\\note Load control requires a Controlling Zone name.\n";
    ss << "\\note SetPoint control requires set points at coil outlet nodes. The user must add appropriate\n";
    ss << "\\note SetpointManager objects to the idf file.\n";
    ss << "A4, \\field Control Zone or Thermostat Location Name\n";
    ss << "\\note This field is required if Control Type is Load.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1, \\field Cooling Supply Air Flow Rate\n";
    ss << "\\note Supply air flow rate during cooling operation\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will *not* be\n";
    ss << "\\note multiplied by any sizing factor or by zone multipliers.  If using zone multipliers\n";
    ss << "\\note a value entered here must be large enough to serve the multiplied zones.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "N2, \\field Heating Supply Air Flow Rate\n";
    ss << "\\note Supply air flow rate during heating operation\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will *not* be\n";
    ss << "\\note multiplied by any sizing factor or by zone multipliers.  If using zone multipliers\n";
    ss << "\\note a value entered here must be large enough to serve the multiplied zones.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "N3, \\field No Load Supply Air Flow Rate\n";
    ss << "\\note Supply air flow rate when no cooling or heating is needed\n";
    ss << "\\note Only used when heat pump fan operating mode is Continuous. This air flow rate\n";
    ss << "\\note is used when no heating or cooling is required and the DX coil compressor is off.\n";
    ss << "\\note If this field is left blank or zero, the supply air flow rate from the previous on cycle\n";
    ss << "\\note (either cooling or heating) is used.\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will *not* be\n";
    ss << "\\note multiplied by any sizing factor or by zone multipliers.  If using zone multipliers\n";
    ss << "\\note a value entered here must be large enough to serve the multiplied zones.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default autosize\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "A5, \\field Supply Fan Operating Mode Schedule Name\n";
    ss << "\\note Refers to a schedule to specify unitary supply fan operating mode.\n";
    ss << "\\note Schedule values of 0 indicate cycling fan (auto)\n";
    ss << "\\note Schedule values of 1 indicate continuous fan (on)\n";
    ss << "\\note If this field is left blank, a schedule of always zero (cycling fan) will be used.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6, \\field Supply Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default BlowThrough\n";
    ss << "N4, \\field Supply Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N5, \\field Supply Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 600\n";
    ss << "N6, \\field Supply Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N7, \\field Supply Fan Motor in Air Stream Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A7, \\field Cooling Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  SingleSpeedDX\n";
    ss << "\\key  TwoSpeedDX\n";
    ss << "\\key  MultiSpeedDX\n";
    ss << "\\key  TwoStageDX\n";
    ss << "\\key  TwoStageHumidityControlDX\n";
    ss << "\\key  HeatExchangerAssistedDX\n";
    ss << "\\key  SingleSpeedDXWaterCooled\n";
    ss << "\\key  ChilledWater\n";
    ss << "\\key  ChilledWaterDetailedFlatModel\n";
    ss << "\\key  HeatExchangerAssistedChilledWater\n";
    ss << "\\key  None\n";
    ss << "\\default SingleSpeedDX\n";
    ss << "N8, \\field Number of Speeds for Cooling\n";
    ss << "\\note Used only for Cooling Coil Type = MultiSpeedDX.\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 4\n";
    ss << "\\default 1\n";
    ss << "A8, \\field Cooling Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N9, \\field Cooling Design Supply Air Temperature\n";
    ss << "\\note Used for sizing.\n";
    ss << "\\default 12.8\n";
    ss << "\\units C\n";
    ss << "N10, \\field DX Cooling Coil Gross Rated Total Capacity\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\note Rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N11, \\field DX Cooling Coil Gross Rated Sensible Heat Ratio\n";
    ss << "\\note Rated sensible heat ratio (gross sensible capacity/gross total capacity)\n";
    ss << "\\note Sensible and total capacities do not include effect of supply fan heat\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default autosize\n";
    ss << "N12, \\field DX Cooling Coil Gross Rated COP\n";
    ss << "\\note Gross cooling capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply fan heat or supply fan electric power input\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.0\n";
    ss << "A9, \\field Heating Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  Electric\n";
    ss << "\\key  Gas\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  SingleSpeedDXHeatPumpAirSource\n";
    ss << "\\key  MultiSpeedDXHeatPumpAirSource\n";
    ss << "\\key  SingleSpeedDXHeatPumpWaterSource\n";
    ss << "\\key  MultiStageElectric\n";
    ss << "\\key  MultiStageGas\n";
    ss << "\\key  None\n";
    ss << "\\default Gas\n";
    ss << "N13, \\field Number of Speeds or Stages for Heating\n";
    ss << "\\note Used only for Heating Coil Type = MultiSpeedDXHeatPumpAirSource),\n";
    ss << "\\note MultiStageElectric, or MultiStageGas.\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 4\n";
    ss << "\\default 1\n";
    ss << "A10, \\field Heating Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N14, \\field Heating Design Supply Air Temperature\n";
    ss << "\\note Used for sizing.\n";
    ss << "\\default 50.0\n";
    ss << "\\units C\n";
    ss << "N15, \\field Heating Coil Gross Rated Capacity\n";
    ss << "\\note Rated heating capacity excluding the effect of supply air fan heat\n";
    ss << "\\note Rating point outdoor dry-bulb temp 8.33 C, outdoor wet-bulb temp 6.11 C\n";
    ss << "\\note Rating point heating coil entering air dry-bulb 21.11 C, coil entering wet-bulb 15.55 C\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N16, \\field Gas Heating Coil Efficiency\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.8\n";
    ss << "N17, \\field Gas Heating Coil Parasitic Electric Load\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N18, \\field Heat Pump Heating Coil Gross Rated COP\n";
    ss << "\\note Heating Coil Rated Capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply air fan heat or supply air fan electrical energy.\n";
    ss << "\\note Rating point outdoor dry-bulb temp 8.33 C, outdoor wet-bulb temp 6.11 C\n";
    ss << "\\note Rating point heating coil entering air dry-bulb 21.11 C, coil entering wet-bulb 15.55 C\n";
    ss << "\\note Applies only to DX coils\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 2.75\n";
    ss << "N19, \\field Heat Pump Heating Minimum Outdoor Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\minimum -20.0\n";
    ss << "\\default -8.0\n";
    ss << "\\units C\n";
    ss << "N20, \\field Heat Pump Defrost Maximum Outdoor Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 7.22\n";
    ss << "\\default 5.0\n";
    ss << "\\units C\n";
    ss << "A11, \\field Heat Pump Defrost Strategy\n";
    ss << "\\type choice\n";
    ss << "\\key ReverseCycle\n";
    ss << "\\key Resistive\n";
    ss << "\\default ReverseCycle\n";
    ss << "A12, \\field Heat Pump Defrost Control\n";
    ss << "\\type choice\n";
    ss << "\\key Timed\n";
    ss << "\\key OnDemand\n";
    ss << "\\default Timed\n";
    ss << "N21, \\field Heat Pump Defrost Time Period Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.058333\n";
    ss << "\\note Fraction of time in defrost mode\n";
    ss << "\\note only applicable if Timed defrost control is specified\n";
    ss << "A13, \\field Supplemental Heating or Reheat Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  Electric\n";
    ss << "\\key  Gas\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  DesuperHeater\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A14, \\field Supplemental Heating or Reheat Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N22, \\field Supplemental Heating or Reheat Coil Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N23, \\field Supplemental Heating or Reheat Coil Maximum Outdoor Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\maximum 21.0\n";
    ss << "\\default 21.0\n";
    ss << "\\units C\n";
    ss << "\\note Supplemental heater will not operate when outdoor temperature exceeds this value.\n";
    ss << "N24, \\field Supplemental Gas Heating or Reheat Coil Efficiency\n";
    ss << "\\note Applies only if Supplemental Heating Coil Type is Gas\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.8\n";
    ss << "N25, \\field Supplemental Gas Heating or Reheat Coil Parasitic Electric Load\n";
    ss << "\\note Applies only if Supplemental Heating Coil Type is Gas\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N26, \\field Maximum Outdoor Air Flow Rate\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "N27, \\field Minimum Outdoor Air Flow Rate\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "A15, \\field Minimum Outdoor Air Schedule Name\n";
    ss << "\\note Schedule values multiply the minimum outdoor air flow rate\n";
    ss << "\\note If blank, multiplier is always one\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A16, \\field Economizer Type\n";
    ss << "\\type choice\n";
    ss << "\\key FixedDryBulb\n";
    ss << "\\key FixedEnthalpy\n";
    ss << "\\key DifferentialDryBulb\n";
    ss << "\\key DifferentialEnthalpy\n";
    ss << "\\key FixedDewPointAndDryBulb\n";
    ss << "\\key ElectronicEnthalpy\n";
    ss << "\\key DifferentialDryBulbAndEnthalpy\n";
    ss << "\\key NoEconomizer\n";
    ss << "\\default NoEconomizer\n";
    ss << "A17, \\field Economizer Lockout\n";
    ss << "\\type choice\n";
    ss << "\\key NoLockout\n";
    ss << "\\key LockoutWithHeating\n";
    ss << "\\key LockoutWithCompressor\n";
    ss << "\\default NoLockout\n";
    ss << "N28, \\field Economizer Maximum Limit Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the maximum outdoor dry-bulb temperature limit for FixedDryBulb\n";
    ss << "\\note economizer control type. No input or blank input means this limit is\n";
    ss << "\\note not operative. Limit is applied regardless of economizer control type.\n";
    ss << "N29, \\field Economizer Maximum Limit Enthalpy\n";
    ss << "\\type real\n";
    ss << "\\units J/kg\n";
    ss << "\\note Enter the maximum outdoor enthalpy limit for FixedEnthalpy economizer control type.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "N30, \\field Economizer Maximum Limit Dewpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the maximum outdoor dewpoint temperature limit for FixedDewPointAndDryBulb\n";
    ss << "\\note economizer control type. No input or blank input means this limit is not operative.\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "N31, \\field Economizer Minimum Limit Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the minimum outdoor dry-bulb temperature limit for economizer control.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "A18, \\field Supply Plenum Name\n";
    ss << "\\note Plenum zone name.  Supply plenum serves all zones on this system.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A19, \\field Return Plenum Name\n";
    ss << "\\note Plenum zone name.  Return plenum serves all zones on this system.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A20, \\field Heat Recovery Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Sensible\n";
    ss << "\\key Enthalpy\n";
    ss << "\\default None\n";
    ss << "N32, \\field Sensible Heat Recovery Effectiveness\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.70\n";
    ss << "N33, \\field Latent Heat Recovery Effectiveness\n";
    ss << "\\note Applicable only if Heat Recovery Type is Enthalpy.\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.65\n";
    ss << "A21, \\field Heat Recovery Heat Exchanger Type\n";
    ss << "\\type choice\n";
    ss << "\\key Plate\n";
    ss << "\\key Rotary\n";
    ss << "\\default Plate\n";
    ss << "A22, \\field Heat Recovery Frost Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key ExhaustAirRecirculation\n";
    ss << "\\key ExhaustOnly\n";
    ss << "\\key MinimumExhaustTemperature\n";
    ss << "\\default None\n";
    ss << "A23, \\field Dehumidification Control Type\n";
    ss << "\\note None = meet sensible load only\n";
    ss << "\\note CoolReheat = cool beyond the dry-bulb setpoint, reheat with reheat coil\n";
    ss << "\\note If no reheat coil specified, cold supply temps may occur.\n";
    ss << "\\note Multimode = activate enhanced dehumidification mode as needed and meet sensible load.\n";
    ss << "\\note Valid only for Cooling Coil Type = TwoStageHumidityControlDX or HeatExchangerAssistedDX\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key CoolReheat\n";
    ss << "\\key Multimode\n";
    ss << "\\default None\n";
    ss << "A24, \\field Dehumidification Control Zone Name\n";
    ss << "\\note Zone name where humidistat is located\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N34, \\field Dehumidification Relative Humidity Setpoint\n";
    ss << "\\note Zone relative humidity setpoint in percent (0 to 100)\n";
    ss << "\\note Ignored if Dehumidification Relative Humidity Setpoint Schedule specified below\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\default 60.0\n";
    ss << "\\units percent\n";
    ss << "A25, \\field Dehumidification Relative Humidity Setpoint Schedule Name\n";
    ss << "\\note Leave blank to use constant setpoint specified in Dehumidification Relative Humidity\n";
    ss << "\\note Setpoint above. Schedule values must be in percent relative humidity (0 to 100).\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A26, \\field Humidifier Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key ElectricSteam\n";
    ss << "\\default None\n";
    ss << "A27, \\field Humidifier Availability Schedule Name\n";
    ss << "\\note If blank, always available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N35, \\field Humidifier Rated Capacity\n";
    ss << "\\note Moisture output rate at full rated power input.\n";
    ss << "\\note The humidifier does not currently autosize, so the default is very large\n";
    ss << "\\note to allow for adequate capacity.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.000001\n";
    ss << "\\ip-units gal/min\n";
    ss << "N36, \\field Humidifier Rated Electric Power\n";
    ss << "\\note Electric power input at rated capacity moisture output.\n";
    ss << "\\note Power consumption is proportional to moisture output with no part-load penalty.\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\ip-units W\n";
    ss << "A28, \\field Humidifier Control Zone Name\n";
    ss << "\\note Zone name where humidistat is located\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N37, \\field Humidifier Relative Humidity Setpoint\n";
    ss << "\\note Zone relative humidity setpoint in percent (0 to 100).\n";
    ss << "\\note Ignored if Humidifier Relative Humidity Setpoint Schedule specified below\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\default 30.0\n";
    ss << "\\units percent\n";
    ss << "A29, \\field Humidifier Relative Humidity Setpoint Schedule Name\n";
    ss << "\\note Leave blank to use constant setpoint specified in Humidifier Relative Humidity\n";
    ss << "\\note  Setpoint above.Schedule values must be in percent relative humidity (0 to 100).\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A30, \\field Sizing Option\n";
    ss << "\\note Select whether autosized system supply flow rate is the sum of Coincident or NonCoincident\n";
    ss << "\\note zone air flow rates.\n";
    ss << "\\type choice\n";
    ss << "\\key Coincident\n";
    ss << "\\key NonCoincident\n";
    ss << "\\default NonCoincident\n";
    ss << "A31, \\field Return Fan\n";
    ss << "\\note Specifies if the system has a return fan.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N38, \\field Return Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N39, \\field Return Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 300\n";
    ss << "N40, \\field Return Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N41; \\field Return Fan Motor in Air Stream Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::HVACTemplate_System_UnitarySystem);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:System:UnitarySystem",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_System_UnitarySystem);
  return object;
}

IddObject createHVACTemplate_System_VAVIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:System:VAV,\n";
    ss << "\\min-fields 61\n";
    ss << "\\memo Variable Air Volume (VAV) air loop with optional heating coil\n";
    ss << "\\memo and optional preheat.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CompactHVACSystemVAV\n";
    ss << "\\reference HVACTemplateSystems\n";
    ss << "A2, \\field System Availability Schedule Name\n";
    ss << "\\note If blank, always on; VAV System always on.  Schedule is used in availability manager\n";
    ss << "\\note and fan scheduling.\n";
    ss << "\\note Also see \"Night Cycle Control\" field.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Supply Fan Maximum Flow Rate\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will *not* be\n";
    ss << "\\note multiplied by any sizing factor or by zone multipliers.  If using zone multipliers\n";
    ss << "\\note a value entered here must be large enough to serve the multiplied zones.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2, \\field Supply Fan Minimum Flow Rate\n";
    ss << "\\note This field is only used to set a minimum part load on the VAV fan power curve.\n";
    ss << "\\note Autosize or zero is recommended.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "N3, \\field Supply Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N4, \\field Supply Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 1000\n";
    ss << "N5, \\field Supply Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N6, \\field Supply Fan Motor in Air Stream Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A3, \\field Cooling Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  ChilledWater\n";
    ss << "\\key  ChilledWaterDetailedFlatModel\n";
    ss << "\\default  ChilledWater\n";
    ss << "A4, \\field Cooling Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5, \\field Cooling Coil Setpoint Schedule Name\n";
    ss << "\\note  Leave blank if constant setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N7, \\field Cooling Coil Design Setpoint\n";
    ss << "\\note  Used for sizing and as constant setpoint if no Cooling Coil Setpoint Schedule Name is specified.\n";
    ss << "\\default 12.8\n";
    ss << "\\units C\n";
    ss << "A6, \\field Heating Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  Gas\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A7, \\field Heating Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A8, \\field Heating Coil Setpoint Schedule Name\n";
    ss << "\\note  Leave blank if constant setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N8, \\field Heating Coil Design Setpoint\n";
    ss << "\\note   Used for sizing and as constant setpoint if no Heating Coil Setpoint Schedule Name is specified.\n";
    ss << "\\default 10.0\n";
    ss << "\\units C\n";
    ss << "N9, \\field Gas Heating Coil Efficiency\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.8\n";
    ss << "N10, \\field Gas Heating Coil Parasitic Electric Load\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "A9, \\field Preheat Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  Gas\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A10, \\field Preheat Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A11, \\field Preheat Coil Setpoint Schedule Name\n";
    ss << "\\note  Leave blank if constant setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N11, \\field Preheat Coil Design Setpoint\n";
    ss << "\\note   Used for sizing and as constant setpoint if no Preheat Coil Setpoint Schedule Name specified.\n";
    ss << "\\units C\n";
    ss << "\\default 7.2\n";
    ss << "N12, \\field Gas Preheat Coil Efficiency\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.8\n";
    ss << "N13, \\field Gas Preheat Coil Parasitic Electric Load\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N14, \\field Maximum Outdoor Air Flow Rate\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "N15, \\field Minimum Outdoor Air Flow Rate\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "A12, \\field Minimum Outdoor Air Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key FixedMinimum\n";
    ss << "\\key ProportionalMinimum\n";
    ss << "\\default ProportionalMinimum\n";
    ss << "A13, \\field Minimum Outdoor Air Schedule Name\n";
    ss << "\\note Schedule values multiply the Minimum Outdoor Air Flow Rate\n";
    ss << "\\note If blank, multiplier is always one\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A14, \\field Economizer Type\n";
    ss << "\\type choice\n";
    ss << "\\key FixedDryBulb\n";
    ss << "\\key FixedEnthalpy\n";
    ss << "\\key DifferentialDryBulb\n";
    ss << "\\key DifferentialEnthalpy\n";
    ss << "\\key FixedDewPointAndDryBulb\n";
    ss << "\\key ElectronicEnthalpy\n";
    ss << "\\key DifferentialDryBulbAndEnthalpy\n";
    ss << "\\key NoEconomizer\n";
    ss << "\\default NoEconomizer\n";
    ss << "A15, \\field Economizer Lockout\n";
    ss << "\\type choice\n";
    ss << "\\key NoLockout\n";
    ss << "\\default NoLockout\n";
    ss << "N16, \\field Economizer Upper Temperature Limit\n";
    ss << "\\note Outdoor temperature above which economizer is disabled and\n";
    ss << "\\note heat recovery is enabled (if available).\n";
    ss << "\\note Blank means no limit.\n";
    ss << "\\units C\n";
    ss << "N17, \\field Economizer Lower Temperature Limit\n";
    ss << "\\note Outdoor temperature below which economizer is disabled and\n";
    ss << "\\note heat recovery is enabled (if available).\n";
    ss << "\\note Blank means no limit.\n";
    ss << "\\units C\n";
    ss << "N18, \\field Economizer Upper Enthalpy Limit\n";
    ss << "\\note Outdoor enthalpy above which economizer is disabled and\n";
    ss << "\\note heat recovery is enabled (if available).\n";
    ss << "\\note Blank means no limit.\n";
    ss << "\\units J/kg\n";
    ss << "N19, \\field Economizer Maximum Limit Dewpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the maximum outdoor dewpoint temperature limit for FixedDewPointAndDryBulb\n";
    ss << "\\note economizer control type. No input or blank input means this limit is not operative.\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "A16, \\field Supply Plenum Name\n";
    ss << "\\note Plenum zone name.  Supply plenum serves all zones on this system.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A17, \\field Return Plenum Name\n";
    ss << "\\note Plenum zone name.  Supply plenum serves all zones on this system.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A18, \\field Supply Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key DrawThrough\n";
    ss << "\\key BlowThrough\n";
    ss << "\\default DrawThrough\n";
    ss << "A19, \\field Supply Fan Part-Load Power Coefficients\n";
    ss << "\\note This field selects a predefined set of fan power coefficients.\n";
    ss << "\\note The ASHRAE 90.1-2004 Appendix G coefficients are from TABLE G3.1.3.15, Method 2.\n";
    ss << "\\note The other sets of coefficients are from the EnergyPlus Input\n";
    ss << "\\note Output Reference, Fan Coefficient Values table.\n";
    ss << "\\type choice\n";
    ss << "\\key InletVaneDampers\n";
    ss << "\\key OutletDampers\n";
    ss << "\\key VariableSpeedMotor\n";
    ss << "\\key ASHRAE90.1-2004AppendixG\n";
    ss << "\\key VariableSpeedMotorPressureReset\n";
    ss << "\\default InletVaneDampers\n";
    ss << "A20, \\field Night Cycle Control\n";
    ss << "\\type choice\n";
    ss << "\\key StayOff\n";
    ss << "\\key CycleOnAny\n";
    ss << "\\key CycleOnControlZone\n";
    ss << "\\key CycleOnAnyZoneFansOnly\n";
    ss << "\\default StayOff\n";
    ss << "A21, \\field Night Cycle Control Zone Name\n";
    ss << "\\note Applicable only if Night Cycle Control is Cycle On Control Zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A22, \\field Heat Recovery Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Sensible\n";
    ss << "\\key Enthalpy\n";
    ss << "\\default None\n";
    ss << "N20, \\field Sensible Heat Recovery Effectiveness\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.70\n";
    ss << "N21, \\field Latent Heat Recovery Effectiveness\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.65\n";
    ss << "A23, \\field Cooling Coil Setpoint Reset Type\n";
    ss << "\\note Overrides Cooling Coil Setpoint Schedule Name\n";
    ss << "\\note None = no reset, control to Cooling Coil Design Setpoint Temperature or Schedule\n";
    ss << "\\note Warmest = reset as warm as possible yet meet all zone cooling loads at max supply air flow rate\n";
    ss << "\\note OutdoorAirTemperatureReset = reset based on outdoor air temperature (18.0C at 15.6C ODB,\n";
    ss << "\\note to the Cooling Design Setpoint at 26.7C)\n";
    ss << "\\note WarmestTemperatureFirst = reset as warm as possible yet meet all zone cooling loads at\n";
    ss << "\\note min supply air flow rate\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Warmest\n";
    ss << "\\key OutdoorAirTemperatureReset\n";
    ss << "\\key WarmestTemperatureFirst\n";
    ss << "\\default None\n";
    ss << "A24, \\field Heating Coil Setpoint Reset Type\n";
    ss << "\\note Overrides Heating Coil Setpoint Schedule Name\n";
    ss << "\\note None = no reset, control to Heating Coil Design Setpoint Temperature or Schedule\n";
    ss << "\\note OutdoorAirTemperatureReset = reset based on outdoor air temperature\n";
    ss << "\\note (Heating Design Setpoint at -6.7C ODB to Heating Design Setpoint minus 5.2C at 10C ODB)\n";
    ss << "\\note min supply air flow rate\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key OutdoorAirTemperatureReset\n";
    ss << "\\default None\n";
    ss << "A25, \\field Dehumidification Control Type\n";
    ss << "\\note None = meet sensible load only\n";
    ss << "\\note CoolReheat = cool beyond the dry-bulb setpoint\n";
    ss << "\\note as required to meet the humidity setpoint.\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key CoolReheat\n";
    ss << "\\default None\n";
    ss << "A26, \\field Dehumidification Control Zone Name\n";
    ss << "\\note Zone name where humidistat is located\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N22, \\field Dehumidification Setpoint\n";
    ss << "\\note Zone relative humidity setpoint in percent (0 to 100)\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\default 60.0\n";
    ss << "\\units percent\n";
    ss << "A27, \\field Humidifier Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key ElectricSteam\n";
    ss << "\\default None\n";
    ss << "A28, \\field Humidifier Availability Schedule Name\n";
    ss << "\\note If blank, always available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N23, \\field Humidifier Rated Capacity\n";
    ss << "\\note Moisture output rate at full rated power input.\n";
    ss << "\\note The humidifier does not currently autosize, so the default is very large\n";
    ss << "\\note to allow for adequate capacity.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.000001\n";
    ss << "\\ip-units gal/min\n";
    ss << "N24, \\field Humidifier Rated Electric Power\n";
    ss << "\\note Electric power input at rated capacity moisture output.\n";
    ss << "\\note Power consumption is proportional to moisture output with no part-load penalty.\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\ip-units W\n";
    ss << "A29, \\field Humidifier Control Zone Name\n";
    ss << "\\note Zone name where humidistat is located\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N25, \\field Humidifier Setpoint\n";
    ss << "\\note Zone relative humidity setpoint in percent (0 to 100)\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\default 30.0\n";
    ss << "\\units percent\n";
    ss << "A30, \\field Sizing Option\n";
    ss << "\\note Select whether autosized system supply flow rate is the sum of Coincident or NonCoincident\n";
    ss << "\\note zone air flow rates.\n";
    ss << "\\type choice\n";
    ss << "\\key Coincident\n";
    ss << "\\key NonCoincident\n";
    ss << "\\default NonCoincident\n";
    ss << "A31, \\field Return Fan\n";
    ss << "\\note Specifies if the system has a return fan.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N26, \\field Return Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N27, \\field Return Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 500\n";
    ss << "N28, \\field Return Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N29, \\field Return Fan Motor in Air Stream Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A32; \\field Return Fan Part-Load Power Coefficients\n";
    ss << "\\note This field selects a predefined set of fan power coefficients.\n";
    ss << "\\note The ASHRAE 90.1-2004 Appendix G coefficients are from TABLE G3.1.3.15, Method 2.\n";
    ss << "\\note The other sets of coefficients are from the EnergyPlus Input\n";
    ss << "\\note Output Reference, Fan Coefficient Values table.\n";
    ss << "\\type choice\n";
    ss << "\\key InletVaneDampers\n";
    ss << "\\key OutletDampers\n";
    ss << "\\key VariableSpeedMotor\n";
    ss << "\\key ASHRAE90.1-2004AppendixG\n";
    ss << "\\key VariableSpeedMotorPressureReset\n";
    ss << "\\default InletVaneDampers\n";

    IddObjectType objType(IddObjectType::HVACTemplate_System_VAV);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:System:VAV",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_System_VAV);
  return object;
}

IddObject createHVACTemplate_System_PackagedVAVIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:System:PackagedVAV,\n";
    ss << "\\min-fields 59\n";
    ss << "\\memo Packaged Variable Air Volume (PVAV) air loop with optional heating coil\n";
    ss << "\\memo and optional preheat.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CompactHVACSystemVAV\n";
    ss << "\\reference HVACTemplateSystems\n";
    ss << "A2, \\field System Availability Schedule Name\n";
    ss << "\\note If blank, always on; PVAV System always on.  Schedule is used in availability manager\n";
    ss << "\\note and fan scheduling.\n";
    ss << "\\note Also see \"Night Cycle Control\" field.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Supply Fan Maximum Flow Rate\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will *not* be\n";
    ss << "\\note multiplied by any sizing factor or by zone multipliers.  If using zone multipliers\n";
    ss << "\\note a value entered here must be large enough to serve the multiplied zones.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2, \\field Supply Fan Minimum Flow Rate\n";
    ss << "\\note This field is only used to set a minimum part load on the VAV fan power curve.\n";
    ss << "\\note Autosize or zero is recommended.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "A3, \\field Supply Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key DrawThrough\n";
    ss << "\\key BlowThrough\n";
    ss << "\\default DrawThrough\n";
    ss << "N3, \\field Supply Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N4, \\field Supply Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 1000\n";
    ss << "N5, \\field Supply Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N6, \\field Supply Fan Motor in Air Stream Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A4, \\field Cooling Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  TwoSpeedDX\n";
    ss << "\\key  TwoSpeedHumidControlDX\n";
    ss << "\\default TwoSpeedDX\n";
    ss << "A5, \\field Cooling Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6, \\field Cooling Coil Setpoint Schedule Name\n";
    ss << "\\note  Leave blank if constant setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N7, \\field Cooling Coil Design Setpoint\n";
    ss << "\\note  Used for sizing and as constant setpoint if no Cooling Coil Setpoint Schedule Name is specified.\n";
    ss << "\\default 12.8\n";
    ss << "\\units C\n";
    ss << "N8, \\field Cooling Coil Gross Rated Total Capacity\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N9, \\field Cooling Coil Gross Rated Sensible Heat Ratio\n";
    ss << "\\note Gross SHR\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default autosize\n";
    ss << "N10, \\field Cooling Coil Gross Rated COP\n";
    ss << "\\note Gross cooling capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply fan heat or supply fan electric power input\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.0\n";
    ss << "A7, \\field Heating Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  Gas\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A8, \\field Heating Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A9, \\field Heating Coil Setpoint Schedule Name\n";
    ss << "\\note  Leave blank if constant setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N11, \\field Heating Coil Design Setpoint\n";
    ss << "\\note   Used for sizing and as constant setpoint if no Heating Coil Setpoint Schedule Name is specified.\n";
    ss << "\\default 10.0\n";
    ss << "\\units C\n";
    ss << "N12, \\field Heating Coil Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N13, \\field Gas Heating Coil Efficiency\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.8\n";
    ss << "N14, \\field Gas Heating Coil Parasitic Electric Load\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N15, \\field Maximum Outdoor Air Flow Rate\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "N16, \\field Minimum Outdoor Air Flow Rate\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "A10, \\field Minimum Outdoor Air Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key FixedMinimum\n";
    ss << "\\key ProportionalMinimum\n";
    ss << "\\default ProportionalMinimum\n";
    ss << "A11, \\field Minimum Outdoor Air Schedule Name\n";
    ss << "\\note Schedule values multiply the Minimum Outdoor Air Flow Rate\n";
    ss << "\\note If blank, multiplier is always one\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A12, \\field Economizer Type\n";
    ss << "\\type choice\n";
    ss << "\\key FixedDryBulb\n";
    ss << "\\key FixedEnthalpy\n";
    ss << "\\key DifferentialDryBulb\n";
    ss << "\\key DifferentialEnthalpy\n";
    ss << "\\key FixedDewPointAndDryBulb\n";
    ss << "\\key ElectronicEnthalpy\n";
    ss << "\\key DifferentialDryBulbAndEnthalpy\n";
    ss << "\\key NoEconomizer\n";
    ss << "\\default NoEconomizer\n";
    ss << "A13, \\field Economizer Lockout\n";
    ss << "\\type choice\n";
    ss << "\\key NoLockout\n";
    ss << "\\key LockoutWithHeating\n";
    ss << "\\key LockoutWithCompressor\n";
    ss << "\\default NoLockout\n";
    ss << "N17, \\field Economizer Maximum Limit Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the maximum outdoor dry-bulb temperature limit for FixedDryBulb\n";
    ss << "\\note economizer control type. No input or blank input means this limit is\n";
    ss << "\\note not operative. Limit is applied regardless of economizer control type.\n";
    ss << "N18, \\field Economizer Maximum Limit Enthalpy\n";
    ss << "\\type real\n";
    ss << "\\units J/kg\n";
    ss << "\\note Enter the maximum outdoor enthalpy limit for FixedEnthalpy economizer control type.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "N19, \\field Economizer Maximum Limit Dewpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the maximum outdoor dewpoint temperature limit for FixedDewPointAndDryBulb\n";
    ss << "\\note economizer control type. No input or blank input means this limit is not operative.\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "N20, \\field Economizer Minimum Limit Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the minimum outdoor dry-bulb temperature limit for economizer control.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "A14, \\field Supply Plenum Name\n";
    ss << "\\note Plenum zone name.  Supply plenum serves all zones on this system.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A15, \\field Return Plenum Name\n";
    ss << "\\note Plenum zone name.  Supply plenum serves all zones on this system.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A16, \\field Supply Fan Part-Load Power Coefficients\n";
    ss << "\\note This field selects a predefined set of fan power coefficients.\n";
    ss << "\\note The ASHRAE 90.1-2004 Appendix G coefficients are from TABLE G3.1.3.15, Method 2.\n";
    ss << "\\note The other sets of coefficients are from the EnergyPlus Input\n";
    ss << "\\note Output Reference, Fan Coefficient Values table.\n";
    ss << "\\type choice\n";
    ss << "\\key InletVaneDampers\n";
    ss << "\\key OutletDampers\n";
    ss << "\\key VariableSpeedMotor\n";
    ss << "\\key ASHRAE90.1-2004AppendixG\n";
    ss << "\\key VariableSpeedMotorPressureReset\n";
    ss << "\\default InletVaneDampers\n";
    ss << "A17, \\field Night Cycle Control\n";
    ss << "\\type choice\n";
    ss << "\\key StayOff\n";
    ss << "\\key CycleOnAny\n";
    ss << "\\key CycleOnControlZone\n";
    ss << "\\key CycleOnAnyZoneFansOnly\n";
    ss << "\\default StayOff\n";
    ss << "A18, \\field Night Cycle Control Zone Name\n";
    ss << "\\note Applicable only if Night Cycle Control is Cycle On Control Zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A19, \\field Heat Recovery Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Sensible\n";
    ss << "\\key Enthalpy\n";
    ss << "\\default None\n";
    ss << "N21, \\field Sensible Heat Recovery Effectiveness\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.70\n";
    ss << "N22, \\field Latent Heat Recovery Effectiveness\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.65\n";
    ss << "A20, \\field Cooling Coil Setpoint Reset Type\n";
    ss << "\\note Overrides Cooling Coil Setpoint Schedule Name\n";
    ss << "\\note None = no reset, control to Cooling Coil Design Setpoint Temperature or Schedule\n";
    ss << "\\note Warmest = reset as warm as possible yet meet all zone cooling loads at max supply air flow rate\n";
    ss << "\\note OutdoorAirTemperatureReset = reset based on outdoor air temperature (18.0C at 15.6C ODB,\n";
    ss << "\\note to the Cooling Design Setpoint at 26.7C)\n";
    ss << "\\note WarmestTemperatureFirst = reset as warm as possible yet meet all zone cooling loads at\n";
    ss << "\\note min supply air flow rate\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Warmest\n";
    ss << "\\key OutdoorAirTemperatureReset\n";
    ss << "\\key WarmestTemperatureFirst\n";
    ss << "\\default None\n";
    ss << "A21, \\field Heating Coil Setpoint Reset Type\n";
    ss << "\\note Overrides Heating Coil Setpoint Schedule Name\n";
    ss << "\\note None = no reset, control to Heating Coil Design Setpoint Temperature or Schedule\n";
    ss << "\\note OutdoorAirTemperatureReset = reset based on outdoor air temperature\n";
    ss << "\\note (Heating Design Setpoint at -6.7C ODB to Heating Design Setpoint minus 5.2C at 10C ODB)\n";
    ss << "\\note min supply air flow rate\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key OutdoorAirTemperatureReset\n";
    ss << "\\default None\n";
    ss << "A22, \\field Dehumidification Control Type\n";
    ss << "\\note None = meet sensible load only\n";
    ss << "\\note CoolReheat = cool beyond the dry-bulb setpoint\n";
    ss << "\\note as required to meet the humidity setpoint.\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key CoolReheat\n";
    ss << "\\default None\n";
    ss << "A23, \\field Dehumidification Control Zone Name\n";
    ss << "\\note Zone name where humidistat is located\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N23, \\field Dehumidification Setpoint\n";
    ss << "\\note Zone relative humidity setpoint in percent (0 to 100)\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\default 60.0\n";
    ss << "\\units percent\n";
    ss << "A24, \\field Humidifier Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key ElectricSteam\n";
    ss << "\\default None\n";
    ss << "A25, \\field Humidifier Availability Schedule Name\n";
    ss << "\\note If blank, always available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N24, \\field Humidifier Rated Capacity\n";
    ss << "\\note Moisture output rate at full rated power input.\n";
    ss << "\\note The humidifier does not currently autosize, so the default is very large\n";
    ss << "\\note to allow for adequate capacity.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.000001\n";
    ss << "\\ip-units gal/min\n";
    ss << "N25, \\field Humidifier Rated Electric Power\n";
    ss << "\\note Electric power input at rated capacity moisture output.\n";
    ss << "\\note Power consumption is proportional to moisture output with no part-load penalty.\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\ip-units W\n";
    ss << "A26, \\field Humidifier Control Zone Name\n";
    ss << "\\note Zone name where humidistat is located\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N26, \\field Humidifier Setpoint\n";
    ss << "\\note Zone relative humidity setpoint in percent (0 to 100)\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\default 30.0\n";
    ss << "\\units percent\n";
    ss << "A27, \\field Sizing Option\n";
    ss << "\\note Select whether autosized system supply flow rate is the sum of Coincident or NonCoincident\n";
    ss << "\\note zone air flow rates.\n";
    ss << "\\type choice\n";
    ss << "\\key Coincident\n";
    ss << "\\key NonCoincident\n";
    ss << "\\default NonCoincident\n";
    ss << "A28, \\field Return Fan\n";
    ss << "\\note Specifies if the system has a return fan.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N27, \\field Return Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N28, \\field Return Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 500\n";
    ss << "N29, \\field Return Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N30, \\field Return Fan Motor in Air Stream Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A29; \\field Return Fan Part-Load Power Coefficients\n";
    ss << "\\note This field selects a predefined set of fan power coefficients.\n";
    ss << "\\note The ASHRAE 90.1-2004 Appendix G coefficients are from TABLE G3.1.3.15, Method 2.\n";
    ss << "\\note The other sets of coefficients are from the EnergyPlus Input\n";
    ss << "\\note Output Reference, Fan Coefficient Values table.\n";
    ss << "\\type choice\n";
    ss << "\\key InletVaneDampers\n";
    ss << "\\key OutletDampers\n";
    ss << "\\key VariableSpeedMotor\n";
    ss << "\\key ASHRAE90.1-2004AppendixG\n";
    ss << "\\key VariableSpeedMotorPressureReset\n";
    ss << "\\default InletVaneDampers\n";

    IddObjectType objType(IddObjectType::HVACTemplate_System_PackagedVAV);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:System:PackagedVAV",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_System_PackagedVAV);
  return object;
}

IddObject createHVACTemplate_System_ConstantVolumeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:System:ConstantVolume,\n";
    ss << "\\min-fields 70\n";
    ss << "\\memo Constant Air Volume air loop with optional chilled water cooling coil,\n";
    ss << "\\memo optional heating coil and optional preheat.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CompactHVACSystemConstantVolume\n";
    ss << "\\reference HVACTemplateSystems\n";
    ss << "A2, \\field System Availability Schedule Name\n";
    ss << "\\note If blank, always on;  Schedule is used in availability manager\n";
    ss << "\\note and fan scheduling.\n";
    ss << "\\note Also see \"Night Cycle Control\" field.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Supply Fan Maximum Flow Rate\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will *not* be\n";
    ss << "\\note multiplied by any sizing factor or by zone multipliers.  If using zone multipliers\n";
    ss << "\\note a value entered here must be large enough to serve the multiplied zones.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2, \\field Supply Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N3, \\field Supply Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 600\n";
    ss << "N4, \\field Supply Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N5, \\field Supply Fan Motor in Air Stream Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A3, \\field Supply Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key DrawThrough\n";
    ss << "\\key BlowThrough\n";
    ss << "\\default DrawThrough\n";
    ss << "A4, \\field Cooling Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  ChilledWater\n";
    ss << "\\key  ChilledWaterDetailedFlatModel\n";
    ss << "\\key  HeatExchangerAssistedChilledWater\n";
    ss << "\\key  None\n";
    ss << "\\default  ChilledWater\n";
    ss << "A5, \\field Cooling Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6, \\field Cooling Coil Setpoint Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key  FixedSetpoint\n";
    ss << "\\key  Scheduled\n";
    ss << "\\key  OutdoorAirTemperatureReset\n";
    ss << "\\key  Warmest\n";
    ss << "\\key  ControlZone\n";
    ss << "\\default FixedSetpoint\n";
    ss << "A7, \\field Cooling Coil Control Zone name\n";
    ss << "\\note name of the HVACTemplate:ZoneConstantVolume object that\n";
    ss << "\\note contains the cooling thermostat when Cooling Coil Setpoint Control Type = ControlZone\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HVACTemplateConstantVolumeZones\n";
    ss << "N6, \\field Cooling Coil Design Setpoint Temperature\n";
    ss << "\\note  Used for sizing and as constant setpoint if no Cooling Coil Setpoint Schedule Name is specified.\n";
    ss << "\\default 12.8\n";
    ss << "\\units C\n";
    ss << "A8, \\field Cooling Coil Setpoint Schedule Name\n";
    ss << "\\note  Leave blank if constant setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N7, \\field Cooling Coil Setpoint at Outdoor Dry-Bulb Low\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 15.6\n";
    ss << "N8, \\field Cooling Coil Reset Outdoor Dry-Bulb Low\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\note Defaults are 15.6C (60F) at 15.6C (60F) to 12.8C (55F) at 23.3C (74F)\n";
    ss << "\\units C\n";
    ss << "\\default 15.6\n";
    ss << "N9, \\field Cooling Coil Setpoint at Outdoor Dry-Bulb High\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 12.8\n";
    ss << "N10, \\field Cooling Coil Reset Outdoor Dry-Bulb High\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 23.3\n";
    ss << "A9, \\field Heating Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  Gas\n";
    ss << "\\key  None\n";
    ss << "\\default HotWater\n";
    ss << "A10, \\field Heating Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A11, \\field Heating Coil Setpoint Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key  FixedSetpoint\n";
    ss << "\\key  Scheduled\n";
    ss << "\\key  OutdoorAirTemperatureReset\n";
    ss << "\\key  ControlZone\n";
    ss << "\\default FixedSetpoint\n";
    ss << "A12, \\field Heating Coil Control Zone name\n";
    ss << "\\note name of the HVACTemplate:ZoneConstantVolume object that\n";
    ss << "\\note contains the heating thermostat\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HVACTemplateConstantVolumeZones\n";
    ss << "N11, \\field Heating Coil Design Setpoint\n";
    ss << "\\note  Used for sizing and as constant setpoint if no Heating Coil Setpoint Schedule Name is specified.\n";
    ss << "\\default 10.0\n";
    ss << "\\units C\n";
    ss << "A13, \\field Heating Coil Setpoint Schedule Name\n";
    ss << "\\note  Leave blank if constant setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N12, \\field Heating Coil Setpoint at Outdoor Dry-Bulb Low\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 15.0\n";
    ss << "N13, \\field Heating Coil Reset Outdoor Dry-Bulb Low\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\note Defaults are 15.6C (60F) at 15.6C (60F) to 12.8C (55F) at 23.3C (74F)\n";
    ss << "\\units C\n";
    ss << "\\default 7.8\n";
    ss << "N14, \\field Heating Coil Setpoint at Outdoor Dry-Bulb High\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 12.2\n";
    ss << "N15, \\field Heating Coil Reset Outdoor Dry-Bulb High\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 12.2\n";
    ss << "N16, \\field Heating Coil Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N17, \\field Gas Heating Coil Efficiency\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.8\n";
    ss << "N18, \\field Gas Heating Coil Parasitic Electric Load\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "A14, \\field Preheat Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  Gas\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A15, \\field Preheat Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N19, \\field Preheat Coil Design Setpoint\n";
    ss << "\\note   Used for sizing and as constant setpoint if no Preheat Coil Setpoint Schedule Name specified.\n";
    ss << "\\units C\n";
    ss << "\\default 7.2\n";
    ss << "A16, \\field Preheat Coil Setpoint Schedule Name\n";
    ss << "\\note  Leave blank if constant setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N20, \\field Gas Preheat Coil Efficiency\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.8\n";
    ss << "N21, \\field Gas Preheat Coil Parasitic Electric Load\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N22, \\field Maximum Outdoor Air Flow Rate\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "N23, \\field Minimum Outdoor Air Flow Rate\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "A17, \\field Minimum Outdoor Air Schedule Name\n";
    ss << "\\note Schedule values multiply the Minimum Outdoor Air Flow Rate\n";
    ss << "\\note If blank, multiplier is always one\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A18, \\field Economizer Type\n";
    ss << "\\type choice\n";
    ss << "\\key FixedDryBulb\n";
    ss << "\\key FixedEnthalpy\n";
    ss << "\\key DifferentialDryBulb\n";
    ss << "\\key DifferentialEnthalpy\n";
    ss << "\\key FixedDewPointAndDryBulb\n";
    ss << "\\key ElectronicEnthalpy\n";
    ss << "\\key DifferentialDryBulbAndEnthalpy\n";
    ss << "\\key NoEconomizer\n";
    ss << "\\default NoEconomizer\n";
    ss << "N24, \\field Economizer Upper Temperature Limit\n";
    ss << "\\note Outdoor temperature above which economizer is disabled and\n";
    ss << "\\note heat recovery is enabled (if available).\n";
    ss << "\\note Blank means no limit.\n";
    ss << "\\units C\n";
    ss << "N25, \\field Economizer Lower Temperature Limit\n";
    ss << "\\note Outdoor temperature below which economizer is disabled and\n";
    ss << "\\note heat recovery is enabled (if available).\n";
    ss << "\\note Blank means no limit.\n";
    ss << "\\units C\n";
    ss << "N26, \\field Economizer Upper Enthalpy Limit\n";
    ss << "\\note Outdoor enthalpy above which economizer is disabled and\n";
    ss << "\\note heat recovery is enabled (if available).\n";
    ss << "\\note Blank means no limit.\n";
    ss << "\\units J/kg\n";
    ss << "N27, \\field Economizer Maximum Limit Dewpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the maximum outdoor dewpoint temperature limit for FixedDewPointAndDryBulb\n";
    ss << "\\note economizer control type. No input or blank input means this limit is not operative.\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "A19, \\field Supply Plenum Name\n";
    ss << "\\note Plenum zone name.  Supply plenum serves all zones on this system.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A20, \\field Return Plenum Name\n";
    ss << "\\note Plenum zone name.  Supply plenum serves all zones on this system.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A21, \\field Night Cycle Control\n";
    ss << "\\type choice\n";
    ss << "\\key StayOff\n";
    ss << "\\key CycleOnAny\n";
    ss << "\\key CycleOnControlZone\n";
    ss << "\\key CycleOnAnyZoneFansOnly\n";
    ss << "\\default StayOff\n";
    ss << "A22, \\field Night Cycle Control Zone Name\n";
    ss << "\\note Applicable only if Night Cycle Control is Cycle On Control Zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A23, \\field Heat Recovery Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Sensible\n";
    ss << "\\key Enthalpy\n";
    ss << "\\default None\n";
    ss << "N28, \\field Sensible Heat Recovery Effectiveness\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.70\n";
    ss << "N29, \\field Latent Heat Recovery Effectiveness\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.65\n";
    ss << "A24, \\field Heat Recovery Heat Exchanger Type\n";
    ss << "\\type choice\n";
    ss << "\\key Plate\n";
    ss << "\\key Rotary\n";
    ss << "\\default Plate\n";
    ss << "A25, \\field Heat Recovery Frost Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key ExhaustAirRecirculation\n";
    ss << "\\key ExhaustOnly\n";
    ss << "\\key MinimumExhaustTemperature\n";
    ss << "\\default None\n";
    ss << "A26, \\field Dehumidification Control Type\n";
    ss << "\\note None = meet sensible load only\n";
    ss << "\\note CoolReheat = cool beyond the dry-bulb setpoint\n";
    ss << "\\note as required to meet the humidity setpoint.\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key CoolReheat\n";
    ss << "\\default None\n";
    ss << "A27, \\field Dehumidification Control Zone Name\n";
    ss << "\\note Zone name where humidistat is located\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N30, \\field Dehumidification Relative Humidity Setpoint\n";
    ss << "\\note Zone relative humidity setpoint in percent (0 to 100)\n";
    ss << "\\note Ignored if Dehumidification Relative Humidity Setpoint Schedule specified below\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\default 60.0\n";
    ss << "\\units percent\n";
    ss << "A28, \\field Dehumidification Relative Humidity Setpoint Schedule Name\n";
    ss << "\\note Leave blank to use constant setpoint specified in Dehumidification Relative Humidity\n";
    ss << "\\note Setpoint above. Schedule values must be in percent relative humidity (0 to 100).\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A29, \\field Humidifier Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key ElectricSteam\n";
    ss << "\\default None\n";
    ss << "A30, \\field Humidifier Availability Schedule Name\n";
    ss << "\\note If blank, always available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N31, \\field Humidifier Rated Capacity\n";
    ss << "\\note Moisture output rate at full rated power input.\n";
    ss << "\\note The humidifier does not currently autosize, so the default is very large\n";
    ss << "\\note to allow for adequate capacity.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.000001\n";
    ss << "\\ip-units gal/min\n";
    ss << "N32, \\field Humidifier Rated Electric Power\n";
    ss << "\\note Electric power input at rated capacity moisture output.\n";
    ss << "\\note Power consumption is proportional to moisture output with no part-load penalty.\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\ip-units W\n";
    ss << "A31, \\field Humidifier Control Zone Name\n";
    ss << "\\note Zone name where humidistat is located\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N33, \\field Humidifier Relative Humidity Setpoint\n";
    ss << "\\note Zone relative humidity setpoint in percent (0 to 100).\n";
    ss << "\\note Ignored if Humidifier Relative Humidity Setpoint Schedule specified below\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\default 30.0\n";
    ss << "\\units percent\n";
    ss << "A32, \\field Humidifier Relative Humidity Setpoint Schedule Name\n";
    ss << "\\note Leave blank to use constant setpoint specified in Humidifier Relative Humidity\n";
    ss << "\\note  Setpoint above.Schedule values must be in percent relative humidity (0 to 100).\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A33, \\field Return Fan\n";
    ss << "\\note Specifies if the system has a return fan.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N34, \\field Return Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N35, \\field Return Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 300\n";
    ss << "N36, \\field Return Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N37; \\field Return Fan Motor in Air Stream Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::HVACTemplate_System_ConstantVolume);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:System:ConstantVolume",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_System_ConstantVolume);
  return object;
}

IddObject createHVACTemplate_System_DualDuctIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:System:DualDuct,\n";
    ss << "\\min-fields 91\n";
    ss << "\\memo Dual-duct constant volume or variable volume air loop\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CompactHVACSystemDualDuct\n";
    ss << "\\reference HVACTemplateSystems\n";
    ss << "A2, \\field System Availability Schedule Name\n";
    ss << "\\note If blank, always on;  Schedule is used in availability manager\n";
    ss << "\\note and fan scheduling.\n";
    ss << "\\note Also see \"Night Cycle Control\" field.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field System Configuration Type\n";
    ss << "\\note SingleFan - a single supply fan before the split to dual ducts\n";
    ss << "\\note DualFan - two supply fans, one each for the cold and hot ducts\n";
    ss << "\\note ConstantVolume - constant volume\n";
    ss << "\\note VariableVolume - variable volume\n";
    ss << "\\type choice\n";
    ss << "\\key SingleFanConstantVolume\n";
    ss << "\\key DualFanConstantVolume\n";
    ss << "\\key SingleFanVariableVolume\n";
    ss << "\\key DualFanVariableVolume\n";
    ss << "\\default SingleFanConstantVolume\n";
    ss << "N1, \\field Main Supply Fan Maximum Flow Rate\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will *not* be\n";
    ss << "\\note multiplied by any sizing factor or by zone multipliers.  If using zone multipliers\n";
    ss << "\\note a value entered here must be large enough to serve the multiplied zones.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2, \\field Main Supply Fan Minimum Flow Fraction\n";
    ss << "\\default 0.2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N3, \\field Main Supply Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N4, \\field Main Supply Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 1000\n";
    ss << "N5, \\field Main Supply Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N6, \\field Main Supply Fan Motor in Air Stream Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A4, \\field Main Supply Fan Part-Load Power Coefficients\n";
    ss << "\\note This field selects a predefined set of fan power coefficients.\n";
    ss << "\\note The ASHRAE 90.1-2004 Appendix G coefficients are from TABLE G3.1.3.15, Method 2.\n";
    ss << "\\note The other sets of coefficients are from the EnergyPlus Input\n";
    ss << "\\note Output Reference, Fan Coefficient Values table.\n";
    ss << "\\type choice\n";
    ss << "\\key InletVaneDampers\n";
    ss << "\\key OutletDampers\n";
    ss << "\\key VariableSpeedMotor\n";
    ss << "\\key ASHRAE90.1-2004AppendixG\n";
    ss << "\\key VariableSpeedMotorPressureReset\n";
    ss << "\\default InletVaneDampers\n";
    ss << "N7, \\field Cold Duct Supply Fan Maximum Flow Rate\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will *not* be\n";
    ss << "\\note multiplied by any sizing factor or by zone multipliers.  If using zone multipliers\n";
    ss << "\\note a value entered here must be large enough to serve the multiplied zones.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "N8, \\field Cold Duct Supply Fan Minimum Flow Fraction\n";
    ss << "\\default 0.2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N9, \\field Cold Duct Supply Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N10, \\field Cold Duct Supply Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 1000\n";
    ss << "N11, \\field Cold Duct Supply Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N12, \\field Cold Duct Supply Fan Motor in Air Stream Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A5, \\field Cold Duct Supply Fan Part-Load Power Coefficients\n";
    ss << "\\note This field selects a predefined set of fan power coefficients.\n";
    ss << "\\note The ASHRAE 90.1-2004 Appendix G coefficients are from TABLE G3.1.3.15, Method 2.\n";
    ss << "\\note The other sets of coefficients are from the EnergyPlus Input\n";
    ss << "\\note Output Reference, Fan Coefficient Values table.\n";
    ss << "\\type choice\n";
    ss << "\\key InletVaneDampers\n";
    ss << "\\key OutletDampers\n";
    ss << "\\key VariableSpeedMotor\n";
    ss << "\\key ASHRAE90.1-2004AppendixG\n";
    ss << "\\key VariableSpeedMotorPressureReset\n";
    ss << "\\default InletVaneDampers\n";
    ss << "A6, \\field Cold Duct Supply Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default DrawThrough\n";
    ss << "N13, \\field Hot Duct Supply Fan Maximum Flow Rate\n";
    ss << "\\note This field may be set to \"autosize\".  If a value is entered, it will *not* be\n";
    ss << "\\note multiplied by any sizing factor or by zone multipliers.  If using zone multipliers\n";
    ss << "\\note a value entered here must be large enough to serve the multiplied zones.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "N14, \\field Hot Duct Supply Fan Minimum Flow Fraction\n";
    ss << "\\default 0.2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N15, \\field Hot Duct Supply Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N16, \\field Hot Duct Supply Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 1000\n";
    ss << "N17, \\field Hot Duct Supply Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N18, \\field Hot Duct Supply Fan Motor in Air Stream Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A7, \\field Hot Duct Supply Fan Part-Load Power Coefficients\n";
    ss << "\\note This field selects a predefined set of fan power coefficients.\n";
    ss << "\\note The ASHRAE 90.1-2004 Appendix G coefficients are from TABLE G3.1.3.15, Method 2.\n";
    ss << "\\note The other sets of coefficients are from the EnergyPlus Input\n";
    ss << "\\note Output Reference, Fan Coefficient Values table.\n";
    ss << "\\type choice\n";
    ss << "\\key InletVaneDampers\n";
    ss << "\\key OutletDampers\n";
    ss << "\\key VariableSpeedMotor\n";
    ss << "\\key ASHRAE90.1-2004AppendixG\n";
    ss << "\\key VariableSpeedMotorPressureReset\n";
    ss << "\\default InletVaneDampers\n";
    ss << "A8, \\field Hot Duct Supply Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default DrawThrough\n";
    ss << "A9, \\field Cooling Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  ChilledWater\n";
    ss << "\\key  ChilledWaterDetailedFlatModel\n";
    ss << "\\key  None\n";
    ss << "\\default  ChilledWater\n";
    ss << "A10, \\field Cooling Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A11, \\field Cooling Coil Setpoint Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key  FixedSetpoint\n";
    ss << "\\key  Scheduled\n";
    ss << "\\key  OutdoorAirTemperatureReset\n";
    ss << "\\key  Warmest\n";
    ss << "\\default FixedSetpoint\n";
    ss << "N19, \\field Cooling Coil Design Setpoint Temperature\n";
    ss << "\\note  Used for sizing and as constant setpoint if no Cooling Coil Setpoint Schedule Name is specified.\n";
    ss << "\\default 12.8\n";
    ss << "\\units C\n";
    ss << "A12, \\field Cooling Coil Setpoint Schedule Name\n";
    ss << "\\note  Leave blank if constant setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N20, \\field Cooling Coil Setpoint at Outdoor Dry-Bulb Low\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 15.6\n";
    ss << "N21, \\field Cooling Coil Reset Outdoor Dry-Bulb Low\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\note Defaults are 15.6C (60F) at 15.6C (60F) to 12.8C (55F) at 23.3C (74F)\n";
    ss << "\\units C\n";
    ss << "\\default 15.6\n";
    ss << "N22, \\field Cooling Coil Setpoint at Outdoor Dry-Bulb High\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 12.8\n";
    ss << "N23, \\field Cooling Coil Reset Outdoor Dry-Bulb High\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 23.3\n";
    ss << "A13, \\field Heating Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  Gas\n";
    ss << "\\key  None\n";
    ss << "\\default HotWater\n";
    ss << "A14, \\field Heating Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A15, \\field Heating Coil Setpoint Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key  FixedSetpoint\n";
    ss << "\\key  Scheduled\n";
    ss << "\\key  OutdoorAirTemperatureReset\n";
    ss << "\\key  Coldest\n";
    ss << "\\default FixedSetpoint\n";
    ss << "N24, \\field Heating Coil Design Setpoint\n";
    ss << "\\note  Used for sizing and as constant setpoint if no Heating Coil Setpoint Schedule Name is specified.\n";
    ss << "\\default 50.0\n";
    ss << "\\units C\n";
    ss << "A16, \\field Heating Coil Setpoint Schedule Name\n";
    ss << "\\note  Leave blank if constant setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N25, \\field Heating Coil Setpoint at Outdoor Dry-Bulb Low\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 50.0\n";
    ss << "N26, \\field Heating Coil Reset Outdoor Dry-Bulb Low\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\note Defaults are 15.6C (60F) at 15.6C (60F) to 12.8C (55F) at 23.3C (74F)\n";
    ss << "\\units C\n";
    ss << "\\default 7.8\n";
    ss << "N27, \\field Heating Coil Setpoint at Outdoor Dry-Bulb High\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 20.0\n";
    ss << "N28, \\field Heating Coil Reset Outdoor Dry-Bulb High\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 12.2\n";
    ss << "N29, \\field Heating Coil Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N30, \\field Gas Heating Coil Efficiency\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.8\n";
    ss << "N31, \\field Gas Heating Coil Parasitic Electric Load\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "A17, \\field Preheat Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  Gas\n";
    ss << "\\key  None\n";
    ss << "\\default None\n";
    ss << "A18, \\field Preheat Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N32, \\field Preheat Coil Design Setpoint\n";
    ss << "\\note   Used for sizing and as constant setpoint if no Preheat Coil Setpoint Schedule Name specified.\n";
    ss << "\\units C\n";
    ss << "\\default 7.2\n";
    ss << "A19, \\field Preheat Coil Setpoint Schedule Name\n";
    ss << "\\note  Leave blank if constant setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N33, \\field Gas Preheat Coil Efficiency\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.8\n";
    ss << "N34, \\field Gas Preheat Coil Parasitic Electric Load\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N35, \\field Maximum Outdoor Air Flow Rate\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "N36, \\field Minimum Outdoor Air Flow Rate\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "A20, \\field Minimum Outdoor Air Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key FixedMinimum\n";
    ss << "\\key ProportionalMinimum\n";
    ss << "\\default ProportionalMinimum\n";
    ss << "A21, \\field Minimum Outdoor Air Schedule Name\n";
    ss << "\\note Schedule values multiply the Minimum Outdoor Air Flow Rate\n";
    ss << "\\note If blank, multiplier is always one\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A22, \\field Economizer Type\n";
    ss << "\\type choice\n";
    ss << "\\key FixedDryBulb\n";
    ss << "\\key FixedEnthalpy\n";
    ss << "\\key DifferentialDryBulb\n";
    ss << "\\key DifferentialEnthalpy\n";
    ss << "\\key FixedDewPointAndDryBulb\n";
    ss << "\\key ElectronicEnthalpy\n";
    ss << "\\key DifferentialDryBulbAndEnthalpy\n";
    ss << "\\key NoEconomizer\n";
    ss << "\\default NoEconomizer\n";
    ss << "A23, \\field Economizer Lockout\n";
    ss << "\\type choice\n";
    ss << "\\key NoLockout\n";
    ss << "\\default NoLockout\n";
    ss << "N37, \\field Economizer Upper Temperature Limit\n";
    ss << "\\note Outdoor temperature above which economizer is disabled and\n";
    ss << "\\note heat recovery is enabled (if available).\n";
    ss << "\\note Blank means no limit.\n";
    ss << "\\units C\n";
    ss << "N38, \\field Economizer Lower Temperature Limit\n";
    ss << "\\note Outdoor temperature below which economizer is disabled and\n";
    ss << "\\note heat recovery is enabled (if available).\n";
    ss << "\\note Blank means no limit.\n";
    ss << "\\units C\n";
    ss << "N39, \\field Economizer Upper Enthalpy Limit\n";
    ss << "\\note Outdoor enthalpy above which economizer is disabled and\n";
    ss << "\\note heat recovery is enabled (if available).\n";
    ss << "\\note Blank means no limit.\n";
    ss << "\\units J/kg\n";
    ss << "N40, \\field Economizer Maximum Limit Dewpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the maximum outdoor dewpoint temperature limit for FixedDewPointAndDryBulb\n";
    ss << "\\note economizer control type. No input or blank input means this limit is not operative.\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "A24, \\field Cold Supply Plenum Name\n";
    ss << "\\note Plenum zone name.  Supply plenum serves the cold inlets of all zones on this system.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A25, \\field Hot Supply Plenum Name\n";
    ss << "\\note Plenum zone name.  Supply plenum serves the hot inlets of all zones on this system.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A26, \\field Return Plenum Name\n";
    ss << "\\note Plenum zone name.  Supply plenum serves all zones on this system.\n";
    ss << "\\note Blank if none.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A27, \\field Night Cycle Control\n";
    ss << "\\type choice\n";
    ss << "\\key StayOff\n";
    ss << "\\key CycleOnAny\n";
    ss << "\\key CycleOnControlZone\n";
    ss << "\\default StayOff\n";
    ss << "A28, \\field Night Cycle Control Zone Name\n";
    ss << "\\note Applicable only if Night Cycle Control is Cycle On Control Zone.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A29, \\field Heat Recovery Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Sensible\n";
    ss << "\\key Enthalpy\n";
    ss << "\\default None\n";
    ss << "N41, \\field Sensible Heat Recovery Effectiveness\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.70\n";
    ss << "N42, \\field Latent Heat Recovery Effectiveness\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.65\n";
    ss << "A30, \\field Heat Recovery Heat Exchanger Type\n";
    ss << "\\type choice\n";
    ss << "\\key Plate\n";
    ss << "\\key Rotary\n";
    ss << "\\default Plate\n";
    ss << "A31, \\field Heat Recovery Frost Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key ExhaustAirRecirculation\n";
    ss << "\\key ExhaustOnly\n";
    ss << "\\key MinimumExhaustTemperature\n";
    ss << "\\default None\n";
    ss << "A32, \\field Dehumidification Control Type\n";
    ss << "\\note None = meet sensible load only\n";
    ss << "\\note CoolReheat = cool beyond the dry-bulb setpoint\n";
    ss << "\\note as required to meet the humidity setpoint.\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key CoolReheat\n";
    ss << "\\default None\n";
    ss << "A33, \\field Dehumidification Control Zone Name\n";
    ss << "\\note Zone name where humidistat is located\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N43, \\field Dehumidification Relative Humidity Setpoint\n";
    ss << "\\note Zone relative humidity setpoint in percent (0 to 100)\n";
    ss << "\\note Ignored if Dehumidification Relative Humidity Setpoint Schedule specified below\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\default 60.0\n";
    ss << "\\units percent\n";
    ss << "A34, \\field Dehumidification Relative Humidity Setpoint Schedule Name\n";
    ss << "\\note Leave blank to use constant setpoint specified in Dehumidification Relative Humidity\n";
    ss << "\\note Setpoint above. Schedule values must be in percent relative humidity (0 to 100).\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A35, \\field Humidifier Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key ElectricSteam\n";
    ss << "\\default None\n";
    ss << "A36, \\field Humidifier Availability Schedule Name\n";
    ss << "\\note If blank, always available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N44, \\field Humidifier Rated Capacity\n";
    ss << "\\note Moisture output rate at full rated power input.\n";
    ss << "\\note The humidifier does not currently autosize, so the default is very large\n";
    ss << "\\note to allow for adequate capacity.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.000001\n";
    ss << "\\ip-units gal/min\n";
    ss << "N45, \\field Humidifier Rated Electric Power\n";
    ss << "\\note Electric power input at rated capacity moisture output.\n";
    ss << "\\note Power consumption is proportional to moisture output with no part-load penalty.\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\ip-units W\n";
    ss << "A37, \\field Humidifier Control Zone Name\n";
    ss << "\\note Zone name where humidistat is located\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N46, \\field Humidifier Relative Humidity Setpoint\n";
    ss << "\\note Zone relative humidity setpoint in percent (0 to 100).\n";
    ss << "\\note Ignored if Humidifier Relative Humidity Setpoint Schedule specified below\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\default 30.0\n";
    ss << "\\units percent\n";
    ss << "A38, \\field Humidifier Relative Humidity Setpoint Schedule Name\n";
    ss << "\\note Leave blank to use constant setpoint specified in Humidifier Relative Humidity\n";
    ss << "\\note  Setpoint above.Schedule values must be in percent relative humidity (0 to 100).\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A39, \\field Sizing Option\n";
    ss << "\\note Select whether autosized system supply flow rate is the sum of Coincident or NonCoincident\n";
    ss << "\\note zone air flow rates.\n";
    ss << "\\type choice\n";
    ss << "\\key Coincident\n";
    ss << "\\key NonCoincident\n";
    ss << "\\default NonCoincident\n";
    ss << "A40, \\field Return Fan\n";
    ss << "\\note Specifies if the system has a return fan.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N47, \\field Return Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N48, \\field Return Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 500\n";
    ss << "N49, \\field Return Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N50, \\field Return Fan Motor in Air Stream Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A41; \\field Return Fan Part-Load Power Coefficients\n";
    ss << "\\note This field selects a predefined set of fan power coefficients.\n";
    ss << "\\note The ASHRAE 90.1-2004 Appendix G coefficients are from TABLE G3.1.3.15, Method 2.\n";
    ss << "\\note The other sets of coefficients are from the EnergyPlus Input\n";
    ss << "\\note Output Reference, Fan Coefficient Values table.\n";
    ss << "\\type choice\n";
    ss << "\\key InletVaneDampers\n";
    ss << "\\key OutletDampers\n";
    ss << "\\key VariableSpeedMotor\n";
    ss << "\\key ASHRAE90.1-2004AppendixG\n";
    ss << "\\key VariableSpeedMotorPressureReset\n";
    ss << "\\default InletVaneDampers\n";

    IddObjectType objType(IddObjectType::HVACTemplate_System_DualDuct);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:System:DualDuct",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_System_DualDuct);
  return object;
}

IddObject createHVACTemplate_System_DedicatedOutdoorAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:System:DedicatedOutdoorAir,\n";
    ss << "\\min-fields 46\n";
    ss << "\\memo This object creates a dedicated outdoor air system that must be used with\n";
    ss << "\\memo HVACTemplate:Zone:* objects for BaseboardHeat FanCoil PTAC PTHP WaterToAirHeatPump and VRF.\n";
    ss << "\\memo Does not support HVACTemplate:Zone:VAV or other central multizone systems\n";
    ss << "A1, \\field Name\n";
    ss << "\\reference HVACTemplateDOASSystems\n";
    ss << "\\reference HVACTemplateSystems\n";
    ss << "A2, \\field System Availability Schedule Name\n";
    ss << "\\note If blank, always on; DOAS System always on.  Schedule is used in availability manager\n";
    ss << "\\note and fan scheduling.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Air Outlet Type\n";
    ss << "\\type choice\n";
    ss << "\\key  DirectIntoZone\n";
    ss << "\\default  DirectIntoZone\n";
    ss << "N1, \\field Supply Fan Flow Rate\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2, \\field Supply Fan Total Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N3, \\field Supply Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\minimum 0\n";
    ss << "\\default 1000\n";
    ss << "N4, \\field Supply Fan Motor Efficiency\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N5, \\field Supply Fan Motor in Air Stream Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A4, \\field Supply Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key DrawThrough\n";
    ss << "\\key BlowThrough\n";
    ss << "\\default DrawThrough\n";
    ss << "A5, \\field Cooling Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  ChilledWater\n";
    ss << "\\key  ChilledWaterDetailedFlatModel\n";
    ss << "\\key  TwoSpeedDX\n";
    ss << "\\key  TwoStageDX\n";
    ss << "\\key  TwoStageHumidityControlDX\n";
    ss << "\\key  HeatExchangerAssistedChilledWater\n";
    ss << "\\key  HeatExchangerAssistedDX\n";
    ss << "\\key  None\n";
    ss << "\\default  ChilledWater\n";
    ss << "A6, \\field Cooling Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A7, \\field Cooling Coil Setpoint Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key  FixedSetpoint\n";
    ss << "\\key  Scheduled\n";
    ss << "\\key  OutdoorAirTemperatureReset\n";
    ss << "\\default FixedSetpoint\n";
    ss << "N6, \\field Cooling Coil Design Setpoint\n";
    ss << "\\note  Used for sizing and as constant setpoint if no Cooling Coil Setpoint Schedule Name is specified.\n";
    ss << "\\default 12.8\n";
    ss << "\\units C\n";
    ss << "A8, \\field Cooling Coil Setpoint Schedule Name\n";
    ss << "\\note  Leave blank if constant setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N7, \\field Cooling Coil Setpoint at Outdoor Dry-Bulb Low\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 15.6\n";
    ss << "N8, \\field Cooling Coil Reset Outdoor Dry-Bulb Low\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\note Defaults are 15.6C (60F) at 15.6C (60F) to 12.8C (55F) at 23.3C (74F)\n";
    ss << "\\units C\n";
    ss << "\\default 15.6\n";
    ss << "N9, \\field Cooling Coil Setpoint at Outdoor Dry-Bulb High\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 12.8\n";
    ss << "N10, \\field Cooling Coil Reset Outdoor Dry-Bulb High\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 23.3\n";
    ss << "N11, \\field DX Cooling Coil Gross Rated Total Capacity\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N12, \\field DX Cooling Coil Gross Rated Sensible Heat Ratio\n";
    ss << "\\note Gross SHR\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default autosize\n";
    ss << "N13, \\field DX Cooling Coil Gross Rated COP\n";
    ss << "\\note Gross cooling capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply fan heat or supply fan electrical energy input\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.0\n";
    ss << "A9, \\field Heating Coil Type\n";
    ss << "\\type choice\n";
    ss << "\\key  HotWater\n";
    ss << "\\key  Electric\n";
    ss << "\\key  Gas\n";
    ss << "\\key  None\n";
    ss << "\\default HotWater\n";
    ss << "A10, \\field Heating Coil Availability Schedule Name\n";
    ss << "\\note If blank, always on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A11, \\field Heating Coil Setpoint Control Type\n";
    ss << "\\note When selecting OutdoorAirTemperatureReset, the Heating Coil Design Setpoint may need to be changed\n";
    ss << "\\type choice\n";
    ss << "\\key  FixedSetpoint\n";
    ss << "\\key  Scheduled\n";
    ss << "\\key  OutdoorAirTemperatureReset\n";
    ss << "\\default FixedSetpoint\n";
    ss << "N14, \\field Heating Coil Design Setpoint\n";
    ss << "\\note   Used for sizing and as constant setpoint if no Heating Coil Setpoint Schedule Name is specified.\n";
    ss << "\\default 12.2\n";
    ss << "\\units C\n";
    ss << "A12, \\field Heating Coil Setpoint Schedule Name\n";
    ss << "\\note  Leave blank if constant setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N15, \\field Heating Coil Setpoint at Outdoor Dry-Bulb Low\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\note Defaults 15.0C (59F) at 7.8C (46F) to 12.2C (54F) at 12.2C (54F)\n";
    ss << "\\units C\n";
    ss << "\\default 15.0\n";
    ss << "N16, \\field Heating Coil Reset Outdoor Dry-Bulb Low\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 7.8\n";
    ss << "N17, \\field Heating Coil Setpoint at Outdoor Dry-Bulb High\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 12.2\n";
    ss << "N18, \\field Heating Coil Reset Outdoor Dry-Bulb High\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 12.2\n";
    ss << "N19, \\field Gas Heating Coil Efficiency\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.8\n";
    ss << "N20, \\field Gas Heating Coil Parasitic Electric Load\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "A13, \\field Heat Recovery Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Sensible\n";
    ss << "\\key Enthalpy\n";
    ss << "\\default None\n";
    ss << "N21, \\field Heat Recovery Sensible Effectiveness\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.70\n";
    ss << "N22, \\field Heat Recovery Latent Effectiveness\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.65\n";
    ss << "A14, \\field Heat Recovery Heat Exchanger Type\n";
    ss << "\\type choice\n";
    ss << "\\key Plate\n";
    ss << "\\key Rotary\n";
    ss << "\\default Plate\n";
    ss << "A15, \\field Heat Recovery Frost Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key ExhaustAirRecirculation\n";
    ss << "\\key ExhaustOnly\n";
    ss << "\\key MinimumExhaustTemperature\n";
    ss << "\\default None\n";
    ss << "A16, \\field Dehumidification Control Type\n";
    ss << "\\note None = meet sensible load only\n";
    ss << "\\note CoolReheatHeatingCoil = cool beyond the dry-bulb setpoint, reheat with heating coil\n";
    ss << "\\note Valid for all cooling coil types.  If no heating coil specified, cold supply temps may occur.\n";
    ss << "\\note CoolReheatDesuperheater = cool beyond the dry-bulb setpoint\n";
    ss << "\\note as required to meet the humidity setpoint, reheat with desuperheater coil.\n";
    ss << "\\note Valid only for Cooling Coil Type = TwoSpeedDX, TwoStageDX, TwoStageHumidityControlDX, or HeatExchangerAssistedDX.\n";
    ss << "\\note Multimode = activate enhanced dehumidification mode as needed and meet sensible load.\n";
    ss << "\\note Valid only for Cooling Coil Type = TwoStageHumidityControlDX or HeatExchangerAssistedDX\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key CoolReheatHeatingCoil\n";
    ss << "\\key CoolReheatDesuperheater\n";
    ss << "\\key Multimode\n";
    ss << "\\default None\n";
    ss << "N23, \\field Dehumidification Setpoint\n";
    ss << "\\note The supply air humidity ratio for dehumidification control.\n";
    ss << "\\note Default of 0.00924 kgWater/kgDryAir is equivalent to 12.8C (55F) dewpoint.\n";
    ss << "\\note Ignored if Dehumidification Setpoint Schedule specified below\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.00924\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "A17, \\field Humidifier Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key ElectricSteam\n";
    ss << "\\default None\n";
    ss << "A18, \\field Humidifier Availability Schedule Name\n";
    ss << "\\note If blank, always available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N24, \\field Humidifier Rated Capacity\n";
    ss << "\\note Moisture output rate at full rated power input.\n";
    ss << "\\note The humidifier does not currently autosize, so the default is very large\n";
    ss << "\\note to allow for adequate capacity.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.000001\n";
    ss << "\\ip-units gal/min\n";
    ss << "N25, \\field Humidifier Rated Electric Power\n";
    ss << "\\note Electric power input at rated capacity moisture output.\n";
    ss << "\\note Power consumption is proportional to moisture output with no part-load penalty.\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\ip-units W\n";
    ss << "N26, \\field Humidifier Constant Setpoint\n";
    ss << "\\note The supply air humidity ratio for humidification control.\n";
    ss << "\\note Ignored if Humidifier Setpoint Schedule specified below\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.003\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "A19, \\field Dehumidification Setpoint Schedule Name\n";
    ss << "\\note Leave blank to use constant setpoint specified in Dehumidification Setpoint above.\n";
    ss << "\\note Schedule values must be in units of humidity ratio (kgWater/kgDryAir or lbWater/lbDryAir)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A20; \\field Humidifier Setpoint Schedule Name\n";
    ss << "\\note Leave blank to use constant setpoint specified in Humidifier Constant Setpoint above.\n";
    ss << "\\note Schedule values must be in units of humidity ratio (kgWater/kgDryAir or lbWater/lbDryAir)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::HVACTemplate_System_DedicatedOutdoorAir);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:System:DedicatedOutdoorAir",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_System_DedicatedOutdoorAir);
  return object;
}

IddObject createHVACTemplate_Plant_ChilledWaterLoopIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Plant:ChilledWaterLoop,\n";
    ss << "\\min-fields 21\n";
    ss << "\\memo Plant and condenser loops to serve all HVACTemplate\n";
    ss << "\\memo chilled water coils, chillers, and towers.\n";
    ss << "\\unique-object\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Pump Schedule Name\n";
    ss << "\\note If blank, always available\n";
    ss << "\\note Applies to both chilled water and condenser loop pumps\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Pump Control Type\n";
    ss << "\\note Applies to both chilled water and condenser loop pumps\n";
    ss << "\\type choice\n";
    ss << "\\key Intermittent\n";
    ss << "\\key Continuous\n";
    ss << "\\default Intermittent\n";
    ss << "A4, \\field Chiller Plant Operation Scheme Type\n";
    ss << "\\note Default operation type makes all equipment available\n";
    ss << "\\note at all times operating in order of Priority specified\n";
    ss << "\\note in HVACTemplate:Plant:Chiller objects.\n";
    ss << "\\type choice\n";
    ss << "\\key Default\n";
    ss << "\\key UserDefined\n";
    ss << "\\default Default\n";
    ss << "A5, \\field Chiller Plant Equipment Operation Schemes Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PlantOperationSchemes\n";
    ss << "\\note Name of a PlantEquipmentOperationSchemes object\n";
    ss << "\\note Ignored if Chiller Plant Operation Scheme Type = Default\n";
    ss << "A6, \\field Chilled Water Setpoint Schedule Name\n";
    ss << "\\note  Leave blank if constant setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Chilled Water Design Setpoint\n";
    ss << "\\note   Used for sizing and as constant setpoint if no Chilled Water Setpoint Schedule Name is specified.\n";
    ss << "\\default 7.22\n";
    ss << "\\units C\n";
    ss << "A7, \\field Chilled Water Pump Configuration\n";
    ss << "\\note VariablePrimaryNoSecondary - variable flow to chillers and coils\n";
    ss << "\\note ConstantPrimaryNoSecondary - constant flow to chillers and coils, excess bypassed\n";
    ss << "\\note ConstantPrimaryVariableSecondary - constant flow to chillers, variable flow to coils\n";
    ss << "\\note VariablePrimaryConstantSecondary - currently unsupported - variable flow to chillers, constant flow to coils\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantPrimaryNoSecondary\n";
    ss << "\\key VariablePrimaryNoSecondary\n";
    ss << "\\key ConstantPrimaryVariableSecondary\n";
    ss << "\\default ConstantPrimaryNoSecondary\n";
    ss << "N2, \\field Primary Chilled Water Pump Rated Head\n";
    ss << "\\units Pa\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 179352\n";
    ss << "\\note default head is 60 feet H2O\n";
    ss << "\\ip-units ftH2O\n";
    ss << "N3, \\field Secondary Chilled Water Pump Rated Head\n";
    ss << "\\units Pa\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 179352\n";
    ss << "\\note default head is 60 feet H2O\n";
    ss << "\\ip-units ftH2O\n";
    ss << "A8, \\field Condenser Plant Operation Scheme Type\n";
    ss << "\\note Default operation type makes all equipment available\n";
    ss << "\\note at all times operating in order of Priority specified\n";
    ss << "\\note in HVACTemplate:Plant:Tower objects.\n";
    ss << "\\type choice\n";
    ss << "\\key Default\n";
    ss << "\\key UserDefined\n";
    ss << "\\default Default\n";
    ss << "\\note  May be left blank if not serving any water cooled chillers\n";
    ss << "A9, \\field Condenser Equipment Operation Schemes Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CondenserOperationSchemes\n";
    ss << "\\note Name of a CondenserEquipmentOperationSchemes object\n";
    ss << "\\note Ignored if Condenser Plant Operation Scheme Type = Default\n";
    ss << "\\note  May be left blank if not serving any water cooled chillers\n";
    ss << "A10, \\field Condenser Water Temperature Control Type\n";
    ss << "\\note  May be left blank if not serving any water cooled chillers\n";
    ss << "\\type choice\n";
    ss << "\\key OutdoorWetBulbTemperature\n";
    ss << "\\key SpecifiedSetpoint\n";
    ss << "A11, \\field Condenser Water Setpoint Schedule Name\n";
    ss << "\\note  Leave blank if constant setpoint\n";
    ss << "\\note  May be left blank if not serving any water cooled chillers\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N4, \\field Condenser Water Design Setpoint\n";
    ss << "\\note  Used for sizing and as constant setpoint if no Condenser Water Setpoint Schedule Name is specified.\n";
    ss << "\\note  May be left blank if not serving any water cooled chillers\n";
    ss << "\\default 29.4\n";
    ss << "\\units C\n";
    ss << "N5, \\field Condenser Water Pump Rated Head\n";
    ss << "\\note  May be left blank if not serving any water cooled chillers\n";
    ss << "\\units Pa\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 179352\n";
    ss << "\\note default head is 60 feet H2O\n";
    ss << "\\ip-units ftH2O\n";
    ss << "A12, \\field Chilled Water Setpoint Reset Type\n";
    ss << "\\note Overrides Chilled Water Setpoint Schedule Name\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key OutdoorAirTemperatureReset\n";
    ss << "\\default None\n";
    ss << "N6, \\field Chilled Water Setpoint at Outdoor Dry-Bulb Low\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 12.2\n";
    ss << "N7, \\field Chilled Water Reset Outdoor Dry-Bulb Low\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 15.6\n";
    ss << "N8, \\field Chilled Water Setpoint at Outdoor Dry-Bulb High\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 6.7\n";
    ss << "N9, \\field Chilled Water Reset Outdoor Dry-Bulb High\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 26.7\n";
    ss << "A13, \\field Chilled Water Primary Pump Type\n";
    ss << "\\note Describes the type of pump configuration used for the primary portion of the chilled water loop.\n";
    ss << "\\type choice\n";
    ss << "\\key SinglePump\n";
    ss << "\\key PumpPerChiller\n";
    ss << "\\key TwoHeaderedPumps\n";
    ss << "\\key ThreeHeaderedPumps\n";
    ss << "\\key FourHeaderedPumps\n";
    ss << "\\key FiveHeaderedPumps\n";
    ss << "\\default SinglePump\n";
    ss << "A14, \\field Chilled Water Secondary Pump Type\n";
    ss << "\\note Describes the type of pump configuration used for the secondary portion of the chilled water loop.\n";
    ss << "\\type choice\n";
    ss << "\\key SinglePump\n";
    ss << "\\key TwoHeaderedPumps\n";
    ss << "\\key ThreeHeaderedPumps\n";
    ss << "\\key FourHeaderedPumps\n";
    ss << "\\key FiveHeaderedPumps\n";
    ss << "\\default SinglePump\n";
    ss << "A15, \\field Condenser Water Pump Type\n";
    ss << "\\note Describes the type of pump configuration used for the condenser water loop.\n";
    ss << "\\type choice\n";
    ss << "\\key SinglePump\n";
    ss << "\\key PumpPerTower\n";
    ss << "\\key TwoHeaderedPumps\n";
    ss << "\\key ThreeHeaderedPumps\n";
    ss << "\\key FourHeaderedPumps\n";
    ss << "\\key FiveHeaderedPumps\n";
    ss << "\\default SinglePump\n";
    ss << "A16,\\field Chilled Water Supply Side Bypass Pipe\n";
    ss << "\\note Determines if a supply side bypass pipe is present in the chilled water loop.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "A17,\\field Chilled Water Demand Side Bypass Pipe\n";
    ss << "\\note Determines if a demand side bypass pipe is present in the chilled water loop.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "A18,\\field Condenser Water Supply Side Bypass Pipe\n";
    ss << "\\note Determines if a supply side bypass pipe is present in the condenser water loop.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "A19,\\field Condenser Water Demand Side Bypass Pipe\n";
    ss << "\\note Determines if a demand side bypass pipe is present in the condenser water loop.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "A20,\\field Fluid Type\n";
    ss << "\\type choice\n";
    ss << "\\key Water\n";
    ss << "\\key EthyleneGlycol30\n";
    ss << "\\key EthyleneGlycol40\n";
    ss << "\\key EthyleneGlycol50\n";
    ss << "\\key EthyleneGlycol60\n";
    ss << "\\key PropyleneGlycol30\n";
    ss << "\\key PropyleneGlycol40\n";
    ss << "\\key PropyleneGlycol50\n";
    ss << "\\key PropyleneGlycol60\n";
    ss << "\\default Water\n";
    ss << "N10,\\field Loop Design Delta Temperature\n";
    ss << "\\note The temperature difference used in sizing the loop flow rate.\n";
    ss << "\\units deltaC\n";
    ss << "\\default 6.67\n";
    ss << "N11,\\field Minimum Outdoor Dry Bulb Temperature\n";
    ss << "\\note The minimum outdoor dry-bulb temperature that the chilled water loops operate.\n";
    ss << "\\note Leave blank for no limit.\n";
    ss << "\\units C\n";
    ss << "A21,\\field Chilled Water Load Distribution Scheme\n";
    ss << "\\type choice\n";
    ss << "\\key Optimal\n";
    ss << "\\key SequentialLoad\n";
    ss << "\\key UniformLoad\n";
    ss << "\\key UniformPLR\n";
    ss << "\\key SequentialUniformPLR\n";
    ss << "\\default SequentialLoad\n";
    ss << "A22;\\field Condenser Water Load Distribution Scheme\n";
    ss << "\\type choice\n";
    ss << "\\key Optimal\n";
    ss << "\\key SequentialLoad\n";
    ss << "\\key UniformLoad\n";
    ss << "\\key UniformPLR\n";
    ss << "\\key SequentialUniformPLR\n";
    ss << "\\default SequentialLoad\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Plant_ChilledWaterLoop);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Plant:ChilledWaterLoop",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Plant_ChilledWaterLoop);
  return object;
}

IddObject createHVACTemplate_Plant_ChillerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Plant:Chiller,\n";
    ss << "\\min-fields 7\n";
    ss << "\\memo This object adds a chiller to an HVACTemplate:Plant:ChilledWaterLoop.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Chiller Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key DistrictChilledWater\n";
    ss << "\\key ElectricCentrifugalChiller\n";
    ss << "\\key ElectricScrewChiller\n";
    ss << "\\key ElectricReciprocatingChiller\n";
    ss << "N1, \\field Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2, \\field Nominal COP\n";
    ss << "\\required-field\n";
    ss << "\\note Not applicable if Chiller Type is DistrictChilledWater\n";
    ss << "\\note Electric Reciprocating Chiller\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "A3, \\field Condenser Type\n";
    ss << "\\note Not applicable if Chiller Type is DistrictChilledWater\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key WaterCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "\\default WaterCooled\n";
    ss << "A4, \\field Priority\n";
    ss << "\\note If Chiller Plant Operation Scheme Type=Default\n";
    ss << "\\note in HVACTemplate:Plant:ChilledWaterLoop, then equipment\n";
    ss << "\\note operates in Priority order, 1, 2, 3, etc.\n";
    ss << "N3, \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N4, \\field Minimum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\note Part load ratio below which the chiller starts cycling on/off to meet the load.\n";
    ss << "\\note Must be less than or equal to Maximum Part Load Ratio.\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N5, \\field Maximum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\note Maximum allowable part load ratio. Must be greater than or equal to Minimum Part Load Ratio.\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N6, \\field Optimum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\note Optimum part load ratio where the chiller is most efficient.\n";
    ss << "\\note Must be greater than or equal to the Minimum Part Load Ratio\n";
    ss << "\\note and less than or equal to the Maximum Part Load Ratio.\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N7, \\field Minimum Unloading Ratio\n";
    ss << "\\type real\n";
    ss << "\\note Part load ratio where the chiller can no longer unload and false loading begins.\n";
    ss << "\\note Minimum unloading ratio must be greater than or equal to the Minimum Part Load Ratio\n";
    ss << "\\note and less than or equal to the Maximum Part Load Ratio.\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.25\n";
    ss << "N8; \\field Leaving Chilled Water Lower Temperature Limit\n";
    ss << "\\type real\n";
    ss << "\\default 5.0\n";
    ss << "\\units C\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Plant_Chiller);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Plant:Chiller",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Plant_Chiller);
  return object;
}

IddObject createHVACTemplate_Plant_Chiller_ObjectReferenceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Plant:Chiller:ObjectReference,\n";
    ss << "\\min-fields 4\n";
    ss << "\\memo This object references a detailed chiller object and adds it to\n";
    ss << "\\memo an HVACTemplate:Plant:ChilledWaterLoop. The user must create a complete\n";
    ss << "\\memo detailed chiller object with all required curve or performance objects.\n";
    ss << "A1, \\field Name\n";
    ss << "\\note The name of this object.\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Chiller Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Chiller:Electric:EIR\n";
    ss << "\\key Chiller:Electric:ReformulatedEIR\n";
    ss << "\\default Chiller:Electric:EIR\n";
    ss << "A3, \\field Chiller Name\n";
    ss << "\\note The name of the detailed chiller object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Chillers\n";
    ss << "N1; \\field Priority\n";
    ss << "\\note If Chiller Plant Operation Scheme Type=Default\n";
    ss << "\\note in HVACTemplate:Plant:ChilledWaterLoop, then equipment\n";
    ss << "\\note operates in Priority order, 1, 2, 3, etc.\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Plant_Chiller_ObjectReference);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Plant:Chiller:ObjectReference",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Plant_Chiller_ObjectReference);
  return object;
}

IddObject createHVACTemplate_Plant_TowerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Plant:Tower,\n";
    ss << "\\min-fields 9\n";
    ss << "\\memo This object adds a cooling tower to an HVACTemplate:Plant:ChilledWaterLoop or MixedWaterLoop.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Tower Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key SingleSpeed\n";
    ss << "\\key TwoSpeed\n";
    ss << "N1, \\field High Speed Nominal Capacity\n";
    ss << "\\note Applicable for tower type SingleSpeed and TwoSpeed\n";
    ss << "\\note Nominal tower capacity with entering water at 35C (95F), leaving water at\n";
    ss << "\\note 29.44C (85F), entering air at 25.56C (78F) wet-bulb temperature and 35C (95F)\n";
    ss << "\\note dry-bulb temperature, with the tower fan operating at high speed. Design water\n";
    ss << "\\note flow rate assumed to be 5.382E-8 m3/s per watt(3 gpm/ton). Nominal tower capacity\n";
    ss << "\\note times (1.25) gives the actual tower heat rejection at these operating conditions.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2, \\field High Speed Fan Power\n";
    ss << "\\note Applicable for tower type SingleSpeed and TwoSpeed\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3, \\field Low Speed Nominal Capacity\n";
    ss << "\\note Applicable only for Tower Type TwoSpeed\n";
    ss << "\\note Nominal tower capacity with entering water at 35C (95F), leaving water at\n";
    ss << "\\note 29.44C (85F), entering air at 25.56C (78F) wet-bulb temperature and 35C (95F)\n";
    ss << "\\note dry-bulb temperature, with the tower fan operating at low speed. Design water flow\n";
    ss << "\\note rate assumed to be 5.382E-8 m3/s per watt of tower high-speed nominal capacity\n";
    ss << "\\note (3 gpm/ton). Nominal tower capacity times (1.25) gives the actual tower heat\n";
    ss << "\\note rejection at these operating conditions.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "N4, \\field Low Speed Fan Power\n";
    ss << "\\note Applicable only for Tower Type TwoSpeed\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "N5, \\field Free Convection Capacity\n";
    ss << "\\note Applicable for Tower Type SingleSpeed and TwoSpeed\n";
    ss << "\\note Tower capacity in free convection regime with entering water at 35C (95F),\n";
    ss << "\\note leaving water at 29.44C (85F), entering air at 25.56C (78F) wet-bulb temperature\n";
    ss << "\\note and 35C (95F) dry-bulb temperature. Design water flow rate assumed to be\n";
    ss << "\\note 5.382E-8 m3/s per watt of tower high-speed nominal capacity (3 gpm/ton). Tower\n";
    ss << "\\note free convection capacity times (1.25) gives the actual tower heat rejection at\n";
    ss << "\\note these operating conditions.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "A3, \\field Priority\n";
    ss << "\\note Applicable for all Tower Types\n";
    ss << "\\note If Condenser Plant Operation Scheme Type=Default\n";
    ss << "\\note in HVACTemplate:Plant:ChilledWaterLoop, then equipment\n";
    ss << "\\note operates in Priority order, 1, 2, 3, etc.\n";
    ss << "N6, \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "A4; \\field Template Plant Loop Type\n";
    ss << "\\note Specifies if this tower serves a template chilled water loop or mixed water loop\n";
    ss << "\\note If left blank, will serve a chilled water loop if present, or a mixed water loop (if\n";
    ss << "\\note no chilled water loop is present).\n";
    ss << "\\type choice\n";
    ss << "\\key ChilledWater\n";
    ss << "\\key MixedWater\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Plant_Tower);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Plant:Tower",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Plant_Tower);
  return object;
}

IddObject createHVACTemplate_Plant_Tower_ObjectReferenceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Plant:Tower:ObjectReference,\n";
    ss << "\\min-fields 4\n";
    ss << "\\memo This object references a detailed cooling tower object and adds it to\n";
    ss << "\\memo an HVACTemplate:Plant:ChilledWaterLoop or MixedWaterLoop. The user must create a complete\n";
    ss << "\\memo detailed cooling tower object with all required curve or performance objects.\n";
    ss << "A1, \\field Name\n";
    ss << "\\note The name of this object.\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Cooling Tower Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key CoolingTower:SingleSpeed\n";
    ss << "\\key CoolingTower:TwoSpeed\n";
    ss << "\\key CoolingTower:VariableSpeed\n";
    ss << "\\default CoolingTower:SingleSpeed\n";
    ss << "A3, \\field Cooling Tower Name\n";
    ss << "\\note The name of the detailed cooling tower object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingTowers\n";
    ss << "N1, \\field Priority\n";
    ss << "\\note If Condenser Plant Operation Scheme Type=Default\n";
    ss << "\\note in HVACTemplate:Plant:ChilledWaterLoop or MixedWaterLoop, then equipment\n";
    ss << "\\note operates in Priority order, 1, 2, 3, etc.\n";
    ss << "A4; \\field Template Plant Loop Type\n";
    ss << "\\note Specifies if this tower serves a template chilled water loop or mixed water loop\n";
    ss << "\\note If left blank, will serve a chilled water loop if present, or a mixed water loop (if\n";
    ss << "\\note no chilled water loop is present).\n";
    ss << "\\type choice\n";
    ss << "\\key ChilledWater\n";
    ss << "\\key MixedWater\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Plant_Tower_ObjectReference);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Plant:Tower:ObjectReference",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Plant_Tower_ObjectReference);
  return object;
}

IddObject createHVACTemplate_Plant_HotWaterLoopIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Plant:HotWaterLoop,\n";
    ss << "\\min-fields 14\n";
    ss << "\\unique-object\n";
    ss << "\\memo Plant loop to serve all HVACTemplate\n";
    ss << "\\memo hot water coils and boilers.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Pump Schedule Name\n";
    ss << "\\note If blank, always available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Pump Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Intermittent\n";
    ss << "\\key Continuous\n";
    ss << "\\default Intermittent\n";
    ss << "A4, \\field Hot Water Plant Operation Scheme Type\n";
    ss << "\\note Default operation type makes all equipment available\n";
    ss << "\\note at all times operating in order of Priority specified\n";
    ss << "\\note in HVACTemplate:Plant:Boiler objects.\n";
    ss << "\\type choice\n";
    ss << "\\key Default\n";
    ss << "\\key UserDefined\n";
    ss << "\\default Default\n";
    ss << "A5, \\field Hot Water Plant Equipment Operation Schemes Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PlantOperationSchemes\n";
    ss << "\\note Name of a PlantEquipmentOperationSchemes object\n";
    ss << "\\note Ignored if Plant Operation Scheme Type = Default\n";
    ss << "A6, \\field Hot Water Setpoint Schedule Name\n";
    ss << "\\note Leave blank if constant setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Hot Water Design Setpoint\n";
    ss << "\\note  Used for sizing and as constant setpoint if no Setpoint Schedule Name is specified.\n";
    ss << "\\default 82.0\n";
    ss << "\\units C\n";
    ss << "A7, \\field Hot Water Pump Configuration\n";
    ss << "\\note VariableFlow - variable flow to boilers and coils, excess bypassed\n";
    ss << "\\note ConstantFlow - constant flow to boilers and coils, excess bypassed\n";
    ss << "\\type choice\n";
    ss << "\\key VariableFlow\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\default ConstantFlow\n";
    ss << "N2, \\field Hot Water Pump Rated Head\n";
    ss << "\\units Pa\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 179352\n";
    ss << "\\note Default head is 60 feet H2O\n";
    ss << "\\ip-units ftH2O\n";
    ss << "A8, \\field Hot Water Setpoint Reset Type\n";
    ss << "\\note Overrides Hot Water Setpoint Schedule Name\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key OutdoorAirTemperatureReset\n";
    ss << "\\default None\n";
    ss << "N3, \\field Hot Water Setpoint at Outdoor Dry-Bulb Low\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 82.2\n";
    ss << "N4, \\field Hot Water Reset Outdoor Dry-Bulb Low\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default -6.7\n";
    ss << "N5, \\field Hot Water Setpoint at Outdoor Dry-Bulb High\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 65.6\n";
    ss << "N6, \\field Hot Water Reset Outdoor Dry-Bulb High\n";
    ss << "\\note Applicable only for OutdoorAirTemperatureReset control.\n";
    ss << "\\units C\n";
    ss << "\\default 10.0\n";
    ss << "A9, \\field Hot Water Pump Type\n";
    ss << "\\note Describes the type of pump configuration used for the hot water loop.\n";
    ss << "\\type choice\n";
    ss << "\\key SinglePump\n";
    ss << "\\key PumpPerBoiler\n";
    ss << "\\key TwoHeaderedPumps\n";
    ss << "\\key ThreeHeaderedPumps\n";
    ss << "\\key FourHeaderedPumps\n";
    ss << "\\key FiveHeaderedPumps\n";
    ss << "\\default SinglePump\n";
    ss << "A10,\\field Supply Side Bypass Pipe\n";
    ss << "\\note Determines if a supply side bypass pipe is present in the hot water loop.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "A11,\\field Demand Side Bypass Pipe\n";
    ss << "\\note Determines if a demand side bypass pipe is present in the hot water loop.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "A12,\\field Fluid Type\n";
    ss << "\\type choice\n";
    ss << "\\key Water\n";
    ss << "\\key EthyleneGlycol30\n";
    ss << "\\key EthyleneGlycol40\n";
    ss << "\\key EthyleneGlycol50\n";
    ss << "\\key EthyleneGlycol60\n";
    ss << "\\key PropyleneGlycol30\n";
    ss << "\\key PropyleneGlycol40\n";
    ss << "\\key PropyleneGlycol50\n";
    ss << "\\key PropyleneGlycol60\n";
    ss << "\\default Water\n";
    ss << "N7, \\field Loop Design Delta Temperature\n";
    ss << "\\note The temperature difference used in sizing the loop flow rate.\n";
    ss << "\\units deltaC\n";
    ss << "\\default 11.0\n";
    ss << "N8, \\field Maximum Outdoor Dry Bulb Temperature\n";
    ss << "\\note The maximum outdoor dry-bulb temperature that the hot water loops operate.\n";
    ss << "\\note Leave blank for no limit.\n";
    ss << "\\units C\n";
    ss << "A13;\\field Load Distribution Scheme\n";
    ss << "\\type choice\n";
    ss << "\\key Optimal\n";
    ss << "\\key SequentialLoad\n";
    ss << "\\key UniformLoad\n";
    ss << "\\key UniformPLR\n";
    ss << "\\key SequentialUniformPLR\n";
    ss << "\\default SequentialLoad\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Plant_HotWaterLoop);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Plant:HotWaterLoop",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Plant_HotWaterLoop);
  return object;
}

IddObject createHVACTemplate_Plant_BoilerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Plant:Boiler,\n";
    ss << "\\min-fields 7\n";
    ss << "\\memo This object adds a boiler to an HVACTemplate:Plant:HotWaterLoop or MixedWaterLoop.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Boiler Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key DistrictHotWater\n";
    ss << "\\key HotWaterBoiler\n";
    ss << "\\key CondensingHotWaterBoiler\n";
    ss << "N1, \\field Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2, \\field Efficiency\n";
    ss << "\\note Not applicable  if Boiler Type is DistrictHotWater\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.8\n";
    ss << "A3, \\field Fuel Type\n";
    ss << "\\note Not applicable  if Boiler Type is DistrictHotWater\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "A4, \\field Priority\n";
    ss << "\\note If Hot Water Plant Operation Scheme Type=Default\n";
    ss << "\\note in HVACTemplate:Plant:HotWaterLoop, then equipment\n";
    ss << "\\note operates in priority order, 1, 2, 3, etc.\n";
    ss << "N3, \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N4, \\field Minimum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N5, \\field Maximum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.1\n";
    ss << "N6, \\field Optimum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N7, \\field Water Outlet Upper Temperature Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 100.0\n";
    ss << "A5; \\field Template Plant Loop Type\n";
    ss << "\\note Specifies if this boiler serves a template hot water loop or mixed water loop\n";
    ss << "\\note If left blank, will serve a hot water loop if present, or a mixed water loop (if\n";
    ss << "\\note no hot water loop is present).\n";
    ss << "\\type choice\n";
    ss << "\\key HotWater\n";
    ss << "\\key MixedWater\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Plant_Boiler);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Plant:Boiler",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Plant_Boiler);
  return object;
}

IddObject createHVACTemplate_Plant_Boiler_ObjectReferenceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Plant:Boiler:ObjectReference,\n";
    ss << "\\min-fields 4\n";
    ss << "\\memo This object references a detailed boiler object and adds it to\n";
    ss << "\\memo an HVACTemplate:Plant:HotWaterLoop or MixedWaterLoop. The user must create a complete\n";
    ss << "\\memo detailed boiler object with all required curve or performance objects.\n";
    ss << "A1, \\field Name\n";
    ss << "\\note The name of this object.\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Boiler Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Boiler:HotWater\n";
    ss << "\\default Boiler:HotWater\n";
    ss << "A3, \\field Boiler Name\n";
    ss << "\\note The name of the detailed boiler object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Boilers\n";
    ss << "N1, \\field Priority\n";
    ss << "\\note If Hot Water Plant Operation Scheme Type=Default\n";
    ss << "\\note in HVACTemplate:Plant:HotWaterLoop or MixedWaterLoop, then equipment\n";
    ss << "\\note operates in Priority order, 1, 2, 3, etc.\n";
    ss << "A4; \\field Template Plant Loop Type\n";
    ss << "\\note Specifies if this boiler serves a template hot water loop or mixed water loop\n";
    ss << "\\note If left blank, will serve a hot water loop if present, or a mixed water loop (if\n";
    ss << "\\note no hot water loop is present).\n";
    ss << "\\type choice\n";
    ss << "\\key HotWater\n";
    ss << "\\key MixedWater\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Plant_Boiler_ObjectReference);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Plant:Boiler:ObjectReference",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Plant_Boiler_ObjectReference);
  return object;
}

IddObject createHVACTemplate_Plant_MixedWaterLoopIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HVACTemplate:Plant:MixedWaterLoop,\n";
    ss << "\\min-fields 11\n";
    ss << "\\memo Central plant loop portion of a water source heat pump system.\n";
    ss << "\\unique-object\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Pump Schedule Name\n";
    ss << "\\note If blank, always available\n";
    ss << "\\note Applies to both chilled water and condenser loop pumps\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Pump Control Type\n";
    ss << "\\note Applies to both chilled water and condenser loop pumps\n";
    ss << "\\type choice\n";
    ss << "\\key Intermittent\n";
    ss << "\\key Continuous\n";
    ss << "\\default Intermittent\n";
    ss << "A4, \\field Operation Scheme Type\n";
    ss << "\\note Default operation type makes all equipment available\n";
    ss << "\\note at all times operating in order of Priority specified\n";
    ss << "\\note in HVACTemplate:Plant:Boiler and HVACTemplate:Plant:Tower objects.\n";
    ss << "\\type choice\n";
    ss << "\\key Default\n";
    ss << "\\key UserDefined\n";
    ss << "\\default Default\n";
    ss << "A5, \\field Equipment Operation Schemes Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PlantOperationSchemes\n";
    ss << "\\note Name of a PlantEquipmentOperationSchemes object\n";
    ss << "\\note Ignored if Plant Operation Scheme Type = Default\n";
    ss << "A6, \\field High Temperature Setpoint Schedule Name\n";
    ss << "\\note Leave blank if constant setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field High Temperature Design Setpoint\n";
    ss << "\\note  Used for sizing and as constant setpoint if no Setpoint Schedule Name is specified.\n";
    ss << "\\default 33.0\n";
    ss << "\\units C\n";
    ss << "A7, \\field Low Temperature Setpoint Schedule Name\n";
    ss << "\\note  Leave blank if constant setpoint\n";
    ss << "\\note  May be left blank if not serving any water cooled chillers\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N2, \\field Low Temperature Design Setpoint\n";
    ss << "\\note  Used for sizing and as constant setpoint if no Condenser Water Setpoint Schedule Name is specified.\n";
    ss << "\\note  May be left blank if not serving any water cooled chillers\n";
    ss << "\\default 20.0\n";
    ss << "\\units C\n";
    ss << "A8, \\field Water Pump Configuration\n";
    ss << "\\note VariableFlow - variable flow to boilers and coils, excess bypassed\n";
    ss << "\\note ConstantFlow - constant flow to boilers and coils, excess bypassed\n";
    ss << "\\type choice\n";
    ss << "\\key VariableFlow\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\default ConstantFlow\n";
    ss << "N3, \\field Water Pump Rated Head\n";
    ss << "\\note  May be left blank if not serving any water cooled chillers\n";
    ss << "\\units Pa\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 179352\n";
    ss << "\\note default head is 60 feet H2O\n";
    ss << "\\ip-units ftH2O\n";
    ss << "A9, \\field Water Pump Type\n";
    ss << "\\note Describes the type of pump configuration used for the mixed water loop.\n";
    ss << "\\type choice\n";
    ss << "\\key SinglePump\n";
    ss << "\\key PumpPerTowerOrBoiler\n";
    ss << "\\key TwoHeaderedPumps\n";
    ss << "\\key ThreeHeaderedPumps\n";
    ss << "\\key FourHeaderedPumps\n";
    ss << "\\key FiveHeaderedPumps\n";
    ss << "\\default SinglePump\n";
    ss << "A10,\\field Supply Side Bypass Pipe\n";
    ss << "\\note Determines if a supply side bypass pipe is present in the hot water loop.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "A11,\\field Demand Side Bypass Pipe\n";
    ss << "\\note Determines if a demand side bypass pipe is present in the hot water loop.\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "A12,\\field Fluid Type\n";
    ss << "\\type choice\n";
    ss << "\\key Water\n";
    ss << "\\key EthyleneGlycol30\n";
    ss << "\\key EthyleneGlycol40\n";
    ss << "\\key EthyleneGlycol50\n";
    ss << "\\key EthyleneGlycol60\n";
    ss << "\\key PropyleneGlycol30\n";
    ss << "\\key PropyleneGlycol40\n";
    ss << "\\key PropyleneGlycol50\n";
    ss << "\\key PropyleneGlycol60\n";
    ss << "\\default Water\n";
    ss << "N4, \\field Loop Design Delta Temperature\n";
    ss << "\\note The temperature difference used in sizing the loop flow rate.\n";
    ss << "\\units deltaC\n";
    ss << "\\default 5.6\n";
    ss << "A13;\\field Load Distribution Scheme\n";
    ss << "\\type choice\n";
    ss << "\\key Optimal\n";
    ss << "\\key SequentialLoad\n";
    ss << "\\key UniformLoad\n";
    ss << "\\key UniformPLR\n";
    ss << "\\key SequentialUniformPLR\n";
    ss << "\\default SequentialLoad\n";

    IddObjectType objType(IddObjectType::HVACTemplate_Plant_MixedWaterLoop);
    OptionalIddObject oObj = IddObject::load("HVACTemplate:Plant:MixedWaterLoop",
                                             "HVAC Templates",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HVACTemplate_Plant_MixedWaterLoop);
  return object;
}

IddObject createDesignSpecification_OutdoorAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "DesignSpecification:OutdoorAir,\n";
    ss << "\\min-fields 1\n";
    ss << "\\memo This object is used to describe general outdoor air requirements which\n";
    ss << "\\memo are referenced by other objects.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference DesignSpecificationOutdoorAirNames\n";
    ss << "A2, \\field Outdoor Air Method\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Person\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key AirChanges/Hour\n";
    ss << "\\key Sum\n";
    ss << "\\key Maximum\n";
    ss << "\\default Flow/Person\n";
    ss << "\\note Flow/Person => Outdoor Air Flow per Person * Occupancy = Design Flow Rate,\n";
    ss << "\\note Flow/Area => Outdoor Air Flow per Zone Floor Area * Zone Floor Area = Design Flow Rate,\n";
    ss << "\\note Flow/Zone => Outdoor Air Flow per Zone = Design Flow Rate,\n";
    ss << "\\note AirChanges/Hour => Outdoor Air Flow Air Changes per Hour * Zone Volume adjusted for m3/s = Design Flow Rate\n";
    ss << "N1, \\field Outdoor Air Flow per Person\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-person\n";
    ss << "\\default 0.00944\n";
    ss << "\\minimum 0\n";
    ss << "\\note 0.00944 m3/s is equivalent to 20 cfm per person\n";
    ss << "\\note This input should be used if the field Outdoor Air Method is Flow/Person.\n";
    ss << "\\note This input is used if the field Outdoor Air Method is Flow/Person, Sum, or Maximum\n";
    ss << "N2, \\field Outdoor Air Flow per Zone Floor Area\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\default 0.0\n";
    ss << "\\minimum 0\n";
    ss << "\\note This input should be used if the field Outdoor Air Method is Flow/Area.\n";
    ss << "\\note This input is used if the field Outdoor Air Method is Flow/Area, Sum, or Maximum\n";
    ss << "N3, \\field Outdoor Air Flow per Zone\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0.0\n";
    ss << "\\minimum 0\n";
    ss << "\\note This input should be used if the field Outdoor Air Method is Flow/Zone.\n";
    ss << "\\note This input is used if the field Outdoor Air Method is Flow/Zone, Sum, or Maximum\n";
    ss << "N4, \\field Outdoor Air Flow Air Changes per Hour\n";
    ss << "\\units 1/hr\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "\\minimum 0\n";
    ss << "\\note This input should be used if the field Outdoor Air Method is AirChanges/Hour.\n";
    ss << "\\note This input is used if the field Outdoor Air Method is AirChanges/Hour, Sum, or Maximum\n";
    ss << "A3; \\field Outdoor Air Flow Rate Fraction Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values are multiplied by the Outdoor Air Flow rate calculated using\n";
    ss << "\\note the previous four inputs. Schedule values are limited to 0 to 1.\n";

    IddObjectType objType(IddObjectType::DesignSpecification_OutdoorAir);
    OptionalIddObject oObj = IddObject::load("DesignSpecification:OutdoorAir",
                                             "HVAC Design Objects",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::DesignSpecification_OutdoorAir);
  return object;
}

IddObject createDesignSpecification_ZoneAirDistributionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "DesignSpecification:ZoneAirDistribution,\n";
    ss << "\\min-fields 1\n";
    ss << "\\memo This object is used to describe zone air distribution in terms of air distribution\n";
    ss << "\\memo effectiveness and secondary recirculation fraction. It is referenced by Sizing:Zone\n";
    ss << "\\memo and Controller:MechanicalVentilation objects\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference DesignSpecificationZoneAirDistributionNames\n";
    ss << "N1,  \\field Zone Air Distribution Effectiveness in Cooling Mode\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units dimensionless\n";
    ss << "N2,  \\field Zone Air Distribution Effectiveness in Heating Mode\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units dimensionless\n";
    ss << "A2,  \\field Zone Air Distribution Effectiveness Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note optionally used to replace Zone Air Distribution Effectiveness in Cooling and\n";
    ss << "\\note Heating Mode\n";
    ss << "N3;  \\field Zone Secondary Recirculation Fraction\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units dimensionless\n";

    IddObjectType objType(IddObjectType::DesignSpecification_ZoneAirDistribution);
    OptionalIddObject oObj = IddObject::load("DesignSpecification:ZoneAirDistribution",
                                             "HVAC Design Objects",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::DesignSpecification_ZoneAirDistribution);
  return object;
}

IddObject createSizing_ParametersIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Sizing:Parameters,\n";
    ss << "\\unique-object\n";
    ss << "\\memo Specifies global heating and cooling sizing factors/ratios.\n";
    ss << "\\memo These ratios are applied at the zone level to all of the zone heating and cooling loads\n";
    ss << "\\memo and air flow rates. Then these new loads and air flow rates are used to calculate the\n";
    ss << "\\memo system level flow rates and capacities and are used in all component sizing calculations.\n";
    ss << "\\memo Specifies the width (in load timesteps) of a moving average window\n";
    ss << "\\memo which is used to smooth the peak load across more than one timestep.\n";
    ss << "\\min-fields 1\n";
    ss << "N1, \\field Heating Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N2, \\field Cooling Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N3; \\field Timesteps in Averaging Window\n";
    ss << "\\note blank => set the timesteps in averaging window to\n";
    ss << "\\note Number of Timesteps per Hour resulting in a 1 hour averaging window\n";
    ss << "\\note default is number of timesteps for 1 hour averaging window\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";

    IddObjectType objType(IddObjectType::Sizing_Parameters);
    OptionalIddObject oObj = IddObject::load("Sizing:Parameters",
                                             "HVAC Design Objects",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Sizing_Parameters);
  return object;
}

IddObject createSizing_ZoneIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Sizing:Zone,\n";
    ss << "\\memo Specifies the data needed to perform a zone design air flow calculation.\n";
    ss << "\\memo The calculation is done for every sizing period included in the input. The maximum\n";
    ss << "\\memo cooling and heating load and cooling, heating, and ventilation air flows are then saved\n";
    ss << "\\memo for system level and zone component design calculations.\n";
    ss << "\\min-fields 18\n";
    ss << "A1, \\field Zone or ZoneList Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneAndZoneListNames\n";
    ss << "A2, \\field Zone Cooling Design Supply Air Temperature Input Method\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\default SupplyAirTemperature\n";
    ss << "N1, \\field Zone Cooling Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N2, \\field Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Zone Cooling Design Supply Air Temperature is only used when Zone Cooling Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be subtracted from the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Cooling Design Supply Air Temperature.\n";
    ss << "A3, \\field Zone Heating Design Supply Air Temperature Input Method\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "\\default SupplyAirTemperature\n";
    ss << "N3, \\field Zone Heating Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = SupplyAirTemperature\n";
    ss << "N4, \\field Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Zone Heating Design Supply Air Temperature is only used when Zone Heating Design\n";
    ss << "\\note Supply Air Temperature Input Method = TemperatureDifference\n";
    ss << "\\note The absolute value of this field will be added to the zone temperature\n";
    ss << "\\note at peak load to calculate the Zone Heating Design Supply Air Temperature.\n";
    ss << "N5, \\field Zone Cooling Design Supply Air Humidity Ratio\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0.0\n";
    ss << "\\type real\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "N6, \\field Zone Heating Design Supply Air Humidity Ratio\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0.0\n";
    ss << "\\type real\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "A4, \\field Design Specification Outdoor Air Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "N7, \\field Zone Heating Sizing Factor\n";
    ss << "\\note if blank or zero, global heating sizing factor from Sizing:Parameters is used.\n";
    ss << "\\minimum 0\n";
    ss << "N8, \\field Zone Cooling Sizing Factor\n";
    ss << "\\note if blank or zero, global cooling sizing factor from Sizing:Parameters is used.\n";
    ss << "\\minimum 0\n";
    ss << "A5, \\field Cooling Design Air Flow Method\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key DesignDay\n";
    ss << "\\key DesignDayWithLimit\n";
    ss << "\\default DesignDay\n";
    ss << "N9, \\field Cooling Design Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note This input is used if Cooling Design Air Flow Method is Flow/Zone\n";
    ss << "\\note This value will be multiplied by the global or zone sizing factor and\n";
    ss << "\\note by zone multipliers.\n";
    ss << "N10,\\field Cooling Minimum Air Flow per Zone Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0\n";
    ss << "\\default .000762\n";
    ss << "\\note default is .15 cfm/ft2\n";
    ss << "\\note This input is used if Cooling Design Air Flow Method is DesignDayWithLimit\n";
    ss << "N11,\\field Cooling Minimum Air Flow\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note This input is used if Cooling Design Air Flow Method is DesignDayWithLimit\n";
    ss << "N12,\\field Cooling Minimum Air Flow Fraction\n";
    ss << "\\note fraction of the Cooling design Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note This input is currently used in sizing the Fan minimum Flow Rate.\n";
    ss << "\\note It does not currently affect other component autosizing.\n";
    ss << "A6, \\field Heating Design Air Flow Method\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key DesignDay\n";
    ss << "\\key DesignDayWithLimit\n";
    ss << "\\default DesignDay\n";
    ss << "N13,\\field Heating Design Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note This input is used if Heating Design Air Flow Method is Flow/Zone.\n";
    ss << "\\note This value will be multiplied by the global or zone sizing factor and\n";
    ss << "\\note by zone multipliers.\n";
    ss << "N14,\\field Heating Maximum Air Flow per Zone Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0\n";
    ss << "\\default .002032\n";
    ss << "\\note default is .40 cfm/ft2\n";
    ss << "\\note This field is used to size the heating design flow rate when Heating Design Air Flow Method = Flow/Zone.\n";
    ss << "\\note This input is used for autosizing components when Heating Design Air Flow Method = DesignDayWithLimit.\n";
    ss << "N15,\\field Heating Maximum Air Flow\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\default .1415762\n";
    ss << "\\note default is 300 cfm\n";
    ss << "\\note This input is used for autosizing components when Heating Design Air Flow Method = DesignDayWithLimit.\n";
    ss << "N16,\\field Heating Maximum Air Flow Fraction\n";
    ss << "\\note fraction of the Heating Design Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.3\n";
    ss << "\\note This input is used for autosizing components when Heating Design Air Flow Method = DesignDayWithLimit.\n";
    ss << "A7, \\field Design Specification Zone Air Distribution Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneAirDistributionNames\n";
    ss << "A8, \\field Account for Dedicated Outdoor Air System\n";
    ss << "\\note account for effect of dedicated outdoor air system supplying air directly to the zone\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A9, \\field Dedicated Outdoor Air System Control Strategy\n";
    ss << "\\note 1)supply neutral ventilation air; 2)supply neutral dehumidified and reheated\n";
    ss << "\\note ventilation air; 3)supply cold ventilation air\n";
    ss << "\\type choice\n";
    ss << "\\key NeutralSupplyAir\n";
    ss << "\\key NeutralDehumidifiedSupplyAir\n";
    ss << "\\key ColdSupplyAir\n";
    ss << "\\default NeutralSupplyAir\n";
    ss << "N17,\\field Dedicated Outdoor Air Low Setpoint Temperature for Design\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N18;\\field Dedicated Outdoor Air High Setpoint Temperature for Design\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";

    IddObjectType objType(IddObjectType::Sizing_Zone);
    OptionalIddObject oObj = IddObject::load("Sizing:Zone",
                                             "HVAC Design Objects",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Sizing_Zone);
  return object;
}

IddObject createDesignSpecification_ZoneHVAC_SizingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "DesignSpecification:ZoneHVAC:Sizing,\n";
    ss << "\\min-fields 1\n";
    ss << "\\memo This object is used to describe general scalable zone HVAC equipment sizing which\n";
    ss << "\\memo are referenced by other objects.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference DesignSpecificationZoneHVACSizingName\n";
    ss << "A2, \\field Cooling Supply Air Flow Rate Method\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key SupplyAirFlowRate\n";
    ss << "\\key FlowPerFloorArea\n";
    ss << "\\key FractionOfAutosizedCoolingAirflow\n";
    ss << "\\key FlowPerCoolingCapacity\n";
    ss << "\\default SupplyAirFlowRate\n";
    ss << "\\note Enter the method used to determine the cooling supply air volume flow rate.\n";
    ss << "\\note None is used when a cooling coil is not included in the Zone HVAC Equip or this field\n";
    ss << "\\note may be blank. SupplyAirFlowRate => selected when the magnitude of the supply air volume\n";
    ss << "\\note flow rate is specified. FlowPerFloorArea => selected when the supply air volume flow rate\n";
    ss << "\\note is determined from total floor area served by the Zone HVAC unit and Flow Per Floor Area\n";
    ss << "\\note value specified. FractionOfAutosizedCoolingAirflow => is selected when the supply air volume\n";
    ss << "\\note is determined from a user specified fraction and the autosized cooling supply air flow rate\n";
    ss << "\\note value determined by the simulation. FlowPerCoolingCapacity => is selected when the supply\n";
    ss << "\\note air volume is determined from user specified flow per Cooling Capacity and Cooling Capacity\n";
    ss << "\\note determined by the simulation.\n";
    ss << "N1, \\field Cooling Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Enter the magnitude of supply air volume flow rate during cooling operation.\n";
    ss << "\\note Required field when Cooling Supply Air Flow Rate Method is SupplyAirFlowRate.\n";
    ss << "\\note This field may be blank if a cooling coil is not included in the Zone HVAC equipment.\n";
    ss << "N2, \\field Cooling Supply Air Flow Rate Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the cooling supply air volume flow rate per total conditioned floor area.\n";
    ss << "\\note Required field when Cooling Supply Air Flow Rate Method is FlowPerFloorArea.\n";
    ss << "\\note This field may be blank if a cooling coil is not included in the Zone HVAC equipment.\n";
    ss << "N3, \\field Cooling Fraction of Autosized Cooling Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the cooling supply air flow rate.\n";
    ss << "\\note Required field when Cooling Supply Air Flow Rate Method is\n";
    ss << "\\note FractionOfAutosizedCoolingAirflow.\n";
    ss << "\\note This field may be blank if a cooling coil is not included in the Zone HVAC equipment.\n";
    ss << "N4, \\field Cooling Supply Air Flow Rate Per Unit Cooling Capacity\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the cooling supply air volume flow rate unit cooling capacity.\n";
    ss << "\\note Required field when Cooling Supply Air Flow Rate Method is\n";
    ss << "\\note FlowPerCoolingCapacity. This field may be blank if a cooling coil is not\n";
    ss << "\\note included in the Zone HVAC equipment.\n";
    ss << "A3, \\field No Load Supply Air Flow Rate Method\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key SupplyAirFlowRate\n";
    ss << "\\key FlowPerFloorArea\n";
    ss << "\\key FractionOfAutosizedCoolingAirflow\n";
    ss << "\\key FractionOfAutosizedHeatingAirflow\n";
    ss << "\\default SupplyAirFlowRate\n";
    ss << "\\note Enter the method used to determine the supply air volume flow rate When No Cooling or Heating\n";
    ss << "\\note is Required. None is used when a cooling or heating coil is not included in the Zone HVAC\n";
    ss << "\\note Equipment or this field may be blank. SupplyAirFlowRate => selected when the magnitude of the\n";
    ss << "\\note supply air volume flow rate is specified. FlowPerFloorArea => selected when the supply air\n";
    ss << "\\note volume flow rate is determined from total floor area served by the Zone HVAC unit and Flow Per\n";
    ss << "\\note Floor Area is specified. FractionOfAutosizedCoolingAirflow => is selected when the supply\n";
    ss << "\\note air volume is determined from a user specified fraction and the Autosized cooling supply\n";
    ss << "\\note air flow rate value determined by the simulation. FractionOfAutosizedHeatingAirflow => is\n";
    ss << "\\note selected when the supply air volume is determined from a user specified fraction and the\n";
    ss << "\\note Autosized heating supply air flow rate value determined by the simulation.\n";
    ss << "N5, \\field No Load Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Enter the magnitude of the supply air volume flow rate during when no cooling or heating\n";
    ss << "\\note is required. Required field when No Load Supply Air Flow Rate Method\n";
    ss << "\\note is SupplyAirFlowRate.\n";
    ss << "N6, \\field No Load Supply Air Flow Rate Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate per total floor area.\n";
    ss << "\\note Required field when No Load Supply Air Flow Rate Method\n";
    ss << "\\note is FlowPerFloorArea.\n";
    ss << "N7, \\field No Load Fraction of Cooling Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the cooling supply air flow rate.\n";
    ss << "\\note Required field when No Load Supply Air Flow Rate Method\n";
    ss << "\\note is FractionOfAutosizedCoolingAirflow.\n";
    ss << "N8, \\field No Load Fraction of Heating Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the heating supply air flow rate.\n";
    ss << "\\note Required field when No Load Supply Air Flow Rate Method\n";
    ss << "\\note is FractionOfAutosizedHeatingAirflow.\n";
    ss << "A4, \\field Heating Supply Air Flow Rate Method\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key SupplyAirFlowRate\n";
    ss << "\\key FlowPerFloorArea\n";
    ss << "\\key FractionOfAutosizedHeatingAirflow\n";
    ss << "\\key FlowPerHeatingCapacity\n";
    ss << "\\default SupplyAirFlowRate\n";
    ss << "\\note Enter the method used to determine the heating supply air volume flow rate.\n";
    ss << "\\note None is used when a heating coil is not included in the Zone HVAC Equipment or this field may\n";
    ss << "\\note be blank. SupplyAirFlowRate => selected when the magnitude of the heating supply air volume\n";
    ss << "\\note flow rate is specified.  FlowPerFloorArea => selected when the supply air volume flow rate is\n";
    ss << "\\note determined from total floor area served by a Zone HVAC unit and user specified value of Flow\n";
    ss << "\\note Per Floor Area. FractionOfAutosizedHeatingAirflow => is selected when the supply air volume\n";
    ss << "\\note is determined from a user specified fraction and the Autosized heating supply air flow rate\n";
    ss << "\\note value determined by the simulation. FlowPerHeatingCapacity => is selected when the supply\n";
    ss << "\\note air volume is determined from user specified flow per Heating Capacity and Heating Capacity\n";
    ss << "\\note determined by the simulation.\n";
    ss << "N9, \\field Heating Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Enter the magnitude of the supply air volume flow rate during heating operation.\n";
    ss << "\\note Required field when Heating Supply Air Flow Rate Method is SupplyAirFlowRate.\n";
    ss << "\\note This field may be blank if a heating coil is not included in the Zone HVAC equipment.\n";
    ss << "N10, \\field Heating Supply Air Flow Rate Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the heating supply air volume flow rate per total conditioned floor area.\n";
    ss << "\\note Required field when Heating Supply Air Flow Rate Method is FlowPerFloorArea.\n";
    ss << "\\note This field may be blank if a heating coil is not included in the Zone HVAC equipment.\n";
    ss << "N11, \\field Heating Fraction of Heating Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the heating supply air flow rate.\n";
    ss << "\\note Required field when Heating Supply Air Flow Rate Method is\n";
    ss << "\\note FractionOfAutosizedHeatingAirflow.\n";
    ss << "\\note This field may be blank if a heating coil is not included in the Zone HVAC equipment.\n";
    ss << "N12, \\field Heating Supply Air Flow Rate Per Unit Heating Capacity\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate per unit heating capacity.\n";
    ss << "\\note Required field when Heating Supply Air Flow Rate Method is\n";
    ss << "\\note FlowPerHeatingCapacity.\n";
    ss << "\\note This field may be blank if a heating coil is not included in the Zone HVAC equipment.\n";
    ss << "A5, \\field Cooling Design Capacity Method\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key CoolingDesignCapacity\n";
    ss << "\\key CapacityPerFloorArea\n";
    ss << "\\key FractionOfAutosizedCoolingCapacity\n";
    ss << "\\default None\n";
    ss << "\\note Enter the method used to determine the cooling design capacity for scalable sizing.\n";
    ss << "\\note None is used when a cooling coils is not included in the Zone HVAC Equipment or\n";
    ss << "\\note this field may be blank. If this input field is left blank, then the design cooling\n";
    ss << "\\note capacity is set to zero. CoolingDesignCapacity => selected when the design cooling capacity\n";
    ss << "\\note value is specified or auto-sized. CapacityPerFloorArea => selected when the design cooling\n";
    ss << "\\note capacity is determine from user specified cooling capacity per floor area and zone floor area.\n";
    ss << "\\note FractionOfAutosizedCoolingCapacity => is selected when the design cooling capacity is\n";
    ss << "\\note determined from a user specified fraction and the auto-sized design cooling capacity.\n";
    ss << "N13, \\field Cooling Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Enter the design cooling capacity. Required field when the cooling design capacity method\n";
    ss << "\\note CoolingDesignCapacity.\n";
    ss << "N14, \\field Cooling Design Capacity Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the cooling design capacity per zone floor area. Required field when the cooling design\n";
    ss << "\\note capacity method field is CapacityPerFloorArea.\n";
    ss << "N15, \\field Fraction of Autosized Cooling Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the fraction of auto-sized cooling design capacity. Required field when the cooling\n";
    ss << "\\note design capacity method field is FractionOfAutosizedCoolingCapacity.\n";
    ss << "A6, \\field Heating Design Capacity Method\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key HeatingDesignCapacity\n";
    ss << "\\key CapacityPerFloorArea\n";
    ss << "\\key FractionOfAutosizedHeatingCapacity\n";
    ss << "\\default None\n";
    ss << "\\note Enter the method used to determine the heating design capacity for scalable sizing.\n";
    ss << "\\note None is used when a heating coil is not included in the Zone HVAC Equipment or\n";
    ss << "\\note this field may be blank. If this input field is left blank, then the design heating\n";
    ss << "\\note capacity is set to zero. HeatingDesignCapacity => selected when the design heating capacity\n";
    ss << "\\note value is specified or auto-sized. CapacityPerFloorArea => selected when the design cooling\n";
    ss << "\\note capacity is determine from user specified heating capacity per flow area and zone floor area.\n";
    ss << "\\note FractionOfAutosizedHeatingCapacity => is selected when the design heating capacity is\n";
    ss << "\\note determined from a user specified fraction and the auto-sized design heating capacity\n";
    ss << "N16, \\field Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Enter the design heating capacity. Required field when the heating design capacity method\n";
    ss << "\\note HeatingDesignCapacity.\n";
    ss << "N17, \\field Heating Design Capacity Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the heating design capacity per zone floor area. Required field when the heating design\n";
    ss << "\\note capacity method field is CapacityPerFloorArea.\n";
    ss << "N18; \\field Fraction of Autosized Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the fraction of auto-sized heating design capacity. Required field when capacity the\n";
    ss << "\\note heating design capacity method field is FractionOfAutosizedHeatingCapacity.\n";

    IddObjectType objType(IddObjectType::DesignSpecification_ZoneHVAC_Sizing);
    OptionalIddObject oObj = IddObject::load("DesignSpecification:ZoneHVAC:Sizing",
                                             "HVAC Design Objects",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::DesignSpecification_ZoneHVAC_Sizing);
  return object;
}

IddObject createSizing_SystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Sizing:System,\n";
    ss << "\\memo Specifies the input needed to perform sizing calculations for a central forced air\n";
    ss << "\\memo system. System design air flow, heating capacity, and cooling capacity will be calculated\n";
    ss << "\\memo using this input data.\n";
    ss << "\\min-fields 37\n";
    ss << "A1, \\field AirLoop Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirPrimaryLoops\n";
    ss << "A2, \\field Type of Load to Size On\n";
    ss << "\\note Specifies the basis for sizing the system supply air flow rate\n";
    ss << "\\note Sensible and Total use the zone design air flow rates to size the system supply air flow rate\n";
    ss << "\\note The cooling coil will then be sized at either the peak Sensible or Total flow rate and conditions\n";
    ss << "\\note The heating coil is always sized at the peak sensible heating load.\n";
    ss << "\\note VentilationRequirement uses the system ventilation requirement\n";
    ss << "\\type choice\n";
    ss << "\\key Sensible\n";
    ss << "\\key Total\n";
    ss << "\\key VentilationRequirement\n";
    ss << "\\default Sensible\n";
    ss << "N1, \\field Design Outdoor Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\default autosize\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "N2, \\field Central Heating Maximum System Air Flow Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.5\n";
    ss << "N3, \\field Preheat Design Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N4, \\field Preheat Design Humidity Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "N5, \\field Precool Design Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N6, \\field Precool Design Humidity Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "N7, \\field Central Cooling Design Supply Air Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N8, \\field Central Heating Design Supply Air Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "A3, \\field Type of Zone Sum to Use\n";
    ss << "\\type choice\n";
    ss << "\\key Coincident\n";
    ss << "\\key NonCoincident\n";
    ss << "\\default NonCoincident\n";
    ss << "A4, \\field 100% Outdoor Air in Cooling\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A5, \\field 100% Outdoor Air in Heating\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N9, \\field Central Cooling Design Supply Air Humidity Ratio\n";
    ss << "\\type real\n";
    ss << "\\default 0.008\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "N10, \\field Central Heating Design Supply Air Humidity Ratio\n";
    ss << "\\type real\n";
    ss << "\\default 0.008\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "A6, \\field Cooling Supply Air Flow Rate Method\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/System\n";
    ss << "\\key DesignDay\n";
    ss << "\\key FlowPerFloorArea\n";
    ss << "\\key FractionOfAutosizedCoolingAirflow\n";
    ss << "\\key FlowPerCoolingCapacity\n";
    ss << "\\default DesignDay\n";
    ss << "N11, \\field Cooling Supply Air Flow Rate\n";
    ss << "\\note This input is used if Cooling Supply Air Flow Rate Method is Flow/System\n";
    ss << "\\note This value will *not* be multiplied by any sizing factor or by zone multipliers.\n";
    ss << "\\note If using zone multipliers, this value must be large enough to serve the multiplied zones.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N12, \\field Cooling Supply Air Flow Rate Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the cooling supply air volume flow rate per total conditioned floor area.\n";
    ss << "\\note Required field when Cooling Supply Air Flow Rate Method is FlowPerFloorArea.\n";
    ss << "N13, \\field Cooling Fraction of Autosized Cooling Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the cooling supply air flow rate.\n";
    ss << "\\note Required field when Cooling Supply Air Flow Rate Method is\n";
    ss << "\\note FractionOfAutosizedCoolingAirflow.\n";
    ss << "N14, \\field Cooling Supply Air Flow Rate Per Unit Cooling Capacity\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate per unit cooling capacity.\n";
    ss << "\\note Required field when Cooling Supply Air Flow Rate Method is\n";
    ss << "\\note FlowPerCoolingCapacity.\n";
    ss << "A7, \\field Heating Supply Air Flow Rate Method\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/System\n";
    ss << "\\key DesignDay\n";
    ss << "\\key FlowPerFloorArea\n";
    ss << "\\key FractionOfAutosizedHeatingAirflow\n";
    ss << "\\key FractionOfAutosizedCoolingAirflow\n";
    ss << "\\key FlowPerCoolingCapacity\n";
    ss << "\\default DesignDay\n";
    ss << "N15, \\field Heating Supply Air Flow Rate\n";
    ss << "\\note Required field when Heating Supply Air Flow Rate Method is Flow/System\n";
    ss << "\\note This value will *not* be multiplied by any sizing factor or by zone multipliers.\n";
    ss << "\\note If using zone multipliers, this value must be large enough to serve the multiplied zones.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N16, \\field Heating Supply Air Flow Rate Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the heating supply air volume flow rate per total conditioned floor area.\n";
    ss << "\\note Required field when Heating Supply Air Flow Rate Method is FlowPerFloorArea.\n";
    ss << "N17, \\field Heating Fraction of Autosized Heating Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the heating supply air flow rate.\n";
    ss << "\\note Required field when Heating Supply Air Flow Rate Method is\n";
    ss << "\\note FractionOfAutosizedHeatingAirflow.\n";
    ss << "N18, \\field Heating Fraction of Autosized Cooling Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the cooling supply air flow rate.\n";
    ss << "\\note Required field when Heating Supply Air Flow Rate Method is\n";
    ss << "\\note FractionOfAutosizedCoolingAirflow.\n";
    ss << "N19, \\field Heating Supply Air Flow Rate Per Unit Heating Capacity\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the heating supply air volume flow rate per unit heating capacity.\n";
    ss << "\\note Required field when Heating Supply Air Flow Rate Method is\n";
    ss << "\\note FlowPerHeatingCapacity.\n";
    ss << "A8, \\field System Outdoor Air Method\n";
    ss << "\\type choice\n";
    ss << "\\key ZoneSum\n";
    ss << "\\key VentilationRateProcedure\n";
    ss << "\\default ZoneSum\n";
    ss << "N20, \\field Zone Maximum Outdoor Air Fraction\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units dimensionless\n";
    ss << "A9, \\field Cooling Design Capacity Method\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key CoolingDesignCapacity\n";
    ss << "\\key CapacityPerFloorArea\n";
    ss << "\\key FractionOfAutosizedCoolingCapacity\n";
    ss << "\\default CoolingDesignCapacity\n";
    ss << "\\note Enter the method used to determine the system cooling design capacity for scalable sizing.\n";
    ss << "\\note None is used when a cooling coils is not included in an airloop or this field may be blank.\n";
    ss << "\\note If this input field is left blank, then the design cooling capacity is set to zero.\n";
    ss << "\\note CoolingDesignCapacity => selected when the design cooling capacity value is specified or\n";
    ss << "\\note auto-sized. CapacityPerFloorArea => selected when the design cooling capacity is determined\n";
    ss << "\\note from user specified cooling capacity per floor area and total floor area of cooled zones\n";
    ss << "\\note served by an airloop. FractionOfAutosizedCoolingCapacity => is selected when the design\n";
    ss << "\\note cooling capacity is determined from a user specified fraction and the auto-sized design\n";
    ss << "\\note cooling capacity of the system.\n";
    ss << "N21, \\field Cooling Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\note Enter the design cooling capacity.\n";
    ss << "N22, \\field Cooling Design Capacity Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the cooling design capacity per total floor area of cooled zones served by an airloop.\n";
    ss << "\\note Required field when the cooling design capacity method field is CapacityPerFloorArea.\n";
    ss << "N23, \\field Fraction of Autosized Cooling Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the fraction of auto-sized cooling design capacity. Required field when the cooling\n";
    ss << "\\note design capacity method field is FractionOfAutosizedCoolingCapacity.\n";
    ss << "A10, \\field Heating Design Capacity Method\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key HeatingDesignCapacity\n";
    ss << "\\key CapacityPerFloorArea\n";
    ss << "\\key FractionOfAutosizedHeatingCapacity\n";
    ss << "\\default HeatingDesignCapacity\n";
    ss << "\\note Enter the method used to determine the heating design capacity for scalable sizing.\n";
    ss << "\\note None is used when a heating coil not included in an airloop or this field may be blank.\n";
    ss << "\\note If this input field is left blank, then the design heating capacity is set to zero.\n";
    ss << "\\note HeatingDesignCapacity => selected when the design heating capacity value is specified or\n";
    ss << "\\note auto-sized. CapacityPerFloorArea => selected when the design heating capacity is determined\n";
    ss << "\\note from user specified heating capacity per flow area and total floor area of heated zones\n";
    ss << "\\note served by an airloop. FractionOfAutosizedHeatingCapacity => is selected when the design\n";
    ss << "\\note heating capacity is determined from a user specified fraction and the auto-sized design\n";
    ss << "\\note heating capacity of the system.\n";
    ss << "N24, \\field Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\note Enter the design heating capacity.\n";
    ss << "N25, \\field Heating Design Capacity Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the heating design capacity per zone floor area. Required field when the heating design\n";
    ss << "\\note capacity method field is CapacityPerFloorArea.\n";
    ss << "N26, \\field Fraction of Autosized Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the fraction of auto-sized heating design capacity. Required field when capacity the\n";
    ss << "\\note heating design capacity method field is FractionOfAutosizedHeatingCapacity.\n";
    ss << "A11; \\field Central Cooling Capacity Control Method\n";
    ss << "\\note Method used to control the coil's output\n";
    ss << "\\type choice\n";
    ss << "\\key VAV\n";
    ss << "\\key Bypass\n";
    ss << "\\key VT\n";
    ss << "\\key OnOff\n";
    ss << "\\default OnOff\n";

    IddObjectType objType(IddObjectType::Sizing_System);
    OptionalIddObject oObj = IddObject::load("Sizing:System",
                                             "HVAC Design Objects",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Sizing_System);
  return object;
}

IddObject createSizing_PlantIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Sizing:Plant,\n";
    ss << "\\min-fields 4\n";
    ss << "A1, \\field Plant or Condenser Loop Name\n";
    ss << "\\note Enter the name of a PlantLoop or a CondenserLoop object\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PlantLoops\n";
    ss << "A2, \\field Loop Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Heating\n";
    ss << "\\key Cooling\n";
    ss << "\\key Condenser\n";
    ss << "\\key Steam\n";
    ss << "N1, \\field Design Loop Exit Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N2, \\field Loop Design Temperature Difference\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum> 0.0\n";
    ss << "A3, \\field Sizing Option\n";
    ss << "\\note if Coincident is chosen, then sizing is based on HVAC Sizing Simulations and\n";
    ss << "\\note the input field called Do HVAC Sizing Simulation for Sizing Periods in SimulationControl must be set to Yes\n";
    ss << "\\type choice\n";
    ss << "\\key Coincident\n";
    ss << "\\key NonCoincident\n";
    ss << "\\default NonCoincident\n";
    ss << "N3, \\field Zone Timesteps in Averaging Window\n";
    ss << "\\note this is used in the coincident sizing algorithm to apply a running average to peak flow rates\n";
    ss << "\\note that occur during HVAC Sizing Simulations\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";
    ss << "A4; \\field Coincident Sizing Factor Mode\n";
    ss << "\\note this is used to adjust the result for coincident sizing by applying a sizing factor\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key GlobalHeatingSizingFactor\n";
    ss << "\\key GlobalCoolingSizingFactor\n";
    ss << "\\key LoopComponentSizingFactor\n";

    IddObjectType objType(IddObjectType::Sizing_Plant);
    OptionalIddObject oObj = IddObject::load("Sizing:Plant",
                                             "HVAC Design Objects",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Sizing_Plant);
  return object;
}

IddObject createOutputControl_Sizing_StyleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OutputControl:Sizing:Style,\n";
    ss << "\\memo Default style for the Sizing output files is comma -- this works well for\n";
    ss << "\\memo importing into spreadsheet programs such as Excel(tm) but not so well for word\n";
    ss << "\\memo processing programs -- there tab may be a better choice.  Fixed puts spaces between\n";
    ss << "\\memo the \"columns\"\n";
    ss << "\\unique-object\n";
    ss << "A1; \\field Column Separator\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Comma\n";
    ss << "\\key Tab\n";
    ss << "\\key Fixed\n";

    IddObjectType objType(IddObjectType::OutputControl_Sizing_Style);
    OptionalIddObject oObj = IddObject::load("OutputControl:Sizing:Style",
                                             "HVAC Design Objects",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OutputControl_Sizing_Style);
  return object;
}

IddObject createZoneControl_HumidistatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneControl:Humidistat,\n";
    ss << "\\memo Specifies zone relative humidity setpoint schedules for humidifying and dehumidifying.\n";
    ss << "\\min-fields 3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ZoneControlHumidistatNames\n";
    ss << "A2 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A3 , \\field Humidifying Relative Humidity Setpoint Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\note hourly schedule values should be in Relative Humidity (percent)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 ; \\field Dehumidifying Relative Humidity Setpoint Schedule Name\n";
    ss << "\\note hourly schedule values should be in Relative Humidity (percent)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::ZoneControl_Humidistat);
    OptionalIddObject oObj = IddObject::load("ZoneControl:Humidistat",
                                             "Zone HVAC Controls and Thermostats",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneControl_Humidistat);
  return object;
}

IddObject createZoneControl_ThermostatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneControl:Thermostat,\n";
    ss << "\\memo Define the Thermostat settings for a zone or list of zones.\n";
    ss << "\\memo If you use a ZoneList in the Zone or ZoneList name field then this definition applies\n";
    ss << "\\memo to all the zones in the ZoneList.\n";
    ss << "\\extensible:2\n";
    ss << "\\min-fields 5\n";
    ss << "\\max-fields 11\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ZoneControlThermostaticNames\n";
    ss << "A2 , \\field Zone or ZoneList Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneAndZoneListNames\n";
    ss << "A3 , \\field Control Type Schedule Name\n";
    ss << "\\note This schedule contains appropriate control types for thermostat.\n";
    ss << "\\note Control types are integers: 0 - Uncontrolled (floating, no thermostat), 1 = ThermostatSetpoint:SingleHeating,\n";
    ss << "\\note 2 = ThermostatSetpoint:SingleCooling, 3 = ThermostatSetpoint:SingleHeatingOrCooling, 4 = ThermostatSetpoint:DualSetpoint\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Control 1 Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key ThermostatSetpoint:SingleHeating\n";
    ss << "\\key ThermostatSetpoint:SingleCooling\n";
    ss << "\\key ThermostatSetpoint:SingleHeatingOrCooling\n";
    ss << "\\key ThermostatSetpoint:DualSetpoint\n";
    ss << "\\begin-extensible\n";
    ss << "A5 ; \\field Control 1 Name\n";
    ss << "\\note Control names are names of individual control objects (e.g. ThermostatSetpoint:SingleHeating)\n";
    ss << "\\note Schedule values in these objects list actual setpoint temperatures for the control types\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ControlTypeNames\n";

    IddObjectType objType(IddObjectType::ZoneControl_Thermostat);
    OptionalIddObject oObj = IddObject::load("ZoneControl:Thermostat",
                                             "Zone HVAC Controls and Thermostats",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneControl_Thermostat);
  return object;
}

IddObject createZoneControl_Thermostat_OperativeTemperatureIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneControl:Thermostat:OperativeTemperature,\n";
    ss << "\\memo This object can be used with the ZoneList option on a thermostat or with one\n";
    ss << "\\memo of the zones on that list (but you won't be able to use the object list to\n";
    ss << "\\memo pick only one of those zones.  Thermostat names are <Zone Name> <global Thermostat name> internally.\n";
    ss << "A1,  \\field Thermostat Name\n";
    ss << "\\note Enter the name of a ZoneControl:Thermostat object.\n";
    ss << "\\note This object modifies a ZoneControl:Thermostat object to add a\n";
    ss << "\\note radiative fraction.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneControlThermostaticNames\n";
    ss << "A2,  \\field Radiative Fraction Input Mode\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Constant\n";
    ss << "\\key Scheduled\n";
    ss << "N1,  \\field Fixed Radiative Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum< 0.9\n";
    ss << "A3;  \\field Radiative Fraction Schedule Name\n";
    ss << "\\note Schedule values of 0.0 indicate no operative temperature control\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::ZoneControl_Thermostat_OperativeTemperature);
    OptionalIddObject oObj = IddObject::load("ZoneControl:Thermostat:OperativeTemperature",
                                             "Zone HVAC Controls and Thermostats",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneControl_Thermostat_OperativeTemperature);
  return object;
}

IddObject createZoneControl_Thermostat_ThermalComfortIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneControl:Thermostat:ThermalComfort,\n";
    ss << "\\memo If you use a ZoneList in the Zone or ZoneList name field then this definition applies\n";
    ss << "\\memo to all the zones in the ZoneList.\n";
    ss << "\\min-fields 9\n";
    ss << "\\extensible:2\n";
    ss << "\\max-fields 15\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Zone or ZoneList Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneAndZoneListNames\n";
    ss << "A3 , \\field Averaging Method\n";
    ss << "\\note The method used to calculate thermal comfort dry-bulb temperature setpoint\n";
    ss << "\\note for multiple people objects in a zone\n";
    ss << "\\type choice\n";
    ss << "\\key SpecificObject\n";
    ss << "\\key ObjectAverage\n";
    ss << "\\key PeopleAverage\n";
    ss << "\\default PeopleAverage\n";
    ss << "A4 , \\field Specific People Name\n";
    ss << "\\note Used only when Averaging Method = SpecificObject in the previous field.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PeopleNames\n";
    ss << "N1 , \\field Minimum Dry-Bulb Temperature Setpoint\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 50\n";
    ss << "\\default 0\n";
    ss << "N2 , \\field Maximum Dry-Bulb Temperature Setpoint\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 50\n";
    ss << "\\default 50\n";
    ss << "A5 , \\field Thermal Comfort Control Type Schedule Name\n";
    ss << "\\note The Thermal Comfort Control Type Schedule contains values that are appropriate control types.\n";
    ss << "\\note Thermal Comfort Control types are integers: 0 - Uncontrolled (floating),\n";
    ss << "\\note 1 = ThermostatSetpoint:ThermalComfort:Fanger:SingleHeating\n";
    ss << "\\note 2 = ThermostatSetpoint:ThermalComfort:Fanger:SingleCooling\n";
    ss << "\\note 3 = ThermostatSetpoint:ThermalComfort:Fanger:SingleHeatingOrCooling\n";
    ss << "\\note 4 = ThermostatSetpoint:ThermalComfort:Fanger:DualSetpoint\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6 , \\field Thermal Comfort Control 1 Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key ThermostatSetpoint:ThermalComfort:Fanger:SingleHeating\n";
    ss << "\\key ThermostatSetpoint:ThermalComfort:Fanger:SingleCooling\n";
    ss << "\\key ThermostatSetpoint:ThermalComfort:Fanger:SingleHeatingOrCooling\n";
    ss << "\\key ThermostatSetpoint:ThermalComfort:Fanger:DualSetpoint\n";
    ss << "\\begin-extensible\n";
    ss << "A7 ; \\field Thermal Comfort Control 1 Name\n";
    ss << "\\note Control type names are names for individual control type objects.\n";
    ss << "\\note Schedule values in these objects list actual setpoint temperatures for the control types\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalComfortControlTypeNames\n";

    IddObjectType objType(IddObjectType::ZoneControl_Thermostat_ThermalComfort);
    OptionalIddObject oObj = IddObject::load("ZoneControl:Thermostat:ThermalComfort",
                                             "Zone HVAC Controls and Thermostats",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneControl_Thermostat_ThermalComfort);
  return object;
}

IddObject createZoneControl_Thermostat_TemperatureAndHumidityIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneControl:Thermostat:TemperatureAndHumidity,\n";
    ss << "\\min-fields 2\n";
    ss << "\\memo This object modifies a ZoneControl:Thermostat object to effect temperature control based on\n";
    ss << "\\memo zone air humidity conditions.\n";
    ss << "A1,  \\field Thermostat Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneControlThermostaticNames\n";
    ss << "\\note Enter the name of a ZoneControl:Thermostat object whose operation is to be modified to\n";
    ss << "\\note effect temperature control based on zone air humidity conditions. If the ZoneControl:\n";
    ss << "\\note Thermostat object references a ZoneList, simply enter the name of the ZoneControl:Thermostat\n";
    ss << "\\note object and this temperature and humidity thermostat control will be applied to all zones\n";
    ss << "\\note in the ZoneList. If the ZoneControl:Thermostat object references a ZoneList but it is\n";
    ss << "\\note desired that only a single zone within the ZoneList be controlled based on temperature and\n";
    ss << "\\note humidity control, then the name to be put here is <Zone Name> <Thermostat Name> where the\n";
    ss << "\\note Thermostat Name is the the name of the ZoneControl:Thermostat object.\n";
    ss << "A2 , \\field Dehumidifying Relative Humidity Setpoint Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values should be in Relative Humidity (percent)\n";
    ss << "A3,  \\field Dehumidification Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Overcool\n";
    ss << "\\key None\n";
    ss << "\\default Overcool\n";
    ss << "A4,  \\field Overcool Range Input Method\n";
    ss << "\\type choice\n";
    ss << "\\key Constant\n";
    ss << "\\key Scheduled\n";
    ss << "\\default Constant\n";
    ss << "N1,  \\field Overcool Constant Range\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 3.0\n";
    ss << "\\default 1.7\n";
    ss << "\\note Maximum Overcool temperature range for cooling setpoint reduction.\n";
    ss << "\\note Used with Dehumidification Control Type = Overcool.\n";
    ss << "\\note A value of 0.0 indicates no zone temperature overcooling will be provided to\n";
    ss << "\\note gain additional dehumidification.\n";
    ss << "A5,  \\field Overcool Range Schedule Name\n";
    ss << "\\note Schedule values of 0.0 indicates no zone temperature overcooling will be\n";
    ss << "\\note provided to gain additional dehumidification.\n";
    ss << "\\note Schedule values should be >= 0 and <= 3 (deltaC).\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N2;  \\field Overcool Control Ratio\n";
    ss << "\\type real\n";
    ss << "\\units percent/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 3.6\n";
    ss << "\\note The value of this input field is used to adjust the cooling setpoint temperature\n";
    ss << "\\note (established by the associated ZoneControl:Thermostat object) downward based on the\n";
    ss << "\\note difference between the zone air relative humidity level and the dehumidifying\n";
    ss << "\\note relative humidity setpoint.\n";

    IddObjectType objType(IddObjectType::ZoneControl_Thermostat_TemperatureAndHumidity);
    OptionalIddObject oObj = IddObject::load("ZoneControl:Thermostat:TemperatureAndHumidity",
                                             "Zone HVAC Controls and Thermostats",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneControl_Thermostat_TemperatureAndHumidity);
  return object;
}

IddObject createThermostatSetpoint_SingleHeatingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ThermostatSetpoint:SingleHeating,\n";
    ss << "\\memo Used for a heating only thermostat. The setpoint can be scheduled and varied throughout\n";
    ss << "\\memo the simulation but only heating is allowed with this control type.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ControlTypeNames\n";
    ss << "A2 ; \\field Setpoint Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::ThermostatSetpoint_SingleHeating);
    OptionalIddObject oObj = IddObject::load("ThermostatSetpoint:SingleHeating",
                                             "Zone HVAC Controls and Thermostats",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ThermostatSetpoint_SingleHeating);
  return object;
}

IddObject createThermostatSetpoint_SingleCoolingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ThermostatSetpoint:SingleCooling,\n";
    ss << "\\memo Used for a cooling only thermostat. The setpoint can be scheduled and varied throughout\n";
    ss << "\\memo the simulation but only cooling is allowed.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ControlTypeNames\n";
    ss << "A2 ; \\field Setpoint Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::ThermostatSetpoint_SingleCooling);
    OptionalIddObject oObj = IddObject::load("ThermostatSetpoint:SingleCooling",
                                             "Zone HVAC Controls and Thermostats",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ThermostatSetpoint_SingleCooling);
  return object;
}

IddObject createThermostatSetpoint_SingleHeatingOrCoolingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ThermostatSetpoint:SingleHeatingOrCooling,\n";
    ss << "\\memo Used for a heating and cooling thermostat with a single setpoint. The setpoint can be\n";
    ss << "\\memo scheduled and varied throughout the simulation for both heating and cooling.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ControlTypeNames\n";
    ss << "A2 ; \\field Setpoint Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::ThermostatSetpoint_SingleHeatingOrCooling);
    OptionalIddObject oObj = IddObject::load("ThermostatSetpoint:SingleHeatingOrCooling",
                                             "Zone HVAC Controls and Thermostats",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ThermostatSetpoint_SingleHeatingOrCooling);
  return object;
}

IddObject createThermostatSetpoint_DualSetpointIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ThermostatSetpoint:DualSetpoint,\n";
    ss << "\\memo Used for a heating and cooling thermostat with dual setpoints. The setpoints can be\n";
    ss << "\\memo scheduled and varied throughout the simulation for both heating and cooling.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ControlTypeNames\n";
    ss << "A2 , \\field Heating Setpoint Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 ; \\field Cooling Setpoint Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::ThermostatSetpoint_DualSetpoint);
    OptionalIddObject oObj = IddObject::load("ThermostatSetpoint:DualSetpoint",
                                             "Zone HVAC Controls and Thermostats",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ThermostatSetpoint_DualSetpoint);
  return object;
}

IddObject createThermostatSetpoint_ThermalComfort_Fanger_SingleHeatingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ThermostatSetpoint:ThermalComfort:Fanger:SingleHeating,\n";
    ss << "\\memo Used for heating only thermal comfort control. The PMV setpoint can be scheduled and\n";
    ss << "\\memo varied throughout the simulation but only heating is allowed with this control type.\n";
    ss << "\\min-fields 2\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ThermalComfortControlTypeNames\n";
    ss << "A2 ; \\field Fanger Thermal Comfort Schedule Name\n";
    ss << "\\note Schedule values should be Predicted Mean Vote (PMV)\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::ThermostatSetpoint_ThermalComfort_Fanger_SingleHeating);
    OptionalIddObject oObj = IddObject::load("ThermostatSetpoint:ThermalComfort:Fanger:SingleHeating",
                                             "Zone HVAC Controls and Thermostats",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ThermostatSetpoint_ThermalComfort_Fanger_SingleHeating);
  return object;
}

IddObject createThermostatSetpoint_ThermalComfort_Fanger_SingleCoolingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ThermostatSetpoint:ThermalComfort:Fanger:SingleCooling,\n";
    ss << "\\memo Used for cooling only thermal comfort control. The PMV setpoint can be scheduled and\n";
    ss << "\\memo varied throughout the simulation but only cooling is allowed with this control type.\n";
    ss << "\\min-fields 2\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ThermalComfortControlTypeNames\n";
    ss << "A2 ; \\field Fanger Thermal Comfort Schedule Name\n";
    ss << "\\note Schedule values should be Predicted Mean Vote (PMV)\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::ThermostatSetpoint_ThermalComfort_Fanger_SingleCooling);
    OptionalIddObject oObj = IddObject::load("ThermostatSetpoint:ThermalComfort:Fanger:SingleCooling",
                                             "Zone HVAC Controls and Thermostats",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ThermostatSetpoint_ThermalComfort_Fanger_SingleCooling);
  return object;
}

IddObject createThermostatSetpoint_ThermalComfort_Fanger_SingleHeatingOrCoolingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ThermostatSetpoint:ThermalComfort:Fanger:SingleHeatingOrCooling,\n";
    ss << "\\memo Used for heating and cooling thermal comfort control with a single setpoint. The PMV\n";
    ss << "\\memo setpoint can be scheduled and varied throughout the simulation for both heating and\n";
    ss << "\\memo cooling.\n";
    ss << "\\min-fields 2\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ThermalComfortControlTypeNames\n";
    ss << "A2 ; \\field Fanger Thermal Comfort Schedule Name\n";
    ss << "\\note Schedule values should be Predicted Mean Vote (PMV)\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::ThermostatSetpoint_ThermalComfort_Fanger_SingleHeatingOrCooling);
    OptionalIddObject oObj = IddObject::load("ThermostatSetpoint:ThermalComfort:Fanger:SingleHeatingOrCooling",
                                             "Zone HVAC Controls and Thermostats",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ThermostatSetpoint_ThermalComfort_Fanger_SingleHeatingOrCooling);
  return object;
}

IddObject createThermostatSetpoint_ThermalComfort_Fanger_DualSetpointIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ThermostatSetpoint:ThermalComfort:Fanger:DualSetpoint,\n";
    ss << "\\memo Used for heating and cooling thermal comfort control with dual setpoints. The PMV\n";
    ss << "\\memo setpoints can be scheduled and varied throughout the simulation for both heating and\n";
    ss << "\\memo cooling.\n";
    ss << "\\min-fields 3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ThermalComfortControlTypeNames\n";
    ss << "A2 , \\field Fanger Thermal Comfort Heating Schedule Name\n";
    ss << "\\note Schedule values should be Predicted Mean Vote (PMV)\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 ; \\field Fanger Thermal Comfort Cooling Schedule Name\n";
    ss << "\\note Schedule values should be Predicted Mean Vote (PMV)\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::ThermostatSetpoint_ThermalComfort_Fanger_DualSetpoint);
    OptionalIddObject oObj = IddObject::load("ThermostatSetpoint:ThermalComfort:Fanger:DualSetpoint",
                                             "Zone HVAC Controls and Thermostats",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ThermostatSetpoint_ThermalComfort_Fanger_DualSetpoint);
  return object;
}

IddObject createZoneControl_Thermostat_StagedDualSetpointIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneControl:Thermostat:StagedDualSetpoint,\n";
    ss << "\\memo Define the Thermostat StagedDualSetpoint settings for a zone or list of zones.\n";
    ss << "\\memo If you use a ZoneList in the Zone or ZoneList name field then this definition applies\n";
    ss << "\\memo to all the zones in the ZoneList.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ZoneControlThermostaticNames\n";
    ss << "A2 , \\field Zone or ZoneList Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneAndZoneListNames\n";
    ss << "N1 , \\field Number of Heating Stages\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 4\n";
    ss << "\\note Enter the number of the following sets of data for heating temperature offset\n";
    ss << "A3 , \\field Heating Temperature Setpoint Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N2 , \\field Heating Throttling Temperature Range\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.1\n";
    ss << "N3 , \\field Stage 1 Heating Temperature Offset\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\maximum 0.0\n";
    ss << "\\note The heating temperature offset is used to determine heating stage number for\n";
    ss << "\\note multi stage equipment.\n";
    ss << "\\note When the temperature difference of the heating setpoint and the controlled zone\n";
    ss << "\\note temperature at previous time step is less than Stage 1 value and greater than\n";
    ss << "\\note Stage 2 value, the stage number is 1.\n";
    ss << "N4 , \\field Stage 2 Heating Temperature Offset\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\maximum 0.0\n";
    ss << "\\note The heating temperature offset is used to determine heating stage number for\n";
    ss << "\\note multi stage equipment.\n";
    ss << "\\note When the temperature difference of the heating setpoint and the controlled zone\n";
    ss << "\\note temperature at previous time step is less than Stage 2 value and greater than\n";
    ss << "\\note Stage 3 value, the stage number is 2.\n";
    ss << "\\note The value of this field has to be less the value at the previous field.\n";
    ss << "N5 , \\field Stage 3 Heating Temperature Offset\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\maximum 0.0\n";
    ss << "\\note The heating temperature offset is used to determine heating stage number for\n";
    ss << "\\note multi stage equipment.\n";
    ss << "\\note When the temperature difference of the heating setpoint and the controlled zone\n";
    ss << "\\note temperature at previous time step is less than Stage 3 value and greater than\n";
    ss << "\\note Stage 4 value, the stage number is 3.\n";
    ss << "\\note The value of this field has to be less the value at the previous field.\n";
    ss << "N6 , \\field Stage 4 Heating Temperature Offset\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\maximum 0.0\n";
    ss << "\\note The heating temperature offset is used to determine heating stage number for\n";
    ss << "\\note multi stage equipment.\n";
    ss << "\\note When the temperature difference of the heating setpoint and the controlled zone\n";
    ss << "\\note temperature at previous time step is less than Stage 4 value, the stage number is 4.\n";
    ss << "\\note The value of this field has to be less the value at the previous field.\n";
    ss << "N7 , \\field Number of Cooling Stages\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 4\n";
    ss << "\\note Enter the number of the following sets of data for cooling temperature offset\n";
    ss << "A4 , \\field Cooling Temperature Setpoint Base Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N8 , \\field Cooling Throttling Temperature Range\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.1\n";
    ss << "N9 , \\field Stage 1 Cooling Temperature Offset\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note The cooling temperature offset is used to determine cooling stage number for\n";
    ss << "\\note multi stage equipment.\n";
    ss << "\\note When the temperature difference of the cooling setpoint and the controlled zone\n";
    ss << "\\note temperature at previous time step is greater than Stage 1 value and less than\n";
    ss << "\\note Stage 2 value, the stage number is 1.\n";
    ss << "N10, \\field Stage 2 Cooling Temperature Offset\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note The cooling temperature offset is used to determine cooling stage number for\n";
    ss << "\\note multi stage equipment.\n";
    ss << "\\note When the temperature difference of the cooling setpoint and the controlled zone\n";
    ss << "\\note temperature at previous time step is greater than Stage 2 value and less than\n";
    ss << "\\note Stage 3 value, the stage number is 2.\n";
    ss << "\\note The value of this field has to be greater than the value at the previous field.\n";
    ss << "N11, \\field Stage 3 Cooling Temperature Offset\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note The cooling temperature offset is used to determine cooling stage number for\n";
    ss << "\\note multi stage equipment.\n";
    ss << "\\note When the temperature difference of the cooling setpoint and the controlled zone\n";
    ss << "\\note temperature at previous time step is greater than Stage 3 value and less than\n";
    ss << "\\note Stage 4 value, the stage number is 3.\n";
    ss << "\\note The value of this field has to be greater than the value at the previous field.\n";
    ss << "N12; \\field Stage 4 Cooling Temperature Offset\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note The cooling temperature offset is used to determine cooling stage number for\n";
    ss << "\\note multi stage equipment.\n";
    ss << "\\note When the temperature difference of the cooling setpoint and the controlled zone\n";
    ss << "\\note temperature at previous time step is greater than Stage 4 value, the stage number is 4.\n";
    ss << "\\note The value of this field has to be greater than the value at the previous field.\n";

    IddObjectType objType(IddObjectType::ZoneControl_Thermostat_StagedDualSetpoint);
    OptionalIddObject oObj = IddObject::load("ZoneControl:Thermostat:StagedDualSetpoint",
                                             "Zone HVAC Controls and Thermostats",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneControl_Thermostat_StagedDualSetpoint);
  return object;
}

IddObject createZoneControl_ContaminantControllerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneControl:ContaminantController,\n";
    ss << "\\memo Used to control a zone to a specified indoor level of CO2 or generic contaminants, or\n";
    ss << "\\memo to specify minimum CO2 concentration schedule name for a zone.\n";
    ss << "\\min-fields 4\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Controlled Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A3 , \\field Carbon Dioxide Control Availability Schedule Name\n";
    ss << "\\note Availability schedule name for CO2 controller. Schedule value > 0 means the CO2\n";
    ss << "\\note controller is enabled. If this field is blank, then CO2  controller is always enabled.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Carbon Dioxide Setpoint Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values should be carbon dioxide concentration in parts per million (ppm)\n";
    ss << "A5 , \\field Minimum Carbon Dioxide Concentration Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values should be carbon dioxide concentration in parts per\n";
    ss << "\\note million (ppm)\n";
    ss << "\\note This field is used when the field System Outdoor Air Method =\n";
    ss << "\\note ProportionalControlBasedonOccupancySchedule or ProportionalControlBasedOnDesignOccupancy\n";
    ss << "\\note in Controller:MechanicalVentilation\n";
    ss << "A6 , \\field Generic Contaminant Control Availability Schedule Name\n";
    ss << "\\note Availability schedule name for generic contaminant controller. Schedule value > 0 means\n";
    ss << "\\note the generic contaminant controller is enabled. If this field is blank, then generic\n";
    ss << "\\note contaminant controller is always enabled.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A7 ; \\field Generic Contaminant Setpoint Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values should be generic contaminant concentration in parts per\n";
    ss << "\\note million (ppm)\n";
    ss << "\\note This field is used when the field System Outdoor Air Method =\n";
    ss << "\\note IndoorAirQualityProcedureGenericContaminant in Controller:MechanicalVentilation\n";

    IddObjectType objType(IddObjectType::ZoneControl_ContaminantController);
    OptionalIddObject oObj = IddObject::load("ZoneControl:ContaminantController",
                                             "Zone HVAC Controls and Thermostats",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneControl_ContaminantController);
  return object;
}

IddObject createZoneHVAC_IdealLoadsAirSystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:IdealLoadsAirSystem,\n";
    ss << "\\memo Ideal system used to calculate loads without modeling a full HVAC system. All that is\n";
    ss << "\\memo required for the ideal system are zone controls, zone equipment configurations, and\n";
    ss << "\\memo the ideal loads system component. This component can be thought of as an ideal unit\n";
    ss << "\\memo that mixes zone air with the specified amount of outdoor air and then adds or removes\n";
    ss << "\\memo heat and moisture at 100% efficiency in order to meet the specified controls. Energy\n";
    ss << "\\memo use is reported as DistrictHeating and DistrictCooling.\n";
    ss << "\\min-fields 26\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Zone Supply Air Node Name\n";
    ss << "\\note Must match a zone air inlet node name.\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Zone Exhaust Air Node Name\n";
    ss << "\\note Should match a zone air exhaust node name.\n";
    ss << "\\note This field is optional, but is required if this\n";
    ss << "\\note this object is used with other forced air equipment.\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Maximum Heating Supply Air Temperature\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum< 100\n";
    ss << "\\default 50\n";
    ss << "N2 , \\field Minimum Cooling Supply Air Temperature\n";
    ss << "\\units C\n";
    ss << "\\minimum> -100\n";
    ss << "\\maximum< 50\n";
    ss << "\\default 13\n";
    ss << "N3 , \\field Maximum Heating Supply Air Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.0156\n";
    ss << "N4 , \\field Minimum Cooling Supply Air Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.0077\n";
    ss << "A5 , \\field Heating Limit\n";
    ss << "\\type choice\n";
    ss << "\\key NoLimit\n";
    ss << "\\key LimitFlowRate\n";
    ss << "\\key LimitCapacity\n";
    ss << "\\key LimitFlowRateAndCapacity\n";
    ss << "\\default NoLimit\n";
    ss << "N5 , \\field Maximum Heating Air Flow Rate\n";
    ss << "\\note This field is ignored if Heating Limit = NoLimit\n";
    ss << "\\note If this field is blank, there is no limit.\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N6 , \\field Maximum Sensible Heating Capacity\n";
    ss << "\\note This field is ignored if Heating Limit = NoLimit\n";
    ss << "\\note If this field is blank, there is no limit.\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "A6 , \\field Cooling Limit\n";
    ss << "\\type choice\n";
    ss << "\\key NoLimit\n";
    ss << "\\key LimitFlowRate\n";
    ss << "\\key LimitCapacity\n";
    ss << "\\key LimitFlowRateAndCapacity\n";
    ss << "\\default NoLimit\n";
    ss << "N7 , \\field Maximum Cooling Air Flow Rate\n";
    ss << "\\note This field is ignored if Cooling Limit = NoLimit\n";
    ss << "\\note This field is required if Outdoor Air Economizer Type is anything other than NoEconomizer.\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N8 , \\field Maximum Total Cooling Capacity\n";
    ss << "\\note This field is ignored if Cooling Limit = NoLimit\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "A7 , \\field Heating Availability Schedule Name\n";
    ss << "\\note If blank, heating is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A8 , \\field Cooling Availability Schedule Name\n";
    ss << "\\note If blank, cooling is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A9 , \\field Dehumidification Control Type\n";
    ss << "\\note ConstantSensibleHeatRatio means that the ideal loads system\n";
    ss << "\\note will be controlled to meet the sensible cooling load, and the\n";
    ss << "\\note latent cooling rate will be computed using a constant\n";
    ss << "\\note sensible heat ratio (SHR)\n";
    ss << "\\note Humidistat means that there is a ZoneControl:Humidistat for this\n";
    ss << "\\note zone and the ideal loads system will attempt to satisfy the humidistat.\n";
    ss << "\\note None means that there is no dehumidification.\n";
    ss << "\\note ConstantSupplyHumidityRatio means that during cooling the supply air\n";
    ss << "\\note will always be at the Minimum Cooling Supply Humidity Ratio.\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantSensibleHeatRatio\n";
    ss << "\\key Humidistat\n";
    ss << "\\key None\n";
    ss << "\\key ConstantSupplyHumidityRatio\n";
    ss << "\\default ConstantSensibleHeatRatio\n";
    ss << "N9 , \\field Cooling Sensible Heat Ratio\n";
    ss << "\\note This field is applicable only when Dehumidification Control Type is ConstantSensibleHeatRatio\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "A10, \\field Humidification Control Type\n";
    ss << "\\note None means that there is no humidification.\n";
    ss << "\\note Humidistat means that there is a ZoneControl:Humidistat for this\n";
    ss << "\\note zone and the ideal loads system will attempt to satisfy the humidistat.\n";
    ss << "\\note ConstantSupplyHumidityRatio means that during heating the supply air\n";
    ss << "\\note will always be at the Maximum Heating Supply Humidity Ratio.\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Humidistat\n";
    ss << "\\key ConstantSupplyHumidityRatio\n";
    ss << "\\default None\n";
    ss << "A11, \\field Design Specification Outdoor Air Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "\\note When the name of a DesignSpecification:OutdoorAir object is entered, the minimum\n";
    ss << "\\note outdoor air flow rate will be computed using these specifications. The outdoor air\n";
    ss << "\\note flow rate will also be affected by the next two fields.\n";
    ss << "\\note If this field is blank, there will be no outdoor air and the remaining fields will\n";
    ss << "\\note be ignored.\n";
    ss << "A12, \\field Outdoor Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note This field is required if the system provides outdoor air\n";
    ss << "\\note Enter the name of an outdoor air node. This node name is also specified in\n";
    ss << "\\note an OutdoorAir:Node or OutdoorAir:NodeList object.\n";
    ss << "A13, \\field Demand Controlled Ventilation Type\n";
    ss << "\\note This field controls how the minimum outdoor air flow rate is calculated.\n";
    ss << "\\note None means that design occupancy will be used to compute the minimum outdoor air flow rate\n";
    ss << "\\note OccupancySchedule means that current occupancy level will be used.\n";
    ss << "\\note CO2Setpoint means that the design occupancy will be used to compute the minimum outdoor air flow\n";
    ss << "\\note rate and the outdoor air flow rate may be increased if necessary to maintain the indoor air carbon\n";
    ss << "\\note dioxide setpoint defined in a ZoneControl:ContaminantController object.\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key OccupancySchedule\n";
    ss << "\\key CO2Setpoint\n";
    ss << "\\default None\n";
    ss << "A14, \\field Outdoor Air Economizer Type\n";
    ss << "\\note DifferentialDryBulb and DifferentialEnthalpy will increase the outdoor air flow rate\n";
    ss << "\\note when there is a cooling load and the outdoor air temperature or enthalpy\n";
    ss << "\\note is below the zone exhaust air temperature or enthalpy.\n";
    ss << "\\type choice\n";
    ss << "\\key NoEconomizer\n";
    ss << "\\key DifferentialDryBulb\n";
    ss << "\\key DifferentialEnthalpy\n";
    ss << "\\default NoEconomizer\n";
    ss << "A15, \\field Heat Recovery Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Sensible\n";
    ss << "\\key Enthalpy\n";
    ss << "\\default None\n";
    ss << "N10, \\field Sensible Heat Recovery Effectiveness\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.70\n";
    ss << "N11, \\field Latent Heat Recovery Effectiveness\n";
    ss << "\\note Applicable only if Heat Recovery Type is Enthalpy.\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.65\n";
    ss << "A16; \\field Design Specification ZoneHVAC Sizing Object Name\n";
    ss << "\\note Enter the name of a DesignSpecificationZoneHVACSizing object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneHVACSizingName\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_IdealLoadsAirSystem);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:IdealLoadsAirSystem",
                                             "Zone HVAC Forced Air Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_IdealLoadsAirSystem);
  return object;
}

IddObject createZoneHVAC_FourPipeFanCoilIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:FourPipeFanCoil,\n";
    ss << "\\memo Four pipe fan coil system. Forced-convection hydronic heating-cooling unit with\n";
    ss << "\\memo supply fan, hot water heating coil, chilled water cooling coil, and fixed-position\n";
    ss << "\\memo outdoor air mixer.\n";
    ss << "\\min-fields 24\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference DOAToZonalUnit\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Capacity Control Method\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantFanVariableFlow\n";
    ss << "\\key CyclingFan\n";
    ss << "\\key VariableFanVariableFlow\n";
    ss << "\\key VariableFanConstantFlow\n";
    ss << "\\key MultiSpeedFan\n";
    ss << "\\key ASHRAE90VariableFan\n";
    ss << "N1 , \\field Maximum Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "N2 , \\field Low Speed Supply Air Flow Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.33\n";
    ss << "N3 , \\field Medium Speed Supply Air Flow Ratio\n";
    ss << "\\note Medium Speed Supply Air Flow Ratio should be greater\n";
    ss << "\\note than Low Speed Supply Air Flow Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.66\n";
    ss << "N4 , \\field Maximum Outdoor Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "A4 , \\field Outdoor Air Schedule Name\n";
    ss << "\\note Value of schedule multiplies maximum outdoor air flow rate\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7,  \\field Outdoor Air Mixer Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key OutdoorAir:Mixer\n";
    ss << "\\note currently only one type OutdoorAir:Mixer object is available.\n";
    ss << "A8 , \\field Outdoor Air Mixer Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutdoorAirMixers\n";
    ss << "A9 , \\field Supply Air Fan Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "\\key Fan:VariableVolume\n";
    ss << "\\note Fan type must be according to capacity control method (see I/O)\n";
    ss << "\\note For ConstantFanVariableFlow a Fan:OnOff or Fan:ConstantVolume is valid.\n";
    ss << "\\note For CyclingFan a Fan:OnOff is valid.\n";
    ss << "\\note For VariableFanVariableFlow or VariableFanConstantFlow a Fan:VariableVolume is valid.\n";
    ss << "\\note For ASHRAE90.1 a Fan:OnOff or Fan:VariableVolume is valid.\n";
    ss << "\\note The fan's inlet node should be the same as the outdoor air mixer's mixed air node.\n";
    ss << "A10, \\field Supply Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOffandVAV\n";
    ss << "A11, \\field Cooling Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:Water\n";
    ss << "\\key Coil:Cooling:Water:DetailedGeometry\n";
    ss << "\\key CoilSystem:Cooling:Water:HeatExchangerAssisted\n";
    ss << "A12, \\field Cooling Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsWater\n";
    ss << "N5 , \\field Maximum Cold Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N6 , \\field Minimum Cold Water Flow Rate\n";
    ss << "\\default 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N7 , \\field Cooling Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "A13, \\field Heating Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "A14, \\field Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilsWater\n";
    ss << "\\object-list HeatingCoilsElectric\n";
    ss << "N8 , \\field Maximum Hot Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N9 , \\field Minimum Hot Water Flow Rate\n";
    ss << "\\default 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N10, \\field Heating Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "A15, \\field Availability Manager List Name\n";
    ss << "\\note Enter the name of an AvailabilityManagerAssignmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";
    ss << "A16, \\field Design Specification ZoneHVAC Sizing Object Name\n";
    ss << "\\note Enter the name of a DesignSpecificationZoneHVACSizing object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneHVACSizingName\n";
    ss << "A17, \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Enter the name of a schedule that controls fan operation. Schedule Name values of 0 denote\n";
    ss << "\\note cycling fan operation (fan cycles with cooling coil). Schedule values greater\n";
    ss << "\\note than 0 denote constant fan operation (fan runs continually regardless of coil operation).\n";
    ss << "\\note The fan operating mode defaults to cycling fan operation if this field is left blank.\n";
    ss << "\\note This input field is currently used with MultiStageFan capacity control method\n";
    ss << "N11, \\field Minimum Supply Air Temperature in Cooling Mode\n";
    ss << "\\note For Capacity Control Method = ASHRAE90VariableFan, enter the minimum air temperature in cooling mode.\n";
    ss << "\\note Leave this field blank or enter 0 to control to the zone load per ASHRAE 90.1. In this case, a zone sizing simulation is required.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N12; \\field Maximum Supply Air Temperature in Heating Mode\n";
    ss << "\\note For Capacity Control Method = ASHRAE90VariableFan, enter the maximum air temperature in heating mode.\n";
    ss << "\\note Leave this field blank or enter 0 to control to the zone load per ASHRAE 90.1. In this case, a zone sizing simulation is required.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_FourPipeFanCoil);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:FourPipeFanCoil",
                                             "Zone HVAC Forced Air Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_FourPipeFanCoil);
  return object;
}

IddObject createZoneHVAC_WindowAirConditionerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:WindowAirConditioner,\n";
    ss << "\\memo Window air conditioner. Forced-convection cooling-only unit with supply fan, direct\n";
    ss << "\\memo expansion (DX) cooling coil, and fixed-position outdoor air mixer.\n";
    ss << "\\min-fields 15\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Maximum Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Maximum Outdoor Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5,  \\field Outdoor Air Mixer Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key OutdoorAir:Mixer\n";
    ss << "\\note currently only one OutdoorAir:Mixer object type is available.\n";
    ss << "A6 , \\field Outdoor Air Mixer Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutdoorAirMixers\n";
    ss << "A7 , \\field Supply Air Fan Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "\\note Fan:ConstantVolume only works when continuous fan operation is used the entire\n";
    ss << "\\note simulation (all supply air fan operating mode schedule values are greater than 0).\n";
    ss << "\\note If any fan operating mode schedule values are 0 a Fan:OnOff object must be used.\n";
    ss << "A8 , \\field Supply Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\note Fan type Fan:ConstantVolume is used with continuous fan\n";
    ss << "\\note and fan type Fan:OnOff is used with cycling Fan.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOff\n";
    ss << "A9,  \\field Cooling Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:DX:SingleSpeed\n";
    ss << "\\key CoilSystem:Cooling:DX:HeatExchangerAssisted\n";
    ss << "A10, \\field DX Cooling Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsDXSingleSpeed\n";
    ss << "A11, \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Enter the name of a schedule that controls fan operation. Schedule Name values of 0 denote\n";
    ss << "\\note cycling fan operation (fan cycles with cooling coil). Schedule values greater\n";
    ss << "\\note than 0 denote constant fan operation (fan runs continually regardless of coil operation).\n";
    ss << "\\note The fan operating mode defaults to cycling fan operation if this field is left blank.\n";
    ss << "A12, \\field Fan Placement\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "N3 , \\field Cooling Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "A13, \\field Availability Manager List Name\n";
    ss << "\\note Enter the name of an AvailabilityManagerAssignmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";
    ss << "A14; \\field Design Specification ZoneHVAC Sizing Object Name\n";
    ss << "\\note Enter the name of a DesignSpecificationZoneHVACSizing object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneHVACSizingName\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_WindowAirConditioner);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:WindowAirConditioner",
                                             "Zone HVAC Forced Air Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_WindowAirConditioner);
  return object;
}

IddObject createZoneHVAC_PackagedTerminalAirConditionerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:PackagedTerminalAirConditioner,\n";
    ss << "\\memo Packaged terminal air conditioner (PTAC).  Forced-convection heating-cooling unit\n";
    ss << "\\memo with supply fan, direct expansion (DX) cooling coil, heating coil (gas, electric, hot\n";
    ss << "\\memo water, or steam) and fixed-position outdoor air mixer.\n";
    ss << "\\min-fields 18\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note Unique name for this packaged terminal air conditioner object.\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values of 0 denote the unit is off.\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Air inlet node for the PTAC must be a zone air exhaust Node.\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Air outlet node for the PTAC must be a zone air inlet node.\n";
    ss << "A5,  \\field Outdoor Air Mixer Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key OutdoorAir:Mixer\n";
    ss << "\\note currently only one OutdoorAir:Mixer object type is available.\n";
    ss << "A6 , \\field Outdoor Air Mixer Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutdoorAirMixers\n";
    ss << "\\note Needs to match the name of the PTAC outdoor air mixer object.\n";
    ss << "N1 , \\field Cooling Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to fan size.\n";
    ss << "N2 , \\field Heating Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to fan size.\n";
    ss << "N3 , \\field No Load Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to fan size.\n";
    ss << "\\note Only used when supply air fan operating mode schedule values specify continuous fan\n";
    ss << "\\note (schedule values greater than 0 specify continuous fan operation).\n";
    ss << "\\note This air flow rate is used when no heating or cooling is required and the cooling or\n";
    ss << "\\note heating coil is off. If this field is left blank or zero, the supply air flow rate\n";
    ss << "\\note from the previous on cycle (either cooling or heating) is used.\n";
    ss << "N4 , \\field Cooling Outdoor Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to supply air flow rate during cooling operation.\n";
    ss << "N5 , \\field Heating Outdoor Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to supply air flow rate during heating operation.\n";
    ss << "N6 , \\field No Load Outdoor Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\note Only used when supply air fan operating mode schedule values specify continuous fan\n";
    ss << "\\note (schedule values greater than 0 specify continuous fan operation).\n";
    ss << "\\note This air flow rate is used when no heating or cooling is required and the cooling or\n";
    ss << "\\note heating coil is off. If this field is left blank or zero, the outdoor air flow rate\n";
    ss << "\\note from the previous on cycle (either cooling or heating) is used.\n";
    ss << "A7 , \\field Supply Air Fan Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "\\note Fan:ConstantVolume only works when continuous fan operation is used the entire\n";
    ss << "\\note simulation (all supply air fan operating mode schedule values are greater than 0).\n";
    ss << "\\note If any fan operating mode schedule values are 0 a Fan:OnOff object must be used.\n";
    ss << "A8 , \\field Supply Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOff\n";
    ss << "\\note Needs to match in the fan object.\n";
    ss << "A9 , \\field Heating Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "\\note Select the type of heating coil.\n";
    ss << "A10 , \\field Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "\\note Needs to match in the heating coil object.\n";
    ss << "A11, \\field Cooling Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:DX:SingleSpeed\n";
    ss << "\\key Coil:Cooling:DX:VariableSpeed\n";
    ss << "\\key CoilSystem:Cooling:DX:HeatExchangerAssisted\n";
    ss << "\\note Select the type of Cooling Coil.\n";
    ss << "\\note Only works with Coil:Cooling:DX:SingleSpeed or\n";
    ss << "\\note CoilSystem:Cooling:DX:HeatExchangerAssisted or\n";
    ss << "\\note Coil:Cooling:DX:VariableSpeed.\n";
    ss << "A12, \\field Cooling Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsDXSingleSpeed\n";
    ss << "\\object-list CoolingCoilsDXVariableSpeed\n";
    ss << "\\note Needs to match a DX cooling coil object.\n";
    ss << "A13, \\field Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default DrawThrough\n";
    ss << "\\note Select fan placement as either blow through or draw through.\n";
    ss << "A14, \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Enter the name of a schedule that controls fan operation. Schedule Name values of 0 denote\n";
    ss << "\\note cycling fan operation (fan cycles with cooling or heating coil). Schedule Name values greater\n";
    ss << "\\note than 0 denote constant fan operation (fan runs continually regardless of coil operation).\n";
    ss << "A15, \\field Availability Manager List Name\n";
    ss << "\\note Enter the name of an AvailabilityManagerAssignmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";
    ss << "A16; \\field Design Specification ZoneHVAC Sizing Object Name\n";
    ss << "\\note Enter the name of a DesignSpecificationZoneHVACSizing object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneHVACSizingName\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_PackagedTerminalAirConditioner);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:PackagedTerminalAirConditioner",
                                             "Zone HVAC Forced Air Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_PackagedTerminalAirConditioner);
  return object;
}

IddObject createZoneHVAC_PackagedTerminalHeatPumpIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:PackagedTerminalHeatPump,\n";
    ss << "\\memo Packaged terminal heat pump (PTHP). Forced-convection heating-cooling unit with\n";
    ss << "\\memo supply fan, direct expansion (DX) cooling coil, DX heating coil (air-to-air heat\n";
    ss << "\\memo pump), supplemental heating coil (gas, electric, hot water, or steam), and\n";
    ss << "\\memo fixed-position outdoor air mixer.\n";
    ss << "\\min-fields 27\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note Unique name for this packaged terminal heat pump object.\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values of 0 denote the unit is off.\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Air inlet node for the PTHP must be a zone air exhaust node.\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Air outlet node for the PTHP must be a zone air inlet node.\n";
    ss << "A5,  \\field Outdoor Air Mixer Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key OutdoorAir:Mixer\n";
    ss << "\\note currently only one OutdoorAir:Mixer object type is available.\n";
    ss << "A6 , \\field Outdoor Air Mixer Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutdoorAirMixers\n";
    ss << "\\note Needs to match name of outdoor air mixer object.\n";
    ss << "N1 , \\field Cooling Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to fan size.\n";
    ss << "N2 , \\field Heating Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to fan size.\n";
    ss << "N3 , \\field No Load Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to fan size.\n";
    ss << "\\note Only used when heat pump fan operating mode is continuous. This air flow rate\n";
    ss << "\\note is used when no heating or cooling is required and the DX coil compressor is off.\n";
    ss << "\\note If this field is left blank or zero, the supply air flow rate from the previous on cycle\n";
    ss << "\\note (either cooling or heating) is used.\n";
    ss << "N4 , \\field Cooling Outdoor Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to supply air flow rate during cooling operation.\n";
    ss << "N5 , \\field Heating Outdoor Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to supply air flow rate during heating operation.\n";
    ss << "N6 , \\field No Load Outdoor Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\note Only used when heat pump Fan operating mode is continuous. This air flow rate\n";
    ss << "\\note is used when no heating or cooling is required and the DX coil compressor is off.\n";
    ss << "\\note If this field is left blank or zero, the outdoor air flow rate from the previous on cycle\n";
    ss << "\\note (either cooling or heating) is used.\n";
    ss << "A7 , \\field Supply Air Fan Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "\\note Fan:ConstantVolume only works with fan operating mode is continuous.\n";
    ss << "A8 , \\field Supply Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOff\n";
    ss << "\\note Needs to match a fan object.\n";
    ss << "A9 , \\field Heating Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:DX:SingleSpeed\n";
    ss << "\\key Coil:Heating:DX:VariableSpeed\n";
    ss << "\\note Only works with Coil:Heating:DX:SingleSpeed or\n";
    ss << "\\note Coil:Heating:DX:VariableSpeed.\n";
    ss << "A10 , \\field Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilsDXSingleSpeed\n";
    ss << "\\object-list HeatingCoilsDXVariableSpeed\n";
    ss << "\\note Needs to match in the DX Heating Coil object.\n";
    ss << "N7 , \\field Heating Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Defines Heating convergence tolerance as a fraction of Heating load to be met.\n";
    ss << "N8 , \\field Minimum Outdoor Dry-Bulb Temperature for Compressor Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum -20.0\n";
    ss << "\\default -8.0\n";
    ss << "\\units C\n";
    ss << "\\note Needs to match the corresponding minimum outdoor temperature defined\n";
    ss << "\\note in the DX Heating Coil object.\n";
    ss << "A11, \\field Cooling Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:DX:SingleSpeed\n";
    ss << "\\key Coil:Cooling:DX:VariableSpeed\n";
    ss << "\\key CoilSystem:Cooling:DX:HeatExchangerAssisted\n";
    ss << "\\note Only works with Coil:Cooling:DX:SingleSpeed or\n";
    ss << "\\note CoilSystem:Cooling:DX:HeatExchangerAssisted or\n";
    ss << "\\note Coil:Cooling:DX:VariableSpeed.\n";
    ss << "A12, \\field Cooling Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsDXSingleSpeed\n";
    ss << "\\object-list CoolingCoilsDXVariableSpeed\n";
    ss << "\\note Needs to match in the DX Cooling Coil object.\n";
    ss << "N9 , \\field Cooling Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Defines Cooling convergence tolerance as a fraction of the Cooling load to be met.\n";
    ss << "A13, \\field Supplemental Heating Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "\\note works with gas, electric, hot water and steam heating coil.\n";
    ss << "A14, \\field Supplemental Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "\\note Needs to match in the supplemental heating coil object.\n";
    ss << "N10, \\field Maximum Supply Air Temperature from Supplemental Heater\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "\\note Supply air temperature from the supplemental heater will not exceed this value.\n";
    ss << "N11, \\field Maximum Outdoor Dry-Bulb Temperature for Supplemental Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\maximum 21.0\n";
    ss << "\\default 21.0\n";
    ss << "\\units C\n";
    ss << "\\note Supplemental heater will not operate when outdoor temperature exceeds this value.\n";
    ss << "A15, \\field Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default DrawThrough\n";
    ss << "\\note Select fan placement as either blow through or draw through.\n";
    ss << "A16, \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Enter the name of a schedule that controls fan operation. Schedule values of 0 denote\n";
    ss << "\\note cycling fan operation (fan cycles with cooling or heating coil). Schedule Name values greater\n";
    ss << "\\note than 0 denote constant fan operation (fan runs continually regardless of coil operation).\n";
    ss << "\\note The fan operating mode defaults to cycling fan operation if this field is left blank.\n";
    ss << "A17, \\field Availability Manager List Name\n";
    ss << "\\note Enter the name of an AvailabilityManagerAssignmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";
    ss << "A18; \\field Design Specification ZoneHVAC Sizing Object Name\n";
    ss << "\\note Enter the name of a DesignSpecificationZoneHVACSizing object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneHVACSizingName\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_PackagedTerminalHeatPump);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:PackagedTerminalHeatPump",
                                             "Zone HVAC Forced Air Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_PackagedTerminalHeatPump);
  return object;
}

IddObject createZoneHVAC_WaterToAirHeatPumpIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:WaterToAirHeatPump,\n";
    ss << "\\memo Water-to-air heat pump. Forced-convection heating-cooling unit with supply fan,\n";
    ss << "\\memo water-to-air cooling and heating coils, supplemental heating coil (gas, electric, hot\n";
    ss << "\\memo water, or steam), and fixed-position outdoor air mixer.\n";
    ss << "\\min-fields 25\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference DOAToZonalUnit\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3,  \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5,  \\field Outdoor Air Mixer Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key OutdoorAir:Mixer\n";
    ss << "\\note currently only one OutdoorAir:Mixer object type is available.\n";
    ss << "A6,  \\field Outdoor Air Mixer Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutdoorAirMixers\n";
    ss << "\\note This optional field specifies the name of the outdoor air mixer object.\n";
    ss << "\\note When used, this name needs to match name of outdoor air mixer object.\n";
    ss << "N1 , \\field Cooling Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to fan size.\n";
    ss << "N2 , \\field Heating Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to fan size.\n";
    ss << "N3 , \\field No Load Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to fan size.\n";
    ss << "\\note Only used when heat pump fan operating mode is continuous. This air flow rate\n";
    ss << "\\note is used when no heating or cooling is required and the DX coil compressor is off.\n";
    ss << "\\note If this field is left blank or zero, the supply air flow rate from the previous on cycle\n";
    ss << "\\note (either cooling or heating) is used.\n";
    ss << "N4 , \\field Cooling Outdoor Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to supply air flow rate during cooling operation.\n";
    ss << "N5 , \\field Heating Outdoor Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to supply air flow rate during heating operation.\n";
    ss << "N6 , \\field No Load Outdoor Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\note Only used when heat pump Fan operating mode is continuous. This air flow rate\n";
    ss << "\\note is used when no heating or cooling is required and the DX coil compressor is off.\n";
    ss << "\\note If this field is left blank or zero, the outdoor air flow rate from the previous on cycle\n";
    ss << "\\note (either cooling or heating) is used.\n";
    ss << "A7,  \\field Supply Air Fan Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\note  Only works with On/Off Fan\n";
    ss << "A8,  \\field Supply Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansOnOff\n";
    ss << "\\note Needs to match Fan:OnOff object\n";
    ss << "A9,  \\field Heating Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:WaterToAirHeatPump:EquationFit\n";
    ss << "\\key Coil:Heating:WaterToAirHeatPump:VariableSpeedEquationFit\n";
    ss << "A10, \\field Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilsWaterToAirHP\n";
    ss << "\\object-list HeatingCoilsWaterToAirVSHP\n";
    ss << "\\note  Needs to match in the water-to-air heat pump heating coil object\n";
    ss << "A11, \\field Cooling Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:WaterToAirHeatPump:EquationFit\n";
    ss << "\\key Coil:Cooling:WaterToAirHeatPump:VariableSpeedEquationFit\n";
    ss << "A12, \\field Cooling Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsWaterToAirHP\n";
    ss << "\\object-list CoolingCoilsWaterToAirVSHP\n";
    ss << "\\note Needs to match in the water-to-air heat pump cooling coil object\n";
    ss << "N7,  \\field Maximum Cycling Rate\n";
    ss << "\\type real\n";
    ss << "\\units cycles/hr\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 5.0\n";
    ss << "\\default 2.5\n";
    ss << "\\note The maximum on-off cycling rate for the compressor\n";
    ss << "\\note Suggested value is 2.5 for a typical heat pump\n";
    ss << "N8,  \\field Heat Pump Time Constant\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 500.0\n";
    ss << "\\default 60.0\n";
    ss << "\\note Time constant for the cooling coil's capacity to reach steady state after startup\n";
    ss << "\\note Suggested value is 60 for a typical heat pump\n";
    ss << "N9,  \\field Fraction of On-Cycle Power Use\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.05\n";
    ss << "\\default 0.01\n";
    ss << "\\note The fraction of on-cycle power use to adjust the part load fraction based on\n";
    ss << "\\note the off-cycle power consumption due to crankcase heaters, controls, fans, and etc.\n";
    ss << "\\note Suggested value is 0.01 for a typical heat pump\n";
    ss << "N10, \\field Heat Pump Fan Delay Time\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 60\n";
    ss << "\\note Programmed time delay for heat pump fan to shut off after compressor cycle off.\n";
    ss << "\\note Only required when fan operating mode is cycling\n";
    ss << "\\note Enter 0 when fan operating mode is continuous\n";
    ss << "A13, \\field Supplemental Heating Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "\\note works with gas, electric, hot water and steam heating coils\n";
    ss << "A14, \\field Supplemental Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "\\note  Needs to match in the supplemental heating coil object\n";
    ss << "N11, \\field Maximum Supply Air Temperature from Supplemental Heater\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "N12, \\field Maximum Outdoor Dry-Bulb Temperature for Supplemental Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\maximum 21.0\n";
    ss << "\\default 21.0\n";
    ss << "\\units C\n";
    ss << "A15, \\field Outdoor Dry-Bulb Temperature Sensor Node Name\n";
    ss << "\\type node\n";
    ss << "A16, \\field Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default BlowThrough\n";
    ss << "A17, \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Enter the name of a schedule that controls fan operation. Schedule values of 0 denote\n";
    ss << "\\note cycling fan operation (fan cycles with cooling or heating coil). Schedule values greater\n";
    ss << "\\note than 0 denote constant fan operation (fan runs continually regardless of coil operation).\n";
    ss << "\\note The fan operating mode defaults to cycling fan operation if this field is left blank.\n";
    ss << "A18, \\field Availability Manager List Name\n";
    ss << "\\note Enter the name of an AvailabilityManagerAssignmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";
    ss << "A19, \\field Heat Pump Coil Water Flow Mode\n";
    ss << "\\type choice\n";
    ss << "\\key Constant\n";
    ss << "\\key Cycling\n";
    ss << "\\key ConstantOnDemand\n";
    ss << "\\default Cycling\n";
    ss << "\\note used only when the heat pump coils are of the type WaterToAirHeatPump:EquationFit\n";
    ss << "\\note Constant results in 100% water flow regardless of compressor PLR\n";
    ss << "\\note Cycling results in water flow that matches compressor PLR\n";
    ss << "\\note ConstantOnDemand results in 100% water flow whenever the coil is on, but is 0% whenever the coil has no load\n";
    ss << "A20; \\field Design Specification ZoneHVAC Sizing Object Name\n";
    ss << "\\note Enter the name of a DesignSpecificationZoneHVACSizing object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneHVACSizingName\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_WaterToAirHeatPump);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:WaterToAirHeatPump",
                                             "Zone HVAC Forced Air Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_WaterToAirHeatPump);
  return object;
}

IddObject createZoneHVAC_Dehumidifier_DXIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:Dehumidifier:DX,\n";
    ss << "\\memo This object calculates the performance of zone (room) air dehumidifiers.\n";
    ss << "\\memo Meant to model conventional direct expansion (DX) cooling-based room air\n";
    ss << "\\memo dehumidifiers (reject 100% of condenser heat to the zone air), but this\n";
    ss << "\\memo object might be able to be used to model other room air dehumidifier types.\n";
    ss << "\\min-fields 13\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note Unique name for this direct expansion (DX) zone dehumidifier object.\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values of 0 denote the unit is off.\n";
    ss << "\\note Schedule values >0.0 (usually 1.0) indicate that the dehumidifier is available to operate.\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Air inlet node for the dehumidifier must be a zone air exhaust node.\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Air outlet node for the dehumidifier must be a zone air inlet node.\n";
    ss << "N1,  \\field Rated Water Removal\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units L/day\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Rating point: air entering dehumidifier at 26.7 C (80 F) dry-bulb and 60% relative humidity.\n";
    ss << "N2,  \\field Rated Energy Factor\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units L/kWh\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Rating point: air entering dehumidifier at 26.7 C (80 F) dry-bulb and 60% relative humidity.\n";
    ss << "N3,  \\field Rated Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "A5,  \\field Water Removal Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Name of a curve that describes the water removal rate (normalized to rated conditions)\n";
    ss << "\\note as a function of the dry-bulb temperature and relative humidity of the air\n";
    ss << "\\note entering the dehumidifier.\n";
    ss << "\\note Curve output = (actual water removal/rated water removal) = a + b*T + c*T**2 + d*RH +\n";
    ss << "\\note                                                             e*RH**2 + f*T*RH\n";
    ss << "\\note T = inlet air dry-bulb temperature (C)\n";
    ss << "\\note RH = inlet air RH (%)\n";
    ss << "A6,  \\field Energy Factor Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Name of a curve that describes the energy factor (normalized to rated conditions)\n";
    ss << "\\note as a function of the dry-bulb temperature and relative humidity of the air\n";
    ss << "\\note entering the dehumidifier.\n";
    ss << "\\note Curve output = (actual energy factor/rated energy factor) = a + b*T + c*T**2 + d*RH +\n";
    ss << "\\note                                                             e*RH**2 + f*T*RH\n";
    ss << "\\note T = inlet air dry-bulb temperature (C)\n";
    ss << "\\note RH = inlet air RH (%)\n";
    ss << "A7,  \\field Part Load Fraction Correlation Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Name of a curve that describes the part load fraction (PLF) of the system as\n";
    ss << "\\note a function of the part load ratio. Used to calculate dehumidifier run time fraction\n";
    ss << "\\note and electric power.\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLR = part load ratio (dehumidification load/steady state water removal capacity)\n";
    ss << "N4,  \\field Minimum Dry-Bulb Temperature for Dehumidifier Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 10.0\n";
    ss << "\\note Dehumidifier shut off if inlet air (zone) temperature is below this value.\n";
    ss << "\\note This value must be less than the Maximum Dry-Bulb Temperature for Dehumidifier Operation.\n";
    ss << "N5,  \\field Maximum Dry-Bulb Temperature for Dehumidifier Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 35.0\n";
    ss << "\\note Dehumidifier shut off if inlet air (zone) temperature is above this value.\n";
    ss << "\\note This value must be greater than the Minimum Dry-Bulb Temperature for Dehumidifier Operation.\n";
    ss << "N6,  \\field Off-Cycle Parasitic Electric Load\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Parasitic electric power consumed when the dehumidifier is available to operate, but\n";
    ss << "\\note does not operate (i.e., no high humidity load to be met).\n";
    ss << "\\note Off cycle parasitic power is 0 when the availability schedule is 0.\n";
    ss << "\\note This electric load is considered as a heat gain to the zone air.\n";
    ss << "A8;  \\field Condensate Collection Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "\\note Name of storage tank used to collect water removed by the dehumidifier.\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_Dehumidifier_DX);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:Dehumidifier:DX",
                                             "Zone HVAC Forced Air Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_Dehumidifier_DX);
  return object;
}

IddObject createZoneHVAC_EnergyRecoveryVentilatorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:EnergyRecoveryVentilator,\n";
    ss << "\\memo This compound component models a stand-alone energy recovery ventilator (ERV)\n";
    ss << "\\memo that conditions outdoor ventilation air and supplies that air directly to a zone.\n";
    ss << "\\memo The ERV unit is modeled as a collection of components: air-to-air heat exchanger,\n";
    ss << "\\memo supply air fan, exhaust air fan and an optional controller to avoid overheating\n";
    ss << "\\memo of the supply air (economizer or free cooling operation).\n";
    ss << "\\min-fields 7\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 ,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 ,  \\field Heat Exchanger Name\n";
    ss << "\\required-field\n";
    ss << "\\note Heat exchanger type must be HeatExchanger:AirToAir:SensibleAndLatent\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HXAirToAirSensibleAndLatentNames\n";
    ss << "N1 ,  \\field Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\note This flow rate must match the supply fan's air flow rate.\n";
    ss << "N2 ,  \\field Exhaust Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\note This flow rate must match the supply fan air flow rate.\n";
    ss << "A4 ,  \\field Supply Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\note Fan type must be Fan:OnOff\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansOnOff\n";
    ss << "A5 ,  \\field Exhaust Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\note Fan type must be Fan:OnOff\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansOnOff\n";
    ss << "A6 ,  \\field Controller Name\n";
    ss << "\\note Enter the name of a ZoneHVAC:EnergyRecoveryVentilator:Controller object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ControllerStandAloneEnergyRecoveryVentilator\n";
    ss << "N3 ,  \\field Ventilation Rate per Unit Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note 0.000508 m3/s-m2 corresponds to 0.1 ft3/min-ft2\n";
    ss << "\\note Used only when supply and exhaust air flow rates are autosized.\n";
    ss << "N4 ,  \\field Ventilation Rate per Occupant\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-person\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note 0.00236 m3/s-person corresponds to 5 ft3/min-person\n";
    ss << "\\note Used only when supply and exhaust air flow rates are autosized.\n";
    ss << "A7;   \\field Availability Manager List Name\n";
    ss << "\\note Enter the name of an AvailabilityManagerAssignmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_EnergyRecoveryVentilator);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:EnergyRecoveryVentilator",
                                             "Zone HVAC Forced Air Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_EnergyRecoveryVentilator);
  return object;
}

IddObject createZoneHVAC_EnergyRecoveryVentilator_ControllerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:EnergyRecoveryVentilator:Controller,\n";
    ss << "\\memo This controller is used exclusively by the ZoneHVAC:EnergyRecoveryVentilator object\n";
    ss << "\\memo to allow economizer (free cooling) operation when possible.\n";
    ss << "\\min-fields 3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ControllerStandAloneEnergyRecoveryVentilator\n";
    ss << "N1 , \\field Temperature High Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the maximum outdoor dry-bulb temperature limit for economizer operation.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "N2 , \\field Temperature Low Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the minimum outdoor dry-bulb temperature limit for economizer operation.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "N3 , \\field Enthalpy High Limit\n";
    ss << "\\type real\n";
    ss << "\\units J/kg\n";
    ss << "\\note Enter the maximum outdoor enthalpy limit for economizer operation.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "N4 , \\field Dewpoint Temperature Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the maximum outdoor dew point temperature limit for economizer operation.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "A2 , \\field Electronic Enthalpy Limit Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Enter the name of a quadratic or cubic curve which defines the maximum outdoor\n";
    ss << "\\note humidity ratio (function of outdoor dry-bulb temperature) for economizer operation.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "A3 , \\field Exhaust Air Temperature Limit\n";
    ss << "\\type choice\n";
    ss << "\\key ExhaustAirTemperatureLimit\n";
    ss << "\\key NoExhaustAirTemperatureLimit\n";
    ss << "\\default NoExhaustAirTemperatureLimit\n";
    ss << "A4 , \\field Exhaust Air Enthalpy Limit\n";
    ss << "\\type choice\n";
    ss << "\\key ExhaustAirEnthalpyLimit\n";
    ss << "\\key NoExhaustAirEnthalpyLimit\n";
    ss << "\\default NoExhaustAirEnthalpyLimit\n";
    ss << "A5 , \\field Time of Day Economizer Flow Control Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values greater than 0 indicate economizer operation is active. This\n";
    ss << "\\note schedule may be used with or without the High Humidity Control option.\n";
    ss << "\\note When used together, high humidity control has priority over economizer control.\n";
    ss << "A6 , \\field High Humidity Control Flag\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note Select Yes to modify air flow rates based on a zone humidistat.\n";
    ss << "\\note Select No to disable this feature.\n";
    ss << "A7 , \\field Humidistat Control Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note Enter the name of the zone where the humidistat is located.\n";
    ss << "N5 , \\field High Humidity Outdoor Air Flow Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Enter the ratio of supply (outdoor) air to the maximum supply air flow rate when modified\n";
    ss << "\\note air flow rates are active based on high indoor humidity.\n";
    ss << "A8 ; \\field Control High Indoor Humidity Based on Outdoor Humidity Ratio\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "\\note If NO is selected, the air flow rate is modified any time indoor relative\n";
    ss << "\\note humidity is above humidistat setpoint. If YES is selected, outdoor air flow\n";
    ss << "\\note rate is modified any time indoor relative humidity is above the humidistat\n";
    ss << "\\note setpoint AND the outdoor humidity ratio is less than the indoor humidity ratio.\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_EnergyRecoveryVentilator_Controller);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:EnergyRecoveryVentilator:Controller",
                                             "Zone HVAC Forced Air Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_EnergyRecoveryVentilator_Controller);
  return object;
}

IddObject createZoneHVAC_UnitVentilatorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:UnitVentilator,\n";
    ss << "\\memo Unit ventilator. Forced-convection ventilation unit with supply fan (constant-volume\n";
    ss << "\\memo or variable-volume), optional chilled water cooling coil, optional heating coil\n";
    ss << "\\memo (gas, electric, hot water, or steam) and controllable outdoor air mixer.\n";
    ss << "\\min-fields 16\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Maximum Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "A3 , \\field Outdoor Air Control Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key FixedAmount\n";
    ss << "\\key VariablePercent\n";
    ss << "\\key FixedTemperature\n";
    ss << "N2 , \\field Minimum Outdoor Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.0\n";
    ss << "A4 , \\field Minimum Outdoor Air Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note schedule values multiply the minimum outdoor air flow rate\n";
    ss << "N3 , \\field Maximum Outdoor Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "A5 , \\field Maximum Outdoor Air Fraction or Temperature Schedule Name\n";
    ss << "\\note that this depends on the control type as to whether it is a fraction or temperature\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A8,  \\field Outdoor Air Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A9,  \\field Exhaust Air Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A10, \\field Mixed Air Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note inlet to coils\n";
    ss << "A11, \\field Supply Air Fan Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "\\key Fan:VariableVolume\n";
    ss << "\\note Allowable fan types are Fan:ConstantVolume, Fan:OnOff and\n";
    ss << "\\note Fan:VariableVolume\n";
    ss << "A12, \\field Supply Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandVAV\n";
    ss << "A13, \\field Coil Option\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Heating\n";
    ss << "\\key Cooling\n";
    ss << "\\key HeatingAndCooling\n";
    ss << "A14, \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Enter the name of a schedule that controls fan operation. Schedule\n";
    ss << "\\note name values of 0 denote cycling fan operation (fan cycles with\n";
    ss << "\\note cooling/heating coil). Schedule values greater than 0 denote\n";
    ss << "\\note constant fan operation (fan runs continually regardless of coil\n";
    ss << "\\note operation). The fan operating mode defaults to cycling fan operation\n";
    ss << "\\note if this input field is left blank.\n";
    ss << "A15, \\field Heating Coil Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "A16, \\field Heating Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N4 , \\field Heating Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "A17, \\field Cooling Coil Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:Water\n";
    ss << "\\key Coil:Cooling:Water:DetailedGeometry\n";
    ss << "\\key CoilSystem:Cooling:Water:HeatExchangerAssisted\n";
    ss << "A18, \\field Cooling Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsWater\n";
    ss << "N5 , \\field Cooling Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "A19, \\field Availability Manager List Name\n";
    ss << "\\note Enter the name of an AvailabilityManagerAssignmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";
    ss << "A20; \\field Design Specification ZoneHVAC Sizing Object Name\n";
    ss << "\\note Enter the name of a DesignSpecificationZoneHVACSizing object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneHVACSizingName\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_UnitVentilator);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:UnitVentilator",
                                             "Zone HVAC Forced Air Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_UnitVentilator);
  return object;
}

IddObject createZoneHVAC_UnitHeaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:UnitHeater,\n";
    ss << "\\memo Unit heater. Forced-convection heating-only unit with supply fan, heating coil\n";
    ss << "\\memo (gas, electric, hot water, or steam) and fixed-position outdoor air mixer.\n";
    ss << "\\min-fields 11\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Supply Air Fan Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "\\key Fan:VariableVolume\n";
    ss << "\\note Allowable fan types are Fan:ConstantVolume, Fan:OnOff and\n";
    ss << "\\note Fan:VariableVolume\n";
    ss << "A6 , \\field Supply Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandVAV\n";
    ss << "N1 , \\field Maximum Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "A7 , \\field Heating Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "A8 , \\field Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "A9 , \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Enter the name of a schedule that controls fan operation. Schedule\n";
    ss << "\\note name values of 0 denote cycling fan operation (fan cycles with the\n";
    ss << "\\note heating coil). Schedule values greater than 0 denote constant fan\n";
    ss << "\\note operation (fan runs continually regardless of coil operation).\n";
    ss << "\\note The fan operating mode defaults to cycling fan operation if this\n";
    ss << "\\note input field is left blank.\n";
    ss << "A10, \\field Supply Air Fan Operation During No Heating\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\note This choice field allows the user to define how the unit heater will operate\n";
    ss << "\\note under no heating load or cooling conditions. If the No is selected, then\n";
    ss << "\\note the fan will not run unless there is a heating load. If the fan does not run,\n";
    ss << "\\note this effectively shuts the unit heater system off when there is no heating load.\n";
    ss << "\\note If the Yes is selected, the unit heater is available and has a ConstantVolume\n";
    ss << "\\note fan, or has an OnOff fan with Supply Air Fan Operating Mode Schedule value\n";
    ss << "\\note greater than zero, then the fan will always run regardless of the zone load.\n";
    ss << "N2 , \\field Maximum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when heating coil is gas or electric\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N3 , \\field Minimum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when heating coil is gas or electric\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N4 , \\field Heating Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "A11, \\field Availability Manager List Name\n";
    ss << "\\note Enter the name of an AvailabilityManagerAssignmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";
    ss << "A12; \\field Design Specification ZoneHVAC Sizing Object Name\n";
    ss << "\\note Enter the name of a DesignSpecificationZoneHVACSizing object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneHVACSizingName\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_UnitHeater);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:UnitHeater",
                                             "Zone HVAC Forced Air Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_UnitHeater);
  return object;
}

IddObject createZoneHVAC_EvaporativeCoolerUnitIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:EvaporativeCoolerUnit,\n";
    ss << "\\memo Zone evaporative cooler. Forced-convection cooling-only unit with supply fan,\n";
    ss << "\\memo 100% outdoor air supply.  Optional relief exhaust node\n";
    ss << "\\min-fields 15\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3,  \\field Availability Manager List Name\n";
    ss << "\\note Enter the name of an AvailabilityManagerAssignmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";
    ss << "A4 , \\field Outdoor Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note this is an outdoor air node\n";
    ss << "A5 , \\field Cooler Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note this is a zone inlet node\n";
    ss << "A6 , \\field Zone Relief Air Node Name\n";
    ss << "\\type node\n";
    ss << "\\note this is a zone exhaust node, optional if flow is being balanced elsewhere\n";
    ss << "A7 , \\field Supply Air Fan Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\key Fan:VariableVolume\n";
    ss << "\\key Fan:ComponentModel\n";
    ss << "A8 , \\field Supply Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Fans\n";
    ss << "N1 , \\field Design Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "A9 , \\field Fan Placement\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "A10, \\field Cooler Unit Control Method\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key ZoneTemperatureDeadbandOnOffCycling\n";
    ss << "\\key ZoneCoolingLoadOnOffCycling\n";
    ss << "\\key ZoneCoolingLoadVariableSpeedFan\n";
    ss << "N2 , \\field Throttling Range Temperature Difference\n";
    ss << "\\note used for ZoneTemperatureDeadbandOnOffCycling hystersis range for thermostatic control\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3 , \\field Cooling Load Control Threshold Heat Transfer Rate\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\default 100.0\n";
    ss << "\\note Sign convention is that positive values indicate a cooling load\n";
    ss << "\\minimum> 0.0\n";
    ss << "A11, \\field First Evaporative Cooler Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key EvaporativeCooler:Direct:CelDekPad\n";
    ss << "\\key EvaporativeCooler:Direct:ResearchSpecial\n";
    ss << "\\key EvaporativeCooler:Indirect:CelDekPad\n";
    ss << "\\key EvaporativeCooler:Indirect:WetCoil\n";
    ss << "\\key EvaporativeCooler:Indirect:ResearchSpecial\n";
    ss << "A12, \\field First Evaporative Cooler Object Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list EvapCoolerNames\n";
    ss << "A13, \\field Second Evaporative Cooler Object Type\n";
    ss << "\\note optional, used for direct/indirect configurations\n";
    ss << "\\note second cooler must be immediately downstream of first cooler, if present\n";
    ss << "\\type choice\n";
    ss << "\\key EvaporativeCooler:Direct:CelDekPad\n";
    ss << "\\key EvaporativeCooler:Direct:ResearchSpecial\n";
    ss << "\\key EvaporativeCooler:Indirect:CelDekPad\n";
    ss << "\\key EvaporativeCooler:Indirect:WetCoil\n";
    ss << "\\key EvaporativeCooler:Indirect:ResearchSpecial\n";
    ss << "A14, \\field Second Evaporative Cooler Name\n";
    ss << "\\note optional, used for direct/indirect configurations\n";
    ss << "\\type object-list\n";
    ss << "\\object-list EvapCoolerNames\n";
    ss << "A15; \\field Design Specification ZoneHVAC Sizing Object Name\n";
    ss << "\\note Enter the name of a DesignSpecificationZoneHVACSizing object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneHVACSizingName\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_EvaporativeCoolerUnit);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:EvaporativeCoolerUnit",
                                             "Zone HVAC Forced Air Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_EvaporativeCoolerUnit);
  return object;
}

IddObject createZoneHVAC_OutdoorAirUnitIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:OutdoorAirUnit,\n";
    ss << "\\memo The zone outdoor air unit models a single-zone dedicated outdoor air system (DOAS).\n";
    ss << "\\memo Forced-convection 100% outdoor air unit with supply fan and optional equipment\n";
    ss << "\\memo including exhaust fan, heating coil, cooling coil, and heat recovery.\n";
    ss << "\\min-fields 18\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note (name of zone system is serving)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1, \\field Outdoor Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "A4, \\field Outdoor Air Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5, \\field Supply Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\note Allowable fan types are Fan:ConstantVolume and\n";
    ss << "\\note Fan:VariableVolume\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandVAV\n";
    ss << "A6, \\field Supply Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default DrawThrough\n";
    ss << "A7, \\field Exhaust Fan Name\n";
    ss << "\\note Allowable fan types are Fan:ConstantVolume and\n";
    ss << "\\note Fan:VariableVolume\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandVAV\n";
    ss << "N2, \\field Exhaust Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "A8, \\field Exhaust Air Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A9, \\field Unit Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key NeutralControl\n";
    ss << "\\key TemperatureControl\n";
    ss << "\\default NeutralControl\n";
    ss << "A10, \\field High Air Control Temperature Schedule Name\n";
    ss << "\\note Air and control temperatures for cooling. If outdoor air temperature\n";
    ss << "\\note is above the high air control temperature, then the zone inlet air temperature\n";
    ss << "\\note is set to the high air control temperature. If the outdoor air is between high and low\n";
    ss << "\\note air control temperature, then there is no cooling/heating requirements.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A11, \\field Low Air Control Temperature Schedule Name\n";
    ss << "\\note Air and control temperatures for Heating. If outdoor air temperature\n";
    ss << "\\note is below the low air control temperature, then the zone inlet air temperature\n";
    ss << "\\note is set to the low air control temperature. If the outdoor air is between high and low\n";
    ss << "\\note air control temperature, then there is no cooling/heating requirements.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A12, \\field Outdoor Air Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A13, \\field AirOutlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A14, \\field AirInlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note air leaves zone\n";
    ss << "A15, \\field Supply FanOutlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A16, \\field Outdoor Air Unit List Name\n";
    ss << "\\note Enter the name of an ZoneHVAC:OutdoorAirUnit:EquipmentList object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutdoorAirUnitEquipmentLists\n";
    ss << "A17; \\field Availability Manager List Name\n";
    ss << "\\note Enter the name of an AvailabilityManagerAssignmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_OutdoorAirUnit);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:OutdoorAirUnit",
                                             "Zone HVAC Forced Air Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_OutdoorAirUnit);
  return object;
}

IddObject createZoneHVAC_OutdoorAirUnit_EquipmentListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:OutdoorAirUnit:EquipmentList,\n";
    ss << "\\memo Equipment list for components in a ZoneHVAC:OutdoorAirUnit. Components are simulated\n";
    ss << "\\memo sequentially in the order given in the equipment list.\n";
    ss << "\\extensible:2\n";
    ss << "\\max-fields 17\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference OutdoorAirUnitEquipmentLists\n";
    ss << "A2 , \\field Component 1 Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Cooling:Water\n";
    ss << "\\key Coil:Cooling:Water:DetailedGeometry\n";
    ss << "\\key CoilSystem:Cooling:Water:HeatexchangerAssisted\n";
    ss << "\\key CoilSystem:Cooling:DX\n";
    ss << "\\key CoilSystem:Heating:DX\n";
    ss << "\\key HeatExchanger:AirToAir:FlatPlate\n";
    ss << "\\key HeatExchanger:AirToAir:SensibleAndLatent\n";
    ss << "\\key Dehumidifier:Desiccant:NoFans\n";
    ss << "\\begin-extensible\n";
    ss << "A3 ; \\field Component 1 Name\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_OutdoorAirUnit_EquipmentList);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:OutdoorAirUnit:EquipmentList",
                                             "Zone HVAC Forced Air Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_OutdoorAirUnit_EquipmentList);
  return object;
}

IddObject createZoneHVAC_TerminalUnit_VariableRefrigerantFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:TerminalUnit:VariableRefrigerantFlow,\n";
    ss << "\\memo Zone terminal unit with variable refrigerant flow (VRF) DX cooling and heating coils\n";
    ss << "\\memo (air-to-air heat pump). The VRF terminal units are served by an\n";
    ss << "\\memo AirConditioner:VariableRefrigerantFlow system.\n";
    ss << "\\min-fields 19\n";
    ss << "A1 ,  \\field Zone Terminal Unit Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ZoneTerminalUnitNames\n";
    ss << "A2 ,  \\field Terminal Unit Availability Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note The unit is available the entire simulation if this field is left blank\n";
    ss << "\\note Schedule values of 0 denote the unit is off.\n";
    ss << "A3 ,  \\field Terminal Unit Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note the inlet node to the terminal unit\n";
    ss << "A4 ,  \\field Terminal Unit Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note the outlet node of the terminal unit\n";
    ss << "N1 ,  \\field Cooling Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 ,  \\field No Cooling Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N3 ,  \\field Heating Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N4 ,  \\field No Heating Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N5 ,  \\field Cooling Outdoor Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N6 ,  \\field Heating Outdoor Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N7 ,  \\field No Load Outdoor Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "A5 ,  \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6 ,  \\field Supply Air Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\Default BlowThrough\n";
    ss << "\\note Select fan placement as either blow through or draw through.\n";
    ss << "A7 ,  \\field Supply Air Fan Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "\\key Fan:VariableVolume\n";
    ss << "\\note Supply Air Fan Object Type must be\n";
    ss << "\\note Fan:OnOff or Fan:ConstantVolume\n";
    ss << "\\note if AirConditioner:VariableRefrigerantFlow\n";
    ss << "\\note is used to model VRF outdoor unit\n";
    ss << "\\note Supply Air Fan Object Type must be Fan:VariableVolume if\n";
    ss << "\\note AirConditioner:VariableRefrigerantFlow:FluidTemperatureControl\n";
    ss << "\\note is used to model VRF outdoor unit\n";
    ss << "\\default Fan:ConstantVolume\n";
    ss << "A8 ,  \\field Supply Air Fan Object Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOffandVAV\n";
    ss << "A9 ,  \\field Outside Air Mixer Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key OutdoorAir:Mixer\n";
    ss << "\\note If this field is blank, and outside air mixer is not used.\n";
    ss << "A10,  \\field Outside Air Mixer Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutdoorAirMixers\n";
    ss << "\\note If this field is blank, and outside air mixer is not used.\n";
    ss << "A11,  \\field Cooling Coil Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:DX:VariableRefrigerantFlow\n";
    ss << "\\key Coil:Cooling:DX:VariableRefrigerantFlow:FluidTemperatureControl\n";
    ss << "\\note Cooling Coil Type must be Coil:Cooling:DX:VariableRefrigerantFlow\n";
    ss << "\\note if AirConditioner:VariableRefrigerantFlow is used\n";
    ss << "\\note to model VRF outdoor unit\n";
    ss << "\\note Cooling Coil Type must be\n";
    ss << "\\note Coil:Cooling:DX:VariableRefrigerantFlow:FluidTemperatureControl\n";
    ss << "\\note if AirConditioner:VariableRefrigerantFlow:FluidTemperatureControl\n";
    ss << "\\note is used to model VRF outdoor unit\n";
    ss << "\\note This field may be left blank if heating-only mode is used\n";
    ss << "A12,  \\field Cooling Coil Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsDXVarRefrigFlow\n";
    ss << "\\object-list CoolingCoilsDXVarRefrigFlowFluidTemperatureControl\n";
    ss << "\\note Cooling Coil Type must be Coil:Cooling:DX:VariableRefrigerantFlow\n";
    ss << "\\note This field may be left blank if heating-only mode is used\n";
    ss << "A13,  \\field Heating Coil Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:DX:VariableRefrigerantFlow\n";
    ss << "\\key Coil:Heating:DX:VariableRefrigerantFlow:FluidTemperatureControl\n";
    ss << "\\note Heating Coil Type must be Coil:Heating:DX:VariableRefrigerantFlow\n";
    ss << "\\note if AirConditioner:VariableRefrigerantFlow is used\n";
    ss << "\\note to model VRF outdoor unit\n";
    ss << "\\note Heating Coil Type must be\n";
    ss << "\\note Coil:Heating:DX:VariableRefrigerantFlow:FluidTemperatureControl\n";
    ss << "\\note if AirConditioner:VariableRefrigerantFlow:FluidTemperatureControl\n";
    ss << "\\note is used to model VRF outdoor unit\n";
    ss << "\\note This field may be left blank if cooling-only mode is used\n";
    ss << "A14,  \\field Heating Coil Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilsDXVarRefrigFlow\n";
    ss << "\\object-list HeatingCoilsDXVarRefrigFlowFluidTemperatureControl\n";
    ss << "\\note Heating Coil Type must be Coil:Heating:DX:VariableRefrigerantFlow\n";
    ss << "\\note This field may be left blank if cooling-only mode is used\n";
    ss << "N8 ,  \\field Zone Terminal Unit On Parasitic Electric Energy Use\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N9 ,  \\field Zone Terminal Unit Off Parasitic Electric Energy Use\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N10, \\field Rated Total Heating Capacity Sizing Ratio\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note If this terminal unit's heating coil is autosized, the heating capacity is sized\n";
    ss << "\\note to be equal to the cooling capacity multiplied by this sizing ratio.\n";
    ss << "\\note This input applies to the terminal unit heating coil and overrides the sizing\n";
    ss << "\\note ratio entered in the AirConditioner:VariableRefrigerantFlow object.\n";
    ss << "A15, \\field Availability Manager List Name\n";
    ss << "\\note Enter the name of an AvailabilityManagerAssignmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";
    ss << "A16; \\field Design Specification ZoneHVAC Sizing Object Name\n";
    ss << "\\note Enter the name of a DesignSpecificationZoneHVACSizing object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneHVACSizingName\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_TerminalUnit_VariableRefrigerantFlow);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:TerminalUnit:VariableRefrigerantFlow",
                                             "Zone HVAC Forced Air Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_TerminalUnit_VariableRefrigerantFlow);
  return object;
}

IddObject createZoneHVAC_Baseboard_RadiantConvective_WaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:Baseboard:RadiantConvective:Water,\n";
    ss << "\\extensible:2 - repeat last two fields, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\memo The number of surfaces can be expanded beyond 100, if necessary, by adding more\n";
    ss << "\\memo groups to the end of the list\n";
    ss << "\\min-fields 12\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3,  \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,  \\field Rated Average Water Temperature\n";
    ss << "\\note Rated average water temperature is the average of the inlet and outlet water temperatures\n";
    ss << "\\note at rated conditions.\n";
    ss << "\\type real\n";
    ss << "\\maximum 150.0\n";
    ss << "\\minimum 20.0\n";
    ss << "\\units C\n";
    ss << "\\default 87.78\n";
    ss << "N2,  \\field Rated Water Mass Flow Rate\n";
    ss << "\\note Standard is I=B=R Rating document where all baseboards are rated at either 0.063 kg/s (1 gpm)\n";
    ss << "\\note or 0.252 kg/s (4 gpm).  It is recommended that users find data for the baseboard heater that\n";
    ss << "\\note corresponds to performance at 0.063 kg/s unless the flow rate is expected to be above 0.252 kg/s.\n";
    ss << "\\note If the flow rate is expected to be above 0.252 kg/s, this field should be 0.252 kg/s.\n";
    ss << "\\type real\n";
    ss << "\\maximum 10.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units kg/s\n";
    ss << "\\default 0.063\n";
    ss << "A5,  \\field Heating Design Capacity Method\n";
    ss << "\\type choice\n";
    ss << "\\key HeatingDesignCapacity\n";
    ss << "\\key CapacityPerFloorArea\n";
    ss << "\\key FractionOfAutosizedHeatingCapacity\n";
    ss << "\\default HeatingDesignCapacity\n";
    ss << "\\note Enter the method used to determine the heating design capacity.\n";
    ss << "\\note HeatingDesignCapacity = > selected when the design heating capacity value or autosize\n";
    ss << "\\note is specified. CapacityPerFloorArea = > selected when the design heating capacity is\n";
    ss << "\\note determine from user specified heating capacity per floor area and zone floor area.\n";
    ss << "\\note FractionOfAutosizedHeatingCapacity = > is selected when the design heating capacity is\n";
    ss << "\\note determined from a user specified fraction and the auto-sized design heating capacity.\n";
    ss << "N3 , \\field Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\default autosize\n";
    ss << "\\note Enter the design heating capacity. Required field when the heating design capacity method\n";
    ss << "\\note HeatingDesignCapacity. This input field is rated heating capacity. Users must multiply the\n";
    ss << "\\note actual finned length published in the literature to determine the rated capacity. Rated\n";
    ss << "\\note Capacity is for an inlet air dry-bulb temperature of 18.0C, the Rated Water Mass Flow Rate\n";
    ss << "\\note of 0.063kg/s or 0.252kg/s, and the Rated Average Water Temperature between 32.2C and 115.6C.\n";
    ss << "N4 , \\field Heating Design Capacity Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the heating design capacity per zone floor area.Required field when the heating design\n";
    ss << "\\note capacity method field is CapacityPerFloorArea.\n";
    ss << "N5 , \\field Fraction of Autosized Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Enter the fraction of auto - sized heating design capacity.Required field when capacity the\n";
    ss << "\\note heating design capacity method field is FractionOfAutosizedHeatingCapacity.\n";
    ss << "N6,  \\field Maximum Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N7,  \\field Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "N8,  \\field Fraction Radiant\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "N9,  \\field Fraction of Radiant Energy Incident on People\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "A6,  \\field Surface 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\note Radiant energy may be distributed to specific surfaces\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllHeatTranSurfNames\n";
    ss << "N10;  \\field Fraction of Radiant Energy to Surface 1\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_Baseboard_RadiantConvective_Water);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:Baseboard:RadiantConvective:Water",
                                             "Zone HVAC Radiative/Convective Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_Baseboard_RadiantConvective_Water);
  return object;
}

IddObject createZoneHVAC_Baseboard_RadiantConvective_SteamIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:Baseboard:RadiantConvective:Steam,\n";
    ss << "\\min-fields 11\n";
    ss << "\\extensible:2 - repeat last two fields, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\memo The number of surfaces can be expanded beyond 100, if necessary, by adding more\n";
    ss << "\\memo groups to the end of the list\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3,  \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Heating Design Capacity Method\n";
    ss << "\\type choice\n";
    ss << "\\key HeatingDesignCapacity\n";
    ss << "\\key CapacityPerFloorArea\n";
    ss << "\\key FractionOfAutosizedHeatingCapacity\n";
    ss << "\\default HeatingDesignCapacity\n";
    ss << "\\note Enter the method used to determine the heating design capacity.\n";
    ss << "\\note HeatingDesignCapacity = > selected when the design heating capacity value or autosize\n";
    ss << "\\note is specified. CapacityPerFloorArea = > selected when the design heating capacity is\n";
    ss << "\\note determine from user specified heating capacity per floor area and zone floor area.\n";
    ss << "\\note FractionOfAutosizedHeatingCapacity = > is selected when the design heating capacity is\n";
    ss << "\\note determined from a user specified fraction and the auto-sized design heating capacity.\n";
    ss << "N1 , \\field Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\default autosize\n";
    ss << "\\note Enter the design heating capacity.Required field when the heating design capacity method\n";
    ss << "\\note HeatingDesignCapacity.\n";
    ss << "N2 , \\field Heating Design Capacity Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the heating design capacity per zone floor area.Required field when the heating design\n";
    ss << "\\note capacity method field is CapacityPerFloorArea.\n";
    ss << "N3 , \\field Fraction of Autosized Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Enter the fraction of auto - sized heating design capacity.Required field when capacity the\n";
    ss << "\\note heating design capacity method field is FractionOfAutosizedHeatingCapacity.\n";
    ss << "N4,  \\field Degree of SubCooling\n";
    ss << "\\type real\n";
    ss << "\\minimum 1.0\n";
    ss << "\\default 5.0\n";
    ss << "\\units deltaC\n";
    ss << "N5,  \\field Maximum Steam Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "N6,  \\field Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "N7,  \\field Fraction Radiant\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "N8,  \\field Fraction of Radiant Energy Incident on People\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "A6,  \\field Surface 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\note Radiant energy may be distributed to specific surfaces\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllHeatTranSurfNames\n";
    ss << "N9;  \\field Fraction of Radiant Energy to Surface 1\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_Baseboard_RadiantConvective_Steam);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:Baseboard:RadiantConvective:Steam",
                                             "Zone HVAC Radiative/Convective Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_Baseboard_RadiantConvective_Steam);
  return object;
}

IddObject createZoneHVAC_Baseboard_RadiantConvective_ElectricIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:Baseboard:RadiantConvective:Electric,\n";
    ss << "\\min-fields 8\n";
    ss << "\\extensible:2 - repeat last two fields, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\memo The number of surfaces can be expanded beyond 100, if necessary, by adding more\n";
    ss << "\\memo groups to the end of the list\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Heating Design Capacity Method\n";
    ss << "\\type choice\n";
    ss << "\\key HeatingDesignCapacity\n";
    ss << "\\key CapacityPerFloorArea\n";
    ss << "\\key FractionOfAutosizedHeatingCapacity\n";
    ss << "\\default HeatingDesignCapacity\n";
    ss << "\\note Enter the method used to determine the heating design capacity.\n";
    ss << "\\note HeatingDesignCapacity = > selected when the design heating capacity value or autosize\n";
    ss << "\\note is specified. CapacityPerFloorArea = > selected when the design heating capacity is\n";
    ss << "\\note determine from user specified heating capacity per floor area and zone floor area.\n";
    ss << "\\note FractionOfAutosizedHeatingCapacity = > is selected when the design heating capacity is\n";
    ss << "\\note determined from a user specified fraction and the auto-sized design heating capacity.\n";
    ss << "N1 , \\field Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\default autosize\n";
    ss << "\\note Enter the design heating capacity.Required field when the heating design capacity method\n";
    ss << "\\note HeatingDesignCapacity.\n";
    ss << "N2 , \\field Heating Design Capacity Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the heating design capacity per zone floor area.Required field when the heating design\n";
    ss << "\\note capacity method field is CapacityPerFloorArea.\n";
    ss << "N3 , \\field Fraction of Autosized Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Enter the fraction of auto - sized heating design capacity.Required field when capacity the\n";
    ss << "\\note heating design capacity method field is FractionOfAutosizedHeatingCapacity.\n";
    ss << "N4 , \\field Efficiency\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N5,  \\field Fraction Radiant\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "N6,  \\field Fraction of Radiant Energy Incident on People\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "A4,  \\field Surface 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\note Radiant energy may be distributed to specific surfaces\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllHeatTranSurfNames\n";
    ss << "N7;  \\field Fraction of Radiant Energy to Surface 1\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_Baseboard_RadiantConvective_Electric);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:Baseboard:RadiantConvective:Electric",
                                             "Zone HVAC Radiative/Convective Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_Baseboard_RadiantConvective_Electric);
  return object;
}

IddObject createZoneHVAC_Baseboard_Convective_WaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:Baseboard:Convective:Water,\n";
    ss << "\\memo Hot water baseboard heater, convection-only. Natural convection hydronic heating unit.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Heating Design Capacity Method\n";
    ss << "\\type choice\n";
    ss << "\\key HeatingDesignCapacity\n";
    ss << "\\key CapacityPerFloorArea\n";
    ss << "\\key FractionOfAutosizedHeatingCapacity\n";
    ss << "\\default HeatingDesignCapacity\n";
    ss << "\\note Enter the method used to determine the heating design capacity.\n";
    ss << "\\note HeatingDesignCapacity = > selected when the design heating capacity value or autosize\n";
    ss << "\\note is specified. CapacityPerFloorArea = > selected when the design heating capacity is\n";
    ss << "\\note determine from user specified heating capacity per floor area and zone floor area.\n";
    ss << "\\note FractionOfAutosizedHeatingCapacity = > is selected when the design heating capacity is\n";
    ss << "\\note determined from a user specified fraction and the auto-sized design heating capacity.\n";
    ss << "N1 , \\field Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\default autosize\n";
    ss << "\\note Enter the design heating capacity.Required field when the heating design capacity method\n";
    ss << "\\note HeatingDesignCapacity.\n";
    ss << "N2 , \\field Heating Design Capacity Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the heating design capacity per zone floor area.Required field when the heating design\n";
    ss << "\\note capacity method field is CapacityPerFloorArea.\n";
    ss << "N3 , \\field Fraction of Autosized Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Enter the fraction of auto - sized heating design capacity.Required field when capacity the\n";
    ss << "\\note heating design capacity method field is FractionOfAutosizedHeatingCapacity.\n";
    ss << "N4 , \\field U-Factor Times Area Value\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units W/K\n";
    ss << "N5 , \\field Maximum Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N6 ; \\field Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_Baseboard_Convective_Water);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:Baseboard:Convective:Water",
                                             "Zone HVAC Radiative/Convective Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_Baseboard_Convective_Water);
  return object;
}

IddObject createZoneHVAC_Baseboard_Convective_ElectricIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:Baseboard:Convective:Electric,\n";
    ss << "\\memo Electric baseboard heater, convection-only. Natural convection electric heating unit.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 ,  \\field Heating Design Capacity Method\n";
    ss << "\\type choice\n";
    ss << "\\key HeatingDesignCapacity\n";
    ss << "\\key CapacityPerFloorArea\n";
    ss << "\\key FractionOfAutosizedHeatingCapacity\n";
    ss << "\\default HeatingDesignCapacity\n";
    ss << "\\note Enter the method used to determine the heating design capacity.\n";
    ss << "\\note HeatingDesignCapacity = > selected when the design heating capacity value or autosize\n";
    ss << "\\note is specified. CapacityPerFloorArea = > selected when the design heating capacity is\n";
    ss << "\\note determine from user specified heating capacity per floor area and zone floor area.\n";
    ss << "\\note FractionOfAutosizedHeatingCapacity = > is selected when the design heating capacity is\n";
    ss << "\\note determined from a user specified fraction and the auto-sized design heating capacity.\n";
    ss << "N1 ,  \\field Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\default autosize\n";
    ss << "\\note Enter the design heating capacity.Required field when the heating design capacity method\n";
    ss << "\\note HeatingDesignCapacity.\n";
    ss << "N2 ,  \\field Heating Design Capacity Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the heating design capacity per zone floor area.Required field when the heating design\n";
    ss << "\\note capacity method field is CapacityPerFloorArea.\n";
    ss << "N3 ,  \\field Fraction of Autosized Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Enter the fraction of auto - sized heating design capacity.Required field when capacity the\n";
    ss << "\\note heating design capacity method field is FractionOfAutosizedHeatingCapacity.\n";
    ss << "N4 ;  \\field Efficiency\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_Baseboard_Convective_Electric);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:Baseboard:Convective:Electric",
                                             "Zone HVAC Radiative/Convective Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_Baseboard_Convective_Electric);
  return object;
}

IddObject createZoneHVAC_LowTemperatureRadiant_VariableFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:LowTemperatureRadiant:VariableFlow,\n";
    ss << "\\memo Low temperature hydronic radiant heating and/or cooling system embedded in a building\n";
    ss << "\\memo surface (wall, ceiling, or floor). Controlled by varying the hot or chilled water\n";
    ss << "\\memo flow to the unit.\n";
    ss << "\\min-fields 29\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\note Name of zone system is serving\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A4 , \\field Surface Name or Radiant Surface Group Name\n";
    ss << "\\note Identifies surfaces that radiant system is embedded in.\n";
    ss << "\\note For a system with multiple surfaces, enter the name of\n";
    ss << "\\note a ZoneHVAC:LowTemperatureRadiant:SurfaceGroup object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RadiantSurfaceNames\n";
    ss << "\\object-list RadiantGroupNames\n";
    ss << "N1 , \\field Hydronic Tubing Inside Diameter\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.013\n";
    ss << "\\ip-units in\n";
    ss << "N2 , \\field Hydronic Tubing Length\n";
    ss << "\\note (total length of pipe embedded in surface)\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "A5 , \\field Temperature Control Type\n";
    ss << "\\note (Temperature on which unit is controlled)\n";
    ss << "\\type choice\n";
    ss << "\\key MeanAirTemperature\n";
    ss << "\\key MeanRadiantTemperature\n";
    ss << "\\key OperativeTemperature\n";
    ss << "\\key OutdoorDryBulbTemperature\n";
    ss << "\\key OutdoorWetBulbTemperature\n";
    ss << "\\default MeanAirTemperature\n";
    ss << "A6 , \\field Heating Design Capacity Method\n";
    ss << "\\type choice\n";
    ss << "\\key HeatingDesignCapacity\n";
    ss << "\\key CapacityPerFloorArea\n";
    ss << "\\key FractionOfAutosizedHeatingCapacity\n";
    ss << "\\default HeatingDesignCapacity\n";
    ss << "\\note Enter the method used to determine the heating design capacity.\n";
    ss << "\\note HeatingDesignCapacity = > selected when the design heating capacity value or autosize\n";
    ss << "\\note is specified. CapacityPerFloorArea = > selected when the design heating capacity is\n";
    ss << "\\note determine from user specified heating capacity per floor area and zone floor area.\n";
    ss << "\\note FractionOfAutosizedHeatingCapacity = > is selected when the design heating capacity is\n";
    ss << "\\note determined from a user specified fraction and the auto-sized design heating capacity.\n";
    ss << "N3 , \\field Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\default autosize\n";
    ss << "\\note Enter the design heating capacity.Required field when the heating design capacity method\n";
    ss << "\\note HeatingDesignCapacity.\n";
    ss << "N4 , \\field Heating Design Capacity Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the heating design capacity per zone floor area.Required field when the heating design\n";
    ss << "\\note capacity method field is CapacityPerFloorArea.\n";
    ss << "N5 , \\field Fraction of Autosized Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Enter the fraction of auto - sized heating design capacity.Required field when capacity the\n";
    ss << "\\note heating design capacity method field is FractionOfAutosizedHeatingCapacity.\n";
    ss << "N6 , \\field Maximum Hot Water Flow\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "A7 , \\field Heating Water Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A8 , \\field Heating Water Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N7 , \\field Heating Control Throttling Range\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.5\n";
    ss << "\\default 0.5\n";
    ss << "A9 , \\field Heating Control Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A10,  \\field Cooling Design Capacity Method\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key CoolingDesignCapacity\n";
    ss << "\\key CapacityPerFloorArea\n";
    ss << "\\key FractionOfAutosizedCoolingCapacity\n";
    ss << "\\default CoolingDesignCapacity\n";
    ss << "\\note Enter the method used to determine the cooling design capacity for scalable sizing.\n";
    ss << "\\note CoolingDesignCapacity => selected when the design cooling capacity value is specified or\n";
    ss << "\\note auto-sized. CapacityPerFloorArea => selected when the design cooling capacity is determined\n";
    ss << "\\note from user specified cooling capacity per floor area and total floor area of cooled zone\n";
    ss << "\\note served by the hydrolic unit. FractionOfAutosizedCoolingCapacity => is selected when the\n";
    ss << "\\note design cooling capacity is determined from a user specified fraction and the auto-sized\n";
    ss << "\\note design cooling capacity of the system.\n";
    ss << "N8 , \\field Cooling Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Enter the design cooling capacity. Required field when the cooling design capacity method\n";
    ss << "\\note CoolingDesignCapacity.\n";
    ss << "N9 , \\field Cooling Design Capacity Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the cooling design capacity per total floor area of cooled zones served by the unit.\n";
    ss << "\\note Required field when the cooling design capacity method field is CapacityPerFloorArea.\n";
    ss << "N10, \\field Fraction of Autosized Cooling Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the fraction of auto-sized cooling design capacity. Required field when the cooling\n";
    ss << "\\note design capacity method field is FractionOfAutosizedCoolingCapacity.\n";
    ss << "N11, \\field Maximum Cold Water Flow\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "A11, \\field Cooling Water Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A12, \\field Cooling Water Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N12, \\field Cooling Control Throttling Range\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.5\n";
    ss << "\\default 0.5\n";
    ss << "A13, \\field Cooling Control Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A14, \\field Condensation Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Off\n";
    ss << "\\key SimpleOff\n";
    ss << "\\key VariableOff\n";
    ss << "\\default SimpleOff\n";
    ss << "N13, \\field Condensation Control Dewpoint Offset\n";
    ss << "\\units C\n";
    ss << "\\default 1.0\n";
    ss << "A15, \\field Number of Circuits\n";
    ss << "\\type choice\n";
    ss << "\\key OnePerSurface\n";
    ss << "\\key CalculateFromCircuitLength\n";
    ss << "\\default OnePerSurface\n";
    ss << "N14; \\field Circuit Length\n";
    ss << "\\units m\n";
    ss << "\\default 106.7\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_LowTemperatureRadiant_VariableFlow);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:LowTemperatureRadiant:VariableFlow",
                                             "Zone HVAC Radiative/Convective Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_LowTemperatureRadiant_VariableFlow);
  return object;
}

IddObject createZoneHVAC_LowTemperatureRadiant_ConstantFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:LowTemperatureRadiant:ConstantFlow,\n";
    ss << "\\memo Low temperature hydronic radiant heating and/or cooling system embedded in a building\n";
    ss << "\\memo surface (wall, ceiling, or floor). Controlled by varying the hot or chilled water\n";
    ss << "\\memo temperature circulating through the unit.\n";
    ss << "\\min-fields 29\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\note Name of zone system is serving\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A4 , \\field Surface Name or Radiant Surface Group Name\n";
    ss << "\\note Identifies surfaces that radiant system is embedded in.\n";
    ss << "\\note For a system with multiple surfaces, enter the name of\n";
    ss << "\\note a ZoneHVAC:LowTemperatureRadiant:SurfaceGroup object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RadiantSurfaceNames\n";
    ss << "\\object-list RadiantGroupNames\n";
    ss << "N1 , \\field Hydronic Tubing Inside Diameter\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.013\n";
    ss << "N2 , \\field Hydronic Tubing Length\n";
    ss << "\\note Total length of pipe embedded in surface\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "A5 , \\field Temperature Control Type\n";
    ss << "\\note Temperature used to control system\n";
    ss << "\\type choice\n";
    ss << "\\key MeanAirTemperature\n";
    ss << "\\key MeanRadiantTemperature\n";
    ss << "\\key OperativeTemperature\n";
    ss << "\\key OutdoorDryBulbTemperature\n";
    ss << "\\key OutdoorWetBulbTemperature\n";
    ss << "\\default MeanAirTemperature\n";
    ss << "N3 , \\field Rated Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\autosizable\n";
    ss << "A6 , \\field Pump Flow Rate Schedule Name\n";
    ss << "\\note Modifies the Rated Flow Rate of the pump on a time basis\n";
    ss << "\\note the default is that the pump is ON and runs according to its other\n";
    ss << "\\note operational requirements specified above.  The schedule is for special\n";
    ss << "\\note pump operations.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N4 , \\field Rated Pump Head\n";
    ss << "\\units Pa\n";
    ss << "\\default 179352\n";
    ss << "\\note default head is 60 feet\n";
    ss << "N5 , \\field Rated Power Consumption\n";
    ss << "\\units W\n";
    ss << "N6 , \\field Motor Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N7 , \\field Fraction of Motor Inefficiencies to Fluid Stream\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "A7 , \\field Heating Water Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A8 , \\field Heating Water Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A9 , \\field Heating High Water Temperature Schedule Name\n";
    ss << "\\note Water and control temperatures for heating work together to provide\n";
    ss << "\\note a linear function that determines the water temperature sent to the\n";
    ss << "\\note radiant system.  The current control temperature (see Temperature Control Type above) is\n";
    ss << "\\note compared to the high and low control temperatures at the current time.\n";
    ss << "\\note If the control temperature is above the high temperature, then the\n";
    ss << "\\note inlet water temperature is set to the low water temperature.  If the\n";
    ss << "\\note control temperature is below the low temperature, then the inlet\n";
    ss << "\\note water temperature is set to the high water temperature.  If the control\n";
    ss << "\\note temperature is between the high and low value, then the inlet water\n";
    ss << "\\note temperature is linearly interpolated between the low and high water\n";
    ss << "\\note temperature values.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A10, \\field Heating Low Water Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A11, \\field Heating High Control Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A12, \\field Heating Low Control Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A13, \\field Cooling Water Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A14, \\field Cooling Water Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A15, \\field Cooling High Water Temperature Schedule Name\n";
    ss << "\\note See note for Heating High Water Temperature Schedule above for\n";
    ss << "\\note interpretation information (or see the Input/Output Reference).\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A16, \\field Cooling Low Water Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A17, \\field Cooling High Control Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A18, \\field Cooling Low Control Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A19, \\field Condensation Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Off\n";
    ss << "\\key SimpleOff\n";
    ss << "\\key VariableOff\n";
    ss << "\\default SimpleOff\n";
    ss << "N8 , \\field Condensation Control Dewpoint Offset\n";
    ss << "\\units C\n";
    ss << "\\default 1.0\n";
    ss << "A20, \\field Number of Circuits\n";
    ss << "\\type choice\n";
    ss << "\\key OnePerSurface\n";
    ss << "\\key CalculateFromCircuitLength\n";
    ss << "\\default OnePerSurface\n";
    ss << "N9 ; \\field Circuit Length\n";
    ss << "\\units m\n";
    ss << "\\default 106.7\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_LowTemperatureRadiant_ConstantFlow);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:LowTemperatureRadiant:ConstantFlow",
                                             "Zone HVAC Radiative/Convective Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_LowTemperatureRadiant_ConstantFlow);
  return object;
}

IddObject createZoneHVAC_LowTemperatureRadiant_ElectricIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:LowTemperatureRadiant:Electric,\n";
    ss << "\\memo Electric resistance low temperature radiant system\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\note Name of zone system is serving\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A4 , \\field Surface Name or Radiant Surface Group Name\n";
    ss << "\\note Identifies surfaces that radiant system is embedded in.\n";
    ss << "\\note For a system with multiple surfaces, enter the name of\n";
    ss << "\\note a ZoneHVAC:LowTemperatureRadiant:SurfaceGroup object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RadiantSurfaceNames\n";
    ss << "\\object-list RadiantGroupNames\n";
    ss << "A5 , \\field Heating Design Capacity Method\n";
    ss << "\\type choice\n";
    ss << "\\key HeatingDesignCapacity\n";
    ss << "\\key CapacityPerFloorArea\n";
    ss << "\\key FractionOfAutosizedHeatingCapacity\n";
    ss << "\\default HeatingDesignCapacity\n";
    ss << "\\note Enter the method used to determine the maximum electrical heating design capacity.\n";
    ss << "\\note HeatingDesignCapacity = > selected when the design heating capacity value or autosize\n";
    ss << "\\note is specified. CapacityPerFloorArea = > selected when the design heating capacity is\n";
    ss << "\\note determine from user specified heating capacity per floor area and zone floor area.\n";
    ss << "\\note FractionOfAutosizedHeatingCapacity = > is selected when the design heating capacity is\n";
    ss << "\\note determined from a user specified fraction and the auto-sized design heating capacity.\n";
    ss << "N1 , \\field Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\default autosize\n";
    ss << "\\note Enter the design heating capacity.Required field when the heating design capacity method\n";
    ss << "\\note HeatingDesignCapacity.\n";
    ss << "N2 , \\field Heating Design Capacity Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the heating design capacity per zone floor area.Required field when the heating design\n";
    ss << "\\note capacity method field is CapacityPerFloorArea.\n";
    ss << "N3 , \\field Fraction of Autosized Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Enter the fraction of auto - sized heating design capacity.Required field when capacity the\n";
    ss << "\\note heating design capacity method field is FractionOfAutosizedHeatingCapacity.\n";
    ss << "A6 , \\field Temperature Control Type\n";
    ss << "\\note Temperature used to control unit\n";
    ss << "\\type choice\n";
    ss << "\\key MeanAirTemperature\n";
    ss << "\\key MeanRadiantTemperature\n";
    ss << "\\key OperativeTemperature\n";
    ss << "\\key OutdoorDryBulbTemperature\n";
    ss << "\\key OutdoorWetBulbTemperature\n";
    ss << "\\default MeanAirTemperature\n";
    ss << "N4 , \\field Heating Throttling Range\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "A7 ; \\field Heating Setpoint Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_LowTemperatureRadiant_Electric);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:LowTemperatureRadiant:Electric",
                                             "Zone HVAC Radiative/Convective Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_LowTemperatureRadiant_Electric);
  return object;
}

IddObject createZoneHVAC_LowTemperatureRadiant_SurfaceGroupIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:LowTemperatureRadiant:SurfaceGroup,\n";
    ss << "\\memo This is used to allow the coordinate control of several radiant system surfaces.\n";
    ss << "\\memo Note that the following flow fractions must sum up to 1.0\n";
    ss << "\\extensible:2 - repeat last two fields, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\min-fields 3\n";
    ss << "\\memo The number of surfaces can be expanded beyond 100, if necessary, by adding more\n";
    ss << "\\memo groups to the end of the list\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RadiantGroupNames\n";
    ss << "A2 , \\field Surface 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RadiantSurfaceNames\n";
    ss << "N1 ; \\field Flow Fraction for Surface 1\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0.0\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_LowTemperatureRadiant_SurfaceGroup);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:LowTemperatureRadiant:SurfaceGroup",
                                             "Zone HVAC Radiative/Convective Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_LowTemperatureRadiant_SurfaceGroup);
  return object;
}

IddObject createZoneHVAC_HighTemperatureRadiantIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:HighTemperatureRadiant,\n";
    ss << "\\extensible:2 - repeat last two fields, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\memo The number of surfaces can be expanded beyond 100, if necessary, by adding more\n";
    ss << "\\memo groups to the end of the list\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\note Name of zone system is serving\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A4 , \\field Heating Design Capacity Method\n";
    ss << "\\type choice\n";
    ss << "\\key HeatingDesignCapacity\n";
    ss << "\\key CapacityPerFloorArea\n";
    ss << "\\key FractionOfAutosizedHeatingCapacity\n";
    ss << "\\default HeatingDesignCapacity\n";
    ss << "\\note Enter the method used to determine the maximum heating power input capacity.\n";
    ss << "\\note HeatingDesignCapacity = > selected when the design heating capacity value or autosize\n";
    ss << "\\note is specified. CapacityPerFloorArea = > selected when the design heating capacity is\n";
    ss << "\\note determine from user specified heating capacity per floor area and zone floor area.\n";
    ss << "\\note FractionOfAutosizedHeatingCapacity = > is selected when the design heating capacity is\n";
    ss << "\\note determined from a user specified fraction and the auto-sized design heating capacity.\n";
    ss << "N1 , \\field Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\note Enter the design heating capacity.Required field when the heating design capacity method\n";
    ss << "\\note HeatingDesignCapacity.\n";
    ss << "N2 , \\field Heating Design Capacity Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the heating design capacity per zone floor area.Required field when the heating design\n";
    ss << "\\note capacity method field is CapacityPerFloorArea.\n";
    ss << "N3 , \\field Fraction of Autosized Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Enter the fraction of auto - sized heating design capacity.Required field when capacity the\n";
    ss << "\\note heating design capacity method field is FractionOfAutosizedHeatingCapacity.\n";
    ss << "A5 , \\field Fuel Type\n";
    ss << "\\note Natural gas or electricity\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key Electricity\n";
    ss << "N4 , \\field Combustion Efficiency\n";
    ss << "\\note Not used for non-gas radiant heaters\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.9\n";
    ss << "N5 , \\field Fraction of Input Converted to Radiant Energy\n";
    ss << "\\note Radiant+latent+lost fractions must sum to 1 or less, remainder is considered convective heat\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.7\n";
    ss << "N6 , \\field Fraction of Input Converted to Latent Energy\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N7 , \\field Fraction of Input that Is Lost\n";
    ss << "\\note Fraction of input vented to outdoor environment\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "A6 , \\field Temperature Control Type\n";
    ss << "\\note Temperature type used to control unit\n";
    ss << "\\type choice\n";
    ss << "\\key MeanAirTemperature\n";
    ss << "\\key MeanRadiantTemperature\n";
    ss << "\\key OperativeTemperature\n";
    ss << "\\key MeanAirTemperatureSetpoint\n";
    ss << "\\key MeanRadiantTemperatureSetpoint\n";
    ss << "\\key OperativeTemperatureSetpoint\n";
    ss << "\\default OperativeTemperature\n";
    ss << "N8 , \\field Heating Throttling Range\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0\n";
    ss << "\\default 2.0\n";
    ss << "A7 , \\field Heating Setpoint Temperature Schedule Name\n";
    ss << "\\note This setpoint is an \"operative temperature\" setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N9,  \\field Fraction of Radiant Energy Incident on People\n";
    ss << "\\note This will affect thermal comfort but from an energy balance standpoint this value\n";
    ss << "\\note gets added to the convective gains from the radiant heater\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "A8,  \\field Surface 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\note Radiant energy may be distributed to specific surfaces\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllHeatTranSurfNames\n";
    ss << "N10;  \\field Fraction of Radiant Energy to Surface 1\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_HighTemperatureRadiant);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:HighTemperatureRadiant",
                                             "Zone HVAC Radiative/Convective Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_HighTemperatureRadiant);
  return object;
}

IddObject createZoneHVAC_VentilatedSlabIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:VentilatedSlab,\n";
    ss << "\\memo Ventilated slab system where outdoor air flows through hollow cores in a building\n";
    ss << "\\memo surface (wall, ceiling, or floor).\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\note (name of zone system is serving)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A4 ,\\field Surface Name or Radiant Surface Group Name\n";
    ss << "\\note (name of surface system is embedded in) or list of surfaces\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RadiantSurfaceNames\n";
    ss << "\\object-list VentSlabGroupNames\n";
    ss << "N1, \\field Maximum Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "A5, \\field Outdoor Air Control Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key VariablePercent\n";
    ss << "\\key FixedTemperature\n";
    ss << "\\key FixedAmount\n";
    ss << "N2, \\field Minimum Outdoor Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.0\n";
    ss << "A6, \\field Minimum Outdoor Air Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N3, \\field Maximum Outdoor Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note schedule values multiply the minimum outdoor air flow rate\n";
    ss << "A7, \\field Maximum Outdoor Air Fraction or Temperature Schedule Name\n";
    ss << "\\note Note that this depends on the control type as to whether schedule values are a fraction or temperature\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A8, \\field System Configuration Type\n";
    ss << "\\type choice\n";
    ss << "\\key SlabOnly\n";
    ss << "\\key SlabAndZone\n";
    ss << "\\key SeriesSlabs\n";
    ss << "\\default SlabOnly\n";
    ss << "N4, \\field Hollow Core Inside Diameter\n";
    ss << "\\units m\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.05\n";
    ss << "\\ip-units in\n";
    ss << "N5, \\field Hollow Core Length\n";
    ss << "\\note (length of core cavity embedded in surface)\n";
    ss << "\\units m\n";
    ss << "\\minimum 0\n";
    ss << "N6, \\field Number of Cores\n";
    ss << "\\note flow will be divided evenly among the cores\n";
    ss << "\\minimum 0\n";
    ss << "A9, \\field Temperature Control Type\n";
    ss << "\\note (temperature on which unit is controlled)\n";
    ss << "\\type choice\n";
    ss << "\\key MeanAirTemperature\n";
    ss << "\\key MeanRadiantTemperature\n";
    ss << "\\key OperativeTemperature\n";
    ss << "\\key OutdoorDryBulbTemperature\n";
    ss << "\\key OutdoorWetBulbTemperature\n";
    ss << "\\key SurfaceTemperature\n";
    ss << "\\key ZoneAirDewPointTemperature\n";
    ss << "\\default OutdoorDryBulbTemperature\n";
    ss << "A10, \\field Heating High Air Temperature Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\note Air and control temperatures for heating work together to provide\n";
    ss << "\\note a linear function that determines the air temperature sent to the\n";
    ss << "\\note radiant system. The current control temperature (see A14) is\n";
    ss << "\\note compared to the high and low control temperatures at the current time.\n";
    ss << "\\note If the control temperature is above the high temperature, then the\n";
    ss << "\\note inlet air temperature is set to the low air temperature. If the\n";
    ss << "\\note control temperature is below the low temperature, then the inlet\n";
    ss << "\\note air temperature is set to the high air temperature. If the control\n";
    ss << "\\note temperature is between the high and low value, then the inlet air\n";
    ss << "\\note temperature is linearly interpolated between the low and high air\n";
    ss << "\\note temperature values.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A11, \\field Heating Low Air Temperature Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A12, \\field Heating High Control Temperature Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A13, \\field Heating Low Control Temperature Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A14, \\field Cooling High Air Temperature Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\note See note for heating high air temperature schedule above for\n";
    ss << "\\note interpretation information (or see the Input/Output Reference).\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A15, \\field Cooling Low Air Temperature Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A16, \\field Cooling High Control Temperature Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A17, \\field Cooling Low Control Temperature Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A18, \\field Return Air Node Name\n";
    ss << "\\note This is the zone return air inlet to the ventilated slab system outdoor air mixer.\n";
    ss << "\\note This node is typically a zone exhaust node (do not connect to \"Zone Return Air Node\").\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A19, \\field Slab In Node Name\n";
    ss << "\\note This is the node entering the slab or series of slabs after the fan and coil(s).\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A20, \\field Zone Supply Air Node Name\n";
    ss << "\\note This is the node name exiting the slab.\n";
    ss << "\\note This node is typically a zone inlet node.\n";
    ss << "\\note Leave blank when the system configuration is SlabOnly or SeriesSlabs.\n";
    ss << "\\type node\n";
    ss << "A21, \\field Outdoor Air Node Name\n";
    ss << "\\note This node is the outdoor air inlet to the ventilated slab oa mixer.\n";
    ss << "\\note This node should also be specified in an OutdoorAir:Node or OutdoorAir:NodeList object.\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A22, \\field Relief Air Node Name\n";
    ss << "\\note This node is the relief air node from the ventilated slab outdoor air mixer.\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A23, \\field Outdoor Air Mixer Outlet Node Name\n";
    ss << "\\note This is the node name leaving the outdoor air mixer and entering the fan and coil(s).\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A24, \\field Fan Outlet Node Name\n";
    ss << "\\note This is the node name of the fan outlet.\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A25, \\field Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\note Allowable fan type is Fan:ConstantVolume\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCV\n";
    ss << "A26, \\field Coil Option Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Heating\n";
    ss << "\\key Cooling\n";
    ss << "\\key HeatingAndCooling\n";
    ss << "A27, \\field Heating Coil Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "A28, \\field Heating Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "A29, \\field Hot Water or Steam Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A30, \\field Cooling Coil Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:Water\n";
    ss << "\\key Coil:Cooling:Water:DetailedGeometry\n";
    ss << "\\key CoilSystem:Cooling:Water:HeatExchangerAssisted\n";
    ss << "A31, \\field Cooling Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsWater\n";
    ss << "A32, \\field Cold Water Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A33, \\field Availability Manager List Name\n";
    ss << "\\note Enter the name of an AvailabilityManagerAssignmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";
    ss << "A34; \\field Design Specification ZoneHVAC Sizing Object Name\n";
    ss << "\\note Enter the name of a DesignSpecificationZoneHVACSizing object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneHVACSizingName\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_VentilatedSlab);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:VentilatedSlab",
                                             "Zone HVAC Radiative/Convective Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_VentilatedSlab);
  return object;
}

IddObject createZoneHVAC_VentilatedSlab_SlabGroupIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:VentilatedSlab:SlabGroup,\n";
    ss << "\\memo This is used to allow the coordinate control of several ventilated slab system\n";
    ss << "\\memo surfaces. Note that the flow fractions must sum up to 1.0.\n";
    ss << "\\memo The number of surfaces can be expanded beyond 10, if necessary, by adding more\n";
    ss << "\\memo groups to the end of the list\n";
    ss << "\\extensible:7 - repeat last seven fields, remembering to remove ; from \"inner\" fields.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference VentSlabGroupNames\n";
    ss << "A2  , \\field Zone 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A3  , \\field Surface 1 Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RadiantSurfaceNames\n";
    ss << "N1  , \\field Core Diameter for Surface 1\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0.0\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "N2  , \\field Core Length for Surface 1\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0.0\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "N3  , \\field Core Numbers for Surface 1\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0.0\n";
    ss << "A4  , \\field Slab Inlet Node Name for Surface 1\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5  ; \\field Slab Outlet Node Name for Surface 1\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_VentilatedSlab_SlabGroup);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:VentilatedSlab:SlabGroup",
                                             "Zone HVAC Radiative/Convective Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_VentilatedSlab_SlabGroup);
  return object;
}

IddObject createAirTerminal_SingleDuct_UncontrolledIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirTerminal:SingleDuct:Uncontrolled,\n";
    ss << "\\memo Central air system terminal unit, single duct, constant volume, no controls other than\n";
    ss << "\\memo on/off schedule.\n";
    ss << "\\min-fields 4\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Zone Supply Air Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1; \\field Maximum Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";

    IddObjectType objType(IddObjectType::AirTerminal_SingleDuct_Uncontrolled);
    OptionalIddObject oObj = IddObject::load("AirTerminal:SingleDuct:Uncontrolled",
                                             "Zone HVAC Air Loop Terminal Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirTerminal_SingleDuct_Uncontrolled);
  return object;
}

IddObject createAirTerminal_SingleDuct_ConstantVolume_ReheatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirTerminal:SingleDuct:ConstantVolume:Reheat,\n";
    ss << "\\memo Central air system terminal unit, single duct, constant volume, with reheat coil (hot\n";
    ss << "\\memo water, electric, gas, or steam).\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference AFNTerminalUnitNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3,  \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,  \\field Maximum Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "A5,  \\field Reheat Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "A6,  \\field Reheat Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N2,  \\field Maximum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when reheat coil type is gas or electric\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N3,  \\field Minimum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when reheat coil type is gas or electric\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N4,  \\field Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "N5; \\field Maximum Reheat Air Temperature\n";
    ss << "\\note Specifies the maximum allowable supply air temperature leaving the reheat coil.\n";
    ss << "\\note If left blank, there is no limit and no default. If unknown, 35C (95F) is recommended.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";

    IddObjectType objType(IddObjectType::AirTerminal_SingleDuct_ConstantVolume_Reheat);
    OptionalIddObject oObj = IddObject::load("AirTerminal:SingleDuct:ConstantVolume:Reheat",
                                             "Zone HVAC Air Loop Terminal Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirTerminal_SingleDuct_ConstantVolume_Reheat);
  return object;
}

IddObject createAirTerminal_SingleDuct_VAV_NoReheatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirTerminal:SingleDuct:VAV:NoReheat,\n";
    ss << "\\memo Central air system terminal unit, single duct, variable volume, with no reheat coil.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3,  \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,  \\field Maximum Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "A5 , \\field Zone Minimum Air Flow Input Method\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Constant\n";
    ss << "\\key FixedFlowRate\n";
    ss << "\\key Scheduled\n";
    ss << "\\note Constant = Constant Minimum Air Flow Fraction (a fraction of Maximum Air Flow Rate)\n";
    ss << "\\note FixedFlowRate = Fixed Minimum Air Flow Rate (a fixed minimum air volume flow rate)\n";
    ss << "\\note Scheduled = Scheduled Minimum Air Flow Fraction (a fraction of Maximum Air Flow\n";
    ss << "N2 , \\field Constant Minimum Air Flow Fraction\n";
    ss << "\\note This field is used if the field Zone Minimum Air Flow Input Method is Constant\n";
    ss << "\\note If the field Zone Minimum Air Flow Input Method is Scheduled, then this field\n";
    ss << "\\note is optional; if a value is entered, then it is used for sizing normal-action reheat coils.\n";
    ss << "\\note If both this field and the following field are entered, the larger result is used.\n";
    ss << "N3 , \\field Fixed Minimum Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\note This field is used if the field Zone Minimum Air Flow Input Method is FixedFlowRate.\n";
    ss << "\\note If the field Zone Minimum Air Flow Input Method is Scheduled, then this field\n";
    ss << "\\note is optional; if a value is entered, then it is used for sizing normal-action reheat coils.\n";
    ss << "\\note If both this field and the previous field are entered, the larger result is used.\n";
    ss << "A6 , \\field Minimum Air Flow Fraction Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field is used if the field Zone Minimum Air Flow Input Method is Scheduled\n";
    ss << "\\note Schedule values are fractions, 0.0 to 1.0.\n";
    ss << "\\note If the field Constant Minimum Air Flow Fraction is blank, then the average of the\n";
    ss << "\\note minimum and maximum schedule values is used for sizing normal-action reheat coils.\n";
    ss << "A7 ; \\field Design Specification Outdoor Air Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "\\note When the name of a DesignSpecification:OutdoorAir object is entered, the terminal\n";
    ss << "\\note unit will increase flow as needed to meet this outdoor air requirement.\n";
    ss << "\\note If Outdoor Air Flow per Person is non-zero, then the outdoor air requirement will\n";
    ss << "\\note be computed based on the current number of occupants in the zone.\n";
    ss << "\\note At no time will the supply air flow rate exceed the value for Maximum Air Flow Rate.\n";
    ss << "\\note If this field is blank, then the terminal unit will not be controlled for outdoor air flow.\n";

    IddObjectType objType(IddObjectType::AirTerminal_SingleDuct_VAV_NoReheat);
    OptionalIddObject oObj = IddObject::load("AirTerminal:SingleDuct:VAV:NoReheat",
                                             "Zone HVAC Air Loop Terminal Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirTerminal_SingleDuct_VAV_NoReheat);
  return object;
}

IddObject createAirTerminal_SingleDuct_VAV_ReheatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirTerminal:SingleDuct:VAV:Reheat,\n";
    ss << "\\memo Central air system terminal unit, single duct, variable volume, with reheat coil (hot\n";
    ss << "\\memo water, electric, gas, or steam).\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Damper Air Outlet Node Name\n";
    ss << "\\note the outlet node of the damper and the inlet node of the reheat coil\n";
    ss << "\\note this is an internal node to the terminal unit and connects the damper and reheat coil\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Air Inlet Node Name\n";
    ss << "\\note the inlet node to the terminal unit and the damper\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Maximum Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "A5 , \\field Zone Minimum Air Flow Input Method\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Constant\n";
    ss << "\\key FixedFlowRate\n";
    ss << "\\key Scheduled\n";
    ss << "\\note Constant = Constant Minimum Air Flow Fraction (a fraction of Maximum Air Flow Rate)\n";
    ss << "\\note FixedFlowRate = Fixed Minimum Air Flow Rate (a fixed minimum air volume flow rate)\n";
    ss << "\\note Scheduled = Scheduled Minimum Air Flow Fraction (a fraction of Maximum Air Flow\n";
    ss << "N2 , \\field Constant Minimum Air Flow Fraction\n";
    ss << "\\note This field is used if the field Zone Minimum Air Flow Input Method is Constant\n";
    ss << "\\note If the field Zone Minimum Air Flow Input Method is Scheduled, then this field\n";
    ss << "\\note is optional; if a value is entered, then it is used for sizing normal-action reheat coils.\n";
    ss << "\\note If both this field and the following field are entered, the larger result is used.\n";
    ss << "N3 , \\field Fixed Minimum Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\note This field is used if the field Zone Minimum Air Flow Input Method is FixedFlowRate.\n";
    ss << "\\note If the field Zone Minimum Air Flow Input Method is Scheduled, then this field\n";
    ss << "\\note is optional; if a value is entered, then it is used for sizing normal-action reheat coils.\n";
    ss << "\\note If both this field and the previous field are entered, the larger result is used.\n";
    ss << "A6 , \\field Minimum Air Flow Fraction Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field is used if the field Zone Minimum Air Flow Input Method is Scheduled\n";
    ss << "\\note Schedule values are fractions, 0.0 to 1.0.\n";
    ss << "\\note If the field Constant Minimum Air Flow Fraction is blank, then the average of the\n";
    ss << "\\note minimum and maximum schedule values is used for sizing normal-action reheat coils.\n";
    ss << "A7 , \\field Reheat Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "A8 , \\field Reheat Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N4 , \\field Maximum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when reheat coil type is gas or electric\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N5 , \\field Minimum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when reheat coil type is gas or electric\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "A9 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note The outlet node of the terminal unit and the reheat coil.\n";
    ss << "\\note This is also the zone inlet node.\n";
    ss << "N6 , \\field Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "A10, \\field Damper Heating Action\n";
    ss << "\\type choice\n";
    ss << "\\key Normal\n";
    ss << "\\key Reverse\n";
    ss << "\\default Normal\n";
    ss << "N7 , \\field Maximum Flow per Zone Floor Area During Reheat\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Used only when Reheat Coil Object Type = Coil:Heating:Water and Damper Heating Action = Reverse\n";
    ss << "\\note When autocalculating, the maximum flow per zone is set to 0.002032 m3/s-m2 (0.4 cfm/sqft)\n";
    ss << "\\note This optional field limits the maximum flow allowed in reheat mode.\n";
    ss << "\\note If this field and the following field are left blank, the maximum flow will not be limited.\n";
    ss << "\\note At no time will the maximum flow rate calculated here exceed the value of\n";
    ss << "\\note Maximum Air Flow Rate.\n";
    ss << "N8 , \\field Maximum Flow Fraction During Reheat\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Used only when Reheat Coil Object Type = Coil:Heating:Water and Damper Heating Action = Reverse\n";
    ss << "\\note When autocalculating, the maximum flow fraction is set to the ratio of\n";
    ss << "\\note 0.002032 m3/s-m2 (0.4 cfm/sqft) multiplied by the zone floor area and the\n";
    ss << "\\note Maximum Air Flow Rate.\n";
    ss << "\\note This optional field limits the maximum flow allowed in reheat mode.\n";
    ss << "\\note If this field and the previous field are left blank, the maximum flow will not be limited.\n";
    ss << "\\note At no time will the maximum flow rate calculated here exceed the value of\n";
    ss << "\\note Maximum Air Flow Rate.\n";
    ss << "N9 , \\field Maximum Reheat Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Specifies the maximum allowable supply air temperature leaving the reheat coil.\n";
    ss << "\\note If left blank, there is no limit and no default. If unknown, 35C (95F) is recommended.\n";
    ss << "A11; \\field Design Specification Outdoor Air Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "\\note When the name of a DesignSpecification:OutdoorAir object is entered, the terminal\n";
    ss << "\\note unit will increase flow as needed to meet this outdoor air requirement.\n";
    ss << "\\note If Outdoor Air Flow per Person is non-zero, then the outdoor air requirement will\n";
    ss << "\\note be computed based on the current number of occupants in the zone.\n";
    ss << "\\note At no time will the supply air flow rate exceed the value for Maximum Air Flow Rate.\n";
    ss << "\\note If this field is blank, then the terminal unit will not be controlled for outdoor air flow.\n";

    IddObjectType objType(IddObjectType::AirTerminal_SingleDuct_VAV_Reheat);
    OptionalIddObject oObj = IddObject::load("AirTerminal:SingleDuct:VAV:Reheat",
                                             "Zone HVAC Air Loop Terminal Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirTerminal_SingleDuct_VAV_Reheat);
  return object;
}

IddObject createAirTerminal_SingleDuct_VAV_HeatAndCool_ReheatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirTerminal:SingleDuct:VAV:HeatAndCool:Reheat,\n";
    ss << "\\memo Central air system terminal unit, single duct, variable volume for both cooling and\n";
    ss << "\\memo heating, with reheat coil (hot water, electric, gas, or steam).\n";
    ss << "\\min-fields 11\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3,  \\field Damper Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note the outlet node of the damper and the inlet node of the reheat coil\n";
    ss << "\\note this is an internal node to the terminal unit and connects the damper and reheat coil\n";
    ss << "A4,  \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note the inlet node to the terminal unit and the damper\n";
    ss << "N1,  \\field Maximum Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2,  \\field Zone Minimum Air Flow Fraction\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note fraction of maximum air flow\n";
    ss << "A5,  \\field Reheat Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "A6,  \\field Reheat Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N3,  \\field Maximum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when reheat coil type is gas or electric\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N4,  \\field Minimum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when reheat coil type is gas or electric\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "A7,  \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note The outlet node of the terminal unit and the reheat coil.\n";
    ss << "\\note This is also the zone inlet node.\n";
    ss << "N5,  \\field Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "N6; \\field Maximum Reheat Air Temperature\n";
    ss << "\\note Specifies the maximum allowable supply air temperature leaving the reheat coil.\n";
    ss << "\\note If left blank, there is no limit and no default. If unknown, 35C (95F) is recommended.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";

    IddObjectType objType(IddObjectType::AirTerminal_SingleDuct_VAV_HeatAndCool_Reheat);
    OptionalIddObject oObj = IddObject::load("AirTerminal:SingleDuct:VAV:HeatAndCool:Reheat",
                                             "Zone HVAC Air Loop Terminal Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirTerminal_SingleDuct_VAV_HeatAndCool_Reheat);
  return object;
}

IddObject createAirTerminal_SingleDuct_VAV_HeatAndCool_NoReheatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirTerminal:SingleDuct:VAV:HeatAndCool:NoReheat,\n";
    ss << "\\memo Central air system terminal unit, single duct, variable volume for both cooling and\n";
    ss << "\\memo heating, with no reheat coil.\n";
    ss << "\\min-fields 6\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3,  \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note The outlet node of the terminal unit.\n";
    ss << "\\note This is also the zone inlet node.\n";
    ss << "A4,  \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,  \\field Maximum Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2;  \\field Zone Minimum Air Flow Fraction\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note fraction of maximum air flow\n";

    IddObjectType objType(IddObjectType::AirTerminal_SingleDuct_VAV_HeatAndCool_NoReheat);
    OptionalIddObject oObj = IddObject::load("AirTerminal:SingleDuct:VAV:HeatAndCool:NoReheat",
                                             "Zone HVAC Air Loop Terminal Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirTerminal_SingleDuct_VAV_HeatAndCool_NoReheat);
  return object;
}

IddObject createAirTerminal_SingleDuct_SeriesPIU_ReheatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirTerminal:SingleDuct:SeriesPIU:Reheat,\n";
    ss << "\\memo Central air system terminal unit, single duct, variable volume, series powered\n";
    ss << "\\memo induction unit (PIU), with reheat coil (hot water, electric, gas, or steam).\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1,  \\field Maximum Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2,  \\field Maximum Primary Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N3,  \\field Minimum Primary Air Flow Fraction\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\autosizable\n";
    ss << "A3,  \\field Supply Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Secondary Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A5,  \\field Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A6,  \\field Reheat Coil Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A7,  \\field Zone Mixer Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneMixers\n";
    ss << "A8,  \\field Fan Name\n";
    ss << "\\note Fan type must be Fan:ConstantVolume\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCV\n";
    ss << "A9,  \\field Reheat Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "A10, \\field Reheat Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N4,  \\field Maximum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when reheat coil type is gas or electric\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N5,  \\field Minimum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when reheat coil type is gas or electric\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N6;  \\field Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";

    IddObjectType objType(IddObjectType::AirTerminal_SingleDuct_SeriesPIU_Reheat);
    OptionalIddObject oObj = IddObject::load("AirTerminal:SingleDuct:SeriesPIU:Reheat",
                                             "Zone HVAC Air Loop Terminal Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirTerminal_SingleDuct_SeriesPIU_Reheat);
  return object;
}

IddObject createAirTerminal_SingleDuct_ParallelPIU_ReheatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirTerminal:SingleDuct:ParallelPIU:Reheat,\n";
    ss << "\\memo Central air system terminal unit, single duct, variable volume, parallel powered\n";
    ss << "\\memo induction unit (PIU), with reheat coil (hot water, electric, gas, or steam).\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1,  \\field Maximum Primary Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2,  \\field Maximum Secondary Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N3,  \\field Minimum Primary Air Flow Fraction\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\autosizable\n";
    ss << "N4,  \\field Fan On Flow Fraction\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\autosizable\n";
    ss << "\\note the fraction of the primary air flow at which fan turns on\n";
    ss << "A3,  \\field Supply Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Secondary Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A5,  \\field Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A6,  \\field Reheat Coil Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note mixer outlet node\n";
    ss << "A7,  \\field Zone Mixer Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneMixers\n";
    ss << "A8,  \\field Fan Name\n";
    ss << "\\note Fan type must be Fan:ConstantVolume\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCV\n";
    ss << "A9,  \\field Reheat Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "A10, \\field Reheat Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N5,  \\field Maximum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when reheat coil type is gas or electric\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N6,  \\field Minimum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when reheat coil type is gas or electric\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N7;  \\field Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";

    IddObjectType objType(IddObjectType::AirTerminal_SingleDuct_ParallelPIU_Reheat);
    OptionalIddObject oObj = IddObject::load("AirTerminal:SingleDuct:ParallelPIU:Reheat",
                                             "Zone HVAC Air Loop Terminal Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirTerminal_SingleDuct_ParallelPIU_Reheat);
  return object;
}

IddObject createAirTerminal_SingleDuct_ConstantVolume_FourPipeInductionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirTerminal:SingleDuct:ConstantVolume:FourPipeInduction,\n";
    ss << "\\memo Central air system terminal unit, single duct, variable volume, induction unit with\n";
    ss << "\\memo hot water reheat coil and chilled water recool coil.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1,  \\field Maximum Total Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.0\n";
    ss << "N2,  \\field Induction Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 2.5\n";
    ss << "\\note ratio of induced air flow rate to primary air flow rate\n";
    ss << "A3,  \\field Supply Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A4,  \\field Induced Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "\\note should be a zone exhaust node, also the heating coil inlet node\n";
    ss << "A5,  \\field Air Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "\\note should be a zone inlet node\n";
    ss << "A6,  \\field Heating Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "A7,  \\field Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N3,  \\field Maximum Hot Water Flow Rate\n";
    ss << "\\note Not used when heating coil type is gas or electric\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N4,  \\field Minimum Hot Water Flow Rate\n";
    ss << "\\note Not used when heating coil type is gas or electric\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N5,  \\field Heating Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "A8,  \\field Cooling Coil Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:Water\n";
    ss << "\\key Coil:Cooling:Water:DetailedGeometry\n";
    ss << "A9,  \\field Cooling Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilName\n";
    ss << "N6,  \\field Maximum Cold Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N7,  \\field Minimum Cold Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N8,  \\field Cooling Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "A10; \\field Zone Mixer Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneMixers\n";

    IddObjectType objType(IddObjectType::AirTerminal_SingleDuct_ConstantVolume_FourPipeInduction);
    OptionalIddObject oObj = IddObject::load("AirTerminal:SingleDuct:ConstantVolume:FourPipeInduction",
                                             "Zone HVAC Air Loop Terminal Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirTerminal_SingleDuct_ConstantVolume_FourPipeInduction);
  return object;
}

IddObject createAirTerminal_SingleDuct_ConstantVolume_FourPipeBeamIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirTerminal:SingleDuct:ConstantVolume:FourPipeBeam,\n";
    ss << "\\memo Central air system terminal unit, single duct, constant volume,\n";
    ss << "\\memo with heating and/or cooling.\n";
    ss << "\\memo Operates as two-pipe unit if heating or cooling water is omitted.\n";
    ss << "\\memo Heating and/or cooling can be scheduled off for dedicated ventilation.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Primary Air Availability Schedule Name\n";
    ss << "\\note Primary air is supplied by central air handling unit and must be on for heating or cooling.\n";
    ss << "\\note Schedule value > 0 means the primary air supply is available.\n";
    ss << "\\note If this field is blank, the primary air supply is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Cooling Availability Schedule Name\n";
    ss << "\\note Cooling operation can be controlled separately using this availability schedule.\n";
    ss << "\\note Schedule value > 0 means beam cooling is available.\n";
    ss << "\\note If this field is blank, the beam cooling is always available (as long as primary air is also available).\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Heating Availability Schedule Name\n";
    ss << "\\note Heating operation can be controlled separately using this availability schedule.\n";
    ss << "\\note Schedule value > 0 means beam heating is available.\n";
    ss << "\\note If this field is blank, the beam heating is always available (as long as primary air is also available).\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5 , \\field Primary Air Inlet Node Name\n";
    ss << "\\note Name of the air system node for primary supply air entering the air distribution unit.\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A6 , \\field Primary Air Outlet Node Name\n";
    ss << "\\note Name of the air system node for primary supply air leaving the air distribution unit and entering the zone.\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A7 , \\field Chilled Water Inlet Node Name\n";
    ss << "\\note Name of the plant system node for chilled water entering the beam.\n";
    ss << "\\note The two chilled water nodes can (only) be omitted to model a two-pipe heating only beam.\n";
    ss << "\\type node\n";
    ss << "A8 , \\field Chilled Water Outlet Node Name\n";
    ss << "\\note Name of the plant system node for chilled water leaving the beam.\n";
    ss << "\\type node\n";
    ss << "A9 , \\field Hot Water Inlet Node Name\n";
    ss << "\\note Name of the plant system node for hot water entering the beam.\n";
    ss << "\\note The two hot water nodes can (only) be omitted to model a two-pipe cooling-only beam.\n";
    ss << "\\type node\n";
    ss << "A10, \\field Hot Water Outlet Node Name\n";
    ss << "\\note Name of the plant system node for hot water leaving the beam.\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Design Primary Air Volume Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N2 , \\field Design Chilled Water Volume Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N3 , \\field Design Hot Water Volume Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N4 , \\field Zone Total Beam Length\n";
    ss << "\\note Sum of the length of all the beam units in the zone represented by this terminal unit.\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N5 , \\field Rated Primary Air Flow Rate per Beam Length\n";
    ss << "\\note Primary air supply flow rate normalized by beam length.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.035\n";
    ss << "N6 , \\field Beam Rated Cooling Capacity per Beam Length\n";
    ss << "\\note Sensible cooling capacity per meter of beam length at the rating point.\n";
    ss << "\\type real\n";
    ss << "\\units W/m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 600.0\n";
    ss << "N7 , \\field Beam Rated Cooling Room Air Chilled Water Temperature Difference\n";
    ss << "\\note Difference in temperature between the zone air and the entering chilled water at the rating point.\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 10.0\n";
    ss << "N8 , \\field Beam Rated Chilled Water Volume Flow Rate per Beam Length\n";
    ss << "\\note The volume flow rate of chilled water per meter of beam length at the rating point.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m\n";
    ss << "\\ip-units gal/min-ft\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.00005\n";
    ss << "A11, \\field Beam Cooling Capacity Temperature Difference Modification Factor Curve Name\n";
    ss << "\\note Adjusts beam cooling capacity when the temperature difference between entering water and zone air\n";
    ss << "\\note is different than at the rating point.  Single independent variable is the ratio of the current\n";
    ss << "\\note temperature difference divided by the rating point temperature difference.\n";
    ss << "\\note This field is required when beam is connected to a chilled water plant.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A12, \\field Beam Cooling Capacity Air Flow Modification Factor Curve Name\n";
    ss << "\\note Adjusts beam cooling capacity when the primary air supply flow rate is different\n";
    ss << "\\note than at the rating point. The single independent variable is the current normalized\n";
    ss << "\\note air flow rate divided by the normalized air flow rate at the rating point.\n";
    ss << "\\note This field is required when beam is connected to a chilled water plant.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A13, \\field Beam Cooling Capacity Chilled Water Flow Modification Factor Curve Name\n";
    ss << "\\note Adjusts beam cooling capacity when the normalized chilled water flow rate is different\n";
    ss << "\\note than at the rating point. The single independent variable is the current normalized\n";
    ss << "\\note chilled water flow rate divided by the normalized chilled water flow rate at the rating point.\n";
    ss << "\\note This field is required when beam is connected to a chilled water plant.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "N9 , \\field Beam Rated Heating Capacity per Beam Length\n";
    ss << "\\note Sensible heating capacity per meter of beam length at the rating point.\n";
    ss << "\\type real\n";
    ss << "\\units W/m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1500.0\n";
    ss << "N10, \\field Beam Rated Heating Room Air Hot Water Temperature Difference\n";
    ss << "\\note Difference in temperature between the zone air and the entering hot water at the rating point.\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 27.8\n";
    ss << "N11, \\field Beam Rated Hot Water Volume Flow Rate per Beam Length\n";
    ss << "\\note The volume flow rate of hoy water per meter of beam length at the rating point.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m\n";
    ss << "\\ip-units gal/min-ft\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.00005\n";
    ss << "A14, \\field Beam Heating Capacity Temperature Difference Modification Factor Curve Name\n";
    ss << "\\note Adjusts beam heating capacity when the temperature difference between entering water and zone air\n";
    ss << "\\note is different than at the rating point.  Single independent variable is the ratio of the current\n";
    ss << "\\note temperature difference divided by the rating point temperature difference.\n";
    ss << "\\note This field is required when beam is connected to a hot water plant.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A15, \\field Beam Heating Capacity Air Flow Modification Factor Curve Name\n";
    ss << "\\note Adjusts beam heating capacity when the primary air supply flow rate is different\n";
    ss << "\\note than at the rating point. The single independent variable is the current normalized\n";
    ss << "\\note air flow rate divided by the normalized air flow rate at the rating point.\n";
    ss << "\\note This field is required when beam is connected to a hot water plant.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A16; \\field Beam Heating Capacity Hot Water Flow Modification Factor Curve Name\n";
    ss << "\\note Adjusts beam heating capacity when the normalized hot water flow rate is different\n";
    ss << "\\note than at the rating point. The single independent variable is the current normalized\n";
    ss << "\\note hot water flow rate divided by the normalized hot water flow rate at the rating point.\n";
    ss << "\\note This field is required when beam is connected to a hot water plant.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";

    IddObjectType objType(IddObjectType::AirTerminal_SingleDuct_ConstantVolume_FourPipeBeam);
    OptionalIddObject oObj = IddObject::load("AirTerminal:SingleDuct:ConstantVolume:FourPipeBeam",
                                             "Zone HVAC Air Loop Terminal Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirTerminal_SingleDuct_ConstantVolume_FourPipeBeam);
  return object;
}

IddObject createAirTerminal_SingleDuct_ConstantVolume_CooledBeamIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirTerminal:SingleDuct:ConstantVolume:CooledBeam,\n";
    ss << "\\memo Central air system terminal unit, single duct, constant volume, with cooled beam\n";
    ss << "\\memo (active or passive).\n";
    ss << "\\min-fields 23\n";
    ss << "\\min-fields 23\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Cooled Beam Type\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Active\n";
    ss << "\\key Passive\n";
    ss << "A4 , \\field Supply Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A5 , \\field Supply Air Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A6 , \\field Chilled Water Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A7 , \\field Chilled Water Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field Supply Air Volumetric Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N2,  \\field Maximum Total Chilled Water Volumetric Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N3 , \\field Number of Beams\n";
    ss << "\\note Number of individual beam units in the zone\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N4 , \\field Beam Length\n";
    ss << "\\note Length of an individual beam unit\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N5 , \\field Design Inlet Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 15.0\n";
    ss << "N6 , \\field Design Outlet Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 17.0\n";
    ss << "N7 , \\field Coil Surface Area per Coil Length\n";
    ss << "\\type real\n";
    ss << "\\units m2/m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 5.422\n";
    ss << "N8 , \\field Model Parameter a\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 15.3\n";
    ss << "N9 , \\field Model Parameter n1\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N10, \\field Model Parameter n2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.84\n";
    ss << "N11, \\field Model Parameter n3\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.12\n";
    ss << "N12, \\field Model Parameter a0\n";
    ss << "\\note Free area of the coil in plan view per unit beam length\n";
    ss << "\\type real\n";
    ss << "\\units m2/m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.171\n";
    ss << "N13, \\field Model Parameter K1\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0057\n";
    ss << "N14, \\field Model Parameter n\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.4\n";
    ss << "N15, \\field Coefficient of Induction Kin\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 4.0\n";
    ss << "\\default Autocalculate\n";
    ss << "N16; \\field Leaving Pipe Inside Diameter\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.0145\n";

    IddObjectType objType(IddObjectType::AirTerminal_SingleDuct_ConstantVolume_CooledBeam);
    OptionalIddObject oObj = IddObject::load("AirTerminal:SingleDuct:ConstantVolume:CooledBeam",
                                             "Zone HVAC Air Loop Terminal Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirTerminal_SingleDuct_ConstantVolume_CooledBeam);
  return object;
}

IddObject createAirTerminal_SingleDuct_InletSideMixerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirTerminal:SingleDuct:InletSideMixer,\n";
    ss << "\\memo The inlet side mixer air terminal unit provides a means of supplying central system air\n";
    ss << "\\memo to the air inlet of a zone AC unit such as a four pipe fan coil. Normally the central air\n";
    ss << "\\memo would be ventilation air from a dedicated outdoor air system (DOAS).\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field ZoneHVAC Terminal Unit Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key ZoneHVAC:FourPipeFanCoil\n";
    ss << "\\key ZoneHVAC:WaterToAirHeatPump\n";
    ss << "A3, \\field ZoneHVAC Terminal Unit Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DOAToZonalUnit\n";
    ss << "A4, \\field Terminal Unit Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5, \\field Terminal Unit Primary Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6; \\field Terminal Unit Secondary Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::AirTerminal_SingleDuct_InletSideMixer);
    OptionalIddObject oObj = IddObject::load("AirTerminal:SingleDuct:InletSideMixer",
                                             "Zone HVAC Air Loop Terminal Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirTerminal_SingleDuct_InletSideMixer);
  return object;
}

IddObject createAirTerminal_SingleDuct_SupplySideMixerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirTerminal:SingleDuct:SupplySideMixer,\n";
    ss << "\\memo The supply side mixer air terminal unit provides a means of supplying central system air\n";
    ss << "\\memo to the air outlet of a zone AC unit such as a four pipe fan coil. Normally the central air\n";
    ss << "\\memo would be ventilation air from a dedicated outdoor air system (DOAS).\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field ZoneHVAC Terminal Unit Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key ZoneHVAC:FourPipeFanCoil\n";
    ss << "\\key ZoneHVAC:WaterToAirHeatPump\n";
    ss << "A3, \\field ZoneHVAC Terminal Unit Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DOAToZonalUnit\n";
    ss << "A4, \\field Terminal Unit Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5, \\field Terminal Unit Primary Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6; \\field Terminal Unit Secondary Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::AirTerminal_SingleDuct_SupplySideMixer);
    OptionalIddObject oObj = IddObject::load("AirTerminal:SingleDuct:SupplySideMixer",
                                             "Zone HVAC Air Loop Terminal Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirTerminal_SingleDuct_SupplySideMixer);
  return object;
}

IddObject createAirTerminal_DualDuct_ConstantVolumeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirTerminal:DualDuct:ConstantVolume,\n";
    ss << "\\memo Central air system terminal unit, dual duct, constant volume.\n";
    ss << "\\min-fields 6\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note The outlet node of the terminal unit.\n";
    ss << "\\note This is also the zone inlet node.\n";
    ss << "A4 , \\field Hot Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Cold Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 ; \\field Maximum Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";

    IddObjectType objType(IddObjectType::AirTerminal_DualDuct_ConstantVolume);
    OptionalIddObject oObj = IddObject::load("AirTerminal:DualDuct:ConstantVolume",
                                             "Zone HVAC Air Loop Terminal Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirTerminal_DualDuct_ConstantVolume);
  return object;
}

IddObject createAirTerminal_DualDuct_VAVIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirTerminal:DualDuct:VAV,\n";
    ss << "\\memo Central air system terminal unit, dual duct, variable volume.\n";
    ss << "\\min-fields 7\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note The outlet node of the terminal unit.\n";
    ss << "\\note This is also the zone inlet node.\n";
    ss << "A4 , \\field Hot Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Cold Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Maximum Damper Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Zone Minimum Air Flow Fraction\n";
    ss << "\\note fraction of maximum air flow\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.2\n";
    ss << "A6 ; \\field Design Specification Outdoor Air Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "\\note When the name of a DesignSpecification:OutdoorAir object is entered, the terminal\n";
    ss << "\\note unit will increase flow as needed to meet this outdoor air requirement.\n";
    ss << "\\note If Outdoor Air Flow per Person is non-zero, then the outdoor air requirement will\n";
    ss << "\\note be computed based on the current number of occupants in the zone.\n";
    ss << "\\note At no time will the supply air flow rate exceed the value for Maximum Air Flow Rate.\n";
    ss << "\\note If this field is blank, then the terminal unit will not be controlled for outdoor air flow.\n";

    IddObjectType objType(IddObjectType::AirTerminal_DualDuct_VAV);
    OptionalIddObject oObj = IddObject::load("AirTerminal:DualDuct:VAV",
                                             "Zone HVAC Air Loop Terminal Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirTerminal_DualDuct_VAV);
  return object;
}

IddObject createAirTerminal_DualDuct_VAV_OutdoorAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirTerminal:DualDuct:VAV:OutdoorAir,\n";
    ss << "\\memo Central air system terminal unit, dual duct, variable volume with special controls.\n";
    ss << "\\memo One VAV duct is controlled to supply ventilation air and the other VAV duct is\n";
    ss << "\\memo controlled to meet the zone cooling load.\n";
    ss << "\\min-fields 7\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\note The outlet node of the terminal unit.\n";
    ss << "\\note This is also the zone inlet node.\n";
    ss << "A4 , \\field Outdoor Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Recirculated Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Maximum Terminal Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note If autosized this is the sum of flow needed for cooling and maximum required outdoor air\n";
    ss << "A6 , \\field Design Specification Outdoor Air Object Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "\\note When the name of a DesignSpecification:OutdoorAir object is entered, the terminal\n";
    ss << "\\note unit will increase flow as needed to meet this outdoor air requirement.\n";
    ss << "\\note If Outdoor Air Flow per Person is non-zero, then the outdoor air requirement will\n";
    ss << "\\note be computed based mode selected in the next field.\n";
    ss << "\\note At no time will the supply air flow rate exceed the value for Maximum Air Flow Rate.\n";
    ss << "A7 ; \\field Per Person Ventilation Rate Mode\n";
    ss << "\\type choice\n";
    ss << "\\key CurrentOccupancy\n";
    ss << "\\key DesignOccupancy\n";
    ss << "\\note CurrentOccupancy models demand controlled ventilation using the current number of people\n";
    ss << "\\note DesignOccupancy uses the total Number of People in the zone and is constant\n";

    IddObjectType objType(IddObjectType::AirTerminal_DualDuct_VAV_OutdoorAir);
    OptionalIddObject oObj = IddObject::load("AirTerminal:DualDuct:VAV:OutdoorAir",
                                             "Zone HVAC Air Loop Terminal Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirTerminal_DualDuct_VAV_OutdoorAir);
  return object;
}

IddObject createZoneHVAC_AirDistributionUnitIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:AirDistributionUnit,\n";
    ss << "\\memo Central air system air distribution unit, serves as a wrapper for a specific type of\n";
    ss << "\\memo air terminal unit. This object is referenced in a ZoneHVAC:EquipmentList.\n";
    ss << "\\min-fields 4\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Air Distribution Unit Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3 , \\field Air Terminal Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirTerminal:DualDuct:ConstantVolume\n";
    ss << "\\key AirTerminal:DualDuct:VAV\n";
    ss << "\\key AirTerminal:SingleDuct:ConstantVolume:Reheat\n";
    ss << "\\key AirTerminal:SingleDuct:VAV:Reheat\n";
    ss << "\\key AirTerminal:SingleDuct:VAV:NoReheat\n";
    ss << "\\key AirTerminal:SingleDuct:SeriesPIU:Reheat\n";
    ss << "\\key AirTerminal:SingleDuct:ParallelPIU:Reheat\n";
    ss << "\\key AirTerminal:SingleDuct:ConstantVolume:FourPipeInduction\n";
    ss << "\\key AirTerminal:SingleDuct:VAV:Reheat:VariableSpeedFan\n";
    ss << "\\key AirTerminal:SingleDuct:VAV:HeatAndCool:Reheat\n";
    ss << "\\key AirTerminal:SingleDuct:VAV:HeatAndCool:NoReheat\n";
    ss << "\\key AirTerminal:SingleDuct:ConstantVolume:CooledBeam\n";
    ss << "\\key AirTerminal:DualDuct:VAV:OutdoorAir\n";
    ss << "\\key AirTerminal:SingleDuct:UserDefined\n";
    ss << "\\required-field\n";
    ss << "A4 , \\field Air Terminal Name\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field Nominal Upstream Leakage Fraction\n";
    ss << "\\note fraction at system design Flow; leakage Flow constant, leakage fraction\n";
    ss << "\\note varies with variable system Flow Rate.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 0.3\n";
    ss << "\\default 0\n";
    ss << "N2 ; \\field Constant Downstream Leakage Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 0.3\n";
    ss << "\\default 0\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_AirDistributionUnit);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:AirDistributionUnit",
                                             "Zone HVAC Air Loop Terminal Units",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_AirDistributionUnit);
  return object;
}

IddObject createZoneHVAC_EquipmentListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:EquipmentList,\n";
    ss << "\\extensible:4 Duplicate the four fields Zone Equipment Object Type through Heating Priority\n";
    ss << "\\memo List equipment in simulation order.  Note that an ZoneHVAC:AirDistributionUnit or\n";
    ss << "\\memo AirTerminal:SingleDuct:Uncontrolled object must be listed in this statement if there is a forced\n";
    ss << "\\memo air system serving the zone from the air loop.\n";
    ss << "\\memo Equipment is simulated in the order specified by Zone Equipment Cooling Sequence and\n";
    ss << "\\memo Zone Equipment Heating or No-Load Sequence, depending on the thermostat request.\n";
    ss << "\\memo For equipment of similar type, assign sequence 1 to the first system intended to\n";
    ss << "\\memo serve that type of load.  For situations where one or more equipment types has limited capacity or\n";
    ss << "\\memo limited control, order the sequence so that the most controllable piece of equipment runs last.\n";
    ss << "\\memo For example, with a dedicated outdoor air system (DOAS), the air terminal for the DOAS\n";
    ss << "\\memo should be assigned Heating Sequence = 1 and Cooling Sequence = 1.  Any other equipment should\n";
    ss << "\\memo be assigned sequence 2 or higher so that it will see the net load after the DOAS air is added\n";
    ss << "\\memo to the zone.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ZoneEquipmentLists\n";
    ss << "A2 , \\field Zone Equipment 1 Object Type\n";
    ss << "\\begin-extensible\n";
    ss << "\\type choice\n";
    ss << "\\key ZoneHVAC:TerminalUnit:VariableRefrigerantFlow\n";
    ss << "\\key ZoneHVAC:AirDistributionUnit\n";
    ss << "\\key AirTerminal:SingleDuct:Uncontrolled\n";
    ss << "\\key ZoneHVAC:EnergyRecoveryVentilator\n";
    ss << "\\key ZoneHVAC:EvaporativeCoolerUnit\n";
    ss << "\\key ZoneHVAC:FourPipeFanCoil\n";
    ss << "\\key ZoneHVAC:OutdoorAirUnit\n";
    ss << "\\key ZoneHVAC:PackagedTerminalAirConditioner\n";
    ss << "\\key ZoneHVAC:PackagedTerminalHeatPump\n";
    ss << "\\key ZoneHVAC:UnitHeater\n";
    ss << "\\key ZoneHVAC:UnitVentilator\n";
    ss << "\\key ZoneHVAC:VentilatedSlab\n";
    ss << "\\key ZoneHVAC:WaterToAirHeatPump\n";
    ss << "\\key ZoneHVAC:WindowAirConditioner\n";
    ss << "\\key ZoneHVAC:Baseboard:RadiantConvective:Electric\n";
    ss << "\\key ZoneHVAC:Baseboard:RadiantConvective:Water\n";
    ss << "\\key ZoneHVAC:Baseboard:RadiantConvective:Steam\n";
    ss << "\\key ZoneHVAC:Baseboard:Convective:Electric\n";
    ss << "\\key ZoneHVAC:Baseboard:Convective:Water\n";
    ss << "\\key ZoneHVAC:HighTemperatureRadiant\n";
    ss << "\\key ZoneHVAC:LowTemperatureRadiant:VariableFlow\n";
    ss << "\\key ZoneHVAC:LowTemperatureRadiant:ConstantFlow\n";
    ss << "\\key ZoneHVAC:LowTemperatureRadiant:Electric\n";
    ss << "\\key ZoneHVAC:Dehumidifier:DX\n";
    ss << "\\key ZoneHVAC:IdealLoadsAirSystem\n";
    ss << "\\key ZoneHVAC:RefrigerationChillerSet\n";
    ss << "\\key Fan:ZoneExhaust\n";
    ss << "\\key WaterHeater:HeatPump:PumpedCondenser\n";
    ss << "\\key WaterHeater:HeatPump:WrappedCondenser\n";
    ss << "\\required-field\n";
    ss << "A3 , \\field Zone Equipment 1 Name\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field Zone Equipment 1 Cooling Sequence\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\note Specifies the zone equipment simulation order\n";
    ss << "\\note when the zone thermostat requests cooling\n";
    ss << "N2 ; \\field Zone Equipment 1 Heating or No-Load Sequence\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\note Specifies the zone equipment simulation order\n";
    ss << "\\note when the zone thermostat requests heating or no load\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_EquipmentList);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:EquipmentList",
                                             "Zone HVAC Equipment Connections",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_EquipmentList);
  return object;
}

IddObject createZoneHVAC_EquipmentConnectionsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:EquipmentConnections,\n";
    ss << "\\memo Specifies the HVAC equipment connections for a zone. Node names are specified for the\n";
    ss << "\\memo zone air node, air inlet nodes, air exhaust nodes, and the air return node. A zone\n";
    ss << "\\memo equipment list is referenced which lists all HVAC equipment connected to the zone.\n";
    ss << "A1 , \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A2 , \\field Zone Conditioning Equipment List Name\n";
    ss << "\\note Enter the name of a ZoneHVAC:EquipmentList object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneEquipmentLists\n";
    ss << "A3 , \\field Zone Air Inlet Node or NodeList Name\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Zone Air Exhaust Node or NodeList Name\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Zone Air Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6 , \\field Zone Return Air Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7 , \\field Zone Return Air Flow Rate Fraction Schedule Name\n";
    ss << "\\note This schedule is multiplied times the base return air flow rate.\n";
    ss << "\\note If this field is left blank, the schedule defaults to 1.0 at all times.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A8 ; \\field Zone Return Air Flow Rate Basis Node or NodeList Name\n";
    ss << "\\note The optional basis node(s) used to calculate the base return air flow\n";
    ss << "\\note rate for this zone. The return air flow rate is the sum of the flow rates\n";
    ss << "\\note at the basis node(s) multiplied by the Zone Return Air Flow Rate Fraction Schedule.\n";
    ss << "\\note If this  field is blank, then the base return air flow rate is the total supply\n";
    ss << "\\note inlet flow rate to the zone less the total exhaust node flow rate from the zone.\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_EquipmentConnections);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:EquipmentConnections",
                                             "Zone HVAC Equipment Connections",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_EquipmentConnections);
  return object;
}

IddObject createFan_ConstantVolumeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Fan:ConstantVolume,\n";
    ss << "\\memo Constant volume fan that is intended to operate continuously based on a time schedule.\n";
    ss << "\\memo This fan will not cycle on and off based on cooling/heating load or other control\n";
    ss << "\\memo signals.\n";
    ss << "\\min-fields 9\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference Fans\n";
    ss << "\\reference FansCV\n";
    ss << "\\reference FansCVandOnOff\n";
    ss << "\\reference FansCVandVAV\n";
    ss << "\\reference FansCVandOnOffandVAV\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Fan Total Efficiency\n";
    ss << "\\type real\n";
    ss << "\\default 0.7\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N2 , \\field Pressure Rise\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field Maximum Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N4 , \\field Motor Efficiency\n";
    ss << "\\type real\n";
    ss << "\\default 0.9\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N5 , \\field Motor In Airstream Fraction\n";
    ss << "\\note 0.0 means fan motor outside of air stream, 1.0 means motor inside of air stream\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A5 ; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::Fan_ConstantVolume);
    OptionalIddObject oObj = IddObject::load("Fan:ConstantVolume",
                                             "Fans",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Fan_ConstantVolume);
  return object;
}

IddObject createFan_VariableVolumeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Fan:VariableVolume,\n";
    ss << "\\memo Variable air volume fan where the electric power input varies according to a\n";
    ss << "\\memo performance curve as a function of flow fraction.\n";
    ss << "\\min-fields 17\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference Fans\n";
    ss << "\\reference FansVAV\n";
    ss << "\\reference FansCVandVAV\n";
    ss << "\\reference FansOnOffandVAV\n";
    ss << "\\reference FansCVandOnOffandVAV\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Fan Total Efficiency\n";
    ss << "\\type real\n";
    ss << "\\default 0.7\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N2 , \\field Pressure Rise\n";
    ss << "\\required-field\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "N3 , \\field Maximum Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "A3 , \\field Fan Power Minimum Flow Rate Input Method\n";
    ss << "\\type choice\n";
    ss << "\\key Fraction\n";
    ss << "\\key FixedFlowRate\n";
    ss << "\\default Fraction\n";
    ss << "N4 , \\field Fan Power Minimum Flow Fraction\n";
    ss << "\\type real\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.25\n";
    ss << "N5 , \\field Fan Power Minimum Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "N6 , \\field Motor Efficiency\n";
    ss << "\\type real\n";
    ss << "\\default 0.9\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N7 , \\field Motor In Airstream Fraction\n";
    ss << "\\note 0.0 means fan motor outside of air stream, 1.0 means motor inside of air stream\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N8 , \\field Fan Power Coefficient 1\n";
    ss << "\\note all Fan Power Coefficients should not be 0.0 or no fan power will be consumed.\n";
    ss << "\\note Fan Power Coefficents are specified as function of full flow rate/power\n";
    ss << "\\note Equation:\n";
    ss << "N9 , \\field Fan Power Coefficient 2\n";
    ss << "N10, \\field Fan Power Coefficient 3\n";
    ss << "N11, \\field Fan Power Coefficient 4\n";
    ss << "N12, \\field Fan Power Coefficient 5\n";
    ss << "A4 , \\field Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Air Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A6 ; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::Fan_VariableVolume);
    OptionalIddObject oObj = IddObject::load("Fan:VariableVolume",
                                             "Fans",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Fan_VariableVolume);
  return object;
}

IddObject createFan_OnOffIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Fan:OnOff,\n";
    ss << "\\memo Constant volume fan that is intended to cycle on and off based on cooling/heating load\n";
    ss << "\\memo or other control signals. This fan can also operate continuously like\n";
    ss << "\\memo Fan:ConstantVolume.\n";
    ss << "\\min-fields 9\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference Fans\n";
    ss << "\\reference FansCVandOnOff\n";
    ss << "\\reference FansOnOff\n";
    ss << "\\reference FansOnOffandVAV\n";
    ss << "\\reference FansCVandOnOffandVAV\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Fan Total Efficiency\n";
    ss << "\\type real\n";
    ss << "\\default 0.6\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N2 , \\field Pressure Rise\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field Maximum Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N4 , \\field Motor Efficiency\n";
    ss << "\\type real\n";
    ss << "\\default 0.8\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N5 , \\field Motor In Airstream Fraction\n";
    ss << "\\note 0.0 means fan motor outside of air stream, 1.0 means motor inside of air stream\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Fan Power Ratio Function of Speed Ratio Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ExponentCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A6 , \\field Fan Efficiency Ratio Function of Speed Ratio Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A7 ; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::Fan_OnOff);
    OptionalIddObject oObj = IddObject::load("Fan:OnOff",
                                             "Fans",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Fan_OnOff);
  return object;
}

IddObject createFan_ZoneExhaustIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Fan:ZoneExhaust,\n";
    ss << "\\memo Models a fan that exhausts air from a zone.\n";
    ss << "\\min-fields 7\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference FansZoneExhaust\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Fan Total Efficiency\n";
    ss << "\\type real\n";
    ss << "\\default 0.6\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N2 , \\field Pressure Rise\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field Maximum Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A5 , \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";
    ss << "A6 , \\field Flow Fraction Schedule Name\n";
    ss << "\\note If field is used, then when fan runs the exhausted air flow rate is controlled to be the scheduled fraction times the Maximum Flow Rate\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A7 , \\field System Availability Manager Coupling Mode\n";
    ss << "\\note Control if fan is to be interlocked with HVAC system Availability Managers or not.\n";
    ss << "\\type choice\n";
    ss << "\\key Coupled\n";
    ss << "\\key Decoupled\n";
    ss << "\\default Coupled\n";
    ss << "A8 , \\field Minimum Zone Temperature Limit Schedule Name\n";
    ss << "\\note If field is used, the exhaust fan will not run if the zone temperature is lower than this limit\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A9 ; \\field Balanced Exhaust Fraction Schedule Name\n";
    ss << "\\note Used to control fan's impact on flow at the return air node. Enter the portion of the exhaust that is balanced by simple airflows.\n";
    ss << "\\note\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::Fan_ZoneExhaust);
    OptionalIddObject oObj = IddObject::load("Fan:ZoneExhaust",
                                             "Fans",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Fan_ZoneExhaust);
  return object;
}

IddObject createFanPerformance_NightVentilationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FanPerformance:NightVentilation,\n";
    ss << "\\memo Specifies an alternate set of performance parameters for a fan. These alternate\n";
    ss << "\\memo parameters are used when a system manager (such as AvailabilityManager:NightVentilation)\n";
    ss << "\\memo sets a specified flow rate.  May be used with any type of fan except not with\n";
    ss << "\\memo Fan:ComponentModel. If the fan model senses that a fixed flow rate has been set, it\n";
    ss << "\\memo will use these alternate performance parameters. It is assumed that the fan will\n";
    ss << "\\memo run at a fixed speed in the alternate mode.\n";
    ss << "A1 , \\field Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandVAV\n";
    ss << "N1 , \\field Fan Total Efficiency\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N2 , \\field Pressure Rise\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field Maximum Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N4 , \\field Motor Efficiency\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1.0\n";
    ss << "N5 ; \\field Motor in Airstream Fraction\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note 0.0 means fan motor outside of airstream\n";
    ss << "\\note 1.0 means fan motor inside of airstream\n";

    IddObjectType objType(IddObjectType::FanPerformance_NightVentilation);
    OptionalIddObject oObj = IddObject::load("FanPerformance:NightVentilation",
                                             "Fans",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FanPerformance_NightVentilation);
  return object;
}

IddObject createFan_ComponentModelIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Fan:ComponentModel,\n";
    ss << "\\memo A detailed fan type for constant-air-volume (CAV) and variable-air-volume (VAV)\n";
    ss << "\\memo systems. It includes inputs that describe the air-distribution system as well as the\n";
    ss << "\\memo fan, drive belt (if used), motor, and variable-frequency-drive (if used).\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference Fans\n";
    ss << "A2 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Maximum Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Minimum Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N3 , \\field Fan Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\minimum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Applied to specified or autosized max fan airflow\n";
    ss << "N4 , \\field Fan Wheel Diameter\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Diameter of wheel outer circumference\n";
    ss << "N5 , \\field Fan Outlet Area\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m2\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Area at fan outlet plane for determining discharge velocity pressure\n";
    ss << "N6 , \\field Maximum Fan Static Efficiency\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note Maximum ratio between power delivered to air and fan shaft input power\n";
    ss << "\\note Determined from fan performance data\n";
    ss << "N7 , \\field Euler Number at Maximum Fan Static Efficiency\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Euler number (Eu) determined from fan performance data\n";
    ss << "N8 , \\field Maximum Dimensionless Fan Airflow\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Corresponds to maximum ratio between fan airflow and\n";
    ss << "\\note fan shaft rotational speed for specified fan wheel diameter\n";
    ss << "\\note Determined from fan performance data\n";
    ss << "N9 , \\field Motor Fan Pulley Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Ratio of motor pulley diameter to fan pulley diameter\n";
    ss << "N10 , \\field Belt Maximum Torque\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units N-m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Maximum torque transmitted by belt\n";
    ss << "N11 , \\field Belt Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\minimum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Applied to specified or autosized max torque transmitted by belt\n";
    ss << "N12 , \\field Belt Fractional Torque Transition\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.167\n";
    ss << "\\note Region 1 to 2 curve transition for belt normalized efficiency\n";
    ss << "N13 , \\field Motor Maximum Speed\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units rev/min\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Maximum rotational speed of fan motor shaft\n";
    ss << "N14 , \\field Maximum Motor Output Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Maximum power input to drive belt by motor\n";
    ss << "N15 , \\field Motor Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\minimum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Applied to specified or autosized motor output power\n";
    ss << "N16 , \\field Motor In Airstream Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note 0.0 means motor outside air stream\n";
    ss << "\\note 1.0 means motor inside air stream\n";
    ss << "A5 , \\field VFD Efficiency Type\n";
    ss << "\\type choice\n";
    ss << "\\key Speed\n";
    ss << "\\key Power\n";
    ss << "\\note Efficiency depends on fraction of full-load motor speed\n";
    ss << "\\note Efficiency depends on  fraction of full-load motor input power\n";
    ss << "\\note If field blank, then assumes constant VFD efficiency (0.97)\n";
    ss << "N17 , \\field Maximum VFD Output Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Maximum power input to motor by VFD\n";
    ss << "N18 , \\field VFD Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\minimum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Applied to specified or autosized VFD output power\n";
    ss << "A6 , \\field Fan Pressure Rise Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FanPressureRiseCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Pressure rise depends on volumetric flow, system resistances,\n";
    ss << "\\note system leakage, and duct static pressure set point\n";
    ss << "A7 , \\field Duct Static Pressure Reset Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Function of fan volumetric flow\n";
    ss << "\\note Minimum and maximum fan airflows correspond respectively to\n";
    ss << "\\note minimum and maximum duct static pressure set points\n";
    ss << "A8 , \\field Normalized Fan Static Efficiency Curve Name-Non-Stall Region\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ExponentialSkewNormalCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note xfan <= 0\n";
    ss << "\\note Curve should have maximum of 1.0\n";
    ss << "A9 , \\field Normalized Fan Static Efficiency Curve Name-Stall Region\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ExponentialSkewNormalCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note xfan > 0\n";
    ss << "\\note Curve should have maximum of 1.0\n";
    ss << "A10 , \\field Normalized Dimensionless Airflow Curve Name-Non-Stall Region\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SigmoidCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note xspd <= 0\n";
    ss << "\\note Curve should have maximum of 1.0\n";
    ss << "A11 , \\field Normalized Dimensionless Airflow Curve Name-Stall Region\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SigmoidCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note xspd > 0\n";
    ss << "\\note Curve should have maximum of 1.0\n";
    ss << "A12 , \\field Maximum Belt Efficiency Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuarticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Determines maximum fan drive belt efficiency in log space\n";
    ss << "\\note as function of xbelt,max\n";
    ss << "\\note Curve should have minimum of -4.6 and maximum of 0.0\n";
    ss << "\\note If field blank, assumes output of curve is always 1.0\n";
    ss << "A13 , \\field Normalized Belt Efficiency Curve Name - Region 1\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RectangularHyperbola2Curves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Region 1 (0 <= xbelt < xbelt,trans)\n";
    ss << "\\note Curve should have minimum > 0.0 and maximum of 1.0\n";
    ss << "\\note If field blank, assumes output of curve is always 1.0 in Region 1\n";
    ss << "A14 , \\field Normalized Belt Efficiency Curve Name - Region 2\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ExponentialDecayCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Region 2 (xbelt,trans <= xbelt <= 1)\n";
    ss << "\\note Curve should have minimum > 0.0 and maximum of 1.0\n";
    ss << "\\note If field blank, assumes output of curve is always 1.0 in Region 2\n";
    ss << "A15 , \\field Normalized Belt Efficiency Curve Name - Region 3\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RectangularHyperbola2Curves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Determines normalized drive belt efficiency Region 3 (xbelt > 1)\n";
    ss << "\\note Curve should have minimum > 0.0 and maximum of 1.0\n";
    ss << "\\note If field blank, assumes output of curve is always 1.0 in Region 3\n";
    ss << "A16 , \\field Maximum Motor Efficiency Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RectangularHyperbola1Curves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Curve should have minimum > 0.0 and maximum of 1.0\n";
    ss << "\\note If field blank, assumes output of curve is always 1.0\n";
    ss << "A17 , \\field Normalized Motor Efficiency Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RectangularHyperbola2Curves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Curve should have minimum > 0.0 and maximum of 1.0\n";
    ss << "\\note If field blank, assumes output of curve is always 1.0\n";
    ss << "A18 , \\field VFD Efficiency Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RectangularHyperbola2Curves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Determines VFD efficiency as function of motor load or speed fraction\n";
    ss << "\\note Curve should have minimum > 0.0 and maximum of 1.0\n";
    ss << "\\note If field blank, assumes constant VFD efficiency (0.97)\n";
    ss << "A19 ; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::Fan_ComponentModel);
    OptionalIddObject oObj = IddObject::load("Fan:ComponentModel",
                                             "Fans",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Fan_ComponentModel);
  return object;
}

IddObject createCoil_Cooling_WaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Cooling:Water,\n";
    ss << "\\memo Chilled water cooling coil, NTU-effectiveness model, with inputs for design entering\n";
    ss << "\\memo and leaving conditions.\n";
    ss << "\\min-fields 15\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CoolingCoilName\n";
    ss << "\\reference CoolingCoilsWater\n";
    ss << "\\reference CoolingCoilsWaterNoHX\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "\\reference SimpleCoils\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Design Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\minimum 0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N2 , \\field Design Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\minimum 0\n";
    ss << "N3 , \\field Design Inlet Water Temperature\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\minimum> 0\n";
    ss << "N4 , \\field Design Inlet Air Temperature\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\minimum> 0\n";
    ss << "N5 , \\field Design Outlet Air Temperature\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\minimum> 0\n";
    ss << "N6 , \\field Design Inlet Air Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\minimum 0\n";
    ss << "N7 , \\field Design Outlet Air Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\minimum 0\n";
    ss << "A3 , \\field Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7 , \\field Type of Analysis\n";
    ss << "\\type choice\n";
    ss << "\\key SimpleAnalysis\n";
    ss << "\\key DetailedAnalysis\n";
    ss << "\\default SimpleAnalysis\n";
    ss << "A8 , \\field Heat Exchanger Configuration\n";
    ss << "\\type choice\n";
    ss << "\\key CrossFlow\n";
    ss << "\\key CounterFlow\n";
    ss << "\\default CrossFlow\n";
    ss << "A9;  \\field Condensate Collection Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";

    IddObjectType objType(IddObjectType::Coil_Cooling_Water);
    OptionalIddObject oObj = IddObject::load("Coil:Cooling:Water",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Cooling_Water);
  return object;
}

IddObject createCoil_Cooling_Water_DetailedGeometryIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Cooling:Water:DetailedGeometry,\n";
    ss << "\\memo Chilled water cooling coil, detailed flat fin coil model for continuous plate fins,\n";
    ss << "\\memo with inputs for detailed coil geometry specifications.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CoolingCoilName\n";
    ss << "\\reference CoolingCoilsWater\n";
    ss << "\\reference CoolingCoilsWaterNoHX\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Maximum Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\ip-units gal/min\n";
    ss << "N2 , \\field Tube Outside Surface Area\n";
    ss << "\\units m2\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\note Tube Primary Surface Area\n";
    ss << "N3 , \\field Total Tube Inside Area\n";
    ss << "\\units m2\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\note Total tube inside surface area\n";
    ss << "\\minimum> 0.0\n";
    ss << "N4 , \\field Fin Surface Area\n";
    ss << "\\units m2\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N5 , \\field Minimum Airflow Area\n";
    ss << "\\units m2\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\minimum> 0.0\n";
    ss << "N6 , \\field Coil Depth\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m\n";
    ss << "\\ip-units in\n";
    ss << "\\minimum> 0.0\n";
    ss << "N7 , \\field Fin Diameter\n";
    ss << "\\units m\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\note Fin diameter or the coil height\n";
    ss << "\\ip-units in\n";
    ss << "\\minimum> 0.0\n";
    ss << "N8 , \\field Fin Thickness\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\ip-units in\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default .0015\n";
    ss << "N9 , \\field Tube Inside Diameter\n";
    ss << "\\units m\n";
    ss << "\\note Inner diameter of tubes\n";
    ss << "\\ip-units in\n";
    ss << "\\default .01445\n";
    ss << "\\minimum> 0.0\n";
    ss << "N10, \\field Tube Outside Diameter\n";
    ss << "\\units m\n";
    ss << "\\note Outer diameter of tubes\n";
    ss << "\\ip-units in\n";
    ss << "\\default .0159\n";
    ss << "\\minimum> 0.0\n";
    ss << "N11, \\field Tube Thermal Conductivity\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum 1.0\n";
    ss << "\\default 386.0\n";
    ss << "N12, \\field Fin Thermal Conductivity\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum 1.0\n";
    ss << "\\default 204.0\n";
    ss << "N13, \\field Fin Spacing\n";
    ss << "\\units m\n";
    ss << "\\note Fin spacing or distance\n";
    ss << "\\ip-units in\n";
    ss << "\\default .0018\n";
    ss << "\\minimum> 0.0\n";
    ss << "N14, \\field Tube Depth Spacing\n";
    ss << "\\units m\n";
    ss << "\\ip-units in\n";
    ss << "\\default .026\n";
    ss << "\\minimum> 0.0\n";
    ss << "N15, \\field Number of Tube Rows\n";
    ss << "\\default 4\n";
    ss << "\\minimum> 0.0\n";
    ss << "N16, \\field Number of Tubes per Row\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\minimum> 0.0\n";
    ss << "A3 , \\field Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7 ; \\field Condensate Collection Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";

    IddObjectType objType(IddObjectType::Coil_Cooling_Water_DetailedGeometry);
    OptionalIddObject oObj = IddObject::load("Coil:Cooling:Water:DetailedGeometry",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Cooling_Water_DetailedGeometry);
  return object;
}

IddObject createCoil_Cooling_DX_SingleSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Cooling:DX:SingleSpeed,\n";
    ss << "\\memo Direct expansion (DX) cooling coil and condensing unit (includes electric compressor\n";
    ss << "\\memo and condenser fan), single-speed. Optional inputs for moisture evaporation from wet\n";
    ss << "\\memo coil when compressor cycles off with continuous fan operation.\n";
    ss << "\\min-fields 14\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingCoilsDX\n";
    ss << "\\reference CoolingCoilsDXSingleSpeed\n";
    ss << "\\reference CoolingCoilsDXMultiModeOrSingleSpeed\n";
    ss << "\\reference DesuperHeatingCoilSources\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Gross Rated Total Cooling Capacity\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note gross capacity excluding supply air fan heat\n";
    ss << "\\note rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "N2 , \\field Gross Rated Sensible Heat Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Rated sensible heat ratio (gross sensible capacity/gross total capacity)\n";
    ss << "\\note sensible and total capacities do not include supply fan heat\n";
    ss << "N3 , \\field Gross Rated Cooling COP\n";
    ss << "\\note Gross cooling capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply fan heat or supply fan electrical energy input\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.0\n";
    ss << "N4 , \\field Rated Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Flow rate corresponding to rated total cooling capacity, Rated SHR and Rated COP\n";
    ss << "\\note should be between 0.00004027 m3/s and .00006041 m3/s per watt of rated total cooling capacity\n";
    ss << "N5 , \\field Rated Evaporator Fan Power Per Volume Flow Rate\n";
    ss << "\\note Enter the evaporator fan power per air volume flow rate at the rated test conditions.\n";
    ss << "\\note The test conditions vary external static pressure based on total cooling capacity.\n";
    ss << "\\note This value is only used to calculate Seasonal Energy Efficiency Ratio (SEER), Energy\n";
    ss << "\\note Efficiency Ratio (EER), Integrated Energy Efficiency Ratio (IEER), and the Standard Rating\n";
    ss << "\\note (Net) Cooling Capacity which will be outputs in the EnergyPlus eio file.  This value is not\n";
    ss << "\\note used for modeling the evaporator fan during simulations.\n";
    ss << "\\type real\n";
    ss << "\\units W/(m3/s)\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1250.0\n";
    ss << "\\default 773.3\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Total Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*edb + e*edb**2 + f*wb*edb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note edb = dry-bulb temperature seen by the condenser (C)\n";
    ss << "A6 , \\field Total Cooling Capacity Function of Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = Fraction of the full load flow\n";
    ss << "A7 , \\field Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*edb + e*edb**2 + f*wb*edb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note edb = dry-bulb temperature seen by the condenser (C)\n";
    ss << "A8 , \\field Energy Input Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = Fraction of the full load flow\n";
    ss << "A9 , \\field Part Load Fraction Correlation Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLR = part load ratio (cooling load/steady state capacity)\n";
    ss << "N6, \\field Nominal Time for Condensate Removal to Begin\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 3000.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note The nominal time for condensate to begin leaving the coil's condensate\n";
    ss << "\\note drain line at the coil's rated air flow rate and temperature conditions.\n";
    ss << "\\note Nominal time is equal to the ratio of the energy of the coil's maximum\n";
    ss << "\\note condensate holding capacity (J) to the coil's steady state latent capacity (W).\n";
    ss << "\\note Suggested value is 1000; zero value means latent degradation model is disabled.\n";
    ss << "N7, \\field Ratio of Initial Moisture Evaporation Rate and Steady State Latent Capacity\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 5.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Ratio of the initial moisture evaporation rate from the cooling coil (when\n";
    ss << "\\note the compressor first turns off) and the coil's steady state latent capacity\n";
    ss << "\\note at rated air flow rate and temperature conditions. Suggested value is 1.5; zero value\n";
    ss << "\\note means latent degradation model is disabled.\n";
    ss << "N8, \\field Maximum Cycling Rate\n";
    ss << "\\type real\n";
    ss << "\\units cycles/hr\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 5.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note The maximum on-off cycling Rate for the compressor, which occurs at 50% run time\n";
    ss << "\\note fraction. Suggested value is 3; zero value means latent degradation model is disabled.\n";
    ss << "N9, \\field Latent Capacity Time Constant\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 500.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Time constant for the cooling coil's latent capacity to reach steady state after\n";
    ss << "\\note startup. Suggested value is 45; zero value means latent degradation model is disabled.\n";
    ss << "A10, \\field Condenser Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of an outdoor air node. This node name is also specified in\n";
    ss << "\\note an OutdoorAir:Node or OutdoorAir:NodeList object.\n";
    ss << "A11, \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "\\default AirCooled\n";
    ss << "N10, \\field Evaporative Condenser Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N11, \\field Evaporative Condenser Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Used to calculate evaporative condenser water use\n";
    ss << "N12, \\field Evaporative Condenser Pump Rated Power Consumption\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Rated power consumed by the evaporative condenser's water pump\n";
    ss << "N13, \\field Crankcase Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "N14, \\field Maximum Outdoor Dry-Bulb Temperature for Crankcase Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 10.0\n";
    ss << "\\units C\n";
    ss << "A12, \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A13, \\field Condensate Collection Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "N15, \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled and for periods\n";
    ss << "\\note when the basin heater is available (field Basin Heater Operating Schedule Name).\n";
    ss << "\\note For this situation, the heater maintains the basin water temperature at the basin heater\n";
    ss << "\\note setpoint temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when the DX coil is off.\n";
    ss << "N16, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on.\n";
    ss << "A14, \\field Basin Heater Operating Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";
    ss << "A15, \\field Sensible Heat Ratio Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*db + e*db**2 + f*wb*db\n";
    ss << "\\note wb = entering wet-bulb temperature seen by the DX cooling coil (C)\n";
    ss << "\\note db = entering dry-bulb temperature seen by the DX cooling coil (C)\n";
    ss << "\\note entering temperature can be outside air or pretreated air.\n";
    ss << "A16, \\field Sensible Heat Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";
    ss << "A17, \\field Report ASHRAE Standard 127 Performance Ratings\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note when this input field is specified as Yes then the program calculates the net cooling\n";
    ss << "\\note capacity and total electric power input of DX cooling coils per ANSI/ASHRAE 127.\n";
    ss << "A18; \\field Zone Name for Condenser Placement\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note This input field is name of a conditioned or unconditioned zone where the secondary\n";
    ss << "\\note coil (condenser) of DX system or a heat pump is to be placed.  This is an optional\n";
    ss << "\\note input field specified only when user desires to reject the condenser heat into a\n";
    ss << "\\note zone. The heat rejected is modelled as internal sensible heat gain of the zone.\n";

    IddObjectType objType(IddObjectType::Coil_Cooling_DX_SingleSpeed);
    OptionalIddObject oObj = IddObject::load("Coil:Cooling:DX:SingleSpeed",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Cooling_DX_SingleSpeed);
  return object;
}

IddObject createCoil_Cooling_DX_TwoSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Cooling:DX:TwoSpeed,\n";
    ss << "\\memo Direct expansion (DX) cooling coil and condensing unit (includes electric compressor\n";
    ss << "\\memo and condenser fan), two-speed (or variable-speed). Requires two sets of performance\n";
    ss << "\\memo data and will interpolate between speeds. Modeled as a single coil (multi-speed\n";
    ss << "\\memo compressor or multiple compressors with row split or intertwined coil).\n";
    ss << "\\min-fields 19\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingCoilsDX\n";
    ss << "\\reference DesuperHeatingCoilSources\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field High Speed Gross Rated Total Cooling Capacity\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note gross capacity excluding supply air fan heat\n";
    ss << "\\note rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "N2 , \\field High Speed Rated Sensible Heat Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Rated sensible heat ratio (gross sensible capacity/gross total capacity)\n";
    ss << "\\note sensible and total capacities do not include supply fan heat\n";
    ss << "N3 , \\field High Speed Gross Rated Cooling COP\n";
    ss << "\\note Gross cooling capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply fan heat or supply fan electrical energy input\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.0\n";
    ss << "N4 , \\field High Speed Rated Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Flow rate corresponding to rated total cooling capacity, Rated SHR\n";
    ss << "\\note and Rated COP. Should be between 0.00004027 m3/s and .00006041 m3/s per watt\n";
    ss << "\\note of rated total cooling capacity.\n";
    ss << "N5 , \\field Unit Internal Static Air Pressure\n";
    ss << "\\note Enter pressure drop for the unit containing the coil.\n";
    ss << "\\note This value is only used to calculate Energy Efficiency Ratio\n";
    ss << "\\note (EER), Integrated Energy Efficiency Ratio (IEER), and the\n";
    ss << "\\note Standard Rating (Net) Cooling Capacity. This value is not\n";
    ss << "\\note used for modeling the evaporator fan during simulations.\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\minimum> 0.0\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Total Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*edb + e*edb**2 + f*wb*edb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note edb = dry-bulb temperature seen by the condenser (C)\n";
    ss << "A6 , \\field Total Cooling Capacity Function of Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";
    ss << "A7 , \\field Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*edb + e*edb**2 + f*wb*edb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note edb = dry-bulb temperature seen by the condenser (C)\n";
    ss << "A8 , \\field Energy Input Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";
    ss << "A9 , \\field Part Load Fraction Correlation Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLR = part load ratio (cooling load/steady state capacity)\n";
    ss << "N6 , \\field Low Speed Gross Rated Total Cooling Capacity\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note gross capacity excluding supply air fan heat\n";
    ss << "\\note rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "N7 , \\field Low Speed Gross Rated Sensible Heat Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Gross Rated Sensible Heat Ratio (gross sensible capacity/gross total capacity)\n";
    ss << "\\note sensible and total capacities do not include supply fan heat\n";
    ss << "N8 , \\field Low Speed Gross Rated Cooling COP\n";
    ss << "\\note Gross cooling capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply fan heat or supply fan electrical energy input\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.0\n";
    ss << "N9 , \\field Low Speed Rated Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Flow rate corresponding to rated total cooling capacity, Rated SHR\n";
    ss << "\\note and Rated COP. Should be between 0.00004027 m3/s and .00006041 m3/s per watt\n";
    ss << "\\note of rated total cooling capacity.\n";
    ss << "A10, \\field Low Speed Total Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*edb + e*edb**2 + f*wb*edb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note edb = dry-bulb temperature seen by the condenser (C)\n";
    ss << "A11, \\field Low Speed Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*edb + e*edb**2 + f*wb*edb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note edb = dry-bulb temperature seen by the condenser (C)\n";
    ss << "A12, \\field Condenser Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of an outdoor air node. This node name is also specified in\n";
    ss << "\\note an OutdoorAir:Node or OutdoorAir:NodeList object.\n";
    ss << "A13, \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "\\default AirCooled\n";
    ss << "N10, \\field High Speed Evaporative Condenser Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N11, \\field High Speed Evaporative Condenser Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Used to calculate evaporative condenser water use\n";
    ss << "N12, \\field High Speed Evaporative Condenser Pump Rated Power Consumption\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Rated power consumed by the evaporative condenser's water pump at high speed\n";
    ss << "N13, \\field Low Speed Evaporative Condenser Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N14, \\field Low Speed Evaporative Condenser Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Used to calculate evaporative condenser water use\n";
    ss << "N15, \\field Low Speed Evaporative Condenser Pump Rated Power Consumption\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Rated power consumed by the evaporative condenser's water pump at low speed\n";
    ss << "A14, \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A15, \\field Condensate Collection Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "N16, \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled and for periods\n";
    ss << "\\note when the basin heater is available (field Basin Heater Operating Schedule Name).\n";
    ss << "\\note For this situation, the heater maintains the basin water temperature at the basin heater\n";
    ss << "\\note setpoint temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when the DX coil is off.\n";
    ss << "N17, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on.\n";
    ss << "A16, \\field Basin Heater Operating Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";
    ss << "A17, \\field Sensible Heat Ratio Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*db + e*db**2 + f*wb*db\n";
    ss << "\\note wb = entering wet-bulb temperature seen by the DX cooling coil (C)\n";
    ss << "\\note db = entering dry-bulb temperature seen by the DX cooling coil (C)\n";
    ss << "\\note entering temperature can be outside air or pretreated air.\n";
    ss << "A18, \\field Sensible Heat Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";
    ss << "A19, \\field Low Speed Sensible Heat Ratio Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*db + e*db**2 + f*wb*db\n";
    ss << "\\note wb = entering wet-bulb temperature seen by the DX cooling coil (C)\n";
    ss << "\\note db = entering dry-bulb temperature seen by the DX cooling coil (C)\n";
    ss << "\\note entering temperature can be outside air or pretreated air.\n";
    ss << "A20, \\field Low Speed Sensible Heat Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";
    ss << "A21; \\field Zone Name for Condenser Placement\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note This input field is name of a conditioned or unconditioned zone where the secondary\n";
    ss << "\\note coil (condenser) of DX system or a heat pump is to be placed.  This is an optional\n";
    ss << "\\note input field specified only when user desires to reject the condenser heat into a\n";
    ss << "\\note zone. The heat rejected is modelled as internal sensible heat gain of the zone.\n";

    IddObjectType objType(IddObjectType::Coil_Cooling_DX_TwoSpeed);
    OptionalIddObject oObj = IddObject::load("Coil:Cooling:DX:TwoSpeed",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Cooling_DX_TwoSpeed);
  return object;
}

IddObject createCoil_Cooling_DX_MultiSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Cooling:DX:MultiSpeed,\n";
    ss << "\\memo Direct expansion (DX) cooling coil and condensing unit (includes electric or\n";
    ss << "\\memo engine-driven compressor and condenser fan), multi-speed (or variable-speed).\n";
    ss << "\\memo Optional moisture evaporation from wet coil when compressor cycles off with continuous\n";
    ss << "\\memo fan operation. Requires two to four sets of performance data and will interpolate\n";
    ss << "\\memo between speeds. Modeled as a single coil (multi-speed compressor or multiple\n";
    ss << "\\memo compressors with row split or intertwined coil).\n";
    ss << "\\extensible:19\n";
    ss << "\\min-fields 55\n";
    ss << "\\max-fields 93\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingCoilsDXMultiSpeed\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Condenser Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of an outdoor air node. This node name is also specified in\n";
    ss << "\\note an OutdoorAir:Node or OutdoorAir:NodeList object.\n";
    ss << "A6 , \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "\\default AirCooled\n";
    ss << "A7 , \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A8 , \\field Condensate Collection Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A9 , \\field Apply Part Load Fraction to Speeds Greater than 1\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A10, \\field Apply Latent Degradation to Speeds Greater than 1\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N1 , \\field Crankcase Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "N2 , \\field Maximum Outdoor Dry-Bulb Temperature for Crankcase Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 10.0\n";
    ss << "\\units C\n";
    ss << "N3,  \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled and for periods\n";
    ss << "\\note when the basin heater is available (field Basin Heater Operating Schedule Name).\n";
    ss << "\\note For this situation, the heater maintains the basin water temperature at the basin heater\n";
    ss << "\\note setpoint temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when the DX coil is off.\n";
    ss << "N4,  \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on.\n";
    ss << "A11, \\field Basin Heater Operating Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";
    ss << "A12, \\field Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\default NaturalGas\n";
    ss << "N5 , \\field Number of Speeds\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 2\n";
    ss << "\\maximum 4\n";
    ss << "\\note Enter the number of the following sets of data for coil capacity, SHR, COP,\n";
    ss << "\\note flow rate, and associated curves.\n";
    ss << "N6 , \\field Speed 1 Gross Rated Total Cooling Capacity\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\begin-extensible\n";
    ss << "\\note Gross capacity excluding supply air fan heat\n";
    ss << "\\note Rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "\\note Speed 1 is defined as low speed\n";
    ss << "N7 , \\field Speed 1 Gross Rated Sensible Heat Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Gross Rated Sensible Heat Ratio (gross sensible capacity/gross total capacity)\n";
    ss << "\\note Sensible and total capacities do not include supply fan heat\n";
    ss << "N8 , \\field Speed 1 Gross Rated Cooling COP\n";
    ss << "\\note Gross cooling capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply fan heat or supply fan electrical energy input\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.0\n";
    ss << "N9 , \\field Speed 1 Rated Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Flow rate corresponding to rated total cooling capacity, rated SHR and rated\n";
    ss << "\\note COP should be between 0.00004027 m3/s and .00006041 m3/s per watt of rated total\n";
    ss << "\\note cooling capacity\n";
    ss << "N10, \\field Rated Evaporator Fan Power Per Volume Flow Rate\n";
    ss << "\\note Enter the evaporator fan power per air volume flow rate at the rated test conditions.\n";
    ss << "\\note The test conditions vary external static pressure based on total cooling capacity.\n";
    ss << "\\note This value is only used to calculate Seasonal Energy Efficiency Ratio (SEER), and the\n";
    ss << "\\note Standard Rating (Net) Cooling Capacity which will be outputs in the EnergyPlus eio file.\n";
    ss << "\\note This value is not used for modeling the evaporator fan during simulations.\n";
    ss << "\\type real\n";
    ss << "\\units W/(m3/s)\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1250.0\n";
    ss << "\\default 773.3\n";
    ss << "A13, \\field Speed 1 Total Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*edb + e*edb**2 + f*wb*edb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note edb = dry-bulb temperature seen by the condenser (C)\n";
    ss << "A14, \\field Speed 1 Total Cooling Capacity Function of Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = Fraction of the full load Flow\n";
    ss << "A15, \\field Speed 1 Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*edb + e*edb**2 + f*wb*edb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note edb = dry-bulb temperature seen by the condenser (C)\n";
    ss << "A16, \\field Speed 1 Energy Input Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";
    ss << "A17, \\field Speed 1 Part Load Fraction Correlation Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLR = part load ratio (cooling load/steady state capacity)\n";
    ss << "N11, \\field Speed 1 Nominal Time for Condensate Removal to Begin\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 3000.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note The nominal time for condensate to begin leaving the coil's condensate\n";
    ss << "\\note drain line at the coil's rated air flow rate and temperature conditions.\n";
    ss << "\\note Nominal time is equal to the ratio of the energy of the coil's maximum\n";
    ss << "\\note condensate holding capacity (J) to the coil's steady state latent capacity (W).\n";
    ss << "\\note Suggested value is 1000; zero value means latent degradation model is disabled.\n";
    ss << "N12, \\field Speed 1 Ratio of Initial Moisture Evaporation Rate and Steady State Latent Capacity\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 5.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Ratio of the initial moisture evaporation Rate from the Cooling Coil (when\n";
    ss << "\\note the compressor first turns off) and the Coil's steady state latent capacity\n";
    ss << "\\note at rated air flow rate and temperature conditions. Suggested value is 1.5; zero value\n";
    ss << "\\note means latent degradation model is disabled.\n";
    ss << "N13, \\field Speed 1 Maximum Cycling Rate\n";
    ss << "\\type real\n";
    ss << "\\units cycles/hr\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 5.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note The maximum on-off cycling rate for the compressor, which occurs at 50% run time\n";
    ss << "\\note fraction. Suggested value is 3; zero value means latent degradation\n";
    ss << "\\note model is disabled.\n";
    ss << "N14, \\field Speed 1 Latent Capacity Time Constant\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 500.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Time constant for the cooling coil's latent capacity to reach steady state after\n";
    ss << "\\note startup. Suggested value is 45; zero value means latent degradation\n";
    ss << "\\note model is disabled.\n";
    ss << "N15, \\field Speed 1 Rated Waste Heat Fraction of Power Input\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.2\n";
    ss << "\\note Recoverable waste heat at full load and rated conditions\n";
    ss << "A18, \\field Speed 1 Waste Heat Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*odb + c*odb**2 + d*db + e*db**2 + f*odb*db\n";
    ss << "\\note odb = Outdoor air dry-bulb temperature (C)\n";
    ss << "\\note db = entering coil dry-bulb temperature (C)\n";
    ss << "N16, \\field Speed 1 Evaporative Condenser Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N17, \\field Speed 1 Evaporative Condenser Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Used to calculate evaporative condenser water use\n";
    ss << "N18; \\field Speed 1 Rated Evaporative Condenser Pump Power Consumption\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Rated power consumed by the evaporative condenser's water pump at high speed\n";

    IddObjectType objType(IddObjectType::Coil_Cooling_DX_MultiSpeed);
    OptionalIddObject oObj = IddObject::load("Coil:Cooling:DX:MultiSpeed",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Cooling_DX_MultiSpeed);
  return object;
}

IddObject createCoil_Cooling_DX_VariableSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Cooling:DX:VariableSpeed,\n";
    ss << "\\memo Direct expansion (DX) cooling coil and condensing unit (includes electric compressor\n";
    ss << "\\memo and condenser fan), variable-speed. Optional inputs for moisture evaporation from\n";
    ss << "\\memo wet coil when compressor cycles off with continuous fan operation. Requires two to\n";
    ss << "\\memo ten sets of performance data and will interpolate between speeds. Modeled as a\n";
    ss << "\\memo single coil with variable-speed compressor.\n";
    ss << "\\extensible:10\n";
    ss << "\\min-fields 20\n";
    ss << "\\max-fields 110\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingCoilsDXVariableSpeed\n";
    ss << "A2,  \\field Indoor Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3,  \\field Indoor Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,  \\field Number of Speeds\n";
    ss << "\\units dimensionless\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 10\n";
    ss << "\\default 2\n";
    ss << "N2,  \\field Nominal Speed Level\n";
    ss << "\\units dimensionless\n";
    ss << "\\type integer\n";
    ss << "\\default 2\n";
    ss << "\\note must be lower than or equal to the highest speed number\n";
    ss << "N3,  \\field Gross Rated Total Cooling Capacity At Selected Nominal Speed Level\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N4,  \\field Rated Air Flow Rate At Selected Nominal Speed Level\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N5,  \\field Nominal Time for Condensate to Begin Leaving the Coil\n";
    ss << "\\units s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N6,  \\field Initial Moisture Evaporation Rate Divided by Steady-State AC Latent Capacity\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "A4,  \\field Energy Part Load Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLR = part load ratio (cooling load/steady state capacity)\n";
    ss << "A5,  \\field Condenser Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of an outdoor air node. This node name is also specified in\n";
    ss << "\\note an OutdoorAir:Node or OutdoorAir:NodeList object.\n";
    ss << "A6,  \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "\\default AirCooled\n";
    ss << "N7,  \\field Evaporative Condenser Pump Rated Power Consumption\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Rated power consumed by the evaporative condenser's water pump\n";
    ss << "N8,  \\field Crankcase Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "N9,  \\field Maximum Outdoor Dry-Bulb Temperature for Crankcase Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 10.0\n";
    ss << "\\units C\n";
    ss << "A7,  \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A8,  \\field Condensate Collection Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "N10, \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled and for periods\n";
    ss << "\\note when the basin heater is available (field Basin Heater Operating Schedule Name).\n";
    ss << "\\note For this situation, the heater maintains the basin water temperature at the basin heater\n";
    ss << "\\note setpoint temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when the DX coil is off.\n";
    ss << "N11, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on.\n";
    ss << "A9,  \\field Basin Heater Operating Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";
    ss << "N12, \\field Speed 1 Reference Unit Gross Rated Total Cooling Capacity\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "N13, \\field Speed 1 Reference Unit Gross Rated Sensible Heat Ratio\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\Maximum 1.0\n";
    ss << "\\required-field\n";
    ss << "N14, \\field Speed 1 Reference Unit Gross Rated Cooling COP\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N15, \\field Speed 1 Reference Unit Rated Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N16, \\field Speed 1 Reference Unit Rated Condenser Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled\n";
    ss << "N17, \\field Speed 1 Reference Unit Rated Pad Effectiveness of Evap Precooling\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled\n";
    ss << "A10, \\field Speed 1 Total Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*odb + e*odb**2 + f*wb*odb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note odb = air entering temperature seen by the condenser (C)\n";
    ss << "A11, \\field Speed 1 Total Cooling Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A12, \\field Speed 1 Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*odb + e*odb**2 + f*wb*odb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note odb = air entering temperature seen by the condenser (C)\n";
    ss << "A13; \\field Speed 1 Energy Input Ratio Function of Air Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";

    IddObjectType objType(IddObjectType::Coil_Cooling_DX_VariableSpeed);
    OptionalIddObject oObj = IddObject::load("Coil:Cooling:DX:VariableSpeed",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Cooling_DX_VariableSpeed);
  return object;
}

IddObject createCoil_Cooling_DX_TwoStageWithHumidityControlModeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Cooling:DX:TwoStageWithHumidityControlMode,\n";
    ss << "\\memo Direct expansion (DX) cooling coil and condensing unit (includes electric compressor\n";
    ss << "\\memo and condenser fan), two-stage with humidity control mode (e.g. sub-cool or hot gas\n";
    ss << "\\memo reheat). Optional inputs for moisture evaporation from wet coil when compressor\n";
    ss << "\\memo cycles off with continuous fan operation. Requires two to four sets of performance\n";
    ss << "\\memo data, see CoilPerformance:DX:Cooling. Stages are modeled as a face-split coil.\n";
    ss << "\\min-fields 10\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingCoilsDX\n";
    ss << "\\reference CoolingCoilsDXMultiModeOrSingleSpeed\n";
    ss << "\\reference DesuperHeatingCoilSources\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Crankcase Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "N2 , \\field Maximum Outdoor Dry-Bulb Temperature for Crankcase Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 10.0\n";
    ss << "\\units C\n";
    ss << "N3 , \\field Number of Capacity Stages\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 2\n";
    ss << "\\default 1\n";
    ss << "N4 , \\field Number of Enhanced Dehumidification Modes\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "A5 , \\field Normal Mode Stage 1 Coil Performance Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key CoilPerformance:DX:Cooling\n";
    ss << "A6 , \\field Normal Mode Stage 1 Coil Performance Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoilPerformanceDX\n";
    ss << "A7 , \\field Normal Mode Stage 1+2 Coil Performance Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key CoilPerformance:DX:Cooling\n";
    ss << "A8 , \\field Normal Mode Stage 1+2 Coil Performance Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoilPerformanceDX\n";
    ss << "A9 , \\field Dehumidification Mode 1 Stage 1 Coil Performance Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key CoilPerformance:DX:Cooling\n";
    ss << "A10, \\field Dehumidification Mode 1 Stage 1 Coil Performance Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoilPerformanceDX\n";
    ss << "A11, \\field Dehumidification Mode 1 Stage 1+2 Coil Performance Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key CoilPerformance:DX:Cooling\n";
    ss << "A12, \\field Dehumidification Mode 1 Stage 1+2 Coil Performance Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoilPerformanceDX\n";
    ss << "A13, \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A14, \\field Condensate Collection Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "N5,  \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled and for periods\n";
    ss << "\\note when the basin heater is available (field Basin Heater Operating Schedule Name).\n";
    ss << "\\note For this situation, the heater maintains the basin water temperature at the basin heater\n";
    ss << "\\note setpoint temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when the DX coil is off.\n";
    ss << "N6,  \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on.\n";
    ss << "A15; \\field Basin Heater Operating Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";

    IddObjectType objType(IddObjectType::Coil_Cooling_DX_TwoStageWithHumidityControlMode);
    OptionalIddObject oObj = IddObject::load("Coil:Cooling:DX:TwoStageWithHumidityControlMode",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Cooling_DX_TwoStageWithHumidityControlMode);
  return object;
}

IddObject createCoilPerformance_DX_CoolingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "CoilPerformance:DX:Cooling,\n";
    ss << "\\memo Used to specify DX cooling coil performance for one mode of operation for a\n";
    ss << "\\memo Coil:Cooling:DX:TwoStageWithHumidityControlMode object which may reference one to four\n";
    ss << "\\memo CoilPerformance:DX:Cooling objects depending on the specified number of stages and\n";
    ss << "\\memo dehumidification modes. In nearly all cases, the Rated Air Flow Rate will be the same\n";
    ss << "\\memo for all performance objects associated with a given coil. If bypass is specified,\n";
    ss << "\\memo the Rated Air Flow Rate includes both the bypassed flow and the flow through the\n";
    ss << "\\memo active part of the coil.\n";
    ss << "\\min-fields 11\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoilPerformanceDX\n";
    ss << "N1 , \\field Gross Rated Total Cooling Capacity\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note gross capacity excluding supply air fan heat\n";
    ss << "\\note rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "N2 , \\field Gross Rated Sensible Heat Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Rated sensible heat ratio (gross sensible capacity/gross total capacity)\n";
    ss << "\\note sensible and total capacities do not include supply fan heat\n";
    ss << "N3 , \\field Gross Rated Cooling COP\n";
    ss << "\\note Gross cooling capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply fan heat or supply fan electrical energy input\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.0\n";
    ss << "N4 , \\field Rated Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Flow rate corresponding to Rated total Cooling capacity, Rated SHR and Rated COP\n";
    ss << "N5 , \\field Fraction of Air Flow Bypassed Around Coil\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Fraction of Rated Air Flow Rate which bypasses the cooling coil\n";
    ss << "\\note in this performance mode.  The remaining portion of the flow\n";
    ss << "\\note should be between 0.00004027 m3/s and .00006041 m3/s per watt of rated total cooling capacity.\n";
    ss << "\\note This is used to model face-split coils on multi-stage units or bypass dampers.\n";
    ss << "\\note If total flow rate varies during simulation, the same fraction is bypassed.\n";
    ss << "A2 , \\field Total Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*edb + e*edb**2 + f*wb*edb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note edb = dry-bulb temperature seen by the condenser (C)\n";
    ss << "A3 , \\field Total Cooling Capacity Function of Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";
    ss << "A4 , \\field Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*edb + e*edb**2 + f*wb*edb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note edb = dry-bulb temperature seen by the condenser (C)\n";
    ss << "A5 , \\field Energy Input Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";
    ss << "A6 , \\field Part Load Fraction Correlation Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLR = part load ratio (cooling load/steady state capacity)\n";
    ss << "N6 , \\field Nominal Time for Condensate Removal to Begin\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 3000.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note The nominal time for condensate to begin leaving the coil's condensate\n";
    ss << "\\note drain line at the coil's rated air flow rate and temperature conditions.\n";
    ss << "\\note Nominal time is equal to the ratio of the energy of the coil's maximum\n";
    ss << "\\note condensate holding capacity (J) to the coil's steady state latent capacity (W).\n";
    ss << "\\note Suggested value is 1000; zero value means latent degradation model is disabled.\n";
    ss << "N7 , \\field Ratio of Initial Moisture Evaporation Rate and Steady State Latent Capacity\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 5.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Ratio of the initial moisture evaporation rate from the cooling coil (when\n";
    ss << "\\note the compressor first turns off) and the coil's steady state latent capacity\n";
    ss << "\\note at rated air flow rate and temperature conditions. Suggested value is 1.5; zero value\n";
    ss << "\\note means latent degradation model is disabled.\n";
    ss << "N8 , \\field Maximum Cycling Rate\n";
    ss << "\\type real\n";
    ss << "\\units cycles/hr\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 5.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note The maximum on-off cycling rate for the compressor, which occurs at 50% run time\n";
    ss << "\\note fraction. Suggested value is 3; zero value means latent degradation model is disabled.\n";
    ss << "N9 , \\field Latent Capacity Time Constant\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 500.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Time constant for the cooling coil's latent capacity to reach steady state after\n";
    ss << "\\note startup. Suggested value is 45; zero value means latent degradation model is disabled.\n";
    ss << "A7 , \\field Condenser Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of an outdoor air node. This node name is also specified in\n";
    ss << "\\note an OutdoorAir:Node or OutdoorAir:NodeList object.\n";
    ss << "A8 , \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "\\default AirCooled\n";
    ss << "N10 , \\field Evaporative Condenser Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N11, \\field Evaporative Condenser Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Used to calculate evaporative condenser water use\n";
    ss << "N12, \\field Evaporative Condenser Pump Rated Power Consumption\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Rated power consumed by the evaporative condenser's water pump\n";
    ss << "A9,  \\field Sensible Heat Ratio Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*db + e*db**2 + f*wb*db\n";
    ss << "\\note wb = entering wet-bulb temperature seen by the DX cooling coil (C)\n";
    ss << "\\note db = entering dry-bulb temperature seen by the DX cooling coil (C)\n";
    ss << "\\note entering temperature can be outside air or pretreated air.\n";
    ss << "A10; \\field Sensible Heat Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";

    IddObjectType objType(IddObjectType::CoilPerformance_DX_Cooling);
    OptionalIddObject oObj = IddObject::load("CoilPerformance:DX:Cooling",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::CoilPerformance_DX_Cooling);
  return object;
}

IddObject createCoil_Cooling_DX_VariableRefrigerantFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Cooling:DX:VariableRefrigerantFlow,\n";
    ss << "\\memo Variable refrigerant flow (VRF) direct expansion (DX) cooling coil. Used with\n";
    ss << "\\memo ZoneHVAC:TerminalUnit:VariableRefrigerantFlow. Condensing unit is modeled separately,\n";
    ss << "\\memo see AirConditioner:VariableRefrigerantFlow.\n";
    ss << "\\min-fields 9\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingCoilsDXVarRefrigFlow\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Gross Rated Total Cooling Capacity\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Cooling capacity excluding supply air fan heat\n";
    ss << "N2 , \\field Gross Rated Sensible Heat Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Sensible heat ratio excluding supply air fan heat\n";
    ss << "N3 , \\field Rated Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Volume flow rate corresponding to rated total cooling capacity\n";
    ss << "\\note should be between 0.00004027 m3/s and .00006041 m3/s per watt of rated total cooling capacity\n";
    ss << "A3 , \\field Cooling Capacity Ratio Modifier Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A4 , \\field Cooling Capacity Modifier Curve Function of Flow Fraction Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";
    ss << "A5 , \\field Coil Air Inlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6 , \\field Coil Air Outlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7 ; \\field Name of Water Storage Tank for Condensate Collection\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";

    IddObjectType objType(IddObjectType::Coil_Cooling_DX_VariableRefrigerantFlow);
    OptionalIddObject oObj = IddObject::load("Coil:Cooling:DX:VariableRefrigerantFlow",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Cooling_DX_VariableRefrigerantFlow);
  return object;
}

IddObject createCoil_Heating_DX_VariableRefrigerantFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Heating:DX:VariableRefrigerantFlow,\n";
    ss << "\\memo Variable refrigerant flow (VRF) direct expansion (DX) heating coil (air-to-air heat\n";
    ss << "\\memo pump). Used with ZoneHVAC:TerminalUnit:VariableRefrigerantFlow. Condensing unit is\n";
    ss << "\\memo modeled separately, see AirConditioner:VariableRefrigerantFlow.\n";
    ss << "\\min-fields 5\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatingCoilsDX\n";
    ss << "\\reference HeatingCoilsDXSingleSpeed\n";
    ss << "\\reference HeatingCoilsDXVarRefrigFlow\n";
    ss << "A2 , \\field Availability Schedule\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Gross Rated Heating Capacity\n";
    ss << "\\note Heating capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note capacity excluding supply air fan heat\n";
    ss << "\\note rating point outside dry-bulb temp 8.33 C, outside wet-bulb temp 6.11 C\n";
    ss << "\\note rating point heating coil entering air dry-bulb 21.11 C, coil entering wetbulb 15.55 C\n";
    ss << "N2 , \\field Rated Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note volume flow rate corresponding to rated total capacity\n";
    ss << "\\note should be between 0.00004027 m3/s and .00006041 m3/s per watt of rated heating capacity\n";
    ss << "A3 , \\field Coil Air Inlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Coil Air Outlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Heating Capacity Ratio Modifier Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A6 ; \\field Heating Capacity Modifier Function of Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";

    IddObjectType objType(IddObjectType::Coil_Heating_DX_VariableRefrigerantFlow);
    OptionalIddObject oObj = IddObject::load("Coil:Heating:DX:VariableRefrigerantFlow",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Heating_DX_VariableRefrigerantFlow);
  return object;
}

IddObject createCoil_Cooling_DX_VariableRefrigerantFlow_FluidTemperatureControlIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Cooling:DX:VariableRefrigerantFlow:FluidTemperatureControl,\n";
    ss << "\\memo This is a key object in the new physics based VRF model applicable for Fluid\n";
    ss << "\\memo Temperature Control. It describes the the indoor unit coil of the system at cooling mode.\n";
    ss << "\\memo Used with ZoneHVAC:TerminalUnit:VariableRefrigerantFlow.\n";
    ss << "\\memo Outdoor unit is modeled separately, see AirConditioner:VariableRefrigerantFlow:FluidTemperatureControl.\n";
    ss << "\\min-fields 6\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingCoilsDXVarRefrigFlowFluidTemperatureControl\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Enter the name of a schedule that defines the availability of the coil\n";
    ss << "\\note Schedule values of 0 denote the unit is off. All other values denote the unit is available\n";
    ss << "\\note If this field is left blank, the unit is available the entire simulation\n";
    ss << "A3,  \\field Coil Air Inlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note the inlet node to the coil\n";
    ss << "A4,  \\field Coil Air Outlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note the outlet node to the coil\n";
    ss << "N1,  \\field Rated Total Cooling Capacity\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Supply air fan heat is not included\n";
    ss << "N2,  \\field Rated Sensible Heat Ratio\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Supply air fan heat is not included\n";
    ss << "N3,  \\field Indoor Unit Reference Superheating\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 5.0\n";
    ss << "A5,  \\field Indoor Unit Evaporating Temperature Function of Superheating Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A6;  \\field Name of Water Storage Tank for Condensate Collection\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";

    IddObjectType objType(IddObjectType::Coil_Cooling_DX_VariableRefrigerantFlow_FluidTemperatureControl);
    OptionalIddObject oObj = IddObject::load("Coil:Cooling:DX:VariableRefrigerantFlow:FluidTemperatureControl",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Cooling_DX_VariableRefrigerantFlow_FluidTemperatureControl);
  return object;
}

IddObject createCoil_Heating_DX_VariableRefrigerantFlow_FluidTemperatureControlIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Heating:DX:VariableRefrigerantFlow:FluidTemperatureControl,\n";
    ss << "\\memo This is a key object in the new physics based VRF model applicable for Fluid\n";
    ss << "\\memo Temperature Control. It describes the the indoor unit coil of the system at heating mode.\n";
    ss << "\\memo Used with ZoneHVAC:TerminalUnit:VariableRefrigerantFlow.\n";
    ss << "\\memo Outdoor unit is modeled separately, see AirConditioner:VariableRefrigerantFlow:FluidTemperatureControl.\n";
    ss << "\\min-fields 5\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatingCoilsDXVarRefrigFlowFluidTemperatureControl\n";
    ss << "A2,  \\field Availability Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Enter the name of a schedule that defines the availability of the coil\n";
    ss << "\\note Schedule values of 0 denote the unit is off. All other values denote the unit is available\n";
    ss << "\\note If this field is left blank, the unit is available the entire simulation\n";
    ss << "A3,  \\field Coil Air Inlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note the inlet node to the coil\n";
    ss << "A4,  \\field Coil Air Outlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note the outlet node to the coil\n";
    ss << "N1,  \\field Rated Total Heating Capacity\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Supply air fan heat is not included\n";
    ss << "N2,  \\field Indoor Unit Reference Subcooling\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 5.0\n";
    ss << "A5;  \\field Indoor Unit Condensing Temperature Function of Subcooling Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";

    IddObjectType objType(IddObjectType::Coil_Heating_DX_VariableRefrigerantFlow_FluidTemperatureControl);
    OptionalIddObject oObj = IddObject::load("Coil:Heating:DX:VariableRefrigerantFlow:FluidTemperatureControl",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Heating_DX_VariableRefrigerantFlow_FluidTemperatureControl);
  return object;
}

IddObject createCoil_Heating_WaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Heating:Water,\n";
    ss << "\\memo Hot water heating coil, NTU-effectiveness model, assumes a cross-flow heat exchanger.\n";
    ss << "\\memo Two options for capacity inputs: UA and water flow rate or capacity and design\n";
    ss << "\\memo temperatures.\n";
    ss << "\\min-fields 15\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatingCoilName\n";
    ss << "\\reference HeatingCoilsWater\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "\\reference SimpleCoils\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field U-Factor Times Area Value\n";
    ss << "\\note UA value under rating conditions\n";
    ss << "\\units W/K\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N2 , \\field Maximum Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\default autosize\n";
    ss << "A3 , \\field Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7 , \\field Performance Input Method\n";
    ss << "\\type choice\n";
    ss << "\\key UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\key NominalCapacity\n";
    ss << "\\default UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "N3 , \\field Rated Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0\n";
    ss << "\\default autosize\n";
    ss << "N4 , \\field Rated Inlet Water Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 82.2\n";
    ss << "N5, \\field Rated Inlet Air Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16.6\n";
    ss << "N6, \\field Rated Outlet Water Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 71.1\n";
    ss << "N7, \\field Rated Outlet Air Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 32.2\n";
    ss << "N8; \\field Rated Ratio for Air and Water Convection\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\minimum> 0\n";

    IddObjectType objType(IddObjectType::Coil_Heating_Water);
    OptionalIddObject oObj = IddObject::load("Coil:Heating:Water",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Heating_Water);
  return object;
}

IddObject createCoil_Heating_SteamIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Heating:Steam,\n";
    ss << "\\memo Steam heating coil. Condenses and sub-cools steam at loop pressure and discharges\n";
    ss << "\\memo condensate through steam traps to low pressure condensate line.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatingCoilName\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Maximum Steam Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Degree of SubCooling\n";
    ss << "\\units C\n";
    ss << "\\minimum 1.0\n";
    ss << "\\maximum 5.0\n";
    ss << "N3 , \\field Degree of Loop SubCooling\n";
    ss << "\\units C\n";
    ss << "\\minimum 10.0\n";
    ss << "\\default 20.0\n";
    ss << "A3 , \\field Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7 , \\field Coil Control Type\n";
    ss << "\\note Use ZoneLoadControl if the coil is contained within another component such as an air\n";
    ss << "\\note terminal unit, zone HVAC equipment, or unitary system. Use TemperatureSetpointControl\n";
    ss << "\\note if the coil is located directly in an air loop branch or outdoor air equipment list.\n";
    ss << "\\type choice\n";
    ss << "\\key TemperatureSetpointControl\n";
    ss << "\\key ZoneLoadControl\n";
    ss << "A8 ; \\field Temperature Setpoint Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Required if Coil Control Type is TemperatureSetpointControl\n";

    IddObjectType objType(IddObjectType::Coil_Heating_Steam);
    OptionalIddObject oObj = IddObject::load("Coil:Heating:Steam",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Heating_Steam);
  return object;
}

IddObject createCoil_Heating_ElectricIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Heating:Electric,\n";
    ss << "\\memo Electric heating coil. If the coil is located directly in an air loop branch or\n";
    ss << "\\memo outdoor air equipment list, then it is controlled on leaving air temperature and\n";
    ss << "\\memo the Temperature Setpoint Node Name must be specified. If the coil is contained within\n";
    ss << "\\memo another component such as an air terminal unit, zone HVAC equipment, or unitary\n";
    ss << "\\memo system, then the coil is controlled by the parent component and the setpoint node name\n";
    ss << "\\memo is not entered.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference HeatingCoilName\n";
    ss << "\\reference HeatingCoilsElectric\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Efficiency\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N2 , \\field Nominal Capacity\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 ; \\field Temperature Setpoint Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Required if coil is temperature controlled.\n";

    IddObjectType objType(IddObjectType::Coil_Heating_Electric);
    OptionalIddObject oObj = IddObject::load("Coil:Heating:Electric",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Heating_Electric);
  return object;
}

IddObject createCoil_Heating_Electric_MultiStageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Heating:Electric:MultiStage,\n";
    ss << "\\memo Electric heating coil, multi-stage. If the coil is located directly in an air loop\n";
    ss << "\\memo branch or outdoor air equipment list, then it is controlled on leaving air temperature\n";
    ss << "\\memo and the Temperature Setpoint Node Name must be specified. If the coil is contained\n";
    ss << "\\memo within another component such as an air terminal unit, zone HVAC equipment, or unitary\n";
    ss << "\\memo system, then the coil is controlled by the parent component and the setpoint node name\n";
    ss << "\\memo is not entered.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference HeatingCoilsElectricMultiStage\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Temperature Setpoint Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Required if coil is temperature controlled.\n";
    ss << "\\note controlled\n";
    ss << "N1 , \\field Number of Stages\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 4\n";
    ss << "\\note Enter the number of the following sets of data for coil\n";
    ss << "\\note capacity and Efficiency.\n";
    ss << "N2, \\field Stage 1 Efficiency\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3, \\field Stage 1 Nominal Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N4, \\field Stage 2 Efficiency\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "N5, \\field Stage 2 Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N6, \\field Stage 3 Efficiency\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "N7, \\field Stage 3 Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N8, \\field Stage 4 Efficiency\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "N9; \\field Stage 4 Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";

    IddObjectType objType(IddObjectType::Coil_Heating_Electric_MultiStage);
    OptionalIddObject oObj = IddObject::load("Coil:Heating:Electric:MultiStage",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Heating_Electric_MultiStage);
  return object;
}

IddObject createCoil_Heating_GasIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Heating:Gas,\n";
    ss << "\\memo Gas heating coil. If the coil is located directly in an air loop branch or\n";
    ss << "\\memo outdoor air equipment list, then it is controlled on leaving air temperature and\n";
    ss << "\\memo the Temperature Setpoint Node Name must be specified. If the coil is contained within\n";
    ss << "\\memo another component such as an air terminal unit, zone HVAC equipment, or unitary\n";
    ss << "\\memo system, then the coil is controlled by the parent component and the setpoint node name\n";
    ss << "\\memo is not entered.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatingCoilName\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Gas Burner Efficiency\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.8\n";
    ss << "N2 , \\field Nominal Capacity\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Temperature Setpoint Node Name\n";
    ss << "\\type node\n";
    ss << "\\note optional, used if coil is temperature control and not load-base controlled\n";
    ss << "N3 , \\field Parasitic Electric Load\n";
    ss << "\\units W\n";
    ss << "\\note parasitic electric load associated with the gas coil operation\n";
    ss << "\\note such as an inducer fan, etc..  This will be modified by the part load ratio to reflect\n";
    ss << "\\note the time of operation in a timestep.\n";
    ss << "\\ip-units W\n";
    ss << "A6 , \\field Part Load Fraction Correlation Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve, PLF = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve, PLF = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLF = part load fraction\n";
    ss << "\\note PLR = part load ratio (sensible heating load/steady state heating capacity)\n";
    ss << "\\note Coil runtime fraction = Part Load Ratio / PLF\n";
    ss << "\\note This part load degradation is for coil performance & will\n";
    ss << "\\note increase the gas consumption of the coil due to transient coil operation.\n";
    ss << "N4 ; \\field Parasitic Gas Load\n";
    ss << "\\units W\n";
    ss << "\\note parasitic gas load associated with the gas coil operation (i.e., standing pilot)\n";

    IddObjectType objType(IddObjectType::Coil_Heating_Gas);
    OptionalIddObject oObj = IddObject::load("Coil:Heating:Gas",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Heating_Gas);
  return object;
}

IddObject createCoil_Heating_Gas_MultiStageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Heating:Gas:MultiStage,\n";
    ss << "\\memo Gas heating coil, multi-stage. If the coil is located directly in an air loop\n";
    ss << "\\memo branch or outdoor air equipment list, then it is controlled on leaving air temperature\n";
    ss << "\\memo and the Temperature Setpoint Node Name must be specified. If the coil is contained\n";
    ss << "\\memo within another component such as an air terminal unit, zone HVAC equipment, or unitary\n";
    ss << "\\memo system, then the coil is controlled by the parent component and the setpoint node name\n";
    ss << "\\memo is not entered.\n";
    ss << "\\min-fields 8\n";
    ss << "\\extensible:3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference HeatingCoilsGasMultiStage\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Temperature Setpoint Node Name\n";
    ss << "\\type node\n";
    ss << "\\note optional, used if coil is temperature control and not load-base\n";
    ss << "\\note controlled.\n";
    ss << "A6 , \\field Part Load Fraction Correlation Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve, PLF = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve, PLF = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLF = part load fraction\n";
    ss << "\\note PLR = part load ratio (sensible heating load/steady state\n";
    ss << "\\note heating capacity)\n";
    ss << "\\note Coil runtime fraction = Part Load Ratio / PLF\n";
    ss << "\\note This part load degradation is for coil performance & will\n";
    ss << "\\note increase the gas consumption of the coil due to transient coil\n";
    ss << "\\note operation.\n";
    ss << "N1,  \\field Parasitic Gas Load\n";
    ss << "\\units W\n";
    ss << "\\note parasitic gas load associated with the gas coil operation (i.e.,\n";
    ss << "\\note standing pilot)\n";
    ss << "N2 , \\field Number of Stages\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 4\n";
    ss << "\\note Enter the number of the following sets of data for coil\n";
    ss << "\\note capacity and Gas Burner Efficiency.\n";
    ss << "N3, \\field Stage 1 Gas Burner Efficiency\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "N4, \\field Stage 1 Nominal Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N5; \\field Stage 1 Parasitic Electric Load\n";
    ss << "\\units W\n";
    ss << "\\note Stage 1 parasitic electric load associated with the gas coil operation\n";
    ss << "\\note such as an inducer fan, etc.  This will be modified by the part\n";
    ss << "\\note load ratio to reflect the time of operation in a timestep.\n";
    ss << "\\ip-units W\n";

    IddObjectType objType(IddObjectType::Coil_Heating_Gas_MultiStage);
    OptionalIddObject oObj = IddObject::load("Coil:Heating:Gas:MultiStage",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Heating_Gas_MultiStage);
  return object;
}

IddObject createCoil_Heating_DesuperheaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Heating:Desuperheater,\n";
    ss << "\\memo Desuperheater air heating coil. The heating energy provided by this coil is reclaimed\n";
    ss << "\\memo from the superheated refrigerant gas leaving a compressor and does not impact the\n";
    ss << "\\memo performance of the compressor. If the coil is located directly in an air loop\n";
    ss << "\\memo branch or outdoor air equipment list, then it is controlled on leaving air temperature\n";
    ss << "\\memo and the Temperature Setpoint Node Name must be specified. If the coil is contained\n";
    ss << "\\memo within another component such as a unitary system, then the coil is controlled by the\n";
    ss << "\\memo parent component and the setpoint node name is not entered.\n";
    ss << "\\min-fields 7\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatingCoilsDesuperheater\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Heat Reclaim Recovery Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Heating Source Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:DX:SingleSpeed\n";
    ss << "\\key Coil:Cooling:DX:TwoSpeed\n";
    ss << "\\key Coil:Cooling:DX:TwoStageWithHumidityControlMode\n";
    ss << "\\key Refrigeration:CompressorRack\n";
    ss << "\\key Refrigeration:Condenser:AirCooled\n";
    ss << "\\key Refrigeration:Condenser:EvaporativeCooled\n";
    ss << "\\key Refrigeration:Condenser:WaterCooled\n";
    ss << "A6 , \\field Heating Source Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesuperHeatingCoilSources\n";
    ss << "A7 , \\field Temperature Setpoint Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Required if coil is temperature controlled.\n";
    ss << "\\note Temperature-based control requires the use of a SetpointManager object\n";
    ss << "N2 ; \\field Parasitic Electric Load\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\note parasitic electric load associated with the desuperheater coil operation\n";
    ss << "\\note such as solenoid valves, etc.\n";
    ss << "\\ip-units W\n";

    IddObjectType objType(IddObjectType::Coil_Heating_Desuperheater);
    OptionalIddObject oObj = IddObject::load("Coil:Heating:Desuperheater",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Heating_Desuperheater);
  return object;
}

IddObject createCoil_Heating_DX_SingleSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Heating:DX:SingleSpeed,\n";
    ss << "\\memo Direct expansion (DX) heating coil (air-to-air heat pump) and compressor unit\n";
    ss << "\\memo (includes electric compressor and outdoor fan), single-speed, with defrost controls.\n";
    ss << "\\min-fields 21\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatingCoilsDX\n";
    ss << "\\reference HeatingCoilsDXSingleSpeed\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Gross Rated Heating Capacity\n";
    ss << "\\note Heating capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note capacity excluding supply air fan heat\n";
    ss << "\\note rating point outdoor dry-bulb temp 8.33 C, outdoor wet-bulb temp 6.11 C\n";
    ss << "\\note rating point heating coil entering air dry-bulb 21.11 C, coil entering wet-bulb 15.55 C\n";
    ss << "N2 , \\field Gross Rated Heating COP\n";
    ss << "\\note Rated heating capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply air fan heat or supply air fan electrical energy\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note does not include supply air fan heat or supply air fan electrical energy\n";
    ss << "N3 , \\field Rated Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Flow rate corresponding to rated total capacity\n";
    ss << "\\note should be between 0.00004027 m3/s and .00006041 m3/s per watt of rated heating capacity\n";
    ss << "N4 , \\field Rated Supply Fan Power Per Volume Flow Rate\n";
    ss << "\\note Enter the supply fan power per air volume flow rate at the rated test conditions.\n";
    ss << "\\note The test conditions vary external static pressure based on heating capacity.\n";
    ss << "\\note This value is only used to calculate Heating Seasonal Performance Factor(HSPF). This value is not\n";
    ss << "\\note used for modeling the supply (condenser) fan during simulations.\n";
    ss << "\\type real\n";
    ss << "\\units W/(m3/s)\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1250.0\n";
    ss << "\\default 773.3\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Heating Capacity Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticQuadraticCubicCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note quadratic curve = a + b*oat + c*oat**2\n";
    ss << "\\note cubic curve = a + b*oat + c*oat**2 + d*oat**3\n";
    ss << "\\note biquadratic curve = a + b*iat + c*iat**2 + d*oat + e*oat**2 + f*iat*oat\n";
    ss << "\\note oat = outdoor air dry-bulb temperature (C)\n";
    ss << "\\note iat = indoor air dry-bulb temperature (C)\n";
    ss << "\\note Biquadratic curve is recommended if sufficient manufacturer data is\n";
    ss << "\\note available for the heating capacity to be sensitive to both iat and oat.\n";
    ss << "A6 , \\field Heating Capacity Function of Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";
    ss << "A7 ,  \\field Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticQuadraticCubicCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note quadratic curve = a + b*oat + c*oat**2\n";
    ss << "\\note cubic curve = a + b*oat + c*oat**2 + d*oat**3\n";
    ss << "\\note biquadratic curve = a + b*iat + c*iat**2 + d*oat + e*oat**2 + f*iat*oat\n";
    ss << "\\note oat = outdoor air dry-bulb temperature (C)\n";
    ss << "\\note iat = indoor air dry-bulb temperature (C)\n";
    ss << "\\note biquadratic curve is recommended if sufficient manufacturer data is\n";
    ss << "\\note available for the energy input ratio to be sensitive to both iat and oat.\n";
    ss << "A8 , \\field Energy Input Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";
    ss << "A9 , \\field Part Load Fraction Correlation Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLR = part load ratio (sensible heating load/steady state heating capacity)\n";
    ss << "A10, \\field Defrost Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note biquadratic curve = a + b*wb + c*wb**2 + d*oat + e*oat**2 + f*wb*oat\n";
    ss << "\\note wb = wet-bulb temperature (C) of air entering the indoor coil\n";
    ss << "\\note oat = outdoor air dry-bulb temperature (C)\n";
    ss << "\\note only required if ReverseCycle defrost strategy is specified\n";
    ss << "N5 , \\field Minimum Outdoor Dry-Bulb Temperature for Compressor Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum -20.0\n";
    ss << "\\default -8.0\n";
    ss << "\\units C\n";
    ss << "N6 , \\field Outdoor Dry-Bulb Temperature to Turn On Compressor\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note The outdoor temperature when the compressor is automatically turned back on following an\n";
    ss << "\\note automatic shut off because of low outdoor dry-bulb temperature. This field is only used\n";
    ss << "\\note for the calculation of HSPF. If this field is not provided, then outdoor bin temperature\n";
    ss << "\\note used in the HSPF calculation is always considered to be greater than this temperature and\n";
    ss << "\\note 'Minimum Outdoor Dry-Bulb Temperature for Compressor Operation' field described above.\n";
    ss << "\\note This assumption is based on AHRI standard 210/240 (2008) and can introduce significant error\n";
    ss << "\\note in the final value of HSPF.\n";
    ss << "N7 , \\field Maximum Outdoor Dry-Bulb Temperature for Defrost Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 7.22\n";
    ss << "\\default 5.0\n";
    ss << "\\units C\n";
    ss << "N8,  \\field Crankcase Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "N9,  \\field Maximum Outdoor Dry-Bulb Temperature for Crankcase Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 10.0\n";
    ss << "\\units C\n";
    ss << "A11, \\field Defrost Strategy\n";
    ss << "\\type choice\n";
    ss << "\\key ReverseCycle\n";
    ss << "\\key Resistive\n";
    ss << "\\default ReverseCycle\n";
    ss << "A12, \\field Defrost Control\n";
    ss << "\\type choice\n";
    ss << "\\key Timed\n";
    ss << "\\key OnDemand\n";
    ss << "\\default Timed\n";
    ss << "N10,  \\field Defrost Time Period Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.058333\n";
    ss << "\\note Fraction of time in defrost mode\n";
    ss << "\\note only applicable if timed defrost control is specified\n";
    ss << "N11,  \\field Resistive Defrost Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\note only applicable if resistive defrost strategy is specified\n";
    ss << "\\ip-units W\n";
    ss << "N12, \\field Region number for calculating HSPF\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 6\n";
    ss << "\\default 4\n";
    ss << "\\note Standard Region number for which HSPF and other standard ratings are calculated\n";
    ss << "A13, \\field Evaporator Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of an outdoor air node. This node name is also specified in\n";
    ss << "\\note an OutdoorAir:Node or OutdoorAir:NodeList object.\n";
    ss << "A14, \\field Zone Name for Evaporator Placement\n";
    ss << "\\note This input field is name of a conditioned or unconditioned zone where the secondary\n";
    ss << "\\note coil (evaporator) of a heat pump is to be placed.  This is an optional input field\n";
    ss << "\\note specified only when user desires to extract heat from the zone.  The heat extracted\n";
    ss << "\\note is modelled as internal gain of the zone. If the primary DX system is a heat pump,\n";
    ss << "\\note then the zone name should be the same as the zone name specified for placing the\n";
    ss << "\\note secondary cooling DX coil.\n";
    ss << "N13, \\field Secondary Coil Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note This input value is the secondary coil (evaporator) air flow rate when the heat pump\n";
    ss << "\\note is working in heating mode or the secondary DX coil (condenser) air flow rate when the\n";
    ss << "\\note heat pump is working in cooling mode.\n";
    ss << "N14, \\field Secondary Coil Fan Flow Scaling Factor\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.25\n";
    ss << "\\note This input field is scaling factor for autosizing the secondary DX coil fan flow rate.\n";
    ss << "\\note The secondary air flow rate is determined by multiplying the primary DX coil rated air\n";
    ss << "\\note flow rate by the fan flow scaling factor. Default value is 1.25. If the secondary coil\n";
    ss << "\\note fan flow rate is not autosized, then the secondary coil fan flow scaling factor is set\n";
    ss << "\\note to 1.0.\n";
    ss << "N15, \\field Nominal Sensible Heat Ratio of Secondary Coil\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note This input value is the nominal sensible heat ratio used to split the heat extracted by\n";
    ss << "\\note a secondary DX coil (evaporator) of a heat pump into sensible and latent components.\n";
    ss << "\\note This is an optional input field.  If this input field is left blank, then pure sensible\n";
    ss << "\\note internal heat gain is assumed, i.e., sensible heat ratio of 1.0.\n";
    ss << "A15, \\field Sensible Heat Ratio Modifier Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*db + e*db**2 + f*wb*db\n";
    ss << "\\note wb = entering wet-bulb temperature seen by the secondary DX coil (C)\n";
    ss << "\\note db = entering dry-bulb temperature seen by the primary DX coil (C)\n";
    ss << "\\note This input field is name of sensible heat ratio modifier biquadratic curve.  The value\n";
    ss << "\\note of this curve modifies the nominal sensible heat ratio for current time step depending\n";
    ss << "\\note on the secondary zone air node wet-bulb temperature and the heating DX coil entering\n";
    ss << "\\note air dry-bulb temperature.  This is an optional input field.  If this input field is left\n";
    ss << "\\note blank, then the nominal sensible heat ratio specified in the field above will be used.\n";
    ss << "A16; \\field Sensible Heat Ratio Modifier Function of Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = secondary air flow fraction of the full load flow\n";
    ss << "\\note This input field is name of sensible heat ratio modifier curve.  The value\n";
    ss << "\\note of this curve modifies the nominal sensible heat ratio for current time step depending\n";
    ss << "\\note on the secondary coil air flow fraction. This is an optional input field.  If this input\n";
    ss << "\\note field is left blank, then the nominal sensible heat ratio specified will be used.\n";

    IddObjectType objType(IddObjectType::Coil_Heating_DX_SingleSpeed);
    OptionalIddObject oObj = IddObject::load("Coil:Heating:DX:SingleSpeed",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Heating_DX_SingleSpeed);
  return object;
}

IddObject createCoil_Heating_DX_MultiSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Heating:DX:MultiSpeed,\n";
    ss << "\\memo Direct expansion (DX) heating coil (air-to-air heat pump) and compressor unit\n";
    ss << "\\memo (includes electric or engine-driven compressor and outdoor fan), multi-speed\n";
    ss << "\\memo (or variable-speed), with defrost controls. Requires two to four sets\n";
    ss << "\\memo of performance data and will interpolate between speeds.\n";
    ss << "\\min-fields 40\n";
    ss << "\\extensible:11\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference HeatingCoilsDXMultiSpeed\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Minimum Outdoor Dry-Bulb Temperature for Compressor Operation\n";
    ss << "\\type real\n";
    ss << "\\default -8.0\n";
    ss << "\\units C\n";
    ss << "N2 , \\field Outdoor Dry-Bulb Temperature to Turn On Compressor\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note The outdoor temperature when the compressor is automatically turned back on following an\n";
    ss << "\\note automatic shut off because of low outdoor dry-bulb temperature. This field is only used\n";
    ss << "\\note for the calculation of HSPF. If this field is not provided, then outdoor bin temperature\n";
    ss << "\\note used in the HSPF calculation is always considered to be greater than this temperature and\n";
    ss << "\\note 'Minimum Outdoor Dry-Bulb Temperature for Compressor Operation' field described above.\n";
    ss << "\\note This assumption is based on AHRI standard 210/240 (2008) and can introduce significant error\n";
    ss << "\\note in the final value of HSPF.\n";
    ss << "N3 , \\field Crankcase Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "N4 , \\field Maximum Outdoor Dry-Bulb Temperature for Crankcase Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 10.0\n";
    ss << "\\units C\n";
    ss << "A5 , \\field Defrost Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note biquadratic curve = a + b*wb + c*wb**2 + d*oat + e*oat**2 + f*wb*oat\n";
    ss << "\\note wb = wet-bulb temperature (C) of air entering the indoor coil\n";
    ss << "\\note oat = outdoor air dry-bulb temperature (C)\n";
    ss << "\\note only required if ReverseCycle defrost strategy is specified\n";
    ss << "N5 , \\field Maximum Outdoor Dry-Bulb Temperature for Defrost Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 7.22\n";
    ss << "\\default 5.0\n";
    ss << "\\units C\n";
    ss << "A6 , \\field Defrost Strategy\n";
    ss << "\\type choice\n";
    ss << "\\key ReverseCycle\n";
    ss << "\\key Resistive\n";
    ss << "\\default ReverseCycle\n";
    ss << "A7 , \\field Defrost Control\n";
    ss << "\\type choice\n";
    ss << "\\key Timed\n";
    ss << "\\key OnDemand\n";
    ss << "\\default Timed\n";
    ss << "N6 , \\field Defrost Time Period Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.058333\n";
    ss << "\\note Fraction of time in defrost mode\n";
    ss << "\\note only applicable if timed defrost control is specified\n";
    ss << "N7 , \\field Resistive Defrost Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\note only applicable if resistive defrost strategy is specified\n";
    ss << "\\ip-units W\n";
    ss << "A8 , \\field Apply Part Load Fraction to Speeds Greater than 1\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A9 , \\field Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\default NaturalGas\n";
    ss << "N8,  \\field Region number for Calculating HSPF\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 6\n";
    ss << "\\default 4\n";
    ss << "\\note Standard Region number for which HSPF and other standard ratings are calculated\n";
    ss << "N9 , \\field Number of Speeds\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 2\n";
    ss << "\\maximum 4\n";
    ss << "\\note Enter the number of the following sets of data for coil capacity, COP,\n";
    ss << "\\note flow rate, and associated curves.\n";
    ss << "N10, \\field Speed 1 Gross Rated Heating Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\begin-extensible\n";
    ss << "\\note capacity excluding supply air fan heat\n";
    ss << "\\note rating point outdoor dry-bulb temp 8.33 C, outdoor wet-bulb temp 6.11 C\n";
    ss << "\\note rating point heating coil entering air dry-bulb 21.11 C, coil entering\n";
    ss << "\\note wet-bulb 15.55 C\n";
    ss << "N11, \\field Speed 1 Gross Rated Heating COP\n";
    ss << "\\note Rated heating capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply air fan heat or supply air fan electrical energy\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "N12, \\field Speed 1 Rated Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Flow rate corresponding to rated total capacity\n";
    ss << "\\note should be between 0.00004027 m3/s and .00006041 m3/s per watt of rated total\n";
    ss << "\\note heating capacity\n";
    ss << "N13, \\field Speed 1 Rated Supply Air Fan Power Per Volume Flow Rate\n";
    ss << "\\note Enter the supply air fan power per air volume flow rate at the rated speed 1 test conditions.\n";
    ss << "\\note The test conditions vary external static pressure based on heating capacity. This value\n";
    ss << "\\note is only used to calculate Heating Seasonal Performance Factor(HSPF). This value is not\n";
    ss << "\\note used for modeling the supply air fan during simulations.\n";
    ss << "\\type real\n";
    ss << "\\units W/(m3/s)\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1250.0\n";
    ss << "\\default 773.3\n";
    ss << "A10, \\field Speed 1 Heating Capacity Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticQuadraticCubicCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note quadratic curve = a + b*oat + c*oat**2\n";
    ss << "\\note cubic curve = a + b*oat + c*oat**2 + d*oat**3\n";
    ss << "\\note biquadratic curve = a + b*iat + c*iat**2 + d*oat + e*oat**2 + f*iat*oat\n";
    ss << "\\note oat = outdoor air dry-bulb temperature (C)\n";
    ss << "\\note iat = indoor air dry-bulb temperature (C)\n";
    ss << "\\note biquadratic curve is recommended if sufficient manufacturer data is\n";
    ss << "\\note available for the heating capacity to be sensitive to both iat and oat.\n";
    ss << "A11, \\field Speed 1 Heating Capacity Function of Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";
    ss << "A12, \\field Speed 1 Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticQuadraticCubicCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note quadratic curve = a + b*oat + c*oat**2\n";
    ss << "\\note cubic curve = a + b*oat + c*oat**2 + d*oat**3\n";
    ss << "\\note biquadratic curve = a + b*iat + c*iat**2 + d*oat + e*oat**2 + f*iat*oat\n";
    ss << "\\note oat = outdoor air dry-bulb temperature (C)\n";
    ss << "\\note iat = indoor air dry-bulb temperature (C)\n";
    ss << "\\note biquadratic curve is recommended if sufficient manufacturer data is\n";
    ss << "\\note available for the energy input ratio to be sensitive to both iat and oat.\n";
    ss << "A13, \\field Speed 1 Energy Input Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";
    ss << "A14, \\field Speed 1 Part Load Fraction Correlation Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLR = part load ratio (sensible heating load/steady state heating capacity)\n";
    ss << "N13, \\field Speed 1 Rated Waste Heat Fraction of Power Input\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note recoverable waste heat at full load and rated conditions\n";
    ss << "A15; \\field Speed 1 Waste Heat Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*odb + c*odb**2 + d*db + e*db**2 + f*odb*db\n";
    ss << "\\note odb = Outdoor air dry-bulb temperature (C)\n";
    ss << "\\note db = entering coil dry-bulb temperature (C)\n";

    IddObjectType objType(IddObjectType::Coil_Heating_DX_MultiSpeed);
    OptionalIddObject oObj = IddObject::load("Coil:Heating:DX:MultiSpeed",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Heating_DX_MultiSpeed);
  return object;
}

IddObject createCoil_Heating_DX_VariableSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Heating:DX:VariableSpeed,\n";
    ss << "\\memo Direct expansion (DX) heating coil (air-to-air heat pump) and compressor unit\n";
    ss << "\\memo (includes electric compressor and outdoor fan), variable-speed, with defrost\n";
    ss << "\\memo controls. Requires two to ten sets of performance data and will interpolate between\n";
    ss << "\\memo speeds.\n";
    ss << "\\extensible:7\n";
    ss << "\\min-fields 25\n";
    ss << "\\max-fields 88\n";
    ss << "\\memo This object is used for variable speed DX coil in heating mode using performance curves.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatingCoilsDXVariableSpeed\n";
    ss << "A2,  \\field Indoor Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3,  \\field Indoor Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,  \\field Number of Speeds\n";
    ss << "\\units dimensionless\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 10\n";
    ss << "\\default 2\n";
    ss << "N2,  \\field Nominal Speed Level\n";
    ss << "\\units dimensionless\n";
    ss << "\\type integer\n";
    ss << "\\default 2\n";
    ss << "\\note must be lower than or equal to the highest speed number\n";
    ss << "N3,  \\field Rated Heating Capacity At Selected Nominal Speed Level\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N4,  \\field Rated Air Flow Rate At Selected Nominal Speed Level\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "A4,  \\field Energy Part Load Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLR = part load ratio (heating load/steady state capacity)\n";
    ss << "A5,  \\field Defrost Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note biquadratic curve = a + b*wb + c*wb**2 + d*oat + e*oat**2 + f*wb*oat\n";
    ss << "\\note wb = wet-bulb temperature (C) of air entering the indoor coil\n";
    ss << "\\note oat = outdoor air dry-bulb temperature (C)\n";
    ss << "\\note only required if ReverseCycle defrost strategy is specified\n";
    ss << "N5,  \\field Minimum Outdoor Dry-Bulb Temperature for Compressor Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum -50.0\n";
    ss << "\\default -8.0\n";
    ss << "\\units C\n";
    ss << "N6,  \\field Outdoor Dry-Bulb Temperature to Turn On Compressor\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note The outdoor temperature when the compressor is automatically turned back on following an\n";
    ss << "\\note automatic shut off because of low outdoor dry-bulb temperature. This field is only used\n";
    ss << "\\note for the calculation of HSPF. If this field is not provided, then outdoor bin temperature\n";
    ss << "\\note used in the HSPF calculation is always considered to be greater than this temperature and\n";
    ss << "\\note 'Minimum Outdoor Dry-Bulb Temperature for Compressor Operation' field described above.\n";
    ss << "\\note This assumption is based on AHRI standard 210/240 (2008) and can introduce significant error\n";
    ss << "\\note in the final value of HSPF.\n";
    ss << "N7,  \\field Maximum Outdoor Dry-Bulb Temperature for Defrost Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 7.22\n";
    ss << "\\default 5.0\n";
    ss << "\\units C\n";
    ss << "N8,  \\field Crankcase Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "N9,  \\field Maximum Outdoor Dry-Bulb Temperature for Crankcase Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 10.0\n";
    ss << "\\units C\n";
    ss << "A6,  \\field Defrost Strategy\n";
    ss << "\\type choice\n";
    ss << "\\key ReverseCycle\n";
    ss << "\\key Resistive\n";
    ss << "\\default ReverseCycle\n";
    ss << "A7,  \\field Defrost Control\n";
    ss << "\\type choice\n";
    ss << "\\key Timed\n";
    ss << "\\key OnDemand\n";
    ss << "\\default Timed\n";
    ss << "N10, \\field Defrost Time Period Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.058333\n";
    ss << "\\note Fraction of time in defrost mode\n";
    ss << "\\note only applicable if timed defrost control is specified\n";
    ss << "N11, \\field Resistive Defrost Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\note only applicable if resistive defrost strategy is specified\n";
    ss << "\\ip-units W\n";
    ss << "N12, \\field Speed 1 Reference Unit Gross Rated Heating Capacity\n";
    ss << "\\note Heating capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "N13, \\field Speed 1 Reference Unit Gross Rated Heating COP\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N14,  \\field Speed 1 Reference Unit Rated Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "A8,  \\field Speed 1 Heating Capacity Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*db + c*db**2 + d*oat + e*oat**2 + f*db*oat\n";
    ss << "\\note db = entering air dry-bulb temperature (C)\n";
    ss << "\\note oat = air entering temperature seen by the evaporator (C)\n";
    ss << "A9,  \\field Speed 1 Total  Heating Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A10, \\field Speed 1 Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*db + c*db**2 + d*oat + e*oat**2 + f*db*oat\n";
    ss << "\\note db = entering air dry-bulb temperature (C)\n";
    ss << "\\note oat = air entering temperature seen by the evaporator (C)\n";
    ss << "A11; \\field Speed 1 Energy Input Ratio Function of Air Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";

    IddObjectType objType(IddObjectType::Coil_Heating_DX_VariableSpeed);
    OptionalIddObject oObj = IddObject::load("Coil:Heating:DX:VariableSpeed",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Heating_DX_VariableSpeed);
  return object;
}

IddObject createCoil_Cooling_WaterToAirHeatPump_ParameterEstimationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Cooling:WaterToAirHeatPump:ParameterEstimation,\n";
    ss << "\\memo Direct expansion (DX) cooling coil for water-to-air heat pump (includes electric\n";
    ss << "\\memo compressor), single-speed, parameter estimation model. Optional inputs for moisture\n";
    ss << "\\memo evaporation from wet coil when compressor cycles off with continuous fan operation.\n";
    ss << "\\memo Parameter estimation model is a deterministic model that requires a consistent set of\n";
    ss << "\\memo parameters to describe the operating conditions of the heat pump components.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingCoilsWaterToAirHP\n";
    ss << "A2 , \\field Compressor Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Reciprocating\n";
    ss << "\\key Rotary\n";
    ss << "\\key Scroll\n";
    ss << "\\note Parameters 1-5 are as named below.\n";
    ss << "\\note Parameters 6-10 depend on the type of compressor and fluid.\n";
    ss << "\\note Refer to the InputOutputReference on the parameters required\n";
    ss << "A3,  \\field Refrigerant Type\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FluidNames\n";
    ss << "\\default R22\n";
    ss << "N1,  \\field Design Source Side Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N2,  \\field Nominal Cooling Coil Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W\n";
    ss << "N3,  \\field Nominal Time for Condensate Removal to Begin\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 3000.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note The nominal time for condensate to begin leaving the coil's condensate\n";
    ss << "\\note drain line at the coil's rated air flow rate and temperature conditions.\n";
    ss << "\\note Nominal time is equal to the ratio of the energy of the coil's maximum\n";
    ss << "\\note condensate holding capacity (J) to the coil's steady state latent capacity (W).\n";
    ss << "\\note Suggested value is 1000; zero value means latent degradation model is disabled.\n";
    ss << "N4,  \\field Ratio of Initial Moisture Evaporation Rate and Steady State Latent Capacity\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 5.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Ratio of the initial moisture evaporation rate from the cooling coil (when\n";
    ss << "\\note the compressor first turns off) and the coil's steady state latent capacity\n";
    ss << "\\note at rated air flow rate and temperature conditions. Suggested value is 1.5; zero value\n";
    ss << "\\note means latent degradation model is disabled.\n";
    ss << "N5,  \\field High Pressure Cutoff\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units Pa\n";
    ss << "N6,  \\field Low Pressure Cutoff\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units Pa\n";
    ss << "A4,  \\field Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5,  \\field Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6,  \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7,  \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N7,  \\field Load Side Total Heat Transfer Coefficient\n";
    ss << "\\note Previously called Parameter 1\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "N8,  \\field Load Side Outside Surface Heat Transfer Coefficient\n";
    ss << "\\note Previously called Parameter 2\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "N9,  \\field Superheat Temperature at the Evaporator Outlet\n";
    ss << "\\note Previously called Parameter 3\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N10, \\field Compressor Power Losses\n";
    ss << "\\note Accounts for the loss of work due to mechanical and electrical losses in the compressor.\n";
    ss << "\\note Previously called Parameter 4\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "N11, \\field Compressor Efficiency\n";
    ss << "\\note Previously called Parameter 5\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "N12, \\field Compressor Piston Displacement\n";
    ss << "\\note Use when Compressor Type is Reciprocating or Rotary\n";
    ss << "\\note Leave this field blank for Compressor Type is Scroll.\n";
    ss << "\\note Previously part of Parameter 6\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "N13, \\field Compressor Suction/Discharge Pressure Drop\n";
    ss << "\\note Used when Compressor Type is Rotary or Reciprocating\n";
    ss << "\\note Leave this field blank for Compressor Type is Scroll.\n";
    ss << "\\note Previously part of Parameter 7\n";
    ss << "\\units Pa\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "N14, \\field Compressor Clearance Factor\n";
    ss << "\\note Used when Compressor Type is Reciprocating.\n";
    ss << "\\note Leave this field blank for Compressor Type is Rotary or Scroll.\n";
    ss << "\\note Previously part of Parameter 8\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "N15, \\field Refrigerant Volume Flow Rate\n";
    ss << "\\note Use when Compressor Type is Scroll\n";
    ss << "\\note Leave this field blank for Compressor Type is Rotary or Reciprocating.\n";
    ss << "\\note Previously part of Parameter 6\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "N16, \\field Volume Ratio\n";
    ss << "\\note Use when Compressor Type is Scroll.\n";
    ss << "\\note Leave this field blank for Compressor Type is Rotary or Reciprocating.\n";
    ss << "\\note Previously part of Parameter 7\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "N17, \\field Leak Rate Coefficient\n";
    ss << "\\note Use when Compressor Type is Scroll.\n";
    ss << "\\note Leave this field blank for Compressor Type is Rotary or Reciprocating.\n";
    ss << "\\note Previously part of Parameter 8\n";
    ss << "\\minimum 0.0\n";
    ss << "\\type real\n";
    ss << "N18, \\field Source Side Heat Transfer Coefficient\n";
    ss << "\\note Use when Source Side Fluid Name is Water\n";
    ss << "\\note Leave this field blank when Source Side Fluid Name is an antifreeze\n";
    ss << "\\note Previously part of Parameter 9\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\type real\n";
    ss << "N19, \\field Source Side Heat Transfer Resistance1\n";
    ss << "\\note Use when Source Side Fluid Name is an antifreeze\n";
    ss << "\\note Leave this field blank for Source Side Fluid is Water\n";
    ss << "\\note Previously part of Parameter 9\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "N20; \\field Source Side Heat Transfer Resistance2\n";
    ss << "\\note Use when Source Side Fluid Name is an antifreeze\n";
    ss << "\\note Leave this field blank for Source Side Fluid is Water\n";
    ss << "\\note Previously part of Parameter 10\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::Coil_Cooling_WaterToAirHeatPump_ParameterEstimation);
    OptionalIddObject oObj = IddObject::load("Coil:Cooling:WaterToAirHeatPump:ParameterEstimation",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Cooling_WaterToAirHeatPump_ParameterEstimation);
  return object;
}

IddObject createCoil_Heating_WaterToAirHeatPump_ParameterEstimationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Heating:WaterToAirHeatPump:ParameterEstimation,\n";
    ss << "\\memo Direct expansion (DX) heating coil for water-to-air heat pump (includes electric\n";
    ss << "\\memo compressor), single-speed, parameter estimation model. Parameter estimation model is\n";
    ss << "\\memo a deterministic model that requires a consistent set of parameters to describe\n";
    ss << "\\memo the operating conditions of the heat pump components.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatingCoilsWaterToAirHP\n";
    ss << "A2 , \\field Compressor Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Reciprocating\n";
    ss << "\\key Rotary\n";
    ss << "\\key Scroll\n";
    ss << "\\note Parameters 1-4 are as named below.\n";
    ss << "\\note Parameters 5-9 depend on the type of compressor.\n";
    ss << "\\note Refer to the InputOutputReference on the parameters required\n";
    ss << "A3,  \\field Refrigerant Type\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FluidNames\n";
    ss << "\\default R22\n";
    ss << "N1,  \\field Design Source Side Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N2,  \\field Gross Rated Heating Capacity\n";
    ss << "\\note Heating capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W\n";
    ss << "N3, \\field High Pressure Cutoff\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N4, \\field Low Pressure Cutoff\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units Pa\n";
    ss << "A4,  \\field Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5,  \\field Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6,  \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7,  \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N5,  \\field Load Side Total Heat Transfer Coefficient\n";
    ss << "\\note Previously called Parameter 1\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "N6,  \\field Superheat Temperature at the Evaporator Outlet\n";
    ss << "\\note Previously called Parameter 2\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N7,  \\field Compressor Power Losses\n";
    ss << "\\note Accounts for the loss of work due to mechanical and electrical losses in the compressor.\n";
    ss << "\\note Previously called Parameter 3\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "N8,  \\field Compressor Efficiency\n";
    ss << "\\note Previously called Parameter 4\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "N9,  \\field Compressor Piston Displacement\n";
    ss << "\\note Use when Compressor Type is Reciprocating or Rotary\n";
    ss << "\\note Leave this field blank for Compressor Type is Scroll.\n";
    ss << "\\note Previously part of Parameter 5\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "N10, \\field Compressor Suction/Discharge Pressure Drop\n";
    ss << "\\note Used when Compressor Type is Rotary or Reciprocating\n";
    ss << "\\note Leave this field blank for Compressor Type is Scroll.\n";
    ss << "\\note Previously part of Parameter 6\n";
    ss << "\\units Pa\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "N11, \\field Compressor Clearance Factor\n";
    ss << "\\note Used when Compressor Type is Reciprocating.\n";
    ss << "\\note Leave this field blank for Compressor Type is Rotary or Scroll.\n";
    ss << "\\note Previously part of Parameter 7\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "N12, \\field Refrigerant Volume Flow Rate\n";
    ss << "\\note Use when Compressor Type is Scroll\n";
    ss << "\\note Leave this field blank for Compressor Type is Rotary or Reciprocating.\n";
    ss << "\\note Previously part of Parameter 5\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "N13, \\field Volume Ratio\n";
    ss << "\\note Use when Compressor Type is Scroll.\n";
    ss << "\\note Leave this field blank for Compressor Type is Rotary or Reciprocating.\n";
    ss << "\\note Previously part of Parameter 6\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "N14, \\field Leak Rate Coefficient\n";
    ss << "\\note Use when Compressor Type is Scroll.\n";
    ss << "\\note Leave this field blank for Compressor Type is Rotary or Reciprocating.\n";
    ss << "\\note Previously part of Parameter 7\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\type real\n";
    ss << "N15, \\field Source Side Heat Transfer Coefficient\n";
    ss << "\\note Use when Source Side Fluid Name is Water\n";
    ss << "\\note Leave this field blank when Source Side Fluid is an antifreeze\n";
    ss << "\\note Previously part of Parameter 8\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\type real\n";
    ss << "N16, \\field Source Side Heat Transfer Resistance1\n";
    ss << "\\note Use when Source Side Fluid Name is an antifreeze\n";
    ss << "\\note Leave this field blank for Source Side Fluid is Water\n";
    ss << "\\note Previously part of Parameter 8\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "N17; \\field Source Side Heat Transfer Resistance2\n";
    ss << "\\note Use when Source Side Fluid Name is an antifreeze\n";
    ss << "\\note Leave this field blank for Source Side Fluid is Water\n";
    ss << "\\note Previously part of Parameter 9\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::Coil_Heating_WaterToAirHeatPump_ParameterEstimation);
    OptionalIddObject oObj = IddObject::load("Coil:Heating:WaterToAirHeatPump:ParameterEstimation",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Heating_WaterToAirHeatPump_ParameterEstimation);
  return object;
}

IddObject createCoil_Cooling_WaterToAirHeatPump_EquationFitIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Cooling:WaterToAirHeatPump:EquationFit,\n";
    ss << "\\memo Direct expansion (DX) cooling coil for water-to-air heat pump (includes electric\n";
    ss << "\\memo compressor), single-speed, equation-fit model. Optional inputs for moisture\n";
    ss << "\\memo evaporation from wet coil when compressor cycles off with continuous fan operation.\n";
    ss << "\\memo Equation-fit model uses normalized curves to describe the heat pump performance.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingCoilsWaterToAirHP\n";
    ss << "A2,  \\field Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3,  \\field Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5,  \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,  \\field Rated Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "N2,  \\field Rated Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\autosizable\n";
    ss << "N3,  \\field Gross Rated Total Cooling Capacity\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "N4,  \\field Gross Rated Sensible Cooling Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "N5,  \\field Gross Rated Cooling COP\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N6,  \\field Total Cooling Capacity Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N7, \\field Total Cooling Capacity Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N8, \\field Total Cooling Capacity Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N9, \\field Total Cooling Capacity Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N10, \\field Total Cooling Capacity Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N11, \\field Sensible Cooling Capacity Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N12, \\field Sensible Cooling Capacity Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N13, \\field Sensible Cooling Capacity Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N14, \\field Sensible Cooling Capacity Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N15, \\field Sensible Cooling Capacity Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N16, \\field Sensible Cooling Capacity Coefficient 6\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N17, \\field Cooling Power Consumption Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N18, \\field Cooling Power Consumption Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N19, \\field Cooling Power Consumption Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N20, \\field Cooling Power Consumption Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N21, \\field Cooling Power Consumption Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N22, \\field Nominal Time for Condensate Removal to Begin\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 3000.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note The nominal time for condensate to begin leaving the coil's condensate\n";
    ss << "\\note drain line at the coil's rated air flow and temperature conditions.\n";
    ss << "\\note Nominal time is equal to the ratio of the energy of the coil's maximum\n";
    ss << "\\note condensate holding capacity (J) to the coil's steady state latent capacity (W).\n";
    ss << "\\note Suggested value is 1000; zero value means latent degradation model is disabled.\n";
    ss << "N23; \\field Ratio of Initial Moisture Evaporation Rate and Steady State Latent Capacity\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 5.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Ratio of the initial moisture evaporation rate from the cooling coil (when\n";
    ss << "\\note the compressor first turns off) and the coil's steady state latent capacity\n";
    ss << "\\note at rated air flow rate and temperature conditions. Suggested value is 1.5; zero value\n";
    ss << "\\note means latent degradation model is disabled.\n";

    IddObjectType objType(IddObjectType::Coil_Cooling_WaterToAirHeatPump_EquationFit);
    OptionalIddObject oObj = IddObject::load("Coil:Cooling:WaterToAirHeatPump:EquationFit",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Cooling_WaterToAirHeatPump_EquationFit);
  return object;
}

IddObject createCoil_Cooling_WaterToAirHeatPump_VariableSpeedEquationFitIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Cooling:WaterToAirHeatPump:VariableSpeedEquationFit,\n";
    ss << "\\memo Direct expansion (DX) cooling coil for water-to-air heat pump (includes electric\n";
    ss << "\\memo compressor), variable-speed, equation-fit model. Optional inputs for moisture\n";
    ss << "\\memo evaporation from wet coil when compressor cycles off with continuous fan operation.\n";
    ss << "\\memo Equation-fit model uses normalized curves to describe the heat pump performance.\n";
    ss << "\\memo Requires two to ten sets of performance data and will interpolate between speeds.\n";
    ss << "\\memo Modeled as a single coil with variable-speed compressor.\n";
    ss << "\\extensible:13\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingCoilsWaterToAirVSHP\n";
    ss << "A2,  \\field Water-to-Refrigerant HX Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3,  \\field Water-to-Refrigerant HX Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Indoor Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5,  \\field Indoor Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,  \\field Number of Speeds\n";
    ss << "\\units dimensionless\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 10\n";
    ss << "\\default 2\n";
    ss << "N2,  \\field Nominal Speed Level\n";
    ss << "\\units dimensionless\n";
    ss << "\\type integer\n";
    ss << "\\default 2\n";
    ss << "\\note must be lower than or equal to the highest speed number\n";
    ss << "N3,  \\field Gross Rated Total Cooling Capacity At Selected Nominal Speed Level\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N4,  \\field Rated Air Flow Rate At Selected Nominal Speed Level\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N5,  \\field Rated Water Flow Rate At Selected Nominal Speed Level\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N6,  \\field Nominal Time for Condensate to Begin Leaving the Coil\n";
    ss << "\\units s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N7,  \\field Initial Moisture Evaporation Rate Divided by Steady-State AC Latent Capacity\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N8,  \\field Flag for Using Hot Gas Reheat, 0 or 1\n";
    ss << "\\note Flag for using hot gas reheat, 0 - not used, 1 - used\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "A6,  \\field Energy Part Load Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLR = part load ratio (cooling load/steady state capacity)\n";
    ss << "N9,  \\field Speed 1 Reference Unit Gross Rated Total Cooling Capacity\n";
    ss << "\\begin-extensible\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N10, \\field Speed 1 Reference Unit Gross Rated Sensible Heat Ratio\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\Maximum 1.0\n";
    ss << "\\required-field\n";
    ss << "N11, \\field Speed 1 Reference Unit Gross Rated Cooling COP\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N12, \\field Speed 1 Reference Unit Rated Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N13, \\field Speed 1 Reference Unit Rated Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "A7,  \\field Speed 1 Total Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A8,   \\field Speed 1 Total Cooling Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A9,  \\field Speed 1 Total Cooling Capacity Function of Water Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "A10, \\field Speed 1 Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A11, \\field Speed 1 Energy Input Ratio Function of Air Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A12, \\field Speed 1 Energy Input Ratio Function of Water Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "N14, \\field Speed 1 Reference Unit Waste Heat Fraction of Input Power At Rated Conditions\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "A13; \\field Speed 1 Waste Heat Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";

    IddObjectType objType(IddObjectType::Coil_Cooling_WaterToAirHeatPump_VariableSpeedEquationFit);
    OptionalIddObject oObj = IddObject::load("Coil:Cooling:WaterToAirHeatPump:VariableSpeedEquationFit",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Cooling_WaterToAirHeatPump_VariableSpeedEquationFit);
  return object;
}

IddObject createCoil_Heating_WaterToAirHeatPump_EquationFitIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Heating:WaterToAirHeatPump:EquationFit,\n";
    ss << "\\memo Direct expansion (DX) heating coil for water-to-air heat pump (includes electric\n";
    ss << "\\memo compressor), single-speed, equation-fit model. Equation-fit model uses normalized\n";
    ss << "\\memo curves to describe the heat pump performance.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatingCoilsWaterToAirHP\n";
    ss << "A2,  \\field Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3,  \\field Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5,  \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,  \\field Rated Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "N2,  \\field Rated Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\autosizable\n";
    ss << "N3,  \\field Gross Rated Heating Capacity\n";
    ss << "\\note Heating capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "N4,  \\field Gross Rated Heating COP\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N5,  \\field Heating Capacity Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N6,  \\field Heating Capacity Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N7,  \\field Heating Capacity Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N8,  \\field Heating Capacity Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N9,  \\field Heating Capacity Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N10, \\field Heating Power Consumption Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N11, \\field Heating Power Consumption Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N12, \\field Heating Power Consumption Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N13, \\field Heating Power Consumption Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N14; \\field Heating Power Consumption Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::Coil_Heating_WaterToAirHeatPump_EquationFit);
    OptionalIddObject oObj = IddObject::load("Coil:Heating:WaterToAirHeatPump:EquationFit",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Heating_WaterToAirHeatPump_EquationFit);
  return object;
}

IddObject createCoil_Heating_WaterToAirHeatPump_VariableSpeedEquationFitIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Heating:WaterToAirHeatPump:VariableSpeedEquationFit,\n";
    ss << "\\memo Direct expansion (DX) heating coil for water-to-air heat pump (includes electric\n";
    ss << "\\memo compressor), variable-speed, equation-fit model. Equation-fit model uses normalized\n";
    ss << "\\memo curves to describe the heat pump performance. Requires two to ten sets of performance\n";
    ss << "\\memo data and will interpolate between speeds.\n";
    ss << "\\extensible:12\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatingCoilsWaterToAirVSHP\n";
    ss << "A2,  \\field Water-to-Refrigerant HX Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3,  \\field Water-to-Refrigerant HX Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Indoor Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5,  \\field Indoor Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,  \\field Number of Speeds\n";
    ss << "\\units dimensionless\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 10\n";
    ss << "\\default 2\n";
    ss << "N2,  \\field Nominal Speed Level\n";
    ss << "\\units dimensionless\n";
    ss << "\\type integer\n";
    ss << "\\default 2\n";
    ss << "\\note must be lower than or equal to the highest speed number\n";
    ss << "N3,  \\field Rated Heating Capacity At Selected Nominal Speed Level\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N4,  \\field Rated Air Flow Rate At Selected Nominal Speed Level\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N5,  \\field Rated Water Flow Rate At Selected Nominal Speed Level\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "A6,  \\field Energy Part Load Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLR = part load ratio (heating load/steady state capacity)\n";
    ss << "N6,  \\field Speed 1 Reference Unit Gross Rated Heating Capacity\n";
    ss << "\\note Heating capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "N7,  \\field Speed 1 Reference Unit Gross Rated Heating COP\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N8,  \\field Speed 1 Reference Unit Rated Air Flow\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N9,  \\field Speed 1 Reference Unit Rated Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "A7,  \\field Speed 1 Heating Capacity Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*db + c*db**2 + d*ewt + e*ewt**2 + f*db*ewt\n";
    ss << "\\note db = entering air dry-bulb temperature (C)\n";
    ss << "\\note ewt = water entering temperature seen by the evaporator (C)\n";
    ss << "A8,  \\field Speed 1 Total  Heating Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A9,  \\field Speed 1 Heating Capacity Function of Water Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "A10, \\field Speed 1 Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*db + c*db**2 + d*ewt + e*ewt**2 + f*db*ewt\n";
    ss << "\\note db = entering air dry-bulb temperature (C)\n";
    ss << "\\note ewt = water entering temperature seen by the evaporator (C)\n";
    ss << "A11, \\field Speed 1 Energy Input Ratio Function of Air Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A12, \\field Speed 1 Energy Input Ratio Function of Water Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "N10, \\field Speed 1 Reference Unit Waste Heat Fraction of Input Power At Rated Conditions\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "A13; \\field Speed 1 Waste Heat Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*db + c*db**2 + d*ewt + e*ewt**2 + f*db*ewt\n";
    ss << "\\note db = entering air dry-bulb temperature (C)\n";
    ss << "\\note ewt = water entering temperature seen by the evaporator (C)\n";

    IddObjectType objType(IddObjectType::Coil_Heating_WaterToAirHeatPump_VariableSpeedEquationFit);
    OptionalIddObject oObj = IddObject::load("Coil:Heating:WaterToAirHeatPump:VariableSpeedEquationFit",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Heating_WaterToAirHeatPump_VariableSpeedEquationFit);
  return object;
}

IddObject createCoil_WaterHeating_AirToWaterHeatPump_PumpedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:WaterHeating:AirToWaterHeatPump:Pumped,\n";
    ss << "\\memo Heat pump water heater (HPWH) heating coil, air-to-water direct-expansion (DX)\n";
    ss << "\\memo system which includes a water heating coil, evaporator air coil, evaporator\n";
    ss << "\\memo fan, electric compressor, and water pump. Part of a WaterHeater:HeatPump:PumpedCondenser system.\n";
    ss << "\\min-fields 21\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatPumpWaterHeaterDXCoilsPumped\n";
    ss << "\\note Unique name for this instance of a heat pump water heater DX coil.\n";
    ss << "N1 , \\field Rated Heating Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Heating capacity at the rated inlet air temperatures, rated condenser inlet\n";
    ss << "\\note water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump heat.\n";
    ss << "N2 , \\field Rated COP\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 3.2\n";
    ss << "\\note Heating coefficient of performance at the rated inlet air temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump power and evaporator fan power (see fields below).\n";
    ss << "N3 , \\field Rated Sensible Heat Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.85\n";
    ss << "\\note Gross air-side sensible heat ratio at the rated inlet air temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Sensible heat ratio equals gross sensible cooling capacity divided by gross total cooling\n";
    ss << "\\note capacity. Rated SHR (gross) should not include evaporator fan heat, only sensible cooling\n";
    ss << "\\note and dehumidification by the coil alone.\n";
    ss << "N4 , \\field Rated Evaporator Inlet Air Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 5\n";
    ss << "\\default 19.7\n";
    ss << "\\note Evaporator inlet air dry-bulb temperature corresponding to rated coil performance\n";
    ss << "\\note (heating capacity, COP and SHR).\n";
    ss << "N5 , \\field Rated Evaporator Inlet Air Wet-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 5\n";
    ss << "\\default 13.5\n";
    ss << "\\note Evaporator inlet air wet-bulb temperature corresponding to rated coil performance\n";
    ss << "\\note (heating capacity, COP and SHR).\n";
    ss << "N6 , \\field Rated Condenser Inlet Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 25\n";
    ss << "\\default 57.5\n";
    ss << "\\note Condenser inlet water temperature corresponding to rated coil performance\n";
    ss << "\\note (heating capacity, COP and SHR).\n";
    ss << "N7 , \\field Rated Evaporator Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Evaporator air flow rate corresponding to rated coil performance\n";
    ss << "\\note (heating capacity, COP and SHR).\n";
    ss << "\\note Default is 5.035E-5 m3/s/W (31.25 cfm/MBH) of rated heating capacity when autocalculated.\n";
    ss << "N8 , \\field Rated Condenser Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Condenser water flow rate corresponding to rated coil performance\n";
    ss << "\\note (heating capacity, COP and SHR).\n";
    ss << "\\note Default is 4.487E-8 m3/s/W (0.208 gpm/MBH) of rated heating capacity when autocalculated.\n";
    ss << "\\note A warning message will be issued if the ratio of Rated Condenser Water Flow Rate\n";
    ss << "\\note to Heating Capacity is less than 1.79405E-8 m3/s/W (0.083 gpm/MBH)\n";
    ss << "\\note or greater than 8.97024E-8 m3/s/W (0.417 gpm/MBH), but the simulation will continue.\n";
    ss << "A2 , \\field Evaporator Fan Power Included in Rated COP\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "\\note Select Yes if the evaporator fan power is included in the rated COP. This choice field\n";
    ss << "\\note impacts the calculation of compressor electric power.\n";
    ss << "A3 , \\field Condenser Pump Power Included in Rated COP\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note Select Yes if the condenser pump power is included in the rated COP. This choice field\n";
    ss << "\\note impacts the calculation of compressor electric power.\n";
    ss << "A4 , \\field Condenser Pump Heat Included in Rated Heating Capacity and Rated COP\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note Select Yes if the condenser pump heat is included in the rated heating capacity and\n";
    ss << "\\note rated COP. This choice field impacts the calculation of water heating capacity.\n";
    ss << "N9 , \\field Condenser Water Pump Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note A warning message will be issued if the ratio of Condenser Water Pump Power to Rated\n";
    ss << "\\note Heating Capacity exceeds 0.1422 W/W (41.67 Watts/MBH), but the simulation will continue.\n";
    ss << "N10, \\field Fraction of Condenser Pump Heat to Water\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.2\n";
    ss << "\\note Fraction of pump heat transferred to the condenser water. The pump is assumed\n";
    ss << "\\note to be located downstream of the condenser.\n";
    ss << "A5 , \\field Evaporator Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note The node from which the DX coil draws its inlet air.\n";
    ss << "A6 , \\field Evaporator Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note The node to which the DX coil sends its outlet air.\n";
    ss << "A7 , \\field Condenser Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note The node from which the DX coil condenser draws its inlet water.\n";
    ss << "\\note This name should match the source side outlet node name in the associated\n";
    ss << "\\note water heater tank object.\n";
    ss << "A8 , \\field Condenser Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note The node to which the DX coil condenser sends its outlet water.\n";
    ss << "\\note This name should match the source side inlet node name in the associated\n";
    ss << "\\note water heater tank object.\n";
    ss << "N11, \\field Crankcase Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\units W\n";
    ss << "\\note The compressor crankcase heater only operates when the dry-bulb temperature of air\n";
    ss << "\\note surrounding the compressor is below the Maximum Ambient Temperature for Crankcase\n";
    ss << "\\note Heater Operation and the DX coil is off.  The ambient temperature surrounding the\n";
    ss << "\\note compressor is set by the WaterHeater:HeatPump:PumpedCondenser parent object (field Compressor Location).\n";
    ss << "N12, \\field Maximum Ambient Temperature for Crankcase Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 10\n";
    ss << "\\units C\n";
    ss << "\\note The compressor crankcase heater only operates when the dry-bulb temperature of air\n";
    ss << "\\note surrounding the compressor is below the Maximum Outdoor Temperature for Crankcase\n";
    ss << "\\note Heater Operation and the unit is off. The ambient temperature surrounding the\n";
    ss << "\\note compressor is set by the WaterHeater:HeatPump:PumpedCondenser parent object (field Compressor Location).\n";
    ss << "A9 , \\field Evaporator Air Temperature Type for Curve Objects\n";
    ss << "\\type choice\n";
    ss << "\\key DryBulbTemperature\n";
    ss << "\\key WetBulbTemperature\n";
    ss << "\\default WetBulbTemperature\n";
    ss << "\\note Determines temperature type for heating capacity curves and\n";
    ss << "\\note heating COP curves. This input determines whether\n";
    ss << "\\note the inlet air dry-bulb or wet-bulb temperature is used to evaluate these curves.\n";
    ss << "A10, \\field Heating Capacity Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCubicCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Heating capacity modifier curve (function of temperature) should be biquadratic or cubic.\n";
    ss << "\\note Biquadratic curve = a + b(ta) + c(ta)^2 + d(tw) + e(tw)^2 + f(ta)(tw).\n";
    ss << "\\note Cubic curve = a + b(ta) + c(ta)^2 + d(ta)^3.\n";
    ss << "\\note ta = evaporator inlet air [dry-bulb or wet-bulb] temperature (C).\n";
    ss << "\\note tw = condenser inlet water temperature (C).\n";
    ss << "\\note The field Evaporator Air Temperature Type for Curve Objects determines if dry-bulb or wet-bulb\n";
    ss << "\\note is used as the evaporator inlet air temperature (ta).\n";
    ss << "A11, \\field Heating Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Heating capacity modifier curve (function of air flow fraction) should be quadratic or cubic.\n";
    ss << "\\note Quadratic curve = a + b(ff) + c(ff)^2.\n";
    ss << "\\note Cubic curve = a + b(ff) + c(ff)^2 + d(ff)^3.\n";
    ss << "\\note ff = fraction of the rated evaporator air flow rate.\n";
    ss << "\\note Use curve coefficients of 1,0,0 or leave this field blank when neglecting performance impacts\n";
    ss << "\\note due to variations in air flow rate fraction.\n";
    ss << "A12, \\field Heating Capacity Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Heating capacity modifier curve (function of water flow fraction) should be quadratic or cubic.\n";
    ss << "\\note Quadratic curve = a + b(ff) + c(ff)^2.\n";
    ss << "\\note Cubic curve = a + b(ff) + c(ff)^2 + d(ff)^3.\n";
    ss << "\\note ff = fraction of the rated condenser water flow rate.\n";
    ss << "\\note Use curve coefficients of 1,0,0 or leave this field blank when neglecting performance impacts\n";
    ss << "\\note due to variations in water flow rate fraction.\n";
    ss << "A13, \\field Heating COP Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCubicCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Heating COP modifier curve (function of temperature) should be biquadratic or cubic.\n";
    ss << "\\note Biquadratic curve = a + b(ta) + c(ta)^2 + d(tw) + e(tw)^2 + f(ta)(tw).\n";
    ss << "\\note Cubic curve = a + b(ta) + c(ta)^2 + d(ta)^3.\n";
    ss << "\\note ta = evaporator inlet air [dry-bulb or wet-bulb] temperature (C).\n";
    ss << "\\note tw = condenser inlet water temperature (C).\n";
    ss << "\\note The field Evaporator Air Temperature Type for Curve Objects determines if dry-bulb or wet-bulb\n";
    ss << "\\note is used as the evaporator inlet air temperature (ta).\n";
    ss << "A14, \\field Heating COP Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Heating COP modifier curve (function of air flow fraction) should be quadratic or cubic.\n";
    ss << "\\note Quadratic curve = a + b(ff) + c(ff)^2.\n";
    ss << "\\note Cubic curve = a + b(ff) + c(ff)^2 + d(ff)^3.\n";
    ss << "\\note ff = fraction of the rated evaporator air flow rate.\n";
    ss << "\\note Use curve coefficients of 1,0,0 or leave this field blank when neglecting performance impacts\n";
    ss << "\\note due to variations in air flow rate fraction.\n";
    ss << "A15, \\field Heating COP Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Heating COP modifier curve (function of water flow fraction) should be quadratic or cubic.\n";
    ss << "\\note Quadratic curve = a + b(ff) + c(ff)^2.\n";
    ss << "\\note Cubic curve = a + b(ff) + c(ff)^2 + d(ff)^3.\n";
    ss << "\\note ff = fraction of the rated condenser water flow rate.\n";
    ss << "\\note Use curve coefficients of 1,0,0 or leave this field blank when neglecting performance impacts\n";
    ss << "\\note due to variations in water flow rate fraction.\n";
    ss << "A16; \\field Part Load Fraction Correlation Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Part Load Fraction Correlation (function of part load ratio) should be quadratic or cubic.\n";
    ss << "\\note Quadratic curve = a + b(PLR) + c(PLR)^2.\n";
    ss << "\\note Cubic curve = a + b(PLR) + c(PLR)^2 + d(PLR)^3.\n";
    ss << "\\note PLR = part load ratio (heating delivered/steady state heating capacity).\n";
    ss << "\\note Use curve coefficients of 1,0,0 or leave this field blank when neglecting performance impacts\n";
    ss << "\\note due to variations in part load ratio.\n";

    IddObjectType objType(IddObjectType::Coil_WaterHeating_AirToWaterHeatPump_Pumped);
    OptionalIddObject oObj = IddObject::load("Coil:WaterHeating:AirToWaterHeatPump:Pumped",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_WaterHeating_AirToWaterHeatPump_Pumped);
  return object;
}

IddObject createCoil_WaterHeating_AirToWaterHeatPump_WrappedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:WaterHeating:AirToWaterHeatPump:Wrapped,\n";
    ss << "\\memo Heat pump water heater (HPWH) heating coil, air-to-water direct-expansion (DX)\n";
    ss << "\\memo system which includes a water heating coil, evaporator air coil, evaporator\n";
    ss << "\\memo fan, electric compressor, and water pump. Part of a WaterHeater:HeatPump:WrappedCondenser system.\n";
    ss << "\\min-fields 14\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatPumpWaterHeaterDXCoilsWrapped\n";
    ss << "\\note Unique name for this instance of a heat pump water heater DX coil.\n";
    ss << "N1 , \\field Rated Heating Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Heating capacity at the rated inlet air temperatures, rated condenser inlet\n";
    ss << "\\note water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump heat.\n";
    ss << "N2 , \\field Rated COP\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 3.2\n";
    ss << "\\note Heating coefficient of performance at the rated inlet air temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump power and evaporator fan power (see fields below).\n";
    ss << "N3 , \\field Rated Sensible Heat Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.85\n";
    ss << "\\note Gross air-side sensible heat ratio at the rated inlet air temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Sensible heat ratio equals gross sensible cooling capacity divided by gross total cooling\n";
    ss << "\\note capacity. Rated SHR (gross) should not include evaporator fan heat, only sensible cooling\n";
    ss << "\\note and dehumidification by the coil alone.\n";
    ss << "N4 , \\field Rated Evaporator Inlet Air Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 5\n";
    ss << "\\default 19.7\n";
    ss << "\\note Evaporator inlet air dry-bulb temperature corresponding to rated coil performance\n";
    ss << "\\note (heating capacity, COP and SHR).\n";
    ss << "N5 , \\field Rated Evaporator Inlet Air Wet-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 5\n";
    ss << "\\default 13.5\n";
    ss << "\\note Evaporator inlet air wet-bulb temperature corresponding to rated coil performance\n";
    ss << "\\note (heating capacity, COP and SHR).\n";
    ss << "N6 , \\field Rated Condenser Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 25\n";
    ss << "\\default 57.5\n";
    ss << "\\note Condenser inlet water temperature corresponding to rated coil performance\n";
    ss << "\\note (heating capacity, COP and SHR).\n";
    ss << "N7 , \\field Rated Evaporator Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Evaporator air flow rate corresponding to rated coil performance\n";
    ss << "\\note (heating capacity, COP and SHR).\n";
    ss << "\\note Default is 5.035E-5 m3/s/W (31.25 cfm/MBH) of rated heating capacity when autocalculated.\n";
    ss << "A2 , \\field Evaporator Fan Power Included in Rated COP\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "\\note Select Yes if the evaporator fan power is included in the rated COP. This choice field\n";
    ss << "\\note impacts the calculation of compressor electric power.\n";
    ss << "A3,  \\field Evaporator Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note The node from which the DX coil draws its inlet air.\n";
    ss << "A4,  \\field Evaporator Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note The node to which the DX coil sends its outlet air.\n";
    ss << "N8,  \\field Crankcase Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\units W\n";
    ss << "\\note The compressor crankcase heater only operates when the dry-bulb temperature of air\n";
    ss << "\\note surrounding the compressor is below the Maximum Ambient Temperature for Crankcase\n";
    ss << "\\note Heater Operation and the DX coil is off.  The ambient temperature surrounding the\n";
    ss << "\\note compressor is set by the WaterHeater:HeatPump:WrappedCondenser parent object (field Compressor Location).\n";
    ss << "N9,  \\field Maximum Ambient Temperature for Crankcase Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 10\n";
    ss << "\\units C\n";
    ss << "\\note The compressor crankcase heater only operates when the dry-bulb temperature of air\n";
    ss << "\\note surrounding the compressor is below the Maximum Outdoor Temperature for Crankcase\n";
    ss << "\\note Heater Operation and the unit is off. The ambient temperature surrounding the\n";
    ss << "\\note compressor is set by the WaterHeater:HeatPump:WrappedCondenser parent object (field Compressor Location).\n";
    ss << "A5,  \\field Evaporator Air Temperature Type for Curve Objects\n";
    ss << "\\type choice\n";
    ss << "\\key DryBulbTemperature\n";
    ss << "\\key WetBulbTemperature\n";
    ss << "\\default WetBulbTemperature\n";
    ss << "\\note Determines temperature type for heating capacity curves and\n";
    ss << "\\note heating COP curves. This input determines whether\n";
    ss << "\\note the inlet air dry-bulb or wet-bulb temperature is used to evaluate these curves.\n";
    ss << "A6,  \\field Heating Capacity Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCubicCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Heating capacity modifier curve (function of temperature) should be biquadratic or cubic.\n";
    ss << "\\note Biquadratic curve = a + b(ta) + c(ta)^2 + d(tw) + e(tw)^2 + f(ta)(tw).\n";
    ss << "\\note Cubic curve = a + b(ta) + c(ta)^2 + d(ta)^3.\n";
    ss << "\\note ta = evaporator inlet air [dry-bulb or wet-bulb] temperature (C).\n";
    ss << "\\note tw = condenser inlet water temperature (C).\n";
    ss << "\\note The field Evaporator Air Temperature Type for Curve Objects determines if dry-bulb or wet-bulb\n";
    ss << "\\note is used as the evaporator inlet air temperature (ta).\n";
    ss << "A7,  \\field Heating Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Heating capacity modifier curve (function of air flow fraction) should be quadratic or cubic.\n";
    ss << "\\note Quadratic curve = a + b(ff) + c(ff)^2.\n";
    ss << "\\note Cubic curve = a + b(ff) + c(ff)^2 + d(ff)^3.\n";
    ss << "\\note ff = fraction of the rated evaporator air flow rate.\n";
    ss << "\\note Use curve coefficients of 1,0,0 or leave this field blank when neglecting performance impacts\n";
    ss << "\\note due to variations in air flow rate fraction.\n";
    ss << "A8,  \\field Heating COP Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCubicCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Heating COP modifier curve (function of temperature) should be biquadratic or cubic.\n";
    ss << "\\note Biquadratic curve = a + b(ta) + c(ta)^2 + d(tw) + e(tw)^2 + f(ta)(tw).\n";
    ss << "\\note Cubic curve = a + b(ta) + c(ta)^2 + d(ta)^3.\n";
    ss << "\\note ta = evaporator inlet air [dry-bulb or wet-bulb] temperature (C).\n";
    ss << "\\note tw = condenser inlet water temperature (C).\n";
    ss << "\\note The field Evaporator Air Temperature Type for Curve Objects determines if dry-bulb or wet-bulb\n";
    ss << "\\note is used as the evaporator inlet air temperature (ta).\n";
    ss << "A9,  \\field Heating COP Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Heating COP modifier curve (function of air flow fraction) should be quadratic or cubic.\n";
    ss << "\\note Quadratic curve = a + b(ff) + c(ff)^2.\n";
    ss << "\\note Cubic curve = a + b(ff) + c(ff)^2 + d(ff)^3.\n";
    ss << "\\note ff = fraction of the rated evaporator air flow rate.\n";
    ss << "\\note Use curve coefficients of 1,0,0 or leave this field blank when neglecting performance impacts\n";
    ss << "\\note due to variations in air flow rate fraction.\n";
    ss << "A10; \\field Part Load Fraction Correlation Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Part Load Fraction Correlation (function of part load ratio) should be quadratic or cubic.\n";
    ss << "\\note Quadratic curve = a + b(PLR) + c(PLR)^2.\n";
    ss << "\\note Cubic curve = a + b(PLR) + c(PLR)^2 + d(PLR)^3.\n";
    ss << "\\note PLR = part load ratio (heating delivered/steady state heating capacity).\n";
    ss << "\\note Use curve coefficients of 1,0,0 or leave this field blank when neglecting performance impacts\n";
    ss << "\\note due to variations in part load ratio.\n";

    IddObjectType objType(IddObjectType::Coil_WaterHeating_AirToWaterHeatPump_Wrapped);
    OptionalIddObject oObj = IddObject::load("Coil:WaterHeating:AirToWaterHeatPump:Wrapped",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_WaterHeating_AirToWaterHeatPump_Wrapped);
  return object;
}

IddObject createCoil_WaterHeating_AirToWaterHeatPump_VariableSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:WaterHeating:AirToWaterHeatPump:VariableSpeed,\n";
    ss << "\\memo vairlable-speed Heat pump water heater (VSHPWH) heating coil, air-to-water direct-expansion (DX)\n";
    ss << "\\memo system which includes a variable-speed water heating coil, evaporator air coil, evaporator\n";
    ss << "\\memo fan, electric compressor, and water pump. Part of a WaterHeater:HeatPump system.\n";
    ss << "\\min-fields 33\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatPumpWaterHeaterDXCoilsVariableSpeed\n";
    ss << "\\note Unique name for this instance of a variable-speed heat pump water heater DX coil.\n";
    ss << "N1,  \\field Number of Speeds\n";
    ss << "\\units dimensionless\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 10\n";
    ss << "\\default 1\n";
    ss << "N2 , \\field Nominal Speed Level\n";
    ss << "\\units dimensionless\n";
    ss << "\\type integer\n";
    ss << "\\default 1\n";
    ss << "\\note must be lower than or equal to the highest speed number\n";
    ss << "N3 , \\field Rated Water Heating Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Water Heating capacity at the rated inlet air temperatures, rated condenser inlet\n";
    ss << "\\note water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump heat.\n";
    ss << "N4 , \\field Rated Evaporator Inlet Air Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 5\n";
    ss << "\\default 19.7\n";
    ss << "\\note Evaporator inlet air dry-bulb temperature corresponding to rated coil performance\n";
    ss << "\\note (heating capacity, COP and SHR).\n";
    ss << "N5 , \\field Rated Evaporator Inlet Air Wet-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 5\n";
    ss << "\\default 13.5\n";
    ss << "\\note Evaporator inlet air wet-bulb temperature corresponding to rated coil performance\n";
    ss << "\\note (heating capacity, COP and SHR).\n";
    ss << "N6 , \\field Rated Condenser Inlet Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 25\n";
    ss << "\\default 57.5\n";
    ss << "\\note Condenser inlet water temperature corresponding to rated coil performance\n";
    ss << "\\note (heating capacity, COP and SHR).\n";
    ss << "N7 , \\field Rated Evaporator Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Evaporator air flow rate corresponding to rated coil performance\n";
    ss << "\\note (heating capacity, COP and SHR).\n";
    ss << "\\note Default is 5.035E-5 m3/s/W (31.25 cfm/MBH) of rated heating capacity when autocalculated.\n";
    ss << "N8 , \\field Rated Condenser Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Condenser water flow rate corresponding to rated coil performance\n";
    ss << "\\note (heating capacity, COP and SHR).\n";
    ss << "\\note Default is 4.487E-8 m3/s/W (0.208 gpm/MBH) of rated heating capacity when autocalculated.\n";
    ss << "\\note A warning message will be issued if the ratio of Rated Condenser Water Flow Rate\n";
    ss << "\\note to Heating Capacity is less than 1.79405E-8 m3/s/W (0.083 gpm/MBH)\n";
    ss << "\\note or greater than 8.97024E-8 m3/s/W (0.417 gpm/MBH), but the simulation will continue.\n";
    ss << "A2 , \\field Evaporator Fan Power Included in Rated COP\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "\\note Select Yes if the evaporator fan power is included in the rated COP. This choice field\n";
    ss << "\\note impacts the calculation of compressor electric power.\n";
    ss << "A3 , \\field Condenser Pump Power Included in Rated COP\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note Select Yes if the condenser pump power is included in the rated COP. This choice field\n";
    ss << "\\note impacts the calculation of compressor electric power.\n";
    ss << "A4 , \\field Condenser Pump Heat Included in Rated Heating Capacity and Rated COP\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note Select Yes if the condenser pump heat is included in the rated heating capacity and\n";
    ss << "\\note rated COP. This choice field impacts the calculation of water heating capacity.\n";
    ss << "N9 , \\field Fraction of Condenser Pump Heat to Water\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.2\n";
    ss << "\\note Fraction of pump heat transferred to the condenser water. The pump is assumed\n";
    ss << "\\note to be located downstream of the condenser.\n";
    ss << "A5 , \\field Evaporator Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note The node from which the DX coil draws its inlet air.\n";
    ss << "A6 , \\field Evaporator Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note The node to which the DX coil sends its outlet air.\n";
    ss << "A7 , \\field Condenser Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note The node from which the DX coil condenser draws its inlet water.\n";
    ss << "\\note This name should match the source side outlet node name in the associated\n";
    ss << "\\note water heater tank object.\n";
    ss << "A8 , \\field Condenser Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note The node to which the DX coil condenser sends its outlet water.\n";
    ss << "\\note This name should match the source side inlet node name in the associated\n";
    ss << "\\note water heater tank object.\n";
    ss << "N10, \\field Crankcase Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\units W\n";
    ss << "\\note The compressor crankcase heater only operates when the dry-bulb temperature of air\n";
    ss << "\\note surrounding the compressor is below the Maximum Ambient Temperature for Crankcase\n";
    ss << "\\note Heater Operation and the DX coil is off.  The ambient temperature surrounding the\n";
    ss << "\\note compressor is set by the WaterHeater:HeatPump parent object (field Compressor Location).\n";
    ss << "N11, \\field Maximum Ambient Temperature for Crankcase Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 10\n";
    ss << "\\units C\n";
    ss << "\\note The compressor crankcase heater only operates when the dry-bulb temperature of air\n";
    ss << "\\note surrounding the compressor is below the Maximum Outdoor Temperature for Crankcase\n";
    ss << "\\note Heater Operation and the unit is off. The ambient temperature surrounding the\n";
    ss << "\\note compressor is set by the WaterHeater:HeatPump parent object (field Compressor Location).\n";
    ss << "A9 , \\field Evaporator Air Temperature Type for Curve Objects\n";
    ss << "\\type choice\n";
    ss << "\\key DryBulbTemperature\n";
    ss << "\\key WetBulbTemperature\n";
    ss << "\\default WetBulbTemperature\n";
    ss << "\\note Determines temperature type for heating capacity curves and\n";
    ss << "\\note heating COP curves. This input determines whether\n";
    ss << "\\note the inlet air dry-bulb or wet-bulb temperature is used to evaluate these curves.\n";
    ss << "A10, \\field Part Load Fraction Correlation Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note Part Load Fraction Correlation (function of part load ratio) should be quadratic or cubic.\n";
    ss << "\\note Quadratic curve = a + b(PLR) + c(PLR)^2.\n";
    ss << "\\note Cubic curve = a + b(PLR) + c(PLR)^2 + d(PLR)^3.\n";
    ss << "\\note PLR = part load ratio (heating delivered/steady state heating capacity).\n";
    ss << "\\note Use curve coefficients of 1,0,0 or leave this field blank when neglecting performance impacts\n";
    ss << "\\note due to variations in part load ratio.\n";
    ss << "N12, \\field Rated Water Heating Capacity at Speed 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Heating capacity at the rated inlet air temperatures, rated condenser inlet\n";
    ss << "\\note water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump heat.\n";
    ss << "N13, \\field Rated Water Heating COP at Speed 1\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 3.2\n";
    ss << "\\note Heating coefficient of performance at the rated inlet air and water temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump power and evaporator fan power (see fields below).\n";
    ss << "N14, \\field Rated Sensible Heat Ratio at Speed 1\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.85\n";
    ss << "\\note Gross air-side sensible heat ratio at the rated inlet air temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Sensible heat ratio equals gross sensible cooling capacity divided by gross total cooling\n";
    ss << "\\note capacity. Rated SHR (gross) should not include evaporator fan heat, only sensible cooling\n";
    ss << "\\note and dehumidification by the coil alone.\n";
    ss << "N15, \\field Speed 1 Reference Unit Rated Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N16, \\field Speed 1 Reference Unit Rated Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N17, \\field Speed 1 Reference Unit Water Pump Input Power At Rated Conditions\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "A11, \\field Speed 1 Total WH Capacity Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A12, \\field Speed 1 Total WH Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A13, \\field Speed 1 Total WH Capacity Function of Water Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "A14, \\field Speed 1 COP Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A15, \\field Speed 1 COP Function of Air Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A16, \\field Speed 1 COP Function of Water Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "N18, \\field Rated Water Heating Capacity at Speed 2\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Heating capacity at the rated inlet air temperatures, rated condenser inlet\n";
    ss << "\\note water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump heat.\n";
    ss << "N19, \\field Rated Water Heating COP at Speed 2\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 3.2\n";
    ss << "\\note Heating coefficient of performance at the rated inlet air and water temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump power and evaporator fan power (see fields below).\n";
    ss << "N20, \\field Rated Sensible Heat Ratio at Speed 2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.85\n";
    ss << "\\note Gross air-side sensible heat ratio at the rated inlet air temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Sensible heat ratio equals gross sensible cooling capacity divided by gross total cooling\n";
    ss << "\\note capacity. Rated SHR (gross) should not include evaporator fan heat, only sensible cooling\n";
    ss << "\\note and dehumidification by the coil alone.\n";
    ss << "N21, \\field Speed 2 Reference Unit Rated Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N22, \\field Speed 2 Reference Unit Rated Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N23, \\field Speed 2 Reference Unit Water Pump Input Power At Rated Conditions\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "A17, \\field Speed 2 Total WH Capacity Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A18, \\field Speed 2 Total WH Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A19, \\field Speed 2 Total WH Capacity Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "A20, \\field Speed 2 COP Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A21, \\field Speed 2 COP Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A22, \\field Speed 2 COP Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "N24, \\field Rated Water Heating Capacity at speed 3\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Heating capacity at the rated inlet air temperatures, rated condenser inlet\n";
    ss << "\\note water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump heat.\n";
    ss << "N25, \\field Rated Water Heating COP at Speed 3\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 3.2\n";
    ss << "\\note Heating coefficient of performance at the rated inlet air and water temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump power and evaporator fan power (see fields below).\n";
    ss << "N26, \\field Rated Sensible Heat Ratio at Speed 3\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.85\n";
    ss << "\\note Gross air-side sensible heat ratio at the rated inlet air temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Sensible heat ratio equals gross sensible cooling capacity divided by gross total cooling\n";
    ss << "\\note capacity. Rated SHR (gross) should not include evaporator fan heat, only sensible cooling\n";
    ss << "\\note and dehumidification by the coil alone.\n";
    ss << "N27, \\field Speed 3 Reference Unit Rated Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N28, \\field Speed 3 Reference Unit Rated Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N29, \\field Speed 3 Reference Unit Water Pump Input Power At Rated Conditions\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "A23, \\field Speed 3 Total WH Capacity Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A24, \\field Speed 3 Total WH Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A25, \\field Speed 3 Total WH Capacity Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "A26, \\field Speed 3 COP Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A27, \\field Speed 3 COP Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A28, \\field Speed 3 COP Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "N30, \\field Rated Water Heating Capacity at Speed 4\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Heating capacity at the rated inlet air temperatures, rated condenser inlet\n";
    ss << "\\note water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump heat.\n";
    ss << "N31, \\field Rated Water Heating COP at Speed 4\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 3.2\n";
    ss << "\\note Heating coefficient of performance at the rated inlet air and water temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump power and evaporator fan power (see fields below).\n";
    ss << "N32, \\field Rated Sensible Heat Ratio at Speed 4\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.85\n";
    ss << "\\note Gross air-side sensible heat ratio at the rated inlet air temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Sensible heat ratio equals gross sensible cooling capacity divided by gross total cooling\n";
    ss << "\\note capacity. Rated SHR (gross) should not include evaporator fan heat, only sensible cooling\n";
    ss << "\\note and dehumidification by the coil alone.\n";
    ss << "N33, \\field Speed 4 Reference Unit Rated Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N34, \\field Speed 4 Reference Unit Rated Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N35, \\field Speed 4 Reference Unit Water Pump Input Power At Rated Conditions\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "A29, \\field Speed 4 Total WH Capacity Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A30, \\field Speed 4 Total WH Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A31, \\field Speed 4 Total WH Capacity Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "A32, \\field Speed 4 COP Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A33, \\field Speed 4 COP Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A34, \\field Speed 4 COP Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "N36, \\field Rated Water Heating Capacity at Speed 5\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Heating capacity at the rated inlet air temperatures, rated condenser inlet\n";
    ss << "\\note water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump heat.\n";
    ss << "N37, \\field Rated Water Heating COP at Speed 5\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 3.2\n";
    ss << "\\note Heating coefficient of performance at the rated inlet air and water temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump power and evaporator fan power (see fields below).\n";
    ss << "N38, \\field Rated Sensible Heat Ratio at Speed 5\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.85\n";
    ss << "\\note Gross air-side sensible heat ratio at the rated inlet air temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Sensible heat ratio equals gross sensible cooling capacity divided by gross total cooling\n";
    ss << "\\note capacity. Rated SHR (gross) should not include evaporator fan heat, only sensible cooling\n";
    ss << "\\note and dehumidification by the coil alone.\n";
    ss << "N39, \\field Speed 5 Reference Unit Rated Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N40, \\field Speed 5 Reference Unit Rated Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N41, \\field Speed 5 Reference Unit Water Pump Input Power At Rated Conditions\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "A35, \\field Speed 5 Total WH Capacity Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A36, \\field Speed 5 Total WH Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A37, \\field Speed 5 Total WH Capacity Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "A38, \\field Speed 5 COP Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A39, \\field Speed 5 COP Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A40, \\field Speed 5 COP Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "N42, \\field Rated Water Heating Capacity at Speed 6\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Heating capacity at the rated inlet air temperatures, rated condenser inlet\n";
    ss << "\\note water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump heat.\n";
    ss << "N43, \\field Rated Water Heating COP at Speed 6\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 3.2\n";
    ss << "\\note Heating coefficient of performance at the rated inlet air and water temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump power and evaporator fan power (see fields below).\n";
    ss << "N44, \\field Rated Sensible Heat Ratio at Speed 6\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.85\n";
    ss << "\\note Gross air-side sensible heat ratio at the rated inlet air temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Sensible heat ratio equals gross sensible cooling capacity divided by gross total cooling\n";
    ss << "\\note capacity. Rated SHR (gross) should not include evaporator fan heat, only sensible cooling\n";
    ss << "\\note and dehumidification by the coil alone.\n";
    ss << "N45, \\field Speed 6 Reference Unit Rated Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N46, \\field Speed 6 Reference Unit Rated Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N47, \\field Speed 6 Reference Unit Water Pump Input Power At Rated Conditions\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "A41, \\field Speed 6 Total WH Capacity Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A42, \\field Speed 6 Total WH Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A43, \\field Speed 6 Total WH Capacity Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "A44, \\field Speed 6 COP Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A45, \\field Speed 6 COP Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A46, \\field Speed 6 COP Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "N48, \\field Rated Water Heating Capacity at Speed 7\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Heating capacity at the rated inlet air temperatures, rated condenser inlet\n";
    ss << "\\note water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump heat.\n";
    ss << "N49, \\field Rated Water Heating COP at Speed 7\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 3.2\n";
    ss << "\\note Heating coefficient of performance at the rated inlet air and water temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump power and evaporator fan power (see fields below).\n";
    ss << "N50, \\field Rated Sensible Heat Ratio at Speed 7\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.85\n";
    ss << "\\note Gross air-side sensible heat ratio at the rated inlet air temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Sensible heat ratio equals gross sensible cooling capacity divided by gross total cooling\n";
    ss << "\\note capacity. Rated SHR (gross) should not include evaporator fan heat, only sensible cooling\n";
    ss << "\\note and dehumidification by the coil alone.\n";
    ss << "N51, \\field Speed 7 Reference Unit Rated Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N52, \\field Speed 7 Reference Unit Rated Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N53, \\field Speed 7 Reference Unit Water Pump Input Power At Rated Conditions\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "A47, \\field Speed 7 Total WH Capacity Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A48, \\field Speed 7 Total WH Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A49, \\field Speed 7 Total WH Capacity Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "A50, \\field Speed 7 COP Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A51, \\field Speed 7 COP Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A52, \\field Speed 7 COP Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "N54, \\field Rated Water Heating Capacity at Speed 8\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Heating capacity at the rated inlet air temperatures, rated condenser inlet\n";
    ss << "\\note water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump heat.\n";
    ss << "N55, \\field Rated Water Heating COP at Speed 8\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 3.2\n";
    ss << "\\note Heating coefficient of performance at the rated inlet air and water temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump power and evaporator fan power (see fields below).\n";
    ss << "N56, \\field Rated Sensible Heat Ratio at Speed 8\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.85\n";
    ss << "\\note Gross air-side sensible heat ratio at the rated inlet air temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Sensible heat ratio equals gross sensible cooling capacity divided by gross total cooling\n";
    ss << "\\note capacity. Rated SHR (gross) should not include evaporator fan heat, only sensible cooling\n";
    ss << "\\note and dehumidification by the coil alone.\n";
    ss << "N57, \\field Speed 8 Reference Unit Rated Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N58, \\field Speed 8 Reference Unit Rated Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N59, \\field Speed 8 Reference Unit Water Pump Input Power At Rated Conditions\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "A53, \\field Speed 8 Total WH Capacity Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A54, \\field Speed 8 Total WH Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A55, \\field Speed 8 Total WH Capacity Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "A56, \\field Speed 8 COP Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A57, \\field Speed 8 COP Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A58, \\field Speed 8 COP Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "N60, \\field Rated Water Heating Capacity at Speed 9\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Heating capacity at the rated inlet air temperatures, rated condenser inlet\n";
    ss << "\\note water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump heat.\n";
    ss << "N61, \\field Rated Water Heating COP at Speed 9\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 3.2\n";
    ss << "\\note Heating coefficient of performance at the rated inlet air and water temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump power and evaporator fan power (see fields below).\n";
    ss << "N62, \\field Rated Sensible Heat Ratio at Speed 9\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.85\n";
    ss << "\\note Gross air-side sensible heat ratio at the rated inlet air temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Sensible heat ratio equals gross sensible cooling capacity divided by gross total cooling\n";
    ss << "\\note capacity. Rated SHR (gross) should not include evaporator fan heat, only sensible cooling\n";
    ss << "\\note and dehumidification by the coil alone.\n";
    ss << "N63, \\field Speed 9 Reference Unit Rated Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N64, \\field Speed 9 Reference Unit Rated Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N65, \\field Speed 9 Reference Unit Water Pump Input Power At Rated Conditions\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "A59, \\field Speed 9 Total WH Capacity Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A60, \\field Speed 9 Total WH Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A61, \\field Speed 9 Total WH Capacity Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "A62, \\field Speed 9 COP Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A63, \\field Speed 9 COP Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A64, \\field Speed 9 COP Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "N66, \\field Rated Water Heating Capacity at Speed 10\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Heating capacity at the rated inlet air temperatures, rated condenser inlet\n";
    ss << "\\note water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump heat.\n";
    ss << "N67, \\field Rated Water Heating COP at Speed 10\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 3.2\n";
    ss << "\\note Heating coefficient of performance at the rated inlet air and water temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump power and evaporator fan power (see fields below).\n";
    ss << "N68, \\field Rated Sensible Heat Ratio at Speed 10\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.85\n";
    ss << "\\note Gross air-side sensible heat ratio at the rated inlet air temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Sensible heat ratio equals gross sensible cooling capacity divided by gross total cooling\n";
    ss << "\\note capacity. Rated SHR (gross) should not include evaporator fan heat, only sensible cooling\n";
    ss << "\\note and dehumidification by the coil alone.\n";
    ss << "N69, \\field Speed 10 Reference Unit Rated Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N70, \\field Speed 10 Reference Unit Rated Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N71, \\field Speed 10 Reference Unit Water Pump Input Power At Rated Conditions\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "A65, \\field Speed 10 Total WH Capacity Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A66, \\field Speed 10 Total WH Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A67, \\field Speed 10 Total WH Capacity Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";
    ss << "A68, \\field Speed 10 COP Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*ewt + e*ewt**2 + f*wb*ewt\n";
    ss << "\\note wb = entering wet-bulb temperature or dry bulb temperature upon selection (C)\n";
    ss << "\\note ewt = water entering temperature seen by the condenser (C)\n";
    ss << "A69, \\field Speed 10 COP Function of Air Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffa + c*ffa**2\n";
    ss << "\\note cubic curve = a + b*ffa + c*ffa**2 + d*ffa**3\n";
    ss << "\\note ffa = Fraction of the full load Air Flow\n";
    ss << "A70; \\field Speed 10 COP Function of Water Flow Fraction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Table:OneIndependentVariable object can also be used\n";
    ss << "\\note quadratic curve = a + b*ffw + c*ffw**2\n";
    ss << "\\note cubic curve = a + b*ffw + c*ffw**2 + d*ffw**3\n";
    ss << "\\note ffw = Fraction of the full load Water Flow\n";

    IddObjectType objType(IddObjectType::Coil_WaterHeating_AirToWaterHeatPump_VariableSpeed);
    OptionalIddObject oObj = IddObject::load("Coil:WaterHeating:AirToWaterHeatPump:VariableSpeed",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_WaterHeating_AirToWaterHeatPump_VariableSpeed);
  return object;
}

IddObject createCoil_WaterHeating_DesuperheaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:WaterHeating:Desuperheater,\n";
    ss << "\\memo Desuperheater air heating coil. The heating energy provided by this coil is reclaimed\n";
    ss << "\\memo from the superheated refrigerant gas leaving a compressor and does not impact the\n";
    ss << "\\memo performance of the compressor. This coil must be used with a water heater tank, see\n";
    ss << "\\memo Water Heater:Mixed.\n";
    ss << "\\min-fields 18\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note Unique name for this instance of a desuperheater water heating coil.\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values of 0 denote the desuperheater heating coil is off and the parasitic electric\n";
    ss << "\\note energy is also off.\n";
    ss << "A3 , \\field Setpoint Temperature Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defines the cut-out temperature where the desuperheater water heating coil turns off.\n";
    ss << "\\note The desuperheater heating coil setpoint temperature should always be greater\n";
    ss << "\\note than the water tank's heater (element or burner) setpoint temperature. Temperature\n";
    ss << "\\note schedule values should be in degrees C.\n";
    ss << "N1 , \\field Dead Band Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 20\n";
    ss << "\\default 5\n";
    ss << "\\note Setpoint temperature minus the dead band temperature difference defines\n";
    ss << "\\note the cut-in temperature where the desuperheater water heating coil turns on.\n";
    ss << "\\note The water tank's heater (element or burner) setpoint temperature\n";
    ss << "\\note should always be less than the desuperheater heating coil cut-in temperature.\n";
    ss << "N2 , \\field Rated Heat Reclaim Recovery Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Enter the fraction of waste heat reclaimed by the desuperheater water heating coil.\n";
    ss << "N3 , \\field Rated Inlet Water Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note The inlet water temperature corresponding to the rated heat reclaim recovery efficiency.\n";
    ss << "N4 , \\field Rated Outdoor Air Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note The outdoor air dry-bulb temperature corresponding to the\n";
    ss << "\\note rated heat reclaim recovery efficiency.\n";
    ss << "N5 , \\field Maximum Inlet Water Temperature for Heat Reclaim\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note The desuperheater water heating coil is off when the inlet water temperature is above\n";
    ss << "\\note the maximum inlet water temperature for heat reclaim.\n";
    ss << "A4 , \\field Heat Reclaim Efficiency Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note A biquadratic curve defining the performance of the desuperheater heating coil.\n";
    ss << "\\note Performance can be specified as a function of inlet water temperature, outdoor air\n";
    ss << "\\note dry-bulb temperature, or both.\n";
    ss << "\\note Curve = a + b*Tw + c*Tw**2 + d*odb + e*odb**2 + f*Tw*odb.\n";
    ss << "\\note Tw = desuperheater heating coil entering water temperature (C).\n";
    ss << "\\note Odb = outdoor dry-bulb temperature at DX system condenser (C).\n";
    ss << "A5 , \\field Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note The node from which the desuperheater heating coil draws its inlet water.\n";
    ss << "\\note This name should match the source side outlet node name in the associated\n";
    ss << "\\note water heater tank object.\n";
    ss << "A6 , \\field Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note The node to which the desuperheater heating coil sends its outlet water.\n";
    ss << "\\note This name should match the source side inlet node name in the associated\n";
    ss << "\\note water heater tank object.\n";
    ss << "A7 , \\field Tank Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key WaterHeater:Mixed\n";
    ss << "\\default WaterHeater:Mixed\n";
    ss << "\\note Specify the type of water heater tank used by this desuperheater water heating coil.\n";
    ss << "A8 , \\field Tank Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\note The name of the water heater tank used by this desuperheater water heating coil.\n";
    ss << "\\note Needs to match the name used in the corresponding water heater object.\n";
    ss << "\\object-list WaterHeaterMixedNames\n";
    ss << "A9 , \\field Heating Source Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:DX:SingleSpeed\n";
    ss << "\\key Coil:Cooling:DX:TwoSpeed\n";
    ss << "\\key Coil:Cooling:DX:TwoStageWithHumidityControlMode\n";
    ss << "\\key Refrigeration:CompressorRack\n";
    ss << "\\key Refrigeration:Condenser:AirCooled\n";
    ss << "\\key Refrigeration:Condenser:EvaporativeCooled\n";
    ss << "\\key Refrigeration:Condenser:WaterCooled\n";
    ss << "\\note The type of DX system that is providing waste heat for reclaim.\n";
    ss << "A10, \\field Heating Source Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesuperHeatingCoilSources\n";
    ss << "\\note The name of the DX system used for heat reclaim.\n";
    ss << "N6 , \\field Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\note The operating water flow rate.\n";
    ss << "N7 , \\field Water Pump Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note The water circulation pump electric power.\n";
    ss << "N8 , \\field Fraction of Pump Heat to Water\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.2\n";
    ss << "\\note The fraction of pump heat transferred to the water. The pump is assumed to be downstream of\n";
    ss << "\\note the desuperheater water heating coil.\n";
    ss << "N9 , \\field On-Cycle Parasitic Electric Load\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note Parasitic electric power consumed when the desuperheater water heating coil operates.\n";
    ss << "\\note Parasitic electric load does not contribute to water heating or the zone air heat balance.\n";
    ss << "\\ip-units W\n";
    ss << "N10; \\field Off-Cycle Parasitic Electric Load\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note Parasitic electric load consumed when the desuperheater water heating coil is off.\n";
    ss << "\\note Parasitic electric load does not contribute to water heating or the zone air heat balance.\n";
    ss << "\\note Off-cycle parasitic power is 0 when the availability schedule is 0.\n";
    ss << "\\ip-units W\n";

    IddObjectType objType(IddObjectType::Coil_WaterHeating_Desuperheater);
    OptionalIddObject oObj = IddObject::load("Coil:WaterHeating:Desuperheater",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_WaterHeating_Desuperheater);
  return object;
}

IddObject createCoilSystem_Cooling_DXIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "CoilSystem:Cooling:DX,\n";
    ss << "\\memo Virtual container component that consists of a DX cooling coil and its associated\n";
    ss << "\\memo controls. This control object supports several different types of DX cooling coils\n";
    ss << "\\memo and may be placed directly in an air loop branch or outdoor air equipment list.\n";
    ss << "\\min-fields 7\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field DX Cooling Coil System Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field DX Cooling Coil System Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field DX Cooling Coil System Sensor Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6,  \\field Cooling Coil Object Type\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Coil:Cooling:DX:SingleSpeed\n";
    ss << "\\key CoilSystem:Cooling:DX:HeatExchangerAssisted\n";
    ss << "\\key Coil:Cooling:DX:TwoSpeed\n";
    ss << "\\key Coil:Cooling:DX:TwoStageWithHumidityControlMode\n";
    ss << "\\key Coil:Cooling:DX:VariableSpeed\n";
    ss << "\\key Coil:Cooling:DX:SingleSpeed:ThermalStorage\n";
    ss << "A7,  \\field Cooling Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsDX\n";
    ss << "\\object-list CoolingCoilsDXVariableSpeed\n";
    ss << "A8,  \\field Dehumidification Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Multimode\n";
    ss << "\\key CoolReheat\n";
    ss << "\\default None\n";
    ss << "\\note None = meet sensible load only\n";
    ss << "\\note Multimode = activate enhanced dehumidification mode\n";
    ss << "\\note as needed and meet sensible load. If no sensible load\n";
    ss << "\\note exists, and Run on Latent Load = Yes, and a latent\n";
    ss << "\\note load exists, the unit will operate to meet the latent load.\n";
    ss << "\\note Valid only with Coil:Cooling:DX:TwoStageWithHumidityControlMode\n";
    ss << "\\note or CoilSystem:Cooling:DX:HeatExchangerAssisted.\n";
    ss << "\\note CoolReheat = cool beyond the dry-bulb setpoint.\n";
    ss << "\\note as required to meet the humidity setpoint.\n";
    ss << "\\note Valid for all coil types.\n";
    ss << "\\note For all dehumidification controls, the max\n";
    ss << "\\note humidity setpoint on the Sensor Node is used.\n";
    ss << "\\note SetpointManager:SingleZone:Humidity:Maximum,\n";
    ss << "\\note SetpointManager:MultiZone:Humidity:Maximum, or\n";
    ss << "\\note SetpointManager:MultiZone:MaximumHumidity:Average, and\n";
    ss << "\\note SetpointManager:OutdoorAirPretreat (optional) objects.\n";
    ss << "A9,  \\field Run on Sensible Load\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "\\note If Yes, unit will run if there is a sensible load.\n";
    ss << "\\note If No, unit will not run if there is only a sensible load.\n";
    ss << "\\note Dehumidification controls will be active if specified.\n";
    ss << "A10,  \\field Run on Latent Load\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note If Yes, unit will run if there is a latent load.\n";
    ss << "\\note even if there is no sensible load.\n";
    ss << "\\note If No, unit will not run only if there is a latent load.\n";
    ss << "\\note Dehumidification controls will be active if specified.\n";
    ss << "A11,  \\field Use Outdoor Air DX Cooling Coil\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note This input field is designed for use with DX cooling coils with low air flow\n";
    ss << "\\note to capacity ratio range (100 - 300 cfm/ton). Typical application is 100% dedicated\n";
    ss << "\\note outdoor air system (DOAS). Other air loop or zone HVAC systems with low flow\n";
    ss << "\\note to capacity ratio range may also use this input field.  If Yes, the DX cooling\n";
    ss << "\\note coil runs as 100% DOAS DX coil or low flow to capacity ratio range.\n";
    ss << "\\note If No, the DX cooling coil runs as a regular DX coil. If left blank the\n";
    ss << "\\note default is regular DX coil.\n";
    ss << "N1 ;  \\field Outdoor Air DX Cooling Coil Leaving Minimum Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 7.2\n";
    ss << "\\default 2.0\n";
    ss << "\\note DX cooling coil leaving minimum air temperature defines the minimum DX cooling coil\n";
    ss << "\\note leaving air temperature that should be maintained to avoid frost formation. This input\n";
    ss << "\\note field is optional and only used along with the input field above.\n";

    IddObjectType objType(IddObjectType::CoilSystem_Cooling_DX);
    OptionalIddObject oObj = IddObject::load("CoilSystem:Cooling:DX",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::CoilSystem_Cooling_DX);
  return object;
}

IddObject createCoilSystem_Heating_DXIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "CoilSystem:Heating:DX,\n";
    ss << "\\memo Virtual container component that consists of a DX heating coil (heat pump) and its\n";
    ss << "\\memo associated controls. This control object supports two different types of DX heating\n";
    ss << "\\memo coils and may be placed directly in an air loop branch or outdoor air equipment list.\n";
    ss << "\\min-fields 4\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3,  \\field Heating Coil Object Type\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Coil:Heating:DX:SingleSpeed\n";
    ss << "\\key Coil:Heating:DX:VariableSpeed\n";
    ss << "A4;  \\field Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilsDXSingleSpeed\n";
    ss << "\\object-list HeatingCoilsDXVariableSpeed\n";

    IddObjectType objType(IddObjectType::CoilSystem_Heating_DX);
    OptionalIddObject oObj = IddObject::load("CoilSystem:Heating:DX",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::CoilSystem_Heating_DX);
  return object;
}

IddObject createCoilSystem_Cooling_Water_HeatExchangerAssistedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "CoilSystem:Cooling:Water:HeatExchangerAssisted,\n";
    ss << "\\memo Virtual component consisting of a chilled-water cooling coil and an air-to-air heat\n";
    ss << "\\memo exchanger. The air-to-air heat exchanger precools the air entering the cooling coil\n";
    ss << "\\memo and reuses this energy to reheat the supply air leaving the cooling coil. This heat\n";
    ss << "\\memo exchange process improves the latent removal performance of the cooling coil (lower\n";
    ss << "\\memo sensible heat ratio).\n";
    ss << "\\min-fields 5\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CoolingCoilsWater\n";
    ss << "A2 , \\field Heat Exchanger Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key HeatExchanger:AirToAir:FlatPlate\n";
    ss << "\\key HeatExchanger:AirToAir:SensibleAndLatent\n";
    ss << "A3 , \\field Heat Exchanger Name\n";
    ss << "\\required-field\n";
    ss << "A4 , \\field Cooling Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:Water\n";
    ss << "\\key Coil:Cooling:Water:DetailedGeometry\n";
    ss << "A5 ; \\field Cooling Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsWaterNoHX\n";

    IddObjectType objType(IddObjectType::CoilSystem_Cooling_Water_HeatExchangerAssisted);
    OptionalIddObject oObj = IddObject::load("CoilSystem:Cooling:Water:HeatExchangerAssisted",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::CoilSystem_Cooling_Water_HeatExchangerAssisted);
  return object;
}

IddObject createCoilSystem_Cooling_DX_HeatExchangerAssistedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "CoilSystem:Cooling:DX:HeatExchangerAssisted,\n";
    ss << "\\memo Virtual component consisting of a direct expansion (DX) cooling coil and an\n";
    ss << "\\memo air-to-air heat exchanger. The air-to-air heat exchanger precools the air entering the\n";
    ss << "\\memo cooling coil and reuses this energy to reheat the supply air leaving the cooling\n";
    ss << "\\memo coil. This heat exchange process improves the latent removal performance of the\n";
    ss << "\\memo cooling coil (lower sensible heat ratio).\n";
    ss << "\\min-fields 5\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CoolingCoilsDX\n";
    ss << "\\reference CoolingCoilsDXSingleSpeed\n";
    ss << "\\reference CoolingCoilsDXMultiModeOrSingleSpeed\n";
    ss << "A2 , \\field Heat Exchanger Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key HeatExchanger:AirToAir:FlatPlate\n";
    ss << "\\key HeatExchanger:AirToAir:SensibleAndLatent\n";
    ss << "\\key HeatExchanger:Desiccant:BalancedFlow\n";
    ss << "A3 , \\field Heat Exchanger Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HXAirToAirNames\n";
    ss << "A4 , \\field Cooling Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:DX:SingleSpeed\n";
    ss << "A5 ; \\field Cooling Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsDXSingleSpeed\n";

    IddObjectType objType(IddObjectType::CoilSystem_Cooling_DX_HeatExchangerAssisted);
    OptionalIddObject oObj = IddObject::load("CoilSystem:Cooling:DX:HeatExchangerAssisted",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::CoilSystem_Cooling_DX_HeatExchangerAssisted);
  return object;
}

IddObject createCoil_Cooling_DX_SingleSpeed_ThermalStorageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:Cooling:DX:SingleSpeed:ThermalStorage,\n";
    ss << "\\memo Direct expansion (DX) cooling coil and condensing unit (includes electric compressor\n";
    ss << "\\memo and condenser fan), single-speed with packaged integrated thermal storage for cooling.\n";
    ss << "\\memo\n";
    ss << "\\min-fields 89\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingCoilsDX\n";
    ss << "\\reference CoolingCoilsDXSingleSpeed\n";
    ss << "\\reference CoolingCoilsDXMultiModeOrSingleSpeed\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Operating Mode Control Method\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key ScheduledModes\n";
    ss << "\\key EMSControlled\n";
    ss << "A4 , \\field Operation Mode Control Schedule Name\n";
    ss << "\\note This field is used if the control method is set to ScheduledModes\n";
    ss << "\\note Schedule values control operating mode: 0=off, 1=cooling only, 2= cooling and charge,\n";
    ss << "\\note 3= cooling and discharge, 4= charge only, and 5= discharge only\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5 , \\field Storage Type\n";
    ss << "\\type choice\n";
    ss << "\\key Water\n";
    ss << "\\key UserDefinedFluidType\n";
    ss << "\\key Ice\n";
    ss << "\\required-field\n";
    ss << "A6 , \\field User Defined Fluid Type\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FluidAndGlycolNames\n";
    ss << "\\note This field is required when Storage Type is UserDefinedFluidType\n";
    ss << "N1 , \\field Fluid Storage Volume\n";
    ss << "\\units m3\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\note required field if Storage Type is Water or UserDefinedFluidType\n";
    ss << "\\autocalculatable\n";
    ss << "N2 , \\field Ice Storage Capacity\n";
    ss << "\\units GJ\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\note required field if Storage Type is Ice\n";
    ss << "\\autocalculatable\n";
    ss << "N3 , \\field Storage Capacity Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\units hr\n";
    ss << "\\note If one of the previous two fields is set to autocalculate, this determines the storage capacity\n";
    ss << "\\note as a function of Cooling Only Mode Rated Total Evaporator Cooling Capacity\n";
    ss << "\\note\n";
    ss << "A7 , \\field Storage Tank Ambient Temperature Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "N4 , \\field Storage Tank to Ambient U-value Times Area Heat Transfer Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "N5,  \\field Fluid Storage Tank Rating Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note required field if Storage Type is Water or UserDefinedFluidType\n";
    ss << "N6 , \\field Rated Evaporator Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "\\note Flow rate corresponding to rated total cooling capacity, Rated SHR and Rated COP\n";
    ss << "A8 , \\field Evaporator Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A9 , \\field Evaporator Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A10 , \\field Cooling Only Mode Available\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "N7 , \\field Cooling Only Mode Rated Total Evaporator Cooling Capacity\n";
    ss << "\\note required field if Cooling Only Mode is available or if autocalculating sizes\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note gross capacity excluding supply air fan heat\n";
    ss << "\\note rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "N8 , \\field Cooling Only Mode Rated Sensible Heat Ratio\n";
    ss << "\\note required field if Cooling Only Mode is available\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "\\note Rated sensible heat ratio (gross sensible capacity/gross total capacity)\n";
    ss << "\\note sensible and total capacities do not include supply fan heat\n";
    ss << "N9 , \\field Cooling Only Mode Rated COP\n";
    ss << "\\note Gross cooling capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply fan heat or supply fan electrical energy input\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 3.0\n";
    ss << "\\note required field if Cooling Only Mode is available\n";
    ss << "A11, \\field Cooling Only Mode Total Evaporator Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\note required field if Cooling Only Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiVariateCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Any curve or table with two independent variables can be used\n";
    ss << "\\note biquadratic curve = a + b*ewb + c*ewb**2 + d*db + e*db**2 + f*ewb*db\n";
    ss << "\\note x = ewb = evaporator entering wet-bulb temperature (C)\n";
    ss << "\\note y = db = dry-bulb temperature seen by the condenser (C)\n";
    ss << "A12, \\field Cooling Only Mode Total Evaporator Cooling Capacity Function of Flow Fraction Curve Name\n";
    ss << "\\note required field if Cooling Only Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note x = ff = Fraction of the full load evaporator air flow rate\n";
    ss << "A13, \\field Cooling Only Mode Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\note required field if Cooling Only Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiVariateCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Any curve or table with two independent variables can be used\n";
    ss << "\\note curve = a + b*ewb + c*ewb**2 + d*db + e*db**2 + f*ewb*db\n";
    ss << "\\note x = ewb = evaporator entering wet-bulb temperature (C)\n";
    ss << "\\note y = db = dry-bulb temperature seen by the condenser (C)\n";
    ss << "A14, \\field Cooling Only Mode Energy Input Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\note required field if Cooling Only Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note x = ff = Fraction of the full load evaporator air flow\n";
    ss << "A15, \\field Cooling Only Mode Part Load Fraction Correlation Curve Name\n";
    ss << "\\note required field if Cooling Only Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note x = PLR = part load ratio (evaporator cooling load/steady state capacity)\n";
    ss << "A16, \\field Cooling Only Mode Sensible Heat Ratio Function of Temperature Curve Name\n";
    ss << "\\note required field if Cooling Only Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiVariateCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Any curve or table with two independent variables can be used\n";
    ss << "\\note curve = a + b*ewb + c*ewb**2 + d*edb + e*edb**2 + f*ewb*edb\n";
    ss << "\\note x = ewb = evaporator entering wet-bulb temperature seen by the cooling coil (C)\n";
    ss << "\\note y = edb = evaporator entering dry-bulb temperature seen by the cooling coil (C)\n";
    ss << "A17, \\field Cooling Only Mode Sensible Heat Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\note required field if Cooling Only Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note x = ff = Fraction of the full load evaporator air flow\n";
    ss << "A18, \\field Cooling And Charge Mode Available\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "N10 , \\field Cooling And Charge Mode Rated Total Evaporator Cooling Capacity\n";
    ss << "\\note required field if Cooling And Charge Mode is available\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note gross capacity excluding supply air fan heat\n";
    ss << "\\note rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "\\note thermal storage tank at Fluid Storage Tank Rating Temperature (water or fluid) or storage faction of 0.5 (ice)\n";
    ss << "N11, \\field Cooling And Charge Mode Capacity Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\note If previous field is autocalculate, this determines the evaporator capacity\n";
    ss << "\\note as a multiplier on the Cooling Only Mode Rated Total Evaporator Cooling Capacity\n";
    ss << "N12, \\field Cooling And Charge Mode Rated Storage Charging Capacity\n";
    ss << "\\note required field if Cooling And Charge Mode is available\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note net capacity including any internal devices\n";
    ss << "\\note rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "\\note thermal storage tank at Fluid Storage Tank Rating Temperature (water or fluid) or storage faction of 0.5 (ice)\n";
    ss << "\\autocalculatable\n";
    ss << "N13, \\field Cooling And Charge Mode Storage Capacity Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\note If previous field is autocalculate, this determines the storage cooling capacity\n";
    ss << "\\note as a multiplier on the Cooling Only Mode Rated Total Evaporator Cooling Capacity\n";
    ss << "N14, \\field Cooling And Charge Mode Rated Sensible Heat Ratio\n";
    ss << "\\note required field if Cooling And Charge Mode is available\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "\\note Rated sensible heat ratio (gross sensible evaporator capacity/gross total evaporator capacity)\n";
    ss << "\\note sensible and total capacities do not include supply fan heat\n";
    ss << "N15, \\field Cooling And Charge Mode Cooling Rated COP\n";
    ss << "\\note Gross evaporator cooling capacity divided by power input to the compressor (for cooling) and outdoor fan,\n";
    ss << "\\note does not include supply fan heat or supply fan electrical energy input\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 3.0\n";
    ss << "\\note required field if Cooling And Charge Mode is available\n";
    ss << "N16, \\field Cooling And Charge Mode Charging Rated COP\n";
    ss << "\\note net cooling capacity divided by power input to the compressor (for charging) and outdoor fan,\n";
    ss << "\\note includes any internal devices\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 3.0\n";
    ss << "\\note required field if Cooling And Charge Mode is available\n";
    ss << "A19, \\field Cooling And Charge Mode Total Evaporator Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\note required field if Cooling And Charge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list TriQuadraticCurves\n";
    ss << "\\object-list MultiVariateTables\n";
    ss << "\\note Allowed curve or table objects are Curve:Triquadratic and Table:MultiVariableLookup\n";
    ss << "\\note curve or table = func(x = ewb, y = db, z = stes)\n";
    ss << "\\note x = ewb = evaporator entering wet-bulb temperature (C)\n";
    ss << "\\note y = db = dry-bulb temperature seen by the condenser (C)\n";
    ss << "\\note z = stes = state of thermal energy storage (C or fraction)\n";
    ss << "A20, \\field Cooling And Charge Mode Total Evaporator Cooling Capacity Function of Flow Fraction Curve Name\n";
    ss << "\\note required field if Cooling And Charge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note x = ff = Fraction of the full load evaporator air flow\n";
    ss << "A21, \\field Cooling And Charge Mode Evaporator Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\note required field if Cooling And Charge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list TriQuadraticCurves\n";
    ss << "\\object-list MultiVariateTables\n";
    ss << "\\note Allowed curve or table objects are Curve:Triquadratic and Table:MultiVariableLookup\n";
    ss << "\\note curve or table = func(x = ewb, y = db, z = stes)\n";
    ss << "\\note x = ewb = evaporator entering wet-bulb temperature (C)\n";
    ss << "\\note y = db = dry-bulb temperature seen by the condenser (C)\n";
    ss << "\\note z = stes = state of thermal energy storage (C or fraction)\n";
    ss << "A22, \\field Cooling And Charge Mode Evaporator Energy Input Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\note required field if Cooling And Charge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note x = ff = Fraction of the full load evaporator air flow\n";
    ss << "A23, \\field Cooling And Charge Mode Evaporator Part Load Fraction Correlation Curve Name\n";
    ss << "\\note required field if Cooling And Charge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note x = PLR = part load ratio (evaporator cooling load/steady state capacity)\n";
    ss << "A24, \\field Cooling And Charge Mode Storage Charge Capacity Function of Temperature Curve Name\n";
    ss << "\\note required field if Cooling And Charge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list TriQuadraticCurves\n";
    ss << "\\object-list MultiVariateTables\n";
    ss << "\\note Allowed curve or table objects are Curve:Triquadratic and Table:MultiVariableLookup\n";
    ss << "\\note curve or table = func(x = ewb, y = db, z = stes)\n";
    ss << "\\note x = ewb = evaporator entering wet-bulb temperature (C)\n";
    ss << "\\note y = db = dry-bulb temperature seen by the condenser (C)\n";
    ss << "\\note z = stes = state of thermal energy storage (C or fraction)\n";
    ss << "A25, \\field Cooling And Charge Mode Storage Charge Capacity Function of Total Evaporator PLR Curve Name\n";
    ss << "\\note required field if Cooling And Charge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note x = PLR = part load ratio (evaporator cooling load/steady state capacity)\n";
    ss << "A26, \\field Cooling And Charge Mode Storage Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\note required field if Cooling And Charge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list TriQuadraticCurves\n";
    ss << "\\object-list MultiVariateTables\n";
    ss << "\\note Allowed curve or table objects are Curve:Triquadratic and Table:MultiVariableLookup\n";
    ss << "\\note curve or table = func(x = ewb, y = db, z = stes)\n";
    ss << "\\note x = ewb = evaporator entering wet-bulb temperature (C)\n";
    ss << "\\note y = db = dry-bulb temperature seen by the condenser (C)\n";
    ss << "\\note z = stes = state of thermal energy storage (C or fraction)\n";
    ss << "A27, \\field Cooling And Charge Mode Storage Energy Input Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\note required field if Cooling And Charge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note x = ff = Fraction of the full load evaporator air flow\n";
    ss << "A28, \\field Cooling And Charge Mode Storage Energy Part Load Fraction Correlation Curve Name\n";
    ss << "\\note required field if Cooling And Charge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note x = PLR = part load ratio (evaporator cooling load/steady state capacity)\n";
    ss << "A29, \\field Cooling And Charge Mode Sensible Heat Ratio Function of Temperature Curve Name\n";
    ss << "\\note required field if Cooling And Charge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiVariateCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\object-list TriQuadraticCurves\n";
    ss << "\\object-list MultiVariateTables\n";
    ss << "\\note Curves or tables with either two or three independent variables can be used.\n";
    ss << "\\note Curve:Biquadratic, Table:TwoIndependentVariables, Curve:Bicubic and Curve:QuadraticLinear allowed\n";
    ss << "\\note curve = a + b*ewb + c*ewb**2 + d*edb + e*edb**2 + f*ewb*edb\n";
    ss << "\\note x = ewb = entering wet-bulb temperature seen by the cooling coil (C)\n";
    ss << "\\note y = edb = entering dry-bulb temperature seen by the cooling coil (C)\n";
    ss << "\\note Also allows Curve:Triquadratic and Table:MultiVariableLookup\n";
    ss << "\\note curve or table = func(x = ewb, y = edb, z = stes)\n";
    ss << "\\note z = stes = state of thermal energy storage (C or fraction)\n";
    ss << "A30, \\field Cooling And Charge Mode Sensible Heat Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\note required field if Cooling And Charge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note x = ff = Fraction of the full load evaporator air flow\n";
    ss << "A31, \\field Cooling And Discharge Mode Available\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "N17, \\field Cooling And Discharge Mode Rated Total Evaporator Cooling Capacity\n";
    ss << "\\note required field if Cooling And Discharge Mode is available\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note gross capacity excluding supply air fan heat\n";
    ss << "\\note rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "\\note thermal storage tank at Fluid Storage Tank Rating Temperature (water or fluid) or storage faction of 0.5 (ice)\n";
    ss << "N18, \\field Cooling And Discharge Mode Evaporator Capacity Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\note If previous field is autocalculate, this determines the charging capacity\n";
    ss << "\\note as a multiplier on the Cooling Only Mode Rated Total Evaporator Cooling Capacity\n";
    ss << "N19, \\field Cooling And Discharge Mode Rated Storage Discharging Capacity\n";
    ss << "\\note required field if Cooling And Discharge Mode is available\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note net capacity including any internal devices\n";
    ss << "\\note rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "\\note thermal storage tank at 26.7 C (water) or storage faction of 0.5 (ice)\n";
    ss << "\\autocalculatable\n";
    ss << "N20, \\field Cooling And Discharge Mode Storage Discharge Capacity Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\note If previous field is autocalculate, this determines the charging capacity\n";
    ss << "\\note as a multiplier on the Cooling Only Mode Rated Total Evaporator Cooling Capacity\n";
    ss << "N21, \\field Cooling And Discharge Mode Rated Sensible Heat Ratio\n";
    ss << "\\note required field if Cooling And Discharge Mode is available\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "\\note Rated sensible heat ratio (gross sensible evaporator capacity/gross total evaporator capacity)\n";
    ss << "\\note sensible and total capacities do not include supply fan heat\n";
    ss << "N22, \\field Cooling And Discharge Mode Cooling Rated COP\n";
    ss << "\\note Gross evaporator cooling capacity divided by power input to the compressor (for cooling) and outdoor fan,\n";
    ss << "\\note does not include supply fan heat or supply fan electrical energy input\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 3.0\n";
    ss << "\\note required field if Cooling And Discharge Mode is available\n";
    ss << "N23, \\field Cooling And Discharge Mode Discharging Rated COP\n";
    ss << "\\note gross cooling capacity divided by power input to the compressor (for discharging),\n";
    ss << "\\note includes any internal devices for discharging storage but not supply fan\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 3.0\n";
    ss << "\\note required field if Cooling And Discharge Mode is available\n";
    ss << "A32, \\field Cooling And Discharge Mode Total Evaporator Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\note required field if Cooling Only Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list TriQuadraticCurves\n";
    ss << "\\object-list MultiVariateTables\n";
    ss << "\\note Allowed curve or table objects are Curve:Triquadratic and Table:MultiVariableLookup\n";
    ss << "\\note curve or table = func(x = ewb, y = db, z = stes)\n";
    ss << "\\note x = ewb = evaporator entering wet-bulb temperature (C)\n";
    ss << "\\note y = db = dry-bulb temperature seen by the condenser (C)\n";
    ss << "\\note z = stes = state of thermal energy storage (C or fraction)\n";
    ss << "A33, \\field Cooling And Discharge Mode Total Evaporator Cooling Capacity Function of Flow Fraction Curve Name\n";
    ss << "\\note required field if Cooling And Discharge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note x = ff = Fraction of the full load evaporator air flow\n";
    ss << "A34, \\field Cooling And Discharge Mode Evaporator Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\note required field if Cooling And Discharge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list TriQuadraticCurves\n";
    ss << "\\object-list MultiVariateTables\n";
    ss << "\\note Allowed curve or table objects are Curve:Triquadratic and Table:MultiVariableLookup\n";
    ss << "\\note curve or table = func(x = ewb, y = db, z = stes)\n";
    ss << "\\note x = ewb = evaporator entering wet-bulb temperature (C)\n";
    ss << "\\note y = db = dry-bulb temperature seen by the condenser (C)\n";
    ss << "\\note z = stes = state of thermal energy storage (C or fraction)\n";
    ss << "A35, \\field Cooling And Discharge Mode Evaporator Energy Input Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\note required field if Cooling And Discharge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = Fraction of the full load evaporator air flow\n";
    ss << "A36, \\field Cooling And Discharge Mode Evaporator Part Load Fraction Correlation Curve Name\n";
    ss << "\\note required field if Cooling And Discharge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note x = PLR = part load ratio (evaporator cooling load/steady state capacity)\n";
    ss << "A37, \\field Cooling And Discharge Mode Storage Discharge Capacity Function of Temperature Curve Name\n";
    ss << "\\note required field if Cooling And Discharge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list TriQuadraticCurves\n";
    ss << "\\object-list MultiVariateTables\n";
    ss << "\\note Allowed curve or table objects are Curve:Triquadratic and Table:MultiVariableLookup\n";
    ss << "\\note curve or table = func(x = ewb, y = db, z = stes)\n";
    ss << "\\note x = ewb = evaporator entering wet-bulb temperature (C)\n";
    ss << "\\note y = db = dry-bulb temperature seen by the condenser (C)\n";
    ss << "\\note z = stes = state of thermal energy storage (C or fraction)\n";
    ss << "A38, \\field Cooling And Discharge Mode Storage Discharge Capacity Function of Flow Fraction Curve Name\n";
    ss << "\\note required field if Cooling And Discharge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = Fraction of the full load evaporator air flow\n";
    ss << "A39, \\field Cooling And Discharge Mode Storage Discharge Capacity Function of Total Evaporator PLR Curve Name\n";
    ss << "\\note required field if Cooling And Discharge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note x =PLR = part load ratio (evaporator cooling load/steady state capacity)\n";
    ss << "A40, \\field Cooling And Discharge Mode Storage Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\note required field if Cooling And Discharge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list TriQuadraticCurves\n";
    ss << "\\object-list MultiVariateTables\n";
    ss << "\\note Allowed curve or table objects are Curve:Triquadratic and Table:MultiVariableLookup\n";
    ss << "\\note curve or table = func(x = ewb, y = db, z = stes)\n";
    ss << "\\note x = ewb = evaporator entering wet-bulb temperature (C)\n";
    ss << "\\note y = db = dry-bulb temperature seen by the condenser (C)\n";
    ss << "\\note z = stes = state of thermal energy storage (C or fraction)\n";
    ss << "A41, \\field Cooling And Discharge Mode Storage Energy Input Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\note required field if Cooling And Discharge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note x = ff = Fraction of the full load evaporator air flow\n";
    ss << "A42, \\field Cooling And Discharge Mode Storage Energy Part Load Fraction Correlation Curve Name\n";
    ss << "\\note required field if Cooling And Discharge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note x = PLR = part load ratio (evaporator cooling load/steady state capacity)\n";
    ss << "A43, \\field Cooling And Discharge Mode Sensible Heat Ratio Function of Temperature Curve Name\n";
    ss << "\\note required field if Cooling And Discharge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiVariateCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\object-list TriQuadraticCurves\n";
    ss << "\\object-list MultiVariateTables\n";
    ss << "\\note Curves or tables with either two or three independent variables can be used.\n";
    ss << "\\note curve = a + b*ewb + c*ewb**2 + d*edb + e*edb**2 + f*ewb*edb\n";
    ss << "\\note x = ewb = entering wet-bulb temperature seen by the cooling coil (C)\n";
    ss << "\\note y = edb = entering dry-bulb temperature seen by the cooling coil (C)\n";
    ss << "\\note Also allows Curve:Triquadratic and Table:MultiVariableLookup\n";
    ss << "\\note curve or table = func(x = ewb, y = edb, z = stes)\n";
    ss << "\\note z = stes = state of thermal energy storage (C or fraction)\n";
    ss << "A44, \\field Cooling And Discharge Mode Sensible Heat Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\note required field if Cooling And Discharge Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note x = ff = Fraction of the full load evaporator air flow\n";
    ss << "A45, \\field Charge Only Mode Available\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "N24, \\field Charge Only Mode Rated Storage Charging Capacity\n";
    ss << "\\note required field if Charge Only  Mode is available\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note net capacity including any internal devices\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "\\note thermal storage tank at 26.7 C (water) or storage faction of 0.5 (ice)\n";
    ss << "\\autocalculatable\n";
    ss << "N25, \\field Charge Only Mode Capacity Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\note If previous field is autocalculate, this determines the charging capacity\n";
    ss << "\\note as a multiplier on the Cooling Only Mode Rated Total Evaporator Cooling Capacity\n";
    ss << "N26, \\field Charge Only Mode Charging Rated COP\n";
    ss << "\\note net cooling capacity divided by power input to the compressor (for charging) and outdoor fan,\n";
    ss << "\\note includes any internal devices\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 3.0\n";
    ss << "\\note required field if Charge Only Mode is available\n";
    ss << "A46, \\field Charge Only Mode Storage Charge Capacity Function of Temperature Curve Name\n";
    ss << "\\note required field if Charge Only Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiVariateCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Any curve or table with two independent variables can be used\n";
    ss << "\\note curve = a + b*db + c*db**2 + d*stes + e*stes**2 + f*db*stes\n";
    ss << "\\note x = db = dry-bulb temperature seen by the condenser (C)\n";
    ss << "\\note y = stes = state of thermal energy storage (C or fraction)\n";
    ss << "A47, \\field Charge Only Mode Storage Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\note required field if Charge Only Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiVariateCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Any curve or table with two independent variables can be used\n";
    ss << "\\note curve = a + b*db + c*db**2 + d*stes + e*stes**2 + f*db*stes\n";
    ss << "\\note x = db = dry-bulb temperature seen by the condenser (C)\n";
    ss << "\\note y = stes = state of thermal energy storage (C or fraction)\n";
    ss << "A48, \\field Discharge Only Mode Available\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "N27, \\field Discharge Only Mode Rated Storage Discharging Capacity\n";
    ss << "\\note required field if Discharge Only Mode is available\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note net capacity including any internal devices\n";
    ss << "\\note rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note thermal storage tank at 26.7 C (water) or storage faction of 0.5 (ice)\n";
    ss << "\\autocalculatable\n";
    ss << "N28, \\field Discharge Only Mode Capacity Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\note If previous field is autocalculate, this determines the discharging capacity\n";
    ss << "\\note as a multiplier on the Cooling Only Mode Rated Total Evaporator Cooling Capacity\n";
    ss << "N29, \\field Discharge Only Mode Rated Sensible Heat Ratio\n";
    ss << "\\note required field if Discharge Only Mode is available\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note Rated sensible heat ratio (gross sensible evaporator capacity/gross total evaporator capacity)\n";
    ss << "\\note sensible and total capacities do not include supply fan heat\n";
    ss << "N30, \\field Discharge Only Mode Rated COP\n";
    ss << "\\note required field if Discharge Only Mode is available\n";
    ss << "\\note gross cooling capacity divided by power input to the compressor (for discharging),\n";
    ss << "\\note includes any internal devices for discharging storage but not supply fan\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 3.0\n";
    ss << "A49, \\field Discharge Only Mode Storage Discharge Capacity Function of Temperature Curve Name\n";
    ss << "\\note required field if Discharge Only Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiVariateCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Any curve or table with two independent variables can be used\n";
    ss << "\\note curve = a + b*ewb + c*ewb**2 + d*stes + e*stes**2 + f*ewb*stes\n";
    ss << "\\note x = ewb = evaporator entering wet-bulb temperature (C)\n";
    ss << "\\note y = stes = state of thermal energy storage (C or fraction)\n";
    ss << "A50, \\field Discharge Only Mode Storage Discharge Capacity Function of Flow Fraction Curve Name\n";
    ss << "\\note required field if Discharge Only Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note x = ff = Fraction of the full load evaporator air flow\n";
    ss << "A51, \\field Discharge Only Mode Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\note required field if Discharge Only Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiVariateCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Any curve or table with two independent variables can be used\n";
    ss << "\\note curve = a + b*ewb + c*ewb**2 + d*stes + e*stes**2 + f*ewb*stes\n";
    ss << "\\note x = ewb = evaporator entering wet-bulb temperature (C)\n";
    ss << "\\note y = stes = state of thermal energy storage (C or fraction)\n";
    ss << "A52, \\field Discharge Only Mode Energy Input Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\note required field if Discharge Only Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note x = ff = Fraction of the full load evaporator air flow\n";
    ss << "A53, \\field Discharge Only Mode Part Load Fraction Correlation Curve Name\n";
    ss << "\\note required field if Discharge Only Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "A54, \\field Discharge Only Mode Sensible Heat Ratio Function of Temperature Curve Name\n";
    ss << "\\note required field if Discharge Only Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiVariateCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\object-list TriQuadraticCurves\n";
    ss << "\\object-list MultiVariateTables\n";
    ss << "\\note Curves or tables with either two or three independent variables can be used.\n";
    ss << "\\note Curve:Biquadratic, Table:TwoIndependentVariables, Curve:Bicubic and Curve:QuadraticLinear allowed\n";
    ss << "\\note curve = a + b*ewb + c*ewb**2 + d*edb + e*edb**2 + f*ewb*edb\n";
    ss << "\\note x = ewb = entering wet-bulb temperature seen by the cooling coil (C)\n";
    ss << "\\note y = edb = entering dry-bulb temperature seen by the cooling coil (C)\n";
    ss << "\\note Also allows Curve:Triquadratic and Table:MultiVariableLookup\n";
    ss << "\\note curve or table = func(x = ewb, y = edb, z = stes)\n";
    ss << "\\note z = stes = state of thermal energy storage (C or fraction)\n";
    ss << "A55, \\field Discharge Only Mode Sensible Heat Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\note required field if Discharge Only Mode is available\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = Fraction of the full load evaporator air flow\n";
    ss << "N31, \\field Ancillary Electric Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note controls and miscellaneous standby ancillary electric power draw, when available\n";
    ss << "N32, \\field Cold Weather Operation Minimum Outdoor Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N33, \\field Cold Weather Operation Ancillary Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "A56, \\field Condenser Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of an outdoor air node. This node name is also specified in\n";
    ss << "\\note an OutdoorAir:Node or OutdoorAir:NodeList object.\n";
    ss << "A57, \\field Condenser Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N34, \\field Condenser Design Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Used to calculate condenser leaving conditions and water use if evaporatively cooled.\n";
    ss << "N35, \\field Condenser Air Flow Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\note If previous field is autocalculate, this determines the condenser air flow size as a\n";
    ss << "\\note multiplier on the Rated Evaporator Air Flow Rate.\n";
    ss << "A58, \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "\\default AirCooled\n";
    ss << "N36, \\field Evaporative Condenser Effectiveness\n";
    ss << "\\note required field if condenser type is evaporatively cooled\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N37, \\field Evaporative Condenser Pump Rated Power Consumption\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Rated power consumed by the evaporative condenser's water pump\n";
    ss << "N38, \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled and for periods\n";
    ss << "\\note when the basin heater is available (field Basin Heater Operating Schedule Name).\n";
    ss << "\\note For this situation, the heater maintains the basin water temperature at the basin heater\n";
    ss << "\\note setpoint temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when the DX coil is off.\n";
    ss << "\\note If this field is blank, the basin heater is always available.\n";
    ss << "N39, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on.\n";
    ss << "A59, \\field Basin Heater Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";
    ss << "A60, \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A61, \\field Condensate Collection Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A62, \\field Storage Tank Plant Connection Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A63, \\field Storage Tank Plant Connection Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N40, \\field Storage Tank Plant Connection Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "N41, \\field Storage Tank Plant Connection Heat Transfer Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "N42, \\field Storage Tank Minimum Operating Limit Fluid Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note For fluid storage tanks only, minimum limit for storage tank\n";
    ss << "\\note If omitted,then the minimum temperature limit is that used for fluid property data.\n";
    ss << "N43; \\field Storage Tank Maximum Operating Limit Fluid Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note For fluid storage tanks only, maximum limit for storage tank\n";
    ss << "\\note If omitted,then the maximum temperature limit is that used for fluid property data.\n";

    IddObjectType objType(IddObjectType::Coil_Cooling_DX_SingleSpeed_ThermalStorage);
    OptionalIddObject oObj = IddObject::load("Coil:Cooling:DX:SingleSpeed:ThermalStorage",
                                             "Coils",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_Cooling_DX_SingleSpeed_ThermalStorage);
  return object;
}

IddObject createEvaporativeCooler_Direct_CelDekPadIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EvaporativeCooler:Direct:CelDekPad,\n";
    ss << "\\memo Direct evaporative cooler with rigid media evaporative pad and recirculating water\n";
    ss << "\\memo pump. This model has no controls other than its availability schedule.\n";
    ss << "\\min-fields 7\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\reference EvapCoolerNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Direct Pad Area\n";
    ss << "\\units m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default Autosize\n";
    ss << "N2 , \\field Direct Pad Depth\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default Autosize\n";
    ss << "N3 , \\field Recirculating Water Pump Power Consumption\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "A3 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Control Type\n";
    ss << "\\note This field is not currently used and can be left blank\n";
    ss << "A6 ; \\field Water Supply Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";

    IddObjectType objType(IddObjectType::EvaporativeCooler_Direct_CelDekPad);
    OptionalIddObject oObj = IddObject::load("EvaporativeCooler:Direct:CelDekPad",
                                             "Evaporative Coolers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EvaporativeCooler_Direct_CelDekPad);
  return object;
}

IddObject createEvaporativeCooler_Indirect_CelDekPadIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EvaporativeCooler:Indirect:CelDekPad,\n";
    ss << "\\memo Indirect evaporative cooler with rigid media evaporative pad, recirculating water\n";
    ss << "\\memo pump, and secondary air fan. This model has no controls other than its availability\n";
    ss << "\\memo schedule.\n";
    ss << "\\min-fields 14\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference EvapCoolerNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Direct Pad Area\n";
    ss << "\\type real\n";
    ss << "\\units m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default Autosize\n";
    ss << "N2 , \\field Direct Pad Depth\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default Autosize\n";
    ss << "N3 , \\field Recirculating Water Pump Power Consumption\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "N4 , \\field Secondary Air Fan Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "N5 , \\field Secondary Air Fan Total Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N6 , \\field Secondary Air Fan Delta Pressure\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units inH2O\n";
    ss << "N7 , \\field Indirect Heat Exchanger Effectiveness\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "A3 , \\field Primary Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Primary Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Control Type\n";
    ss << "\\note This field is not currently used and can be left blank\n";
    ss << "A6 , \\field Water Supply Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A7 ; \\field Secondary Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of an outdoor air node\n";

    IddObjectType objType(IddObjectType::EvaporativeCooler_Indirect_CelDekPad);
    OptionalIddObject oObj = IddObject::load("EvaporativeCooler:Indirect:CelDekPad",
                                             "Evaporative Coolers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EvaporativeCooler_Indirect_CelDekPad);
  return object;
}

IddObject createEvaporativeCooler_Indirect_WetCoilIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EvaporativeCooler:Indirect:WetCoil,\n";
    ss << "\\memo Indirect evaporative cooler with wetted coil, recirculating water pump, and secondary\n";
    ss << "\\memo air fan. This model has no controls other than its availability schedule.\n";
    ss << "\\min-fields 13\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference EvapCoolerNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Coil Maximum Efficiency\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N2 , \\field Coil Flow Ratio\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Recirculating Water Pump Power Consumption\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "N4 , \\field Secondary Air Fan Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "N5 , \\field Secondary Air Fan Total Efficiency\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N6 , \\field Secondary Air Fan Delta Pressure\n";
    ss << "\\required-field\n";
    ss << "\\units Pa\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units inH2O\n";
    ss << "A3 , \\field Primary Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Primary Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Control Type\n";
    ss << "\\note This field is not currently used and can be left blank\n";
    ss << "A6 , \\field Water Supply Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A7 ; \\field Secondary Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of an outdoor air node\n";

    IddObjectType objType(IddObjectType::EvaporativeCooler_Indirect_WetCoil);
    OptionalIddObject oObj = IddObject::load("EvaporativeCooler:Indirect:WetCoil",
                                             "Evaporative Coolers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EvaporativeCooler_Indirect_WetCoil);
  return object;
}

IddObject createEvaporativeCooler_Indirect_ResearchSpecialIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EvaporativeCooler:Indirect:ResearchSpecial,\n";
    ss << "\\memo Indirect evaporative cooler with user-specified effectiveness (can represent rigid pad\n";
    ss << "\\memo or wetted coil), recirculating water pump, and secondary air fan. This model is\n";
    ss << "\\memo controlled to meet the primary air outlet temperature setpoint.\n";
    ss << "\\min-fields 21\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\reference EvapCoolerNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Cooler Wetbulb Design Effectiveness\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note wet operation effectiveness with respect to wetbulb depression\n";
    ss << "\\note this is the nominal design wetbulb effectiveness at design air flow rates and water rate\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 2.0\n";
    ss << "A3 , \\field Wetbulb Effectiveness Flow Ratio Modifier Curve Name\n";
    ss << "\\note this curve modifies the wetbulb effectiveness in the previous field (eff_wb_design)\n";
    ss << "\\note by multiplying the value by the result of this curve, eff_wb = eff_wb_design * func(HXFlowRatio)\n";
    ss << "\\note x = HXFlowRatio = sum of the primary and secondary flow rates divided by the sum of the design flow\n";
    ss << "\\note rates. If this input field is left blank, constant cooler wetbulb effectiveness is assumed.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllCurves\n";
    ss << "\\note Any curve or table with one independent variable can be used:\n";
    ss << "\\note Curve:Linear, Curve:Quadratic, Curve:Cubic, Curve:Quartic, Curve:Exponent,\n";
    ss << "\\note Curve:ExponentialSkewNormal, Curve:Sigmoid, Curve:RectuangularHyperbola1,\n";
    ss << "\\note Curve:RectangularHyperbola2, Curve:ExponentialDecay, Curve:DoubleExponentialDecay,\n";
    ss << "\\note Table:OneIndependentVariable\n";
    ss << "N2 , \\field Cooler Drybulb Design Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\note dry operation effectiveness with respect to drybulb temperature difference\n";
    ss << "\\note this is the nominal design dryblub effectiveness at design air flow rates, no evaporation water active\n";
    ss << "\\minimum 0.0\n";
    ss << "A4 , \\field Drybulb Effectiveness Flow Ratio Modifier Curve Name\n";
    ss << "\\note this curve modifies the drybulb effectiveness in the previous field (eff_db_design)\n";
    ss << "\\note by multiplying the value by the result of this curve, eff_db = eff_db_design * f(HXFlowRatio)\n";
    ss << "\\note x = HXFlowRatio = sum of the primary and secondary flow rates divided by the sum of the design flow\n";
    ss << "\\note rates. If this input field is left blank, constant cooler drybulb effectiveness is assumed.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllCurves\n";
    ss << "\\note Any curve or table with one independent variable can be used:\n";
    ss << "\\note Curve:Linear, Curve:Quadratic, Curve:Cubic, Curve:Quartic, Curve:Exponent,\n";
    ss << "\\note Curve:ExponentialSkewNormal, Curve:Sigmoid, Curve:RectuangularHyperbola1,\n";
    ss << "\\note Curve:RectangularHyperbola2, Curve:ExponentialDecay, Curve:DoubleExponentialDecay,\n";
    ss << "\\note Table:OneIndependentVariable\n";
    ss << "N3 , \\field Recirculating Water Pump Design Power\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\note This is the nominal design pump power of water recirculation and spray for evaporation at design air flow\n";
    ss << "\\note rates and cooler design effectiveness\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N4 , \\field Water Pump Power Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\units W/(m3/s)\n";
    ss << "\\ip-units W/(gal/min)\n";
    ss << "\\default 90.0\n";
    ss << "\\note This field is used when the previous field is set to autosize. The pump power is scaled with Secondary Air\n";
    ss << "\\note Design Air Flow Rate. This value was backed out from inputs in energy plus example files. Average Pump Power\n";
    ss << "\\note sizing factor was estimated from pump power and secondary air design flow rates inputs from energyplus example\n";
    ss << "\\note files is about 90.0 [W/(m3/s)] (=90.0 ~ Pump Power / Secondary Air Design Flow Rate). The factor ranges from\n";
    ss << "\\note 55.0 to 150.0 [W/(m3/s)] were noted. The pump power can be sized to zero by setting this factor to zero.\n";
    ss << "A5 , \\field Water Pump Power Modifier Curve Name\n";
    ss << "\\note this curve modifies the pump power in the previous field by multiplying the design power by the result of this curve.\n";
    ss << "\\note x = ff = flow fraction on the secondary side, secondary air flow rate during operation divided by Secondary Air\n";
    ss << "\\note Design Air Flow Rate. If this input field is left blank, pump power is assumed to be proportional to part load ratio.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllCurves\n";
    ss << "\\note Any curve or table with one independent variable can be used:\n";
    ss << "\\note Curve:Linear, Curve:Quadratic, Curve:Cubic, Curve:Quartic, Curve:Exponent,\n";
    ss << "\\note Curve:ExponentialSkewNormal, Curve:Sigmoid, Curve:RectuangularHyperbola1,\n";
    ss << "\\note Curve:RectangularHyperbola2, Curve:ExponentialDecay, Curve:DoubleExponentialDecay,\n";
    ss << "\\note Table:OneIndependentVariable\n";
    ss << "N5 , \\field Secondary Air Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N6 , \\field Secondary Air Flow Scaling Factor\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 1.0\n";
    ss << "\\note This field is used when the previous field is set to autoize.  The Primary Design Air Flow Rate is scaled using this factor\n";
    ss << "\\note to calculate the secondary design air flow rate.\n";
    ss << "N7 , \\field Secondary Air Fan Design Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\note This is the fan design power at Secondary Design Air Flow Rate. This is the nominal design power at full speed.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N8 , \\field Secondary Air Fan Sizing Specific Power\n";
    ss << "\\type real\n";
    ss << "\\units W/(m3/s)\n";
    ss << "\\default 250.0\n";
    ss << "\\note This field is used when the previous field is set to autosize. The fan power is scaled with Secondary Air Design Flow Rate.\n";
    ss << "\\note The default value is estimated from 125 Pa fan total pressure and fan total efficiency of 50.0% (250.0 = 125/0.5).\n";
    ss << "A6 , \\field Secondary Air Fan Power Modifier Curve Name\n";
    ss << "\\note this curve modifies the design fan power in the previous field by multiplying the value by the result\n";
    ss << "\\note of this curve.  It should have a value of 1.0 at a x = 1.0.\n";
    ss << "\\note x = ff = flow fraction on the secondary side, secondary air flow rate during operation divided by Secondary Air Design Air\n";
    ss << "\\note Flow Rate. If this input field is left blank, the secondary fan power is assumed to be proportional to part load ratio.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllCurves\n";
    ss << "\\note Any curve or table with one independent variable can be used:\n";
    ss << "\\note Curve:Linear, Curve:Quadratic, Curve:Cubic, Curve:Quartic, Curve:Exponent,\n";
    ss << "\\note Curve:ExponentialSkewNormal, Curve:Sigmoid, Curve:RectuangularHyperbola1,\n";
    ss << "\\note Curve:RectangularHyperbola2, Curve:ExponentialDecay, Curve:DoubleExponentialDecay,\n";
    ss << "\\note Table:OneIndependentVariable\n";
    ss << "A7 , \\field Primary Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A8 , \\field Primary Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N9 , \\field Primary Air Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N10, \\field Dewpoint Effectiveness Factor\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "A9 , \\field Secondary Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A10, \\field Secondary Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A11, \\field Sensor Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A12, \\field Relief Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A13, \\field Water Supply Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "N11, \\field Drift Loss Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Rate of drift loss as a fraction of evaporated water flow rate.\n";
    ss << "\\note If this input field is left blank, then zero drift loss is assumed.\n";
    ss << "\\default 0.0\n";
    ss << "N12, \\field Blowdown Concentration Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 2.0\n";
    ss << "\\note Characterizes the rate of blowdown in the evaporative cooler.\n";
    ss << "\\note Blowdown is water intentionally drained from the cooler in order to offset the build\n";
    ss << "\\note up of solids in the water that would otherwise occur because of evaporation.\n";
    ss << "\\note Ratio of solids in the blowdown water to solids in the make up water.\n";
    ss << "\\note A typical value is 3.  If left blank then there is no blowdown.\n";
    ss << "N13, \\field Evaporative Operation Minimum Limit Secondary Air Drybulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\note This input field value defines the secondary air inlet node drybulb temperature\n";
    ss << "\\note limits in degreeCelsius. When the secondary side entering air dry bulb temperature\n";
    ss << "\\note drops below this limit, then the evaporative cooler operation mode changes to dry\n";
    ss << "\\note heat exchanger. Users specify their own limits. If this field is left blank, then\n";
    ss << "\\note there is no drybulb temperature lower limit for evaporative cooler operation. If\n";
    ss << "\\note operating range control is desired then this input field and the next two input\n";
    ss << "\\note fields should be specified or all the three should be left blank or left out. If\n";
    ss << "\\note no minimum drybulb temperature limit is desired while there are maximum drybulb\n";
    ss << "\\note and wetbulb temperature limits then specify very low minimum temperature limit\n";
    ss << "\\note value (e.g. -99.0C).\n";
    ss << "N14, \\field Evaporative Operation Maximum Limit Outdoor Wetbulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\note This input field value defines the secondary air inlet node wetbulb temperature\n";
    ss << "\\note limits in degree Celsius. When the secondary side entering air wet bulb temperature\n";
    ss << "\\note exceeds this limit, then the evaporative cooler urns off and does not attempt to do\n";
    ss << "\\note any cooling. If this field is left blank, then there is no wetbulb temperature\n";
    ss << "\\note upper limit for evaporative cooler wet operation mode. If this input field is left\n";
    ss << "\\note blank then, the previous and the next input fields should also be left blank. If no\n";
    ss << "\\note maximum wetbulb temperature limits is desired while there are minimum drybulb and\n";
    ss << "\\note maximum drybulb upper temperature limits then specify very high maximum wetbulb\n";
    ss << "\\note temperature limit value (e.g. 99.0 C).\n";
    ss << "N15; \\field Dry Operation Maximum Limit Outdoor Drybulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\note This input field value defines the secondary air inlet node drybulb temperature\n";
    ss << "\\note limits in degree Celsius. When the secondary side entering air drybulb temperature\n";
    ss << "\\note exceeds this limit, then the evaporative cooler will not run in dry operation mode\n";
    ss << "\\note or may be turned off depending on its wetbulb temperature. If this field is left\n";
    ss << "\\note blank, then there is no drybulb temperature maximum limit for evaporative cooler\n";
    ss << "\\note operation. If this input field is left blank then, the previous and the next input\n";
    ss << "\\note fields should also be left blank. If no maximum drybulb temperature limit is\n";
    ss << "\\note desired while there are minimum drybulb and maximum wetbulb upper temperature\n";
    ss << "\\note limits then specify very high maximum drybulb temperature limit value (e.g. 99.0 C).\n";

    IddObjectType objType(IddObjectType::EvaporativeCooler_Indirect_ResearchSpecial);
    OptionalIddObject oObj = IddObject::load("EvaporativeCooler:Indirect:ResearchSpecial",
                                             "Evaporative Coolers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EvaporativeCooler_Indirect_ResearchSpecial);
  return object;
}

IddObject createEvaporativeCooler_Direct_ResearchSpecialIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EvaporativeCooler:Direct:ResearchSpecial,\n";
    ss << "\\memo Direct evaporative cooler with user-specified effectiveness (can represent rigid pad\n";
    ss << "\\memo or similar media), and recirculating water pump, and secondary air fan. This model is\n";
    ss << "\\memo controlled to meet the primary air outlet temperature setpoint.\n";
    ss << "\\min-fields 11\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\reference EvapCoolerNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Cooler Design Effectiveness\n";
    ss << "\\note effectiveness with respect to wet-bulb depression\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A3 , \\field Effectiveness Flow Ratio Modifier Curve Name\n";
    ss << "\\note this curve modifies the design effectiveness in the previous field\n";
    ss << "\\note by multiplying the value by the result of this curve.  The effectiveness flow modifier curve\n";
    ss << "\\note is a function of flow fraction. Flow fraction is the ratio of current primary air flow rate to\n";
    ss << "\\note the primary air design flow rate. If this input field is left blank then, the effectiveness\n";
    ss << "\\note is assumed to be constant.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllCurves\n";
    ss << "\\note Any curve or table with one independent variable can be used:\n";
    ss << "\\note Curve:Linear, Curve:Quadratic, Curve:Cubic, Curve:Quartic, Curve:Exponent,\n";
    ss << "\\note Curve:ExponentialSkewNormal, Curve:Sigmoid, Curve:RectuangularHyperbola1,\n";
    ss << "\\note Curve:RectangularHyperbola2, Curve:ExponentialDecay, Curve:DoubleExponentialDecay,\n";
    ss << "\\note Table:OneIndependentVariable\n";
    ss << "N2 , \\field Primary Air Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N3 , \\field Recirculating Water Pump Design Power\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note This is the design water pump or spray for evaporation at the primary air design air flow rates\n";
    ss << "\\note and cooler design effectiveness\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N4 , \\field Water Pump Power Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\units W/(m3/s)\n";
    ss << "\\ip-units W/(gal/min)\n";
    ss << "\\default 90.0\n";
    ss << "\\note This field is used when the previous field is set to autosize. The pump power is scaled with Secondary Air\n";
    ss << "\\note Design Air Flow Rate. This value was backed out from inputs in energy plus example files. Average Pump Power\n";
    ss << "\\note sizing factor was estimated from pump power and primary air design flow rates inputs from energyplus example\n";
    ss << "\\note files is about 90.0 [W/(m3/s)] (=90.0 ~ Pump Power / Primary Air Design Flow Rate). The factor ranges from\n";
    ss << "\\note 55.0 to 150.0 [W/(m3/s)]. The pump power can be sized to zero by setting this factor to zero.\n";
    ss << "A4 , \\field Water Pump Power Modifier Curve Name\n";
    ss << "\\note this curve modifies the pump power in the previous field by multiplying the design power by the result of this curve.\n";
    ss << "\\note x = ff = flow fraction on the primary air. The flow fraction is the secondary air flow rate during current operation divided\n";
    ss << "\\note by Primary Air Design Flow Rate\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllCurves\n";
    ss << "\\note Any curve or table with one independent variable can be used:\n";
    ss << "\\note Curve:Linear, Curve:Quadratic, Curve:Cubic, Curve:Quartic, Curve:Exponent,\n";
    ss << "\\note Curve:ExponentialSkewNormal, Curve:Sigmoid, Curve:RectuangularHyperbola1,\n";
    ss << "\\note Curve:RectangularHyperbola2, Curve:ExponentialDecay, Curve:DoubleExponentialDecay,\n";
    ss << "\\note Table:OneIndependentVariable\n";
    ss << "A5 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7 , \\field Sensor Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A8 , \\field Water Supply Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "N5 , \\field Drift Loss Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Rate of drift loss as a fraction of evaporated water flow rate\n";
    ss << "N6 , \\field Blowdown Concentration Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 2.0\n";
    ss << "\\note Characterizes the rate of blowdown in the evaporative cooler.\n";
    ss << "\\note Blowdown is water intentionally drained from the cooler in order to offset the build up\n";
    ss << "\\note of solids in the water that would otherwise occur because of evaporation.\n";
    ss << "\\note Ratio of solids in the blowdown water to solids in the make up water.\n";
    ss << "\\note A typical value is 3. If left blank then there is no blowdown.\n";
    ss << "N7 , \\field Evaporative Operation Minimum Drybulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\minimum -99.0\n";
    ss << "\\note This numeric field defines the evaporative cooler air inlet node drybulb temperature minimum\n";
    ss << "\\note limit in degrees Celsius. The evaporative cooler will be turned off when the evaporator cooler\n";
    ss << "\\note air inlet node dry-bulb temperature falls below this limit. The typical minimum value is 16degC. Users\n";
    ss << "\\note are allowed to specify their own limits. If this field is left blank, then there is no drybulb lower\n";
    ss << "\\note temperature limit for evaporative cooler operation.\n";
    ss << "N8 , \\field Evaporative Operation Maximum Limit Wetbulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\note when outdoor wetbulb temperature rises above this limit the cooler shuts down.\n";
    ss << "\\note This numeric field defines the evaporative cooler air inlet node wet-bulb temperature maximum\n";
    ss << "\\note limit in degrees Celsius. The evaporative cooler will be turned off when the evaporative cooler\n";
    ss << "\\note air inlet node wet-bulb temperature exceeds this limit. The typical maximum value is 24degC. Users\n";
    ss << "\\note are allowed to specify their own limits. If this field is left blank, then there is no upper\n";
    ss << "\\note wetbulb temperature limit for evaporative cooler operation.\n";
    ss << "N9 ; \\field Evaporative Operation Maximum Limit Drybulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\note This numeric field defines the evaporative cooler air inlet node dry-bulb temperature maximum\n";
    ss << "\\note limit in degrees Celsius. The evaporative cooler will be turned off when its air inlet node\n";
    ss << "\\note drybulb temperature exceeds this limit. The typical maximum value is 26degC. Users\n";
    ss << "\\note are allowed to specify their own limits. If this field is left blank, then there is no upper\n";
    ss << "\\note temperature limit for evaporative cooler operation.\n";

    IddObjectType objType(IddObjectType::EvaporativeCooler_Direct_ResearchSpecial);
    OptionalIddObject oObj = IddObject::load("EvaporativeCooler:Direct:ResearchSpecial",
                                             "Evaporative Coolers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EvaporativeCooler_Direct_ResearchSpecial);
  return object;
}

IddObject createHumidifier_Steam_ElectricIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Humidifier:Steam:Electric,\n";
    ss << "\\memo Electrically heated steam humidifier with fan.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Rated Capacity\n";
    ss << "\\note Capacity is m3/s of water at 5.05 C\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\autosizable\n";
    ss << "N2, \\field Rated Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units W\n";
    ss << "\\autosizable\n";
    ss << "\\note if autosized the rated power is calculated from the rated capacity\n";
    ss << "\\note and enthalpy rise of water from 20.0C to 100.0C steam and assumes\n";
    ss << "\\note electric to thermal energy conversion efficiency of 100.0%\n";
    ss << "N3, \\field Rated Fan Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units W\n";
    ss << "N4, \\field Standby Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units W\n";
    ss << "A3, \\field Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A4, \\field Air Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A5; \\field Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";

    IddObjectType objType(IddObjectType::Humidifier_Steam_Electric);
    OptionalIddObject oObj = IddObject::load("Humidifier:Steam:Electric",
                                             "Humidifiers and Dehumidifiers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Humidifier_Steam_Electric);
  return object;
}

IddObject createHumidifier_Steam_GasIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Humidifier:Steam:Gas,\n";
    ss << "\\memo Natural gas fired steam humidifier with optional blower fan.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Rated Capacity\n";
    ss << "\\note Capacity is m3/s of water at 5.05 C\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\autosizable\n";
    ss << "\\note The nominal full capacity water addition rate in m3/s of water at 5.05 C\n";
    ss << "N2, \\field Rated Gas Use Rate\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units W\n";
    ss << "\\autosizable\n";
    ss << "\\note if auto-sized, the rated gas use rate is calculated from the rated\n";
    ss << "\\note capacity and enthalpy rise of water from 20.0C to 100.0C steam and user\n";
    ss << "\\note input thermal efficiency value specified in the next input field. If this\n";
    ss << "\\note input field is hard-sized and Inlet Water Temperature Option input field is\n";
    ss << "\\note selected as FixedInletWaterTemperature, then the thermal efficiency input\n";
    ss << "\\note field will not be used or else if the Inlet Water Temperature Option input\n";
    ss << "\\note field is selected as VariableInletWaterTemperature, then the thermal efficiency\n";
    ss << "\\note input value is overridden by a value calculated from the capacity, rated gas use\n";
    ss << "\\note rate and design condition.\n";
    ss << "N3, \\field Thermal Efficiency\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.80\n";
    ss << "\\note Based on the higher heating value of fuel.\n";
    ss << "\\note If \"Rated Gas Use Rate\" in the field above is not auto-sized and the Inlet Water\n";
    ss << "\\note Temperature Option input field is specified as FixedInletWaterTemperature, then the\n";
    ss << "\\note thermal efficiency specified will not be used in the calculation, or else if the\n";
    ss << "\\note Inlet Water Temperature Option input field is selected as VariableInletWaterTemperature,\n";
    ss << "\\note then the thermal efficiency value is overridden by a value calculated from the capacity,\n";
    ss << "\\note rated gas use rate and design condition.\n";
    ss << "A3, \\field Thermal Efficiency Modifier Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\note Linear, Quadratic and Cubic efficiency curves are solely a function of PLR.\n";
    ss << "\\note Linear = C1 + C2*PLR\n";
    ss << "\\note Quadratic = C1 + C2*PLR + C3*PLR^2\n";
    ss << "\\note Cubic = C1 + C2*PLR + C3*PLR^2 + C4*PLR^3\n";
    ss << "\\note This is thermal efficiency modifier curve name of gas fired steam humidifier.\n";
    ss << "\\note This curve is normalized, i.e., curve output value at rated condition is 1.0.\n";
    ss << "N4, \\field Rated Fan Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units W\n";
    ss << "\\note The nominal full capacity electric power input to the blower fan in Watts. If no\n";
    ss << "\\note blower fan is required to inject the dry steam to the supply air stream, then\n";
    ss << "\\note this input field is set to zero.\n";
    ss << "N5, \\field Auxiliary Electric Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units W\n";
    ss << "\\default 0.0\n";
    ss << "\\note The auxiliary electric power input in watts. This amount of power will be consumed\n";
    ss << "\\note whenever the unit is available (as defined by the availability schedule). This\n";
    ss << "\\note electric power is used for control purpose only.\n";
    ss << "A4, \\field Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A5, \\field Air Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A6, \\field Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A7; \\field Inlet Water Temperature Option\n";
    ss << "\\note The inlet water temperature can be fixed at 20C as it is done for electric steam\n";
    ss << "\\note humidifier or it can be allowed to vary with temperature of the water source.\n";
    ss << "\\note Currently allowed water sources are main water or water storage tank in water use objects.\n";
    ss << "\\note if FixedInletWaterTemperature is specified, then a fixed 20C water temperature will be\n";
    ss << "\\note used, or else if VariableInletWaterTemperature is specified, then inlet water will vary\n";
    ss << "\\note depending the source water temperature. If this input field is left blank, then fixed\n";
    ss << "\\note inlet water temperature of 20C will be assumed.\n";
    ss << "\\type choice\n";
    ss << "\\key FixedInletWaterTemperature\n";
    ss << "\\key VariableInletWaterTemperature\n";
    ss << "\\default FixedInletWaterTemperature\n";

    IddObjectType objType(IddObjectType::Humidifier_Steam_Gas);
    OptionalIddObject oObj = IddObject::load("Humidifier:Steam:Gas",
                                             "Humidifiers and Dehumidifiers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Humidifier_Steam_Gas);
  return object;
}

IddObject createDehumidifier_Desiccant_NoFansIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Dehumidifier:Desiccant:NoFans,\n";
    ss << "\\memo This object models a solid desiccant dehumidifier. The process\n";
    ss << "\\memo air stream is the air which is dehumidified. The regeneration air\n";
    ss << "\\memo stream is the air which is heated to regenerate the desiccant.\n";
    ss << "\\memo This object determines the process air outlet conditions, the\n";
    ss << "\\memo load on the regeneration heating coil, the electric power consumption\n";
    ss << "\\memo for the wheel rotor motor, and the regeneration air fan mass flow rate.\n";
    ss << "\\memo All other heat exchangers are modeled as separate objects connected\n";
    ss << "\\memo to the inlet and outlet nodes of the dehumidifier. The solid\n";
    ss << "\\memo desiccant dehumidifier is typically used in an AirLoopHVAC:OutdoorAirSystem,\n";
    ss << "\\memo but can also be specified in any AirLoopHVAC.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Process Air Inlet Node Name\n";
    ss << "\\note This is the node entering the process side of the desiccant wheel.\n";
    ss << "\\type node\n";
    ss << "A4, \\field Process Air Outlet Node Name\n";
    ss << "\\note This is the node leaving the process side of the desiccant wheel.\n";
    ss << "\\type node\n";
    ss << "A5, \\field Regeneration Air Inlet Node Name\n";
    ss << "\\note This is the node entering the regeneration side of the desiccant wheel\n";
    ss << "\\note after the regeneration coil.\n";
    ss << "\\type node\n";
    ss << "A6, \\field Regeneration Fan Inlet Node Name\n";
    ss << "\\note Node for air entering the regeneration fan, mass flow is set\n";
    ss << "\\note by the desiccant dehumidifier module.\n";
    ss << "\\type node\n";
    ss << "A7, \\field Control Type\n";
    ss << "\\note Type of setpoint control:\n";
    ss << "\\note LeavingMaximumHumidityRatioSetpoint means that the unit is controlled\n";
    ss << "\\note to deliver air at the Leaving Max Humidity Ratio Setpoint (see below),\n";
    ss << "\\note SystemNodeMaximumHumidityRatioSetpoint means that the leaving humidity\n";
    ss << "\\note ratio setpoint is the System Node Humidity Ratio Max property\n";
    ss << "\\note of the Process Air Outlet Node.  A Setpoint\n";
    ss << "\\note object must be used to control this setpoint.\n";
    ss << "\\note Both control types use bypass dampers to prevent over drying.\n";
    ss << "\\type choice\n";
    ss << "\\key LeavingMaximumHumidityRatioSetpoint\n";
    ss << "\\key SystemNodeMaximumHumidityRatioSetpoint\n";
    ss << "N1, \\field Leaving Maximum Humidity Ratio Setpoint\n";
    ss << "\\note Fixed setpoint for maximum process air leaving humidity ratio\n";
    ss << "\\note Applicable only when Control Type = LeavingMaximumHumidityRatioSetpoint.\n";
    ss << "\\type real\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "N2, \\field Nominal Process Air Flow Rate\n";
    ss << "\\note Process air flow rate at nominal conditions\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3, \\field Nominal Process Air Velocity\n";
    ss << "\\note Process air velocity at nominal flow\n";
    ss << "\\note When using Performance Model Type of Default, must be 2.032 to 4.064 m/s (400 to 800 fpm)\n";
    ss << "\\type real\n";
    ss << "\\units m/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 6\n";
    ss << "N4, \\field Rotor Power\n";
    ss << "\\note Power input to wheel rotor motor\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units W\n";
    ss << "A8, \\field Regeneration Coil Object Type\n";
    ss << "\\note heating coil type\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "\\note works with gas, electric, hot water and steam heating coils\n";
    ss << "A9, \\field Regeneration Coil Name\n";
    ss << "\\note Name of heating coil object for regeneration air\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "A10, \\field Regeneration Fan Object Type\n";
    ss << "\\note Type of fan object for regeneration air.  When using the Default\n";
    ss << "\\note Performance Model Type (see below), only Fan:VariableVolume is valid.\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:VariableVolume\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "A11, \\field Regeneration Fan Name\n";
    ss << "\\note Name of fan object for regeneration air\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandVAV\n";
    ss << "A12, \\field Performance Model Type\n";
    ss << "\\note Specifies whether the default performance model or user-specified\n";
    ss << "\\note curves should be used to model the performance.  The default model\n";
    ss << "\\note is a generic solid desiccant wheel using performance curves of the form:\n";
    ss << "\\note curve = C1 + C2*edb + C3*edb**2 + C4*ew + C5*ew**2 + C6*vel + C7*vel**2\n";
    ss << "\\note + C8*edb*ew + C9*edb**2*ew**2 + C10*edb*vel + C11*edb**2*vel**2\n";
    ss << "\\note + C12*ew*vel + C13*ew**2*vel**2 + C14*ALOG(edb) + C15*ALOG(ew) + C16*ALOG(vel)\n";
    ss << "\\note   edb = process entering dry-bulb temperature [C]\n";
    ss << "\\note   ew  = process entering humidity ratio [kgWater/kgDryAir]\n";
    ss << "\\note   vel = process air velocity [m/s]\n";
    ss << "\\note If UserCurves are specified, then performance is calculated as follows:\n";
    ss << "\\note   Leaving Dry-Bulb = (Leaving Dry-Bulb fTW Curve) * (Leaving Dry-Bulb fV Curve)\n";
    ss << "\\note   Leaving Humidity Ratio = (Leaving Humidity Ratio fTW Curve) * (Leaving Humidity Ratio fV Curve)\n";
    ss << "\\note   Regen Energy = (Regen Energy fTW Curve) * (Regen Energy fV Curve)\n";
    ss << "\\note   Regen Velocity = (Regen Velocity fTW Curve) * (Regen Velocity fV Curve)\n";
    ss << "\\type choice\n";
    ss << "\\key Default\n";
    ss << "\\key UserCurves\n";
    ss << "A13, \\field Leaving Dry-Bulb Function of Entering Dry-Bulb and Humidity Ratio Curve Name\n";
    ss << "\\note Leaving dry-bulb of process air as a function of entering dry-bulb\n";
    ss << "\\note and entering humidity ratio, biquadratic curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = C1 + C2*edb + C3*edb**2 + C4*ew + C5*ew**2 + C6*edb*ew\n";
    ss << "\\note edb = process entering dry-bulb temperature [C]\n";
    ss << "\\note ew  = process entering humidity ratio [kgWater/kgDryAir]\n";
    ss << "A14, \\field Leaving Dry-Bulb Function of Air Velocity Curve Name\n";
    ss << "\\note Leaving dry-bulb of process air as a function of air velocity,\n";
    ss << "\\note quadratic curve.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = C1 + C2*v + C3*v**2\n";
    ss << "\\note v = process air velocity [m/s]\n";
    ss << "A15, \\field Leaving Humidity Ratio Function of Entering Dry-Bulb and Humidity Ratio Curve Name\n";
    ss << "\\note Leaving humidity ratio of process air as a function of entering dry-bulb\n";
    ss << "\\note and entering humidity ratio, biquadratic curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = C1 + C2*edb + C3*edb**2 + C4*ew + C5*ew**2 + C6*edb*ew\n";
    ss << "\\note edb = process entering dry-bulb temperature [C]\n";
    ss << "\\note ew  = process entering humidity ratio [kgWater/kgDryAir]\n";
    ss << "A16, \\field Leaving Humidity Ratio Function of Air Velocity Curve Name\n";
    ss << "\\note Leaving humidity ratio of process air as a function of\n";
    ss << "\\note process air velocity, quadratic curve.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = C1 + C2*v + C3*v**2\n";
    ss << "\\note v = process air velocity [m/s]\n";
    ss << "A17, \\field Regeneration Energy Function of Entering Dry-Bulb and Humidity Ratio Curve Name\n";
    ss << "\\note Regeneration energy [J/kg of water removed] as a function of\n";
    ss << "\\note entering dry-bulb and entering humidity ratio, biquadratic curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = C1 + C2*edb + C3*edb**2 + C4*ew + C5*ew**2 + C6*edb*ew\n";
    ss << "\\note edb = process entering dry-bulb temperature [C]\n";
    ss << "\\note ew  = process entering humidity ratio [kgWater/kgDryAir]\n";
    ss << "A18, \\field Regeneration Energy Function of Air Velocity Curve Name\n";
    ss << "\\note Regeneration energy [J/kg of water removed] as a function of\n";
    ss << "\\note process air velocity, quadratic curve.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = C1 + C2*v + C3*v**2\n";
    ss << "\\note v = process air velocity [m/s]\n";
    ss << "A19, \\field Regeneration Velocity Function of Entering Dry-Bulb and Humidity Ratio Curve Name\n";
    ss << "\\note Regeneration velocity [m/s] as a function of\n";
    ss << "\\note entering dry-bulb and entering humidity ratio, biquadratic curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = C1 + C2*edb + C3*edb**2 + C4*ew + C5*ew**2 + C6*edb*ew\n";
    ss << "\\note edb = process entering dry-bulb temperature [C]\n";
    ss << "\\note ew  = process entering humidity ratio [kgWater/kgDryAir]\n";
    ss << "A20, \\field Regeneration Velocity Function of Air Velocity Curve Name\n";
    ss << "\\note Regeneration velocity [m/s] as a function of\n";
    ss << "\\note process air velocity, quadratic curve.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = C1 + C2*v + C3*v**2\n";
    ss << "\\note v = process air velocity [m/s]\n";
    ss << "N5; \\field Nominal Regeneration Temperature\n";
    ss << "\\note Nominal regen temperature upon which the regen energy modifier\n";
    ss << "\\note  curve is based.  Not used if Default if chosen for the field Performance Mode Type.\n";
    ss << "\\note 121 C is a commonly used value.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 40\n";
    ss << "\\maximum 250\n";

    IddObjectType objType(IddObjectType::Dehumidifier_Desiccant_NoFans);
    OptionalIddObject oObj = IddObject::load("Dehumidifier:Desiccant:NoFans",
                                             "Humidifiers and Dehumidifiers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Dehumidifier_Desiccant_NoFans);
  return object;
}

IddObject createDehumidifier_Desiccant_SystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Dehumidifier:Desiccant:System,\n";
    ss << "\\memo This compound object models a desiccant heat exchanger, an optional\n";
    ss << "\\memo heater, and associated fans. The process air stream is the air which\n";
    ss << "\\memo is dehumidified. The regeneration air stream is the air which is\n";
    ss << "\\memo heated to regenerate the desiccant. The desiccant heat exchanger\n";
    ss << "\\memo transfers both sensible and latent energy between the process and\n";
    ss << "\\memo regeneration air streams. The desiccant dehumidifier is typically used\n";
    ss << "\\memo in an AirLoopHVAC:OutdoorAirSystem, but can also be specified in any AirLoopHVAC.\n";
    ss << "\\min-fields 8\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3,  \\field Desiccant Heat Exchanger Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key HeatExchanger:Desiccant:BalancedFlow\n";
    ss << "A4,  \\field Desiccant Heat Exchanger Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HXDesiccantBalanced\n";
    ss << "A5,  \\field Sensor Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6,  \\field Regeneration Air Fan Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "A7,  \\field Regeneration Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansOnOffandVAV\n";
    ss << "A8,  \\field Regeneration Air Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default DrawThrough\n";
    ss << "A9,  \\field Regeneration Air Heater Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "\\note works with gas, electric, hot water and steam heating coils\n";
    ss << "A10, \\field Regeneration Air Heater Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N1,  \\field Regeneration Inlet Air Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "A11, \\field Companion Cooling Coil Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:DX:SingleSpeed\n";
    ss << "\\key Coil:Cooling:DX:TwoStageWithHumidityControlMode\n";
    ss << "A12, \\field Companion Cooling Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsDXMultiModeOrSingleSpeed\n";
    ss << "A13, \\field Companion Cooling Coil Upstream of Dehumidifier Process Inlet\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note Select Yes if the companion cooling coil is located directly upstream\n";
    ss << "\\note of the desiccant heat exchanger's process air inlet node.\n";
    ss << "A14, \\field Companion Coil Regeneration Air Heating\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N2,  \\field Exhaust Fan Maximum Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "N3,  \\field Exhaust Fan Maximum Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "A15; \\field Exhaust Fan Power Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\note Curve object type must be Curve:Quadratic or Curve:Cubic\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list CubicCurves\n";

    IddObjectType objType(IddObjectType::Dehumidifier_Desiccant_System);
    OptionalIddObject oObj = IddObject::load("Dehumidifier:Desiccant:System",
                                             "Humidifiers and Dehumidifiers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Dehumidifier_Desiccant_System);
  return object;
}

IddObject createHeatExchanger_AirToAir_FlatPlateIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HeatExchanger:AirToAir:FlatPlate,\n";
    ss << "\\memo Flat plate air-to-air heat exchanger, typically used for exhaust or relief air heat\n";
    ss << "\\memo recovery.\n";
    ss << "\\min-fields 15\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HXAirToAirNames\n";
    ss << "\\reference AFNHeatExchangerNames\n";
    ss << "A2, \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Flow Arrangement Type\n";
    ss << "\\type choice\n";
    ss << "\\key CounterFlow\n";
    ss << "\\key ParallelFlow\n";
    ss << "\\key CrossFlowBothUnmixed\n";
    ss << "A4, \\field Economizer Lockout\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "\\note Yes means that the heat exchanger will be locked out (off)\n";
    ss << "\\note when the economizer is operating or high humidity control is active\n";
    ss << "N1, \\field Ratio of Supply to Secondary hA Values\n";
    ss << "\\type real\n";
    ss << "\\note Ratio of h*A for supply side to h*A for exhaust side\n";
    ss << "\\minimum 0.0\n";
    ss << "N2, \\field Nominal Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\default Autosize\n";
    ss << "N3, \\field Nominal Supply Air Inlet Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N4, \\field Nominal Supply Air Outlet Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N5, \\field Nominal Secondary Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "N6, \\field Nominal Secondary Air Inlet Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N7, \\field Nominal Electric Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "A5, \\field Supply Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6, \\field Supply Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7, \\field Secondary Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A8; \\field Secondary Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::HeatExchanger_AirToAir_FlatPlate);
    OptionalIddObject oObj = IddObject::load("HeatExchanger:AirToAir:FlatPlate",
                                             "Heat Recovery",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HeatExchanger_AirToAir_FlatPlate);
  return object;
}

IddObject createHeatExchanger_AirToAir_SensibleAndLatentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HeatExchanger:AirToAir:SensibleAndLatent,\n";
    ss << "\\memo This object models an air-to-air heat exchanger using effectiveness relationships.\n";
    ss << "\\memo The heat exchanger can transfer sensible energy, latent energy, or both between the\n";
    ss << "\\memo supply (primary) and exhaust (secondary) air streams.\n";
    ss << "\\min-fields 19\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HXAirToAirNames\n";
    ss << "\\reference HXAirToAirSensibleAndLatentNames\n";
    ss << "\\reference AFNHeatExchangerNames\n";
    ss << "A2, \\field Availability Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Nominal Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "N2, \\field Sensible Effectiveness at 100% Heating Air Flow\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N3, \\field Latent Effectiveness at 100% Heating Air Flow\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N4, \\field Sensible Effectiveness at 75% Heating Air Flow\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N5, \\field Latent Effectiveness at 75% Heating Air Flow\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N6, \\field Sensible Effectiveness at 100% Cooling Air Flow\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N7, \\field Latent Effectiveness at 100% Cooling Air Flow\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N8, \\field Sensible Effectiveness at 75% Cooling Air Flow\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N9, \\field Latent Effectiveness at 75% Cooling Air Flow\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "A3, \\field Supply Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4, \\field Supply Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5, \\field Exhaust Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6, \\field Exhaust Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N10,\\field Nominal Electric Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "A7, \\field Supply Air Outlet Temperature Control\n";
    ss << "\\type choice\n";
    ss << "\\key No\n";
    ss << "\\key Yes\n";
    ss << "\\default No\n";
    ss << "A8, \\field Heat Exchanger Type\n";
    ss << "\\type choice\n";
    ss << "\\key Plate\n";
    ss << "\\key Rotary\n";
    ss << "\\default Plate\n";
    ss << "A9, \\field Frost Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key ExhaustAirRecirculation\n";
    ss << "\\key ExhaustOnly\n";
    ss << "\\key MinimumExhaustTemperature\n";
    ss << "\\default None\n";
    ss << "N11,\\field Threshold Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 1.7\n";
    ss << "\\note Supply (outdoor) air inlet temp threshold for exhaust air recirculation and\n";
    ss << "\\note exhaust only frost control types. Exhaust air outlet threshold Temperature for\n";
    ss << "\\note minimum exhaust temperature frost control type.\n";
    ss << "N12,\\field Initial Defrost Time Fraction\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.083\n";
    ss << "\\note Fraction of the time when frost control will be invoked at the threshold temperature.\n";
    ss << "\\note This field only used for exhaust air recirc and exhaust-only frost control types.\n";
    ss << "N13,\\field Rate of Defrost Time Fraction Increase\n";
    ss << "\\type real\n";
    ss << "\\units 1/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.012\n";
    ss << "\\note Rate of increase in defrost time fraction as actual temp falls below threshold temperature.\n";
    ss << "\\note This field only used for exhaust air recirc and exhaust-only frost control types.\n";
    ss << "A10;\\field Economizer Lockout\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "\\note Yes means that the heat exchanger will be locked out (off)\n";
    ss << "\\note when the economizer is operating or high humidity control is active\n";

    IddObjectType objType(IddObjectType::HeatExchanger_AirToAir_SensibleAndLatent);
    OptionalIddObject oObj = IddObject::load("HeatExchanger:AirToAir:SensibleAndLatent",
                                             "Heat Recovery",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HeatExchanger_AirToAir_SensibleAndLatent);
  return object;
}

IddObject createHeatExchanger_Desiccant_BalancedFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HeatExchanger:Desiccant:BalancedFlow,\n";
    ss << "\\memo This object models a balanced desiccant heat exchanger.\n";
    ss << "\\memo The heat exchanger transfers both sensible and latent energy between the\n";
    ss << "\\memo process and regeneration air streams. The air flow rate and face velocity\n";
    ss << "\\memo are assumed to be the same on both the process and regeneration sides of the\n";
    ss << "\\memo heat exchanger.\n";
    ss << "\\min-fields 8\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HXDesiccantBalanced\n";
    ss << "\\reference HXAirToAirNames\n";
    ss << "\\reference AFNHeatExchangerNames\n";
    ss << "A2, \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Regeneration Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4, \\field Regeneration Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5, \\field Process Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6, \\field Process Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7, \\field Heat Exchanger Performance Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key HeatExchanger:Desiccant:BalancedFlow:PerformanceDataType1\n";
    ss << "\\default HeatExchanger:Desiccant:BalancedFlow:PerformanceDataType1\n";
    ss << "A8, \\field Heat Exchanger Performance Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesiccantHXPerfData\n";
    ss << "A9; \\field Economizer Lockout\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note Yes means that the heat exchanger will be locked out (off)\n";
    ss << "\\note when the economizer is operating or high humidity control is active\n";

    IddObjectType objType(IddObjectType::HeatExchanger_Desiccant_BalancedFlow);
    OptionalIddObject oObj = IddObject::load("HeatExchanger:Desiccant:BalancedFlow",
                                             "Heat Recovery",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HeatExchanger_Desiccant_BalancedFlow);
  return object;
}

IddObject createHeatExchanger_Desiccant_BalancedFlow_PerformanceDataType1IddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HeatExchanger:Desiccant:BalancedFlow:PerformanceDataType1,\n";
    ss << "\\memo RTO = B1 + B2*RWI + B3*RTI + B4*(RWI/RTI) + B5*PWI + B6*PTI + B7*(PWI/PTI)\n";
    ss << "\\memo       + B8*RFV\n";
    ss << "\\memo RWO = C1 + C2*RWI + C3*RTI + C4*(RWI/RTI) + C5*PWI + C6*PTI + C7*(PWI/PTI)\n";
    ss << "\\memo       + C8*RFV\n";
    ss << "\\memo where,\n";
    ss << "\\memo RTO = Dry-bulb temperature of the regeneration outlet air (C)\n";
    ss << "\\memo RWO = Humidity ratio of the regeneration outlet air (kgWater/kgDryAir)\n";
    ss << "\\memo RWI = Humidity ratio of the regeneration inlet air (kgWater/kgDryAir)\n";
    ss << "\\memo RTI = Dry-bulb temperature of the regeneration inlet air (C)\n";
    ss << "\\memo PWI = Humidity ratio of the process inlet air (kgWater/kgDryAir)\n";
    ss << "\\memo PTI = Dry-bulb temperature of the process inlet air (C)\n";
    ss << "\\memo RFV = Regeneration Face Velocity (m/s)\n";
    ss << "\\min-fields 52\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference DesiccantHXPerfData\n";
    ss << "N1,  \\field Nominal Air Flow Rate\n";
    ss << "\\note Air flow rate at nominal conditions (assumed to be the same for both sides\n";
    ss << "\\note of the heat exchanger).\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Nominal Air Face Velocity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 6.0\n";
    ss << "\\autosizable\n";
    ss << "N3 , \\field Nominal Electric Power\n";
    ss << "\\note Parasitic electric power (e.g., desiccant wheel motor)\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N4 , \\field Temperature Equation Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N5 , \\field Temperature Equation Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N6 , \\field Temperature Equation Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N7 , \\field Temperature Equation Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N8 , \\field Temperature Equation Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N9 , \\field Temperature Equation Coefficient 6\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N10, \\field Temperature Equation Coefficient 7\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N11, \\field Temperature Equation Coefficient 8\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N12, \\field Minimum Regeneration Inlet Air Humidity Ratio for Temperature Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N13, \\field Maximum Regeneration Inlet Air Humidity Ratio for Temperature Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N14, \\field Minimum Regeneration Inlet Air Temperature for Temperature Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N15, \\field Maximum Regeneration Inlet Air Temperature for Temperature Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N16, \\field Minimum Process Inlet Air Humidity Ratio for Temperature Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N17, \\field Maximum Process Inlet Air Humidity Ratio for Temperature Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N18, \\field Minimum Process Inlet Air Temperature for Temperature Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N19, \\field Maximum Process Inlet Air Temperature for Temperature Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N20, \\field Minimum Regeneration Air Velocity for Temperature Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "N21, \\field Maximum Regeneration Air Velocity for Temperature Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "N22, \\field Minimum Regeneration Outlet Air Temperature for Temperature Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N23, \\field Maximum Regeneration Outlet Air Temperature for Temperature Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N24, \\field Minimum Regeneration Inlet Air Relative Humidity for Temperature Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "N25, \\field Maximum Regeneration Inlet Air Relative Humidity for Temperature Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "N26, \\field Minimum Process Inlet Air Relative Humidity for Temperature Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "N27, \\field Maximum Process Inlet Air Relative Humidity for Temperature Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "N28, \\field Humidity Ratio Equation Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N29, \\field Humidity Ratio Equation Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N30, \\field Humidity Ratio Equation Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N31, \\field Humidity Ratio Equation Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N32, \\field Humidity Ratio Equation Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N33, \\field Humidity Ratio Equation Coefficient 6\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N34, \\field Humidity Ratio Equation Coefficient 7\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N35, \\field Humidity Ratio Equation Coefficient 8\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N36, \\field Minimum Regeneration Inlet Air Humidity Ratio for Humidity Ratio Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N37, \\field Maximum Regeneration Inlet Air Humidity Ratio for Humidity Ratio Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N38, \\field Minimum Regeneration Inlet Air Temperature for Humidity Ratio Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N39, \\field Maximum Regeneration Inlet Air Temperature for Humidity Ratio Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N40, \\field Minimum Process Inlet Air Humidity Ratio for Humidity Ratio Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N41, \\field Maximum Process Inlet Air Humidity Ratio for Humidity Ratio Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N42, \\field Minimum Process Inlet Air Temperature for Humidity Ratio Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N43, \\field Maximum Process Inlet Air Temperature for Humidity Ratio Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N44, \\field Minimum Regeneration Air Velocity for Humidity Ratio Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "N45, \\field Maximum Regeneration Air Velocity for Humidity Ratio Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "N46, \\field Minimum Regeneration Outlet Air Humidity Ratio for Humidity Ratio Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N47, \\field Maximum Regeneration Outlet Air Humidity Ratio for Humidity Ratio Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N48, \\field Minimum Regeneration Inlet Air Relative Humidity for Humidity Ratio Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "N49, \\field Maximum Regeneration Inlet Air Relative Humidity for Humidity Ratio Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "N50, \\field Minimum Process Inlet Air Relative Humidity for Humidity Ratio Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "N51; \\field Maximum Process Inlet Air Relative Humidity for Humidity Ratio Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";

    IddObjectType objType(IddObjectType::HeatExchanger_Desiccant_BalancedFlow_PerformanceDataType1);
    OptionalIddObject oObj = IddObject::load("HeatExchanger:Desiccant:BalancedFlow:PerformanceDataType1",
                                             "Heat Recovery",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HeatExchanger_Desiccant_BalancedFlow_PerformanceDataType1);
  return object;
}

IddObject createAirLoopHVAC_UnitarySystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirLoopHVAC:UnitarySystem,\n";
    ss << "\\memo AirloopHVAC:UnitarySystem is a generic HVAC system type that allows any\n";
    ss << "\\memo configuration of coils and/or fan. This object is a replacement of other\n";
    ss << "\\memo AirloopHVAC objects. This object can be used in outdoor air systems,\n";
    ss << "\\memo outdoor air units, air loops, and as zone equipment if desired.\n";
    ss << "\\min-fields 14\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note Unique name for the Unitary System.\n";
    ss << "A2,  \\field Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Load\n";
    ss << "\\key SetPoint\n";
    ss << "\\default Load\n";
    ss << "\\note Load control requires a Controlling Zone name.\n";
    ss << "\\note SetPoint control requires set points at coil outlet node.\n";
    ss << "A3,  \\field Controlling Zone or Thermostat Location\n";
    ss << "\\note Used only for Load based control\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note Zone name where thermostat is located. Required when Control Type = Load.\n";
    ss << "A4,  \\field Dehumidification Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Multimode\n";
    ss << "\\key CoolReheat\n";
    ss << "\\default None\n";
    ss << "\\note None = meet sensible load only\n";
    ss << "\\note Multimode = activate enhanced dehumidification mode\n";
    ss << "\\note as needed and meet sensible load.  Valid only with\n";
    ss << "\\note cooling coil type Coil:Cooling:DX:TwoStageWithHumidityControlMode or CoilSystem:Cooling:DX:HeatExchangerAssisted.\n";
    ss << "\\note This control mode either switches the coil mode or allows the heat exchanger to be turned\n";
    ss << "\\note on and off based on the zone dehumidification requirements.\n";
    ss << "\\note A ZoneControl:Humidistat object is also required.\n";
    ss << "\\note CoolReheat = cool beyond the dry-bulb setpoint.\n";
    ss << "\\note as required to meet the humidity setpoint.  Valid with all\n";
    ss << "\\note cooling coil types. When a heat exchanger assisted cooling\n";
    ss << "\\note coil is used, the heat exchanger is locked on at all times.\n";
    ss << "\\note A ZoneControl:Humidistat object is also required.\n";
    ss << "A5,  \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\note A schedule value greater than zero (usually 1 is used) indicates that the unit is\n";
    ss << "\\note available to operate as needed. A value less than or equal to zero (usually zero\n";
    ss << "\\note is used) denotes that the unit must be off.\n";
    ss << "A6,  \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Enter the node name used as the inlet air node for the unitary system.\n";
    ss << "A7,  \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Enter the node name used as the outlet air node for the unitary system.\n";
    ss << "A8, \\field Supply Fan Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "\\key Fan:VariableVolume\n";
    ss << "\\key Fan:ComponentModel\n";
    ss << "\\note Enter the type of supply air fan if included in the unitary system.\n";
    ss << "\\note Fan:ConstantVolume only works with continuous fan operating mode (i.e. supply\n";
    ss << "\\note air fan operating mode schedule values greater than 0).\n";
    ss << "\\note Specify a Fan:OnOff object when the Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\note input field above is left blank.\n";
    ss << "\\note Specify a Fan:VariableVolume when modeling VAV systems which used setpoint based control\n";
    ss << "\\note if the fan is included in the unitary system object.\n";
    ss << "\\note The ComponentModel fan type may be substituted for the ConstantVolume or VariableVolume\n";
    ss << "\\note fan types when more detailed fan modeling is required.\n";
    ss << "\\note The variable or constant volume fan may be specified on the branch instead of contained\n";
    ss << "\\note within the unitary system object (i.e., this field may be blank for certain configurations).\n";
    ss << "A9, \\field Supply Fan Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Fans\n";
    ss << "\\note Enter the name of the supply air fan if included in the unitary system.\n";
    ss << "A10, \\field Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\note Enter the type of supply air fan if included in the unitary system.\n";
    ss << "A11, \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note A fan operating mode schedule value of 0 indicates cycling fan mode (supply air\n";
    ss << "\\note fan cycles on and off in tandem with the cooling or heating coil).\n";
    ss << "\\note Any other schedule value indicates continuous fan mode (supply air fan operates\n";
    ss << "\\note continuously regardless of cooling or heating coil operation). Provide a schedule\n";
    ss << "\\note with non-zero values when high humidity control is specified.\n";
    ss << "\\note Leaving this schedule name blank will default to constant fan mode for the\n";
    ss << "\\note entire simulation period.\n";
    ss << "\\note This field is not used when set point based control is used where a set point\n";
    ss << "\\note controls the coil (i.e., model assumes constant fan mode operation).\n";
    ss << "A12, \\field Heating Coil Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:DX:SingleSpeed\n";
    ss << "\\key Coil:Heating:DX:MultiSpeed\n";
    ss << "\\key Coil:Heating:DX:VariableSpeed\n";
    ss << "\\key Coil:Heating:WaterToAirHeatPump:ParameterEstimation\n";
    ss << "\\key Coil:Heating:WaterToAirHeatPump:EquationFit\n";
    ss << "\\key Coil:Heating:WaterToAirHeatPump:VariableSpeedEquationFit\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Gas:MultiStage\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Electric:MultiStage\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "\\key Coil:Heating:Desuperheater\n";
    ss << "\\key Coil:UserDefined\n";
    ss << "\\note Enter the type of heating coil if included in the unitary system.\n";
    ss << "A13, \\field Heating Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilsDX\n";
    ss << "\\object-list HeatingCoilsDXMultiSpeed\n";
    ss << "\\object-list HeatingCoilsDXVariableSpeed\n";
    ss << "\\object-list HeatingCoilsWaterToAirHP\n";
    ss << "\\object-list HeatingCoilsWaterToAirVSHP\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "\\object-list HeatingCoilsElectricMultiStage\n";
    ss << "\\object-list HeatingCoilsGasMultiStage\n";
    ss << "\\object-list HeatingCoilsDesuperheater\n";
    ss << "\\object-list UserDefinedCoil\n";
    ss << "\\note Enter the name of the heating coil if included in the unitary system.\n";
    ss << "N1 , \\field DX Heating Coil Sizing Ratio\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Used to adjust heat pump heating capacity with respect to DX cooling capacity\n";
    ss << "\\note used only for heat pump configurations (i.e., a DX cooling and DX heating coil is used).\n";
    ss << "A14, \\field Cooling Coil Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:DX:SingleSpeed\n";
    ss << "\\key Coil:Cooling:DX:TwoSpeed\n";
    ss << "\\key Coil:Cooling:DX:MultiSpeed\n";
    ss << "\\key Coil:Cooling:DX:VariableSpeed\n";
    ss << "\\key Coil:Cooling:DX:TwoStageWithHumidityControlMode\n";
    ss << "\\key Coil:Cooling:DX:SingleSpeed:ThermalStorage\n";
    ss << "\\key CoilSystem:Cooling:DX:HeatExchangerAssisted\n";
    ss << "\\key Coil:Cooling:WaterToAirHeatPump:ParameterEstimation\n";
    ss << "\\key Coil:Cooling:WaterToAirHeatPump:EquationFit\n";
    ss << "\\key Coil:Cooling:WaterToAirHeatPump:VariableSpeedEquationFit\n";
    ss << "\\key Coil:Cooling:Water\n";
    ss << "\\key Coil:Cooling:Water:DetailedGeometry\n";
    ss << "\\key CoilSystem:Cooling:Water:HeatExchangerAssisted\n";
    ss << "\\key Coil:UserDefined\n";
    ss << "\\note Enter the type of cooling coil if included in the unitary system.\n";
    ss << "A15, \\field Cooling Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsDX\n";
    ss << "\\object-list CoolingCoilsDXMultiSpeed\n";
    ss << "\\object-list CoolingCoilsDXVariableSpeed\n";
    ss << "\\object-list CoolingCoilsWaterToAirHP\n";
    ss << "\\object-list CoolingCoilsWaterToAirVSHP\n";
    ss << "\\object-list CoolingCoilsWater\n";
    ss << "\\object-list UserDefinedCoil\n";
    ss << "\\note Enter the name of the cooling coil if included in the unitary system.\n";
    ss << "A16, \\field Use DOAS DX Cooling Coil\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note If Yes, the DX cooling coil runs as 100% DOAS DX coil.\n";
    ss << "\\note If No, the DX cooling coil runs as a regular DX coil.\n";
    ss << "\\note If left blank the default is regular dx coil.\n";
    ss << "N2 , \\field DOAS DX Cooling Coil Leaving Minimum Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 7.2\n";
    ss << "\\default 2.0\n";
    ss << "\\note DX cooling coil leaving minimum air temperature defines the minimum DOAS DX cooling coil\n";
    ss << "\\note leaving air temperature that should be maintained to avoid frost formation. This input\n";
    ss << "\\note field is optional and only used along with the input field above.\n";
    ss << "A17, \\field Latent Load Control\n";
    ss << "\\type choice\n";
    ss << "\\key SensibleOnlyLoadControl\n";
    ss << "\\key LatentOnlyLoadControl\n";
    ss << "\\key LatentWithSensibleLoadControl\n";
    ss << "\\key LatentOrSensibleLoadControl\n";
    ss << "\\default SensibleOnlyLoadControl\n";
    ss << "\\note SensibleOnlyLoadControl is selected when thermostat control is used.\n";
    ss << "\\note LatentOnlyLoadControl is selected when humidistat control is used.\n";
    ss << "\\note LatentWithSensibleLoadControl is selected when thermostat control is used and\n";
    ss << "\\note dehumidification is required only when a sensible load exists.\n";
    ss << "\\note LatentOrSensibleLoadControl is selected when thermostat control is used and\n";
    ss << "\\note dehumidification is required any time the humidistat set point is exceeded.\n";
    ss << "A18, \\field Supplemental Heating Coil Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Desuperheater\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "\\key Coil:UserDefined\n";
    ss << "\\note Enter the type of supplemental heating coil if included in the unitary system.\n";
    ss << "\\note Only required if dehumidification control type is \"CoolReheat\".\n";
    ss << "A19, \\field Supplemental Heating Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "\\object-list HeatingCoilsDesuperheater\n";
    ss << "\\object-list UserDefinedCoil\n";
    ss << "\\note Enter the name of the supplemental heating coil if included in the unitary system.\n";
    ss << "\\note Only required if dehumidification control type is \"CoolReheat\".\n";
    ss << "A20, \\field Cooling Supply Air Flow Rate Method\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key SupplyAirFlowRate\n";
    ss << "\\key FlowPerFloorArea\n";
    ss << "\\key FractionOfAutosizedCoolingValue\n";
    ss << "\\key FlowPerCoolingCapacity\n";
    ss << "\\note Enter the method used to determine the cooling supply air volume flow rate.\n";
    ss << "\\note None is used when a cooling coil is not included in the unitary system or this field may be blank.\n";
    ss << "\\note SupplyAirFlowRate is selected when the magnitude of the supply air volume is used.\n";
    ss << "\\note FlowPerFloorArea is selected when the supply air volume flow rate is based on total floor area\n";
    ss << "\\note served by the unitary system.\n";
    ss << "\\note FractionOfAutosizedCoolingValue is selected when the supply air volume is a fraction of the\n";
    ss << "\\note value determined by the simulation.\n";
    ss << "\\note FlowPerCoolingCapacity is selected when the supply air volume is a fraction of the cooling\n";
    ss << "\\note capacity as determined by the simulation.\n";
    ss << "N3 , \\field Cooling Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Enter the magnitude of the supply air volume flow rate during cooling operation.\n";
    ss << "\\note Required field when Cooling Supply Air Flow Rate Method is SupplyAirFlowRate.\n";
    ss << "\\note This field may be blank if a cooling coil is not included in the unitary system.\n";
    ss << "N4 , \\field Cooling Supply Air Flow Rate Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate per total floor area fraction.\n";
    ss << "\\note Required field when Cooling Supply Air Flow Rate Method is FlowPerFloorArea.\n";
    ss << "\\note This field may be blank if a cooling coil is not included in the unitary system.\n";
    ss << "N5 , \\field Cooling Fraction of Autosized Cooling Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the cooling supply air flow rate.\n";
    ss << "\\note Required field when Cooling Supply Air Flow Rate Method is FractionOfAutosizedCoolingValue.\n";
    ss << "\\note This field may be blank if a cooling coil is not included in the unitary system.\n";
    ss << "N6 , \\field Cooling Supply Air Flow Rate Per Unit of Capacity\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the cooling capacity.\n";
    ss << "\\note Required field when Cooling Supply Air Flow Rate Method is FlowPerCoolingCapacity.\n";
    ss << "\\note This field may be blank if a cooling coil is not included in the unitary system.\n";
    ss << "A21, \\field Heating Supply Air Flow Rate Method\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key SupplyAirFlowRate\n";
    ss << "\\key FlowPerFloorArea\n";
    ss << "\\key FractionOfAutosizedHeatingValue\n";
    ss << "\\key FlowPerHeatingCapacity\n";
    ss << "\\note Enter the method used to determine the heating supply air volume flow rate.\n";
    ss << "\\note None is used when a heating coil is not included in the unitary system or this field may be blank.\n";
    ss << "\\note SupplyAirFlowRate is selected when the magnitude of the supply air volume is used.\n";
    ss << "\\note FlowPerFloorArea is selected when the supply air volume flow rate is based on total floor area\n";
    ss << "\\note served by the unitary system.\n";
    ss << "\\note FractionOfAutosizedHeatingValue is selected when the supply air volume is a fraction of the\n";
    ss << "\\note value determined by the simulation.\n";
    ss << "\\note FlowPerHeatingCapacity is selected when the supply air volume is a fraction of the heating\n";
    ss << "\\note capacity as determined by the simulation.\n";
    ss << "N7 , \\field Heating Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Enter the magnitude of the supply air volume flow rate during heating operation.\n";
    ss << "\\note Required field when Heating Supply Air Flow Rate Method is SupplyAirFlowRate.\n";
    ss << "\\note This field may be blank if a heating coil is not included in the unitary system.\n";
    ss << "N8 , \\field Heating Supply Air Flow Rate Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate per total floor area fraction.\n";
    ss << "\\note Required field when Heating Supply Air Flow Rate Method is FlowPerFloorArea.\n";
    ss << "\\note This field may be blank if a heating coil is not included in the unitary system.\n";
    ss << "N9 , \\field Heating Fraction of Autosized Heating Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the heating supply air flow rate.\n";
    ss << "\\note Required field when Heating Supply Air Flow Rate Method is FractionOfAutosizedHeatingValue.\n";
    ss << "\\note This field may be blank if a heating coil is not included in the unitary system.\n";
    ss << "N10, \\field Heating Supply Air Flow Rate Per Unit of Capacity\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the heating capacity.\n";
    ss << "\\note Required field when Heating Supply Air Flow Rate Method is FlowPerHeatingCapacity.\n";
    ss << "\\note This field may be blank if a heating coil is not included in the unitary system.\n";
    ss << "A22, \\field No Load Supply Air Flow Rate Method\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key SupplyAirFlowRate\n";
    ss << "\\key FlowPerFloorArea\n";
    ss << "\\key FractionOfAutosizedCoolingValue\n";
    ss << "\\key FractionOfAutosizedHeatingValue\n";
    ss << "\\key FlowPerCoolingCapacity\n";
    ss << "\\key FlowPerHeatingCapacity\n";
    ss << "\\note Enter the method used to determine the supply air volume flow rate when no cooling or heating is required.\n";
    ss << "\\note None is used when a cooling and heating coil is not included in the unitary system or this field may be blank.\n";
    ss << "\\note SupplyAirFlowRate is selected when the magnitude of the supply air volume is used.\n";
    ss << "\\note FlowPerFloorArea is selected when the supply air volume flow rate is based on total floor area\n";
    ss << "\\note served by the unitary system.\n";
    ss << "\\note FractionOfAutosizedCoolingValue is selected when the supply air volume is a fraction of the\n";
    ss << "\\note cooling value determined by the simulation.\n";
    ss << "\\note FractionOfAutosizedHeatingValue is selected when the supply air volume is a fraction of the\n";
    ss << "\\note heating value determined by the simulation.\n";
    ss << "\\note FlowPerCoolingCapacity is selected when the supply air volume is a fraction of the cooling\n";
    ss << "\\note capacity as determined by the simulation.\n";
    ss << "\\note FlowPerHeatingCapacity is selected when the supply air volume is a fraction of the heating\n";
    ss << "\\note capacity as determined by the simulation.\n";
    ss << "N11, \\field No Load Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Enter the magnitude of the supply air volume flow rate during when no cooling or heating is required.\n";
    ss << "\\note Required field when No Load Supply Air Flow Rate Method is SupplyAirFlowRate.\n";
    ss << "N12, \\field No Load Supply Air Flow Rate Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate per total floor area fraction.\n";
    ss << "\\note Required field when No Load Supply Air Flow Rate Method is FlowPerFloorArea.\n";
    ss << "N13, \\field No Load Fraction of Autosized Cooling Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the cooling supply air flow rate.\n";
    ss << "\\note Required field when No Load Supply Air Flow Rate Method is FractionOfAutosizedCoolingValue.\n";
    ss << "N14, \\field No Load Fraction of Autosized Heating Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the heating supply air flow rate.\n";
    ss << "\\note Required field when No Load Supply Air Flow Rate Method is FractionOfAutosizedHeatingValue.\n";
    ss << "N15, \\field No Load Supply Air Flow Rate Per Unit of Capacity During Cooling Operation\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the cooling capacity.\n";
    ss << "\\note Required field when No Load Supply Air Flow Rate Method is FlowPerCoolingCapacity.\n";
    ss << "N16, \\field No Load Supply Air Flow Rate Per Unit of Capacity During Heating Operation\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the heating capacity.\n";
    ss << "\\note Required field when No Load Supply Air Flow Rate Method is FlowPerHeatingCapacity.\n";
    ss << "N17, \\field Maximum Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "\\default 80.0\n";
    ss << "\\note Enter the maximum supply air temperature leaving the heating coil.\n";
    ss << "N18, \\field Maximum Outdoor Dry-Bulb Temperature for Supplemental Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 21.0\n";
    ss << "\\note Enter the maximum outdoor dry-bulb temperature for supplemental heater operation.\n";
    ss << "A23, \\field Outdoor Dry-Bulb Temperature Sensor Node Name\n";
    ss << "\\type node\n";
    ss << "\\note If this field is blank, outdoor temperature from the weather file is used.\n";
    ss << "\\note If this field is not blank, the node name specified determines the outdoor temperature used\n";
    ss << "\\note for controlling supplemental heater operation.\n";
    ss << "N19, \\field Maximum Cycling Rate\n";
    ss << "\\type real\n";
    ss << "\\units cycles/hr\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 5.0\n";
    ss << "\\default 2.5\n";
    ss << "\\note Used only for water source heat pump.\n";
    ss << "\\note The maximum on-off cycling rate for the compressor.\n";
    ss << "\\note Suggested value is 2.5 for a typical heat pump.\n";
    ss << "N20, \\field Heat Pump Time Constant\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 500.0\n";
    ss << "\\default 60.0\n";
    ss << "\\note Used only for water source heat pump.\n";
    ss << "\\note Time constant for the cooling coil's capacity to reach steady state after startup.\n";
    ss << "\\note Suggested value is 60 for a typical heat pump.\n";
    ss << "N21, \\field Fraction of On-Cycle Power Use\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.05\n";
    ss << "\\default 0.01\n";
    ss << "\\note Used only for water source heat pump.\n";
    ss << "\\note The fraction of on-cycle power use to adjust the part load fraction based on\n";
    ss << "\\note the off-cycle power consumption due to crankcase heaters, controls, fans, and etc.\n";
    ss << "\\note Suggested value is 0.01 for a typical heat pump.\n";
    ss << "N22, \\field Heat Pump Fan Delay Time\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 60\n";
    ss << "\\note Used only for water source heat pump.\n";
    ss << "\\note Programmed time delay for heat pump fan to shut off after compressor cycle off.\n";
    ss << "\\note Only required when fan operating mode is cycling.\n";
    ss << "\\note Enter 0 when fan operating mode is continuous.\n";
    ss << "N23, \\field Ancillary On-Cycle Electric Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note Enter the value of ancillary electric power for controls or other devices consumed during the on cycle.\n";
    ss << "N24, \\field Ancillary Off-Cycle Electric Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note Enter the value of ancillary electric power for controls or other devices consumed during the off cycle.\n";
    ss << "N25, \\field Design Heat Recovery Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note If non-zero, then the heat recovery inlet and outlet node names must be entered.\n";
    ss << "\\note Used for heat recovery to an EnergyPlus plant loop.\n";
    ss << "N26, \\field Maximum Temperature for Heat Recovery\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\maximum 100.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 80.0\n";
    ss << "\\note Enter the maximum heat recovery inlet temperature allowed for heat recovery.\n";
    ss << "A24, \\field Heat Recovery Water Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of the heat recovery water inlet node if plant water loop connections are present.\n";
    ss << "A25, \\field Heat Recovery Water Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of the heat recovery water outlet node if plant water loop connections are present.\n";
    ss << "A26, \\field Design Specification Multispeed Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key UnitarySystemPerformance:Multispeed\n";
    ss << "\\note Enter the type of performance specification object used to describe the multispeed coil.\n";
    ss << "A27; \\field Design Specification Multispeed Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UnitarySystemPerformaceNames\n";
    ss << "\\note Enter the name of the performance specification object used to describe the multispeed coil.\n";

    IddObjectType objType(IddObjectType::AirLoopHVAC_UnitarySystem);
    OptionalIddObject oObj = IddObject::load("AirLoopHVAC:UnitarySystem",
                                             "Unitary Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirLoopHVAC_UnitarySystem);
  return object;
}

IddObject createUnitarySystemPerformance_MultispeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "UnitarySystemPerformance:Multispeed,\n";
    ss << "\\memo The UnitarySystemPerformance object is used to specify the air flow ratio at each\n";
    ss << "\\memo operating speed. This object is primarily used for multispeed DX and water coils to allow\n";
    ss << "\\memo operation at alternate flow rates different from those specified in the coil object.\n";
    ss << "\\extensible:2 - repeat last two fields, remembering to remove ; from \"inner\" fields.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference UnitarySystemPerformaceNames\n";
    ss << "N1 , \\field Number of Speeds for Heating\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 10\n";
    ss << "\\note Used only for Multi speed coils\n";
    ss << "\\note Enter the number of the following sets of data for air flow rates.\n";
    ss << "N2 , \\field Number of Speeds for Cooling\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 10\n";
    ss << "\\note Used only for Multi speed coils\n";
    ss << "\\note Enter the number of the following sets of data for air flow rates.\n";
    ss << "A2 , \\field Single Mode Operation\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note Controls coil operation during each HVAC timestep.\n";
    ss << "\\note This choice does not apply to speed 1 operation.\n";
    ss << "\\note Yes = operate at the highest speed possible without exceeding the current load.\n";
    ss << "\\note No = allow operation at the average of two adjacent speeds to match the current load.\n";
    ss << "N3 , \\field Heating Speed 1 Supply Air Flow Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0\n";
    ss << "\\begin-extensible\n";
    ss << "\\note Used only for Multi speed coils\n";
    ss << "\\note Enter the lowest operating supply air flow ratio during heating\n";
    ss << "\\note operation or specify autosize. This value is the ratio of air flow\n";
    ss << "\\note at this speed to the maximum air flow rate.\n";
    ss << "N4 ; \\field Cooling Speed 1 Supply Air Flow Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Used only for Multi speed coils\n";
    ss << "\\note Enter the lowest operating supply air flow ratio during cooling\n";
    ss << "\\note operation or specify autosize. This value is the ratio of air flow\n";
    ss << "\\note at this speed to the maximum air flow rate.\n";

    IddObjectType objType(IddObjectType::UnitarySystemPerformance_Multispeed);
    OptionalIddObject oObj = IddObject::load("UnitarySystemPerformance:Multispeed",
                                             "Unitary Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::UnitarySystemPerformance_Multispeed);
  return object;
}

IddObject createAirLoopHVAC_Unitary_Furnace_HeatOnlyIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirLoopHVAC:Unitary:Furnace:HeatOnly,\n";
    ss << "\\memo Unitary system, heating-only with constant volume supply fan (continuous or cycling)\n";
    ss << "\\memo and heating coil (gas, electric, hot water, or steam). Identical to\n";
    ss << "\\memo AirLoopHVAC:UnitaryHeatOnly.\n";
    ss << "\\min-fields 13\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3,  \\field Furnace Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Furnace Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5,  \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note A fan operating mode schedule value of 0 indicates cycling fan mode (supply air\n";
    ss << "\\note fan cycles on and off in tandem with the heating coil).\n";
    ss << "\\note Any other schedule value indicates continuous fan mode (supply air fan operates\n";
    ss << "\\note continuously regardless of heating coil operation).\n";
    ss << "\\note Leaving this schedule name blank will default to cycling fan mode for the\n";
    ss << "\\note entire simulation period.\n";
    ss << "N1,  \\field Maximum Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "\\default 80.0\n";
    ss << "N2,  \\field Heating Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note  This value should be > 0 and <= than the fan air flow rate.\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "A6,  \\field Controlling Zone or Thermostat Location\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A7,  \\field Supply Fan Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "\\note Fan:ConstantVolume only works with continuous fan operating mode (i.e. fan\n";
    ss << "\\note operating mode schedule values are greater than 0).\n";
    ss << "A8,  \\field Supply Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOff\n";
    ss << "A9 , \\field Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default BlowThrough\n";
    ss << "A10, \\field Heating Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "\\note works with gas, electric, hot water and steam heating coils\n";
    ss << "A11; \\field Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";

    IddObjectType objType(IddObjectType::AirLoopHVAC_Unitary_Furnace_HeatOnly);
    OptionalIddObject oObj = IddObject::load("AirLoopHVAC:Unitary:Furnace:HeatOnly",
                                             "Unitary Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirLoopHVAC_Unitary_Furnace_HeatOnly);
  return object;
}

IddObject createAirLoopHVAC_Unitary_Furnace_HeatCoolIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirLoopHVAC:Unitary:Furnace:HeatCool,\n";
    ss << "\\memo Unitary system, heating and cooling with constant volume supply fan (continuous or\n";
    ss << "\\memo cycling), direct expansion (DX) cooling coil, heating coil (gas, electric,\n";
    ss << "\\memo hot water, or steam), and optional reheat coil for dehumidification control.\n";
    ss << "\\memo Identical to AirLoopHVAC:UnitaryHeatCool.\n";
    ss << "\\min-fields 17\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note A schedule value greater than zero (usually 1 is used) indicates that the unit is\n";
    ss << "\\note available to operate as needed. A value less than or equal to zero (usually zero\n";
    ss << "\\note is used) denotes that the unit must be off.\n";
    ss << "A3,  \\field Furnace Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Furnace Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5,  \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note A fan operating mode schedule value of 0 indicates cycling fan mode (supply air\n";
    ss << "\\note fan cycles on and off in tandem with the cooling or heating coil).\n";
    ss << "\\note Any other schedule value indicates continuous fan mode (supply air fan operates\n";
    ss << "\\note continuously regardless of cooling or heating coil operation). Provide a schedule\n";
    ss << "\\note with non-zero values when high humidity control is specified.\n";
    ss << "\\note Leaving this schedule name blank will default to cycling fan mode for the\n";
    ss << "\\note entire simulation period.\n";
    ss << "N1,  \\field Maximum Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "\\default 80.0\n";
    ss << "N2,  \\field Cooling Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to the fan's maximum flow rate.\n";
    ss << "N3,  \\field Heating Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to the fan's maximum flow fate.\n";
    ss << "N4,  \\field No Load Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to the fan's maximum flow rate.\n";
    ss << "\\note Only used when fan operating mode is continuous (disregarded for cycling fan mode).\n";
    ss << "\\note This air flow rate is used when no heating or cooling is required (i.e., the DX coil\n";
    ss << "\\note compressor and heating coil are off). If this field is left blank or zero, the supply\n";
    ss << "\\note air flow rate from the previous on cycle (either cooling or heating) is used.\n";
    ss << "A6,  \\field Controlling Zone or Thermostat Location\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A7,  \\field Supply Fan Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "\\note Fan:ConstantVolume only works with continuous fan operating mode (i.e. supply\n";
    ss << "\\note air fan operating mode schedule values not equal to 0).\n";
    ss << "A8,  \\field Supply Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOff\n";
    ss << "A9 , \\field Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default BlowThrough\n";
    ss << "A10, \\field Heating Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "\\note works with gas, electric, hot water and steam heating coils\n";
    ss << "A11, \\field Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "A12, \\field Cooling Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:DX:SingleSpeed\n";
    ss << "\\key Coil:Cooling:DX:VariableSpeed\n";
    ss << "\\key CoilSystem:Cooling:DX:HeatExchangerAssisted\n";
    ss << "\\note  Only works with DX cooling coil types or\n";
    ss << "\\note Coil:Cooling:DX:VariableSpeed.\n";
    ss << "A13, \\field Cooling Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsDXSingleSpeed\n";
    ss << "A14, \\field Dehumidification Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Multimode\n";
    ss << "\\key CoolReheat\n";
    ss << "\\default None\n";
    ss << "\\note None = meet sensible load only\n";
    ss << "\\note Multimode = activate enhanced dehumidification mode\n";
    ss << "\\note as needed and meet sensible load.  Valid only with\n";
    ss << "\\note cooling coil type CoilSystem:Cooling:DX:HeatExchangerAssisted.\n";
    ss << "\\note This control mode allows the heat exchanger to be turned\n";
    ss << "\\note on and off based on the zone dehumidification requirements.\n";
    ss << "\\note A ZoneControl:Humidistat object is also required.\n";
    ss << "\\note CoolReheat = cool beyond the dry-bulb setpoint.\n";
    ss << "\\note as required to meet the humidity setpoint.  Valid with all\n";
    ss << "\\note cooling coil types. When a heat exchanger assisted cooling\n";
    ss << "\\note coil is used, the heat exchanger is locked on at all times.\n";
    ss << "\\note A ZoneControl:Humidistat object is also required.\n";
    ss << "A15, \\field Reheat Coil Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Desuperheater\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "\\note Only required if dehumidification control type is \"CoolReheat\"\n";
    ss << "\\note works with gas, electric, hot water and steam heating coils\n";
    ss << "A16; \\field Reheat Coil Name\n";
    ss << "\\note Only required if dehumidification control type is \"CoolReheat\"\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";

    IddObjectType objType(IddObjectType::AirLoopHVAC_Unitary_Furnace_HeatCool);
    OptionalIddObject oObj = IddObject::load("AirLoopHVAC:Unitary:Furnace:HeatCool",
                                             "Unitary Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirLoopHVAC_Unitary_Furnace_HeatCool);
  return object;
}

IddObject createAirLoopHVAC_UnitaryHeatOnlyIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirLoopHVAC:UnitaryHeatOnly,\n";
    ss << "\\memo Unitary system, heating-only with constant volume supply fan (continuous or cycling)\n";
    ss << "\\memo and heating coil (gas, electric, hot water, or steam). Identical to\n";
    ss << "\\memo AirLoopHVAC:Unitary:Furnace:HeatOnly.\n";
    ss << "\\min-fields 13\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3,  \\field Unitary System Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Unitary System Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5,  \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note A fan operating mode schedule value of 0 indicates cycling fan mode (supply air\n";
    ss << "\\note fan cycles on and off in tandem with the heating coil).\n";
    ss << "\\note Any other schedule value indicates continuous fan mode (supply air fan operates\n";
    ss << "\\note continuously regardless of heating coil operation).\n";
    ss << "\\note Leaving this schedule name blank will default to cycling fan mode for the\n";
    ss << "\\note entire simulation period.\n";
    ss << "N1,  \\field Maximum Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "\\default 80.0\n";
    ss << "N2,  \\field Heating Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note  This value should be > 0 and <= than the fan air flow rate.\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "A6,  \\field Controlling Zone or Thermostat Location\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A7,  \\field Supply Fan Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "\\note Fan:ConstantVolume only works with continuous fan operating mode (i.e. fan\n";
    ss << "\\note operating mode schedule values are greater than 0).\n";
    ss << "A8,  \\field Supply Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOff\n";
    ss << "A9 , \\field Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default BlowThrough\n";
    ss << "A10, \\field Heating Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "\\note works with gas, electric, hot water and steam heating coils\n";
    ss << "A11; \\field Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";

    IddObjectType objType(IddObjectType::AirLoopHVAC_UnitaryHeatOnly);
    OptionalIddObject oObj = IddObject::load("AirLoopHVAC:UnitaryHeatOnly",
                                             "Unitary Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirLoopHVAC_UnitaryHeatOnly);
  return object;
}

IddObject createAirLoopHVAC_UnitaryHeatCoolIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirLoopHVAC:UnitaryHeatCool,\n";
    ss << "\\memo Unitary system, heating and cooling with constant volume supply fan (continuous or\n";
    ss << "\\memo cycling), direct expansion (DX) cooling coil, heating coil (gas, electric,\n";
    ss << "\\memo hot water, or steam), and optional reheat coil for dehumidification control.\n";
    ss << "\\memo Identical to AirLoopHVAC:Unitary:Furnace:HeatCool.\n";
    ss << "\\min-fields 17\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3,  \\field Unitary System Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Unitary System Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5,  \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note A fan operating mode schedule value of 0 indicates cycling fan mode (supply air\n";
    ss << "\\note fan cycles on and off in tandem with the cooling or heating coil).\n";
    ss << "\\note Any other schedule value indicates continuous fan mode (supply air fan operates\n";
    ss << "\\note continuously regardless of cooling or heating coil operation). Provide a schedule\n";
    ss << "\\note with non-zero values when high humidity control is specified.\n";
    ss << "\\note Leaving this schedule name blank will default to cycling fan mode for the\n";
    ss << "\\note entire simulation period.\n";
    ss << "N1,  \\field Maximum Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "\\default 80.0\n";
    ss << "N2,  \\field Cooling Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to the fan's maximum flow rate.\n";
    ss << "N3,  \\field Heating Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to the fan's maximum flow rate.\n";
    ss << "N4,  \\field No Load Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to the fan's maximum flow rate.\n";
    ss << "\\note Only used when fan operating mode is continuous (disregarded for cycling fan mode).\n";
    ss << "\\note This air flow rate is used when no heating or cooling is required (i.e., the DX coil\n";
    ss << "\\note compressor and heating coil are off). If this field is left blank or zero, the supply\n";
    ss << "\\note air flow rate from the previous on cycle (either cooling or heating) is used.\n";
    ss << "A6,  \\field Controlling Zone or Thermostat Location\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A7,  \\field Supply Fan Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "\\note Fan:ConstantVolume only works with continuous fan operating mode (i.e. supply\n";
    ss << "\\note air fan operating mode schedule values not equal to 0).\n";
    ss << "A8,  \\field Supply Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOff\n";
    ss << "A9 , \\field Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default BlowThrough\n";
    ss << "A10, \\field Heating Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "\\note works with gas, electric, hot water and steam heating coils\n";
    ss << "A11, \\field Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "A12, \\field Cooling Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:DX:SingleSpeed\n";
    ss << "\\key CoilSystem:Cooling:DX:HeatExchangerAssisted\n";
    ss << "\\note  Only works with DX cooling coil types\n";
    ss << "A13, \\field Cooling Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsDXSingleSpeed\n";
    ss << "\\object-list CoolingCoilsDXVariableSpeed\n";
    ss << "A14, \\field Dehumidification Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Multimode\n";
    ss << "\\key CoolReheat\n";
    ss << "\\default None\n";
    ss << "\\note None = meet sensible load only\n";
    ss << "\\note Multimode = activate enhanced dehumidification mode\n";
    ss << "\\note as needed and meet sensible load.  Valid only with\n";
    ss << "\\note cooling coil type CoilSystem:Cooling:DX:HeatExchangerAssisted.\n";
    ss << "\\note This control mode allows the heat exchanger to be turned\n";
    ss << "\\note on and off based on the zone dehumidification requirements.\n";
    ss << "\\note A ZoneControl:Humidistat object is also required.\n";
    ss << "\\note CoolReheat = cool beyond the dry-bulb setpoint.\n";
    ss << "\\note as required to meet the humidity setpoint.  Valid with all\n";
    ss << "\\note cooling coil types. When a heat exchanger assisted Cooling\n";
    ss << "\\note coil is used, the heat exchanger is locked on at all times.\n";
    ss << "\\note A ZoneControl:Humidistat object is also required.\n";
    ss << "A15, \\field Reheat Coil Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Desuperheater\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "\\note Only required if dehumidification control type is \"CoolReheat\"\n";
    ss << "\\note works with gas, electric, desuperheating, hot water and steam heating coils\n";
    ss << "A16; \\field Reheat Coil Name\n";
    ss << "\\note Only required if dehumidification control type is \"CoolReheat\"\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";

    IddObjectType objType(IddObjectType::AirLoopHVAC_UnitaryHeatCool);
    OptionalIddObject oObj = IddObject::load("AirLoopHVAC:UnitaryHeatCool",
                                             "Unitary Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirLoopHVAC_UnitaryHeatCool);
  return object;
}

IddObject createAirLoopHVAC_UnitaryHeatPump_AirToAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirLoopHVAC:UnitaryHeatPump:AirToAir,\n";
    ss << "\\memo Unitary heat pump system, heating and cooling, single-speed with supply fan, direct\n";
    ss << "\\memo expansion (DX) cooling coil, DX heating coil (air-to-air heat pump), and supplemental\n";
    ss << "\\memo heating coil (gas, electric, hot water, or steam).\n";
    ss << "\\min-fields 19\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note A schedule value greater than zero (usually 1 is used) indicates that the unit is\n";
    ss << "\\note available to operate as needed. A value less than or equal to zero (usually zero\n";
    ss << "\\note is used) denotes that the unit must be off.\n";
    ss << "A3,  \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,  \\field Cooling Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to the fan's maximum flow rate.\n";
    ss << "N2,  \\field Heating Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to the fan's maximum flow rate.\n";
    ss << "N3,  \\field No Load Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Must be less than or equal to the fan's maximum flow rate.\n";
    ss << "\\note Only used when fan operating mode is continuous (disregarded for cycling fan mode).\n";
    ss << "\\note This air flow rate is used when no heating or cooling is required (i.e., the DX coil\n";
    ss << "\\note compressor and supplemental heating coil are off). If this field is left blank or zero,\n";
    ss << "\\note the supply air flow rate from the previous on cycle (either cooling or heating) is used.\n";
    ss << "A5,  \\field Controlling Zone or Thermostat Location\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A6,  \\field Supply Air Fan Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "\\note Fan:ConstantVolume only works with continuous fan operating mode (i.e. fan\n";
    ss << "\\note operating mode schedule values are greater than 0 or the fan operating mode\n";
    ss << "\\note schedule name field is left blank).\n";
    ss << "A7,  \\field Supply Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOff\n";
    ss << "\\note  Needs to match in the fan object\n";
    ss << "A8,  \\field Heating Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:DX:SingleSpeed\n";
    ss << "\\key Coil:Heating:DX:VariableSpeed\n";
    ss << "\\note  Only works with Coil:Heating:DX:SingleSpeed or\n";
    ss << "\\note Coil:Heating:DX:VariableSpeed\n";
    ss << "A9,  \\field Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilsDXSingleSpeed\n";
    ss << "\\object-list HeatingCoilsDXVariableSpeed\n";
    ss << "\\note  Needs to match in the DX heating coil object\n";
    ss << "A10, \\field Cooling Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:DX:SingleSpeed\n";
    ss << "\\key Coil:Cooling:DX:VariableSpeed\n";
    ss << "\\key CoilSystem:Cooling:DX:HeatExchangerAssisted\n";
    ss << "\\note Only works with Coil:Cooling:DX:SingleSpeed or\n";
    ss << "\\note CoilSystem:Cooling:DX:HeatExchangerAssisted or\n";
    ss << "\\note Coil:Cooling:DX:VariableSpeed\n";
    ss << "A11, \\field Cooling Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\note Needs to match in the DX cooling coil object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsDXSingleSpeed\n";
    ss << "\\object-list CoolingCoilsDXVariableSpeed\n";
    ss << "A12, \\field Supplemental Heating Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "\\note works with gas, electric, hot water and steam heating coils\n";
    ss << "A13, \\field Supplemental Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "\\note  Needs to match in the supplemental heating coil object\n";
    ss << "N4 , \\field Maximum Supply Air Temperature from Supplemental Heater\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "N5 , \\field Maximum Outdoor Dry-Bulb Temperature for Supplemental Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\maximum 21.0\n";
    ss << "\\default 21.0\n";
    ss << "\\units C\n";
    ss << "A14, \\field Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default BlowThrough\n";
    ss << "A15, \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note A fan operating mode schedule value of 0 indicates cycling fan mode (supply air\n";
    ss << "\\note fan cycles on and off in tandem with the cooling or heating coil).\n";
    ss << "\\note Any other schedule value indicates continuous fan mode (supply air fan operates\n";
    ss << "\\note continuously regardless of cooling or heating coil operation).\n";
    ss << "\\note Leaving this schedule name blank will default to cycling fan mode for the\n";
    ss << "\\note entire simulation period.\n";
    ss << "A16; \\field Dehumidification Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Multimode\n";
    ss << "\\key CoolReheat\n";
    ss << "\\default None\n";
    ss << "\\note None = meet sensible load only\n";
    ss << "\\note Multimode = activate enhanced dehumidification mode\n";
    ss << "\\note as needed and meet sensible load.  Valid only with\n";
    ss << "\\note cooling coil type CoilSystem:Cooling:DX:HeatExchangerAssisted.\n";
    ss << "\\note This control mode allows the heat exchanger to be turned\n";
    ss << "\\note on and off based on the zone dehumidification requirements.\n";
    ss << "\\note A ZoneControl:Humidistat object is also required.\n";
    ss << "\\note CoolReheat = cool beyond the dry-bulb setpoint.\n";
    ss << "\\note as required to meet the humidity setpoint.  Valid with all\n";
    ss << "\\note cooling coil types. When a heat exchanger assisted Cooling\n";
    ss << "\\note coil is used, the heat exchanger is locked on at all times.\n";
    ss << "\\note A ZoneControl:Humidistat object is also required.\n";

    IddObjectType objType(IddObjectType::AirLoopHVAC_UnitaryHeatPump_AirToAir);
    OptionalIddObject oObj = IddObject::load("AirLoopHVAC:UnitaryHeatPump:AirToAir",
                                             "Unitary Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirLoopHVAC_UnitaryHeatPump_AirToAir);
  return object;
}

IddObject createAirLoopHVAC_UnitaryHeatPump_WaterToAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirLoopHVAC:UnitaryHeatPump:WaterToAir,\n";
    ss << "\\memo Unitary heat pump system, heating and cooling, single-speed with constant volume\n";
    ss << "\\memo supply fan (continuous or cycling), direct expansion (DX) cooling coil, DX heating\n";
    ss << "\\memo coil (water-to-air heat pump), and supplemental heating coil (gas, electric,\n";
    ss << "\\memo hot water, or steam).\n";
    ss << "\\min-fields 25\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3,  \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,  \\field Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note  This value should be > 0 and <= than the fan air flow rate.\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "A5,  \\field Controlling Zone or Thermostat Location\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A6,  \\field Supply Air Fan Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\note  Only works with On/Off Fan\n";
    ss << "A7,  \\field Supply Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansOnOff\n";
    ss << "\\note Needs to match Fan:OnOff object\n";
    ss << "A8,  \\field Heating Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:WaterToAirHeatPump:ParameterEstimation\n";
    ss << "\\key Coil:Heating:WaterToAirHeatPump:EquationFit\n";
    ss << "\\key Coil:Heating:WaterToAirHeatPump:VariableSpeedEquationFit\n";
    ss << "A9,  \\field Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilsWaterToAirHP\n";
    ss << "\\object-list HeatingCoilsWaterToAirVSHP\n";
    ss << "\\note  Needs to match in the water-to-air heat pump heating coil object\n";
    ss << "N2,  \\field Heating Convergence\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "A10, \\field Cooling Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:WaterToAirHeatPump:ParameterEstimation\n";
    ss << "\\key Coil:Cooling:WaterToAirHeatPump:EquationFit\n";
    ss << "\\key Coil:Cooling:WaterToAirHeatPump:VariableSpeedEquationFit\n";
    ss << "A11, \\field Cooling Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsWaterToAirHP\n";
    ss << "\\object-list CoolingCoilsWaterToAirVSHP\n";
    ss << "\\note Needs to match in the water-to-air heat pump cooling coil object\n";
    ss << "N3,  \\field Cooling Convergence\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "N4,  \\field Maximum Cycling Rate\n";
    ss << "\\type real\n";
    ss << "\\units cycles/hr\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 5.0\n";
    ss << "\\default 2.5\n";
    ss << "\\note The maximum on-off cycling rate for the compressor\n";
    ss << "\\note Suggested value is 2.5 for a typical heat pump\n";
    ss << "N5,  \\field Heat Pump Time Constant\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 500.0\n";
    ss << "\\default 60.0\n";
    ss << "\\note Time constant for the cooling coil's capacity to reach steady state after startup\n";
    ss << "\\note Suggested value is 60 for a typical heat pump\n";
    ss << "N6,  \\field Fraction of On-Cycle Power Use\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.05\n";
    ss << "\\default 0.01\n";
    ss << "\\note The fraction of on-cycle power use to adjust the part load fraction based on\n";
    ss << "\\note the off-cycle power consumption due to crankcase heaters, controls, fans, and etc.\n";
    ss << "\\note Suggested value is 0.01 for a typical heat pump\n";
    ss << "N7,  \\field Heat Pump Fan Delay Time\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 60\n";
    ss << "\\note Programmed time delay for heat pump fan to shut off after compressor cycle off.\n";
    ss << "\\note Only required when fan operating mode is cycling\n";
    ss << "\\note Enter 0 when fan operating mode is continuous\n";
    ss << "A12, \\field Supplemental Heating Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "\\note works with gas, electric, hot water and steam heating coils\n";
    ss << "A13, \\field Supplemental Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "\\note  Needs to match in the supplemental heating coil object\n";
    ss << "N8,  \\field Maximum Supply Air Temperature from Supplemental Heater\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "N9, \\field Maximum Outdoor Dry-Bulb Temperature for Supplemental Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\maximum 21.0\n";
    ss << "\\default 21.0\n";
    ss << "\\units C\n";
    ss << "A14, \\field Outdoor Dry-Bulb Temperature Sensor Node Name\n";
    ss << "\\type node\n";
    ss << "A15, \\field Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default BlowThrough\n";
    ss << "A16, \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Enter the name of a schedule that controls fan operation. Schedule values of 0 denote\n";
    ss << "\\note cycling fan operation (fan cycles with cooling or heating coil). Schedule values greater\n";
    ss << "\\note than 0 denote constant fan operation (fan runs continually regardless of coil operation).\n";
    ss << "\\note The fan operating mode defaults to cycling fan operation if this field is left blank.\n";
    ss << "A17, \\field Dehumidification Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key CoolReheat\n";
    ss << "\\default None\n";
    ss << "\\note None = meet sensible load only\n";
    ss << "\\note CoolReheat = cool beyond the dry-bulb setpoint.\n";
    ss << "\\note as required to meet the humidity setpoint.  Valid only with\n";
    ss << "\\note Coil:Cooling:WaterToAirHeatPump:EquationFit or\n";
    ss << "\\note Coil:Cooling:WaterToAirHeatPump:VariableSpeedEquationFit\n";
    ss << "A18; \\field Heat Pump Coil Water Flow Mode\n";
    ss << "\\type choice\n";
    ss << "\\key Constant\n";
    ss << "\\key Cycling\n";
    ss << "\\key ConstantOnDemand\n";
    ss << "\\default Cycling\n";
    ss << "\\note used only when the heat pump coils are of the type WaterToAirHeatPump:EquationFit\n";
    ss << "\\note Constant results in 100% water flow regardless of compressor PLR\n";
    ss << "\\note Cycling results in water flow that matches compressor PLR\n";
    ss << "\\note ConstantOnDemand results in 100% water flow whenever the coil is on, but is 0% whenever the coil has no load\n";

    IddObjectType objType(IddObjectType::AirLoopHVAC_UnitaryHeatPump_WaterToAir);
    OptionalIddObject oObj = IddObject::load("AirLoopHVAC:UnitaryHeatPump:WaterToAir",
                                             "Unitary Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirLoopHVAC_UnitaryHeatPump_WaterToAir);
  return object;
}

IddObject createAirLoopHVAC_UnitaryHeatCool_VAVChangeoverBypassIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirLoopHVAC:UnitaryHeatCool:VAVChangeoverBypass,\n";
    ss << "\\memo Unitary system, heating and cooling with constant volume supply fan (continuous or\n";
    ss << "\\memo cycling), direct expansion (DX) cooling coil, heating coil (gas, electric,\n";
    ss << "\\memo hot water, steam, or DX air-to-air heat pump) and bypass damper for variable volume\n";
    ss << "\\memo flow to terminal units. Used with AirTerminal:SingleDuct:VAV:HeatAndCool:Reheat\n";
    ss << "\\memo or AirTerminal:SingleDuct:VAV:HeatAndCool:NoReheat.\n";
    ss << "\\min-fields 23\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note Enter a unique name for this unitary system.\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Enter the availability schedule name. Schedule values of zero denote system\n";
    ss << "\\note is Off. Non-zero schedule values denote system is available to operate.\n";
    ss << "N1 , \\field Cooling Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Enter the system air flow rate during cooling\n";
    ss << "\\note operation or specify autosize.\n";
    ss << "N2 , \\field Heating Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Enter the system air flow rate during heating\n";
    ss << "\\note operation or specify autosize.\n";
    ss << "N3 , \\field No Load Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Only used when the supply air fan operating mode is continuous (see field\n";
    ss << "\\note Supply air fan operating mode schedule name). This system air flow rate\n";
    ss << "\\note is used when no heating or cooling is required and the coils are off.\n";
    ss << "\\note If this field is left blank or zero, the system air flow rate from the\n";
    ss << "\\note previous on cycle (either cooling or heating) is used.\n";
    ss << "N4 , \\field Cooling Outdoor Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the outdoor air flow rate during\n";
    ss << "\\note cooling operation or specify autosize.\n";
    ss << "N5 , \\field Heating Outdoor Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the outdoor air flow rate during\n";
    ss << "\\note heating operation or specify autosize.\n";
    ss << "N6 , \\field No Load Outdoor Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Only used when the supply air fan operating mode is continuous (see field\n";
    ss << "\\note Supply air fan operating mode schedule name). This outdoor air flow rate\n";
    ss << "\\note is used when no heating or cooling is required and the coils are off.\n";
    ss << "\\note If this field is left blank or zero, the outdoor air flow rate from the previous on cycle\n";
    ss << "\\note (either cooling or heating) is used.\n";
    ss << "A3 , \\field Outdoor Air Flow Rate Multiplier Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Enter the name of a schedule that contains multipliers for the outdoor air\n";
    ss << "\\note flow rates. Schedule values must be from 0 to 1.\n";
    ss << "\\note If field is left blank, model assumes multiplier is 1 for the entire simulation period.\n";
    ss << "A4 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of the unitary system's air inlet node.\n";
    ss << "A5 , \\field Bypass Duct Mixer Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of the bypass duct mixer node. This name should be the name\n";
    ss << "\\note of the return air node for the outdoor air mixer associated with this system.\n";
    ss << "\\note This node name must be different from the air inlet node name.\n";
    ss << "A6 , \\field Bypass Duct Splitter Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of the bypass duct splitter node.\n";
    ss << "\\note This splitter air node is the outlet node of the last component in this unitary\n";
    ss << "\\note system. For blow through fan placement, the splitter air node is the outlet\n";
    ss << "\\note node of the heating coil. For draw through fan placement, the splitter node\n";
    ss << "\\note is the outlet node of the supply air fan.\n";
    ss << "A7 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of the unitary system's air outlet node.\n";
    ss << "A8,  \\field Outdoor Air Mixer Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key OutdoorAir:Mixer\n";
    ss << "\\note currently only one type OutdoorAir:Mixer object is available.\n";
    ss << "A9 , \\field Outdoor Air Mixer Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutdoorAirMixers\n";
    ss << "\\note Enter the name of the outdoor air mixer used with this unitary system.\n";
    ss << "A10, \\field Supply Air Fan Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "\\note Specify the type of supply air fan used in this unitary system.\n";
    ss << "A11, \\field Supply Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOff\n";
    ss << "\\note Enter the name of the supply air fan used in this unitary system.\n";
    ss << "A12, \\field Supply Air Fan Placement\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\note Specify supply air fan placement as either blow through or draw through.\n";
    ss << "\\note BlowThrough means the supply air fan is located before the cooling\n";
    ss << "\\note coil. DrawThrough means the supply air fan is located after the heating coil.\n";
    ss << "A13, \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Enter the name of a schedule to control the supply air fan. Schedule Name values of zero\n";
    ss << "\\note mean that the supply air fan will cycle off if there is no cooling or heating load\n";
    ss << "\\note in any of the zones being served by this system. Non-zero schedule values mean\n";
    ss << "\\note that the supply air fan will operate continuously even if there is no cooling or\n";
    ss << "\\note heating load in any of the zones being served. If this field is left blank,\n";
    ss << "\\note the supply air fan will operate continuously for the entire simulation period.\n";
    ss << "A14, \\field Cooling Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:DX:SingleSpeed\n";
    ss << "\\key CoilSystem:Cooling:DX:HeatExchangerAssisted\n";
    ss << "\\key Coil:Cooling:DX:TwoStageWithHumidityControlMode\n";
    ss << "\\note Specify the type of cooling coil used in this unitary system.\n";
    ss << "A15, \\field Cooling Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsDXMultiModeOrSingleSpeed\n";
    ss << "\\note Enter the name of the cooling coil used in this unitary system.\n";
    ss << "A16, \\field Heating Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:DX:SingleSpeed\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "\\note works with DX, gas, electric, hot water and steam heating coils\n";
    ss << "\\note Specify the type of heating coil used in this unitary system.\n";
    ss << "A17, \\field Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "\\note Enter the name of the heating coil used in this unitary system.\n";
    ss << "A18, \\field Priority Control Mode\n";
    ss << "\\type choice\n";
    ss << "\\key CoolingPriority\n";
    ss << "\\key HeatingPriority\n";
    ss << "\\key ZonePriority\n";
    ss << "\\default ZonePriority\n";
    ss << "\\note CoolingPriority = system provides cooling if any zone requires cooling.\n";
    ss << "\\note HeatingPriority = system provides heating if any zone requires heating.\n";
    ss << "\\note ZonePriority = system controlled based on the total number of zones\n";
    ss << "\\note requiring cooling or heating (highest number of zones\n";
    ss << "\\note in cooling or heating determines the system's operating mode).\n";
    ss << "N7 , \\field Minimum Outlet Air Temperature During Cooling Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 8.0\n";
    ss << "\\note Specify the minimum outlet air temperature allowed for this unitary system\n";
    ss << "\\note during cooling operation. This value should be less than the maximum outlet\n";
    ss << "\\note air temperature during heating operation.\n";
    ss << "N8 , \\field Maximum Outlet Air Temperature During Heating Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 50.0\n";
    ss << "\\note Specify the maximum outlet air temperature allowed for this unitary system\n";
    ss << "\\note during heating operation. This value should be greater than the minimum outlet\n";
    ss << "\\note air temperature during cooling operation.\n";
    ss << "A19; \\field Dehumidification Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Multimode\n";
    ss << "\\key CoolReheat\n";
    ss << "\\default None\n";
    ss << "\\note None = meet sensible load only.\n";
    ss << "\\note Multimode = activate enhanced dehumidification mode\n";
    ss << "\\note as needed and meet sensible load.  Valid only with\n";
    ss << "\\note Coil:Cooling:DX:TwoStageWithHumidityControlMode.\n";
    ss << "\\note CoolReheat = cool beyond the Dry-Bulb temperature setpoint\n";
    ss << "\\note as required to meet the humidity setpoint.  Valid only with\n";
    ss << "\\note Coil:Cooling:DX:TwoStageWithHumidityControlMode.\n";
    ss << "\\note For all dehumidification controls, the max humidity setpoint\n";
    ss << "\\note on this unitary system's air outlet node is used.\n";
    ss << "\\note This must be set using ZoneControl:Humidistat and\n";
    ss << "\\note SetpointManager:SingleZone:Humidity:Maximum,\n";
    ss << "\\note SetpointManager:MultiZone:Humidity:Maximum or\n";
    ss << "\\note SetpointManager:MultiZone:MaximumHumidity:Average objects.\n";

    IddObjectType objType(IddObjectType::AirLoopHVAC_UnitaryHeatCool_VAVChangeoverBypass);
    OptionalIddObject oObj = IddObject::load("AirLoopHVAC:UnitaryHeatCool:VAVChangeoverBypass",
                                             "Unitary Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirLoopHVAC_UnitaryHeatCool_VAVChangeoverBypass);
  return object;
}

IddObject createAirLoopHVAC_UnitaryHeatPump_AirToAir_MultiSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirLoopHVAC:UnitaryHeatPump:AirToAir:MultiSpeed,\n";
    ss << "\\memo Unitary system, heating and cooling, multi-speed with constant volume supply fan\n";
    ss << "\\memo (continuous or cycling), direct expansion (DX) cooling coil, heating coil\n";
    ss << "\\memo (DX air-to-air heat pump, gas, electric, hot water, or steam), and supplemental\n";
    ss << "\\memo heating coil (gas, electric, hot water, or steam).\n";
    ss << "\\min-fields 31\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3,  \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5,  \\field Controlling Zone or Thermostat Location\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A6,  \\field Supply Air Fan Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "\\note Select the type of supply air fan used in this unitary system.\n";
    ss << "A7,  \\field Supply Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOff\n";
    ss << "\\note Enter the name of the supply air fan used in this unitary system.\n";
    ss << "A8,  \\field Supply Air Fan Placement\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\note Select supply air fan placement as either BlowThrough or DrawThrough.\n";
    ss << "\\note BlowThrough means the supply air fan is located before the cooling\n";
    ss << "\\note coil. DrawThrough means the supply air fan is located after the heating coil\n";
    ss << "\\note but before the optional supplemental heating coil.\n";
    ss << "A9 , \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Enter the name of a schedule to control the supply air fan. Schedule values of zero\n";
    ss << "\\note mean that the supply air fan will cycle off if there is no cooling or heating load\n";
    ss << "\\note in the control zone. Non-zero schedule values mean that the supply air fan\n";
    ss << "\\note will operate continuously even if there is no cooling or heating load\n";
    ss << "\\note in the control zone. If this field is left blank, the supply air fan will\n";
    ss << "\\note operate continuously for the entire simulation period.\n";
    ss << "A10, \\field Heating Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:DX:MultiSpeed\n";
    ss << "\\key Coil:Heating:Electric:MultiStage\n";
    ss << "\\key Coil:Heating:Gas:MultiStage\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "\\note Multi Speed DX, Electric, Gas, and Single speed Water and Steam coils\n";
    ss << "A11, \\field Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilsDXMultiSpeed\n";
    ss << "\\object-list HeatingCoilsElectricMultiStage\n";
    ss << "\\object-list HeatingCoilsGasMultiStage\n";
    ss << "N1 , \\field Minimum Outdoor Dry-Bulb Temperature for Compressor Operation\n";
    ss << "\\type real\n";
    ss << "\\default -8.0\n";
    ss << "\\units C\n";
    ss << "\\note Needs to match the corresponding minimum outdoor temperature defined\n";
    ss << "\\note in the DX heating coil object.\n";
    ss << "A12, \\field Cooling Coil Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Cooling:DX:MultiSpeed\n";
    ss << "\\note Only works with Coil:Cooling:DX:MultiSpeed\n";
    ss << "A13, \\field Cooling Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\note Needs to match in the DX Cooling Coil object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsDXMultiSpeed\n";
    ss << "A14, \\field Supplemental Heating Coil Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Coil:Heating:Electric\n";
    ss << "\\key Coil:Heating:Water\n";
    ss << "\\key Coil:Heating:Steam\n";
    ss << "\\note works with gas, electric, hot water and steam heating coils\n";
    ss << "A15, \\field Supplemental Heating Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "\\note Needs to match in the supplemental heating coil object\n";
    ss << "N2 , \\field Maximum Supply Air Temperature from Supplemental Heater\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "N3 , \\field Maximum Outdoor Dry-Bulb Temperature for Supplemental Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\maximum 21.0\n";
    ss << "\\default 21.0\n";
    ss << "\\units C\n";
    ss << "N4 , \\field Auxiliary On-Cycle Electric Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N5 , \\field Auxiliary Off-Cycle Electric Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N6 , \\field Design Heat Recovery Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\note If non-zero, then the heat recovery inlet and outlet node names must be entered.\n";
    ss << "\\note Used for heat recovery to an EnergyPlus plant loop.\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N7,  \\field Maximum Temperature for Heat Recovery\n";
    ss << "\\units C\n";
    ss << "\\maximum 100.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 80.0\n";
    ss << "A16, \\field Heat Recovery Water Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A17, \\field Heat Recovery Water Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N8 , \\field No Load Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\note Only used when the supply air fan operating mode is continuous (see field\n";
    ss << "\\note Supply Air Fan Operating Mode Schedule Name). This air flow rate\n";
    ss << "\\note is used when no heating or cooling is required and the coils are off.\n";
    ss << "\\note If this field is left blank or zero, the supply air flow rate from the\n";
    ss << "\\note previous on cycle (either cooling or heating) is used.\n";
    ss << "N9, \\field Number of Speeds for Heating\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 4\n";
    ss << "\\note Enter the number of the following sets of data for air flow rates.\n";
    ss << "\\note If Heating Coil Object Type is Coil:Heating:Water or Coil:Heating:Steam,\n";
    ss << "\\note this field should be 1.\n";
    ss << "N10, \\field Number of Speeds for Cooling\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 2\n";
    ss << "\\maximum 4\n";
    ss << "\\note Enter the number of the following sets of data for air flow rates.\n";
    ss << "N11, \\field Heating Speed 1 Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the operating supply air flow rate during heating\n";
    ss << "\\note operation or specify autosize.\n";
    ss << "N12, \\field Heating Speed 2 Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the operating supply air flow rate during heating\n";
    ss << "\\note operation or specify autosize.\n";
    ss << "N13, \\field Heating Speed 3 Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the operating supply air flow rate during heating\n";
    ss << "\\note operation or specify autosize.\n";
    ss << "N14, \\field Heating Speed 4 Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the operating supply air flow rate during heating\n";
    ss << "\\note operation or specify autosize.\n";
    ss << "N15, \\field Cooling Speed 1 Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the operating supply air flow rate during cooling\n";
    ss << "\\note operation or specify autosize.\n";
    ss << "N16, \\field Cooling Speed 2 Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the operating supply air flow rate during cooling\n";
    ss << "\\note operation or specify autosize.\n";
    ss << "N17, \\field Cooling Speed 3 Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the operating supply air flow rate during cooling\n";
    ss << "\\note operation or specify autosize.\n";
    ss << "N18; \\field Cooling Speed 4 Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the operating supply air flow rate during cooling\n";
    ss << "\\note operation or specify autosize.\n";

    IddObjectType objType(IddObjectType::AirLoopHVAC_UnitaryHeatPump_AirToAir_MultiSpeed);
    OptionalIddObject oObj = IddObject::load("AirLoopHVAC:UnitaryHeatPump:AirToAir:MultiSpeed",
                                             "Unitary Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirLoopHVAC_UnitaryHeatPump_AirToAir_MultiSpeed);
  return object;
}

IddObject createAirConditioner_VariableRefrigerantFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirConditioner:VariableRefrigerantFlow,\n";
    ss << "\\memo Variable refrigerant flow (VRF) air-to-air heat pump condensing unit (includes one\n";
    ss << "\\memo or more electric compressors and outdoor fan). Serves one or more VRF zone terminal\n";
    ss << "\\memo units. See ZoneHVAC:TerminalUnit:VariableRefrigerantFlow and ZoneTerminalUnitList.\n";
    ss << "\\min-fields 37\n";
    ss << "A1 , \\field Heat Pump Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note Enter a unique name for this variable refrigerant flow heat pump.\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Enter the name of a schedule that defines the availability of the unit.\n";
    ss << "\\note Schedule values of 0 denote the unit is off. All other values denote the unit is available.\n";
    ss << "\\note If this field is left blank, the unit is available the entire simulation.\n";
    ss << "N1 , \\field Gross Rated Total Cooling Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Enter the total cooling capacity in watts at rated conditions or set to autosize.\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "N2 , \\field Gross Rated Cooling COP\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.3\n";
    ss << "\\note Enter the coefficient of performance at rated conditions or leave blank to use default.\n";
    ss << "\\note COP includes compressor and condenser fan electrical energy input\n";
    ss << "\\note COP does not include supply fan heat or supply fan electric power input\n";
    ss << "N3 , \\field Minimum Outdoor Temperature in Cooling Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default -6.0\n";
    ss << "\\note Enter the minimum outdoor temperature allowed for cooling operation.\n";
    ss << "\\note Cooling is disabled below this temperature.\n";
    ss << "N4 , \\field Maximum Outdoor Temperature in Cooling Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 43.0\n";
    ss << "\\note Enter the maximum outdoor temperature allowed for cooling operation.\n";
    ss << "\\note Cooling is disabled above this temperature.\n";
    ss << "A3 , \\field Cooling Capacity Ratio Modifier Function of Low Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Enter a curve name that represents full load cooling capacity ratio as a\n";
    ss << "\\note function of outdoor dry-bulb temperature and indoor wet-bulb temperature.\n";
    ss << "\\note Up to two curves are allowed if the performance cannot be represented by a single curve.\n";
    ss << "\\note The following two fields are used if two curves are required.\n";
    ss << "A4 , \\field Cooling Capacity Ratio Boundary Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note This curve object is used to allow separate low and high cooling capacity ratio\n";
    ss << "\\note performance curves. This curve represents a line passing through the points where\n";
    ss << "\\note performance changes. The curve calculates outdoor dry-bulb temperature given weighted\n";
    ss << "\\note average indoor wet-bulb temperature. If a single performance curve is used,\n";
    ss << "\\note leave this field blank.\n";
    ss << "A5 , \\field Cooling Capacity Ratio Modifier Function of High Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note This curve object is used to describe the high outdoor temperature\n";
    ss << "\\note performance curve used to describe cooling capacity ratio.\n";
    ss << "\\note This curve is used when a single performance curve does not accurately describe\n";
    ss << "\\note cooling capacity ratio as a function of temperature.\n";
    ss << "\\note If a single performance curve is used, leave this field blank.\n";
    ss << "A6 , \\field Cooling Energy Input Ratio Modifier Function of Low Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Enter a curve name that represents cooling energy ratio as a function of\n";
    ss << "\\note outdoor dry-bulb temperature and indoor wet-bulb temperature\n";
    ss << "A7 , \\field Cooling Energy Input Ratio Boundary Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note This curve object is used to allow separate low and high cooling energy input ratio\n";
    ss << "\\note performance curves. This curve represents a line passing through the points where\n";
    ss << "\\note performance changes. The curve calculates outdoor dry-bulb temperature given weighted\n";
    ss << "\\note average indoor wet-bulb temperature. If a single performance curve is used,\n";
    ss << "\\note leave this field blank.\n";
    ss << "A8 , \\field Cooling Energy Input Ratio Modifier Function of High Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note This curve object is used to describe the high outdoor temperature\n";
    ss << "\\note performance curve used to describe cooling energy ratio.\n";
    ss << "\\note This curve is used when a single performance curve does not accurately describe\n";
    ss << "\\note cooling energy ratio as a function of temperature\n";
    ss << "A9 , \\field Cooling Energy Input Ratio Modifier Function of Low Part-Load Ratio Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Enter a curve name that represents cooling energy ratio as a function of\n";
    ss << "\\note part-load ratio for part-load ratios less than or equal to 1.\n";
    ss << "\\note If this field is left blank, the model assumes energy is proportional to\n";
    ss << "\\note part-load ratio.\n";
    ss << "A10, \\field Cooling Energy Input Ratio Modifier Function of High Part-Load Ratio Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Enter a curve name that represents cooling energy ratio as a function of\n";
    ss << "\\note part-load ratio for part-load ratios greater than 1. Part-load ratios\n";
    ss << "\\note can exceed 1 in variable speed compression systems.\n";
    ss << "\\note If this field is left blank, the model assumes energy is proportional to\n";
    ss << "\\note part-load ratio.\n";
    ss << "A11, \\field Cooling Combination Ratio Correction Factor Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note This curve defines how rated capacity changes when the total indoor terminal unit cooling\n";
    ss << "\\note capacity is greater than the Gross Rated Total Cooling Capacity defined in this object.\n";
    ss << "\\note If this field is left blank, the model assumes total indoor terminal unit cooling\n";
    ss << "\\note capacity is equal to the Gross Rated Total Cooling Capacity defined above.\n";
    ss << "A12, \\field Cooling Part-Load Fraction Correlation Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note This curve defines the cycling losses when the heat pump compressor cycles on and off\n";
    ss << "\\note below the Minimum Heat Pump Part-Load Ratio specified in the field below.\n";
    ss << "N5 , \\field Gross Rated Heating Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "\\note Enter the heating capacity in watts at rated conditions or set to autosize.\n";
    ss << "\\note Heating capacity not accounting for the effect of supply air fan heat\n";
    ss << "N6 , \\field Rated Heating Capacity Sizing Ratio\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note If the Gross Rated Heating Capacity is autosized, the heating capacity is sized\n";
    ss << "\\note to be equal to the cooling capacity multiplied by this sizing ratio. The zone\n";
    ss << "\\note terminal unit heating coils are also sized using this ratio unless the sizing\n";
    ss << "\\note ratio input in the ZoneHVAC:TerminalUnit:VariableRefrigerantFlow object is entered.\n";
    ss << "N7 , \\field Gross Rated Heating COP\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\note COP includes compressor and condenser fan electrical energy input\n";
    ss << "\\note COP does not include supply fan heat or supply fan electrical energy input\n";
    ss << "\\default 3.4\n";
    ss << "N8 , \\field Minimum Outdoor Temperature in Heating Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default -20.0\n";
    ss << "\\note Enter the minimum outdoor temperature allowed for heating operation.\n";
    ss << "N9 , \\field Maximum Outdoor Temperature in Heating Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 16.0\n";
    ss << "\\note Enter the maximum outdoor temperature allowed for heating operation.\n";
    ss << "A13, \\field Heating Capacity Ratio Modifier Function of Low Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Enter a curve name that represents full load heating capacity ratio as a\n";
    ss << "\\note function of outdoor wet-bulb temperature and indoor dry-bulb temperature.\n";
    ss << "\\note Outdoor dry-bulb temperature may be used if wet-bulb temperature data is unavailable.\n";
    ss << "\\note See Heating Performance Curve Outdoor Temperature Type input below to determine which\n";
    ss << "\\note outdoor temperature type to use.\n";
    ss << "\\note Up to two curves are allowed if the performance cannot be represented by a single curve.\n";
    ss << "\\note The following two fields are used if two curves are required.\n";
    ss << "A14, \\field Heating Capacity Ratio Boundary Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note This curve object is used to allow separate low and high heating capacity ratio\n";
    ss << "\\note performance curves. This curve represents a line passing through the points where\n";
    ss << "\\note performance changes. The curve calculates outdoor dry-bulb or wet-bulb temperature\n";
    ss << "\\note given weighted average indoor dry-bulb temperature. See Heating Performance Curve\n";
    ss << "\\note Outdoor Temperature Type input below to determine which outdoor temperature type to use.\n";
    ss << "\\note If a single performance curve is used, leave this field blank.\n";
    ss << "A15, \\field Heating Capacity Ratio Modifier Function of High Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note This curve object is used to describe the high outdoor temperature\n";
    ss << "\\note performance curve used to describe heating capacity ratio.\n";
    ss << "\\note This curve is used when a single performance curve does not accurately describe\n";
    ss << "\\note heating capacity ratio as a function of temperature.\n";
    ss << "\\note If a single performance curve is used, leave this field blank.\n";
    ss << "A16, \\field Heating Energy Input Ratio Modifier Function of Low Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Enter a curve name that represents heating energy ratio as a function of\n";
    ss << "\\note outdoor wet-bulb temperature and indoor dry-bulb temperature\n";
    ss << "\\note Outdoor dry-bulb temperature may be used if wet-bulb temperature data is unavailable.\n";
    ss << "\\note See Heating Performance Curve Outdoor Temperature Type input below to determine which\n";
    ss << "\\note outdoor temperature type to use.\n";
    ss << "A17, \\field Heating Energy Input Ratio Boundary Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note This curve object is used to allow separate low and high heating energy input ratio\n";
    ss << "\\note performance curves. This curve represents a line passing through the points where\n";
    ss << "\\note performance changes. The curve calculates outdoor dry-bulb or wet-bulb temperature\n";
    ss << "\\note given weighted average indoor dry-bulb temperature. See Heating Performance Curve\n";
    ss << "\\note Outdoor Temperature Type input below to determine which outdoor temperature type to use.\n";
    ss << "\\note If a single performance curve is used, leave this field blank.\n";
    ss << "A18, \\field Heating Energy Input Ratio Modifier Function of High Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note This curve object is used to allow separate performance curves for heating energy.\n";
    ss << "\\note If a single performance curve is used, leave this field blank.\n";
    ss << "A19, \\field Heating Performance Curve Outdoor Temperature Type\n";
    ss << "\\type choice\n";
    ss << "\\key DryBulbTemperature\n";
    ss << "\\key WetBulbTemperature\n";
    ss << "\\default WetBulbTemperature\n";
    ss << "\\note Determines temperature type for heating capacity curves and heating energy curves.\n";
    ss << "\\note This input determines whether the outdoor air dry-bulb or wet-bulb temperature\n";
    ss << "\\note is used to evaluate these curves.\n";
    ss << "A20, \\field Heating Energy Input Ratio Modifier Function of Low Part-Load Ratio Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note This curve represents the heating energy input ratio for part-load ratios less than 1.\n";
    ss << "A21, \\field Heating Energy Input Ratio Modifier Function of High Part-Load Ratio Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note This curve represents the heating energy input ratio for part-load ratios greater than 1.\n";
    ss << "A22, \\field Heating Combination Ratio Correction Factor Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note This curve defines how rated capacity changes when the total indoor terminal unit heating\n";
    ss << "\\note capacity is greater than the Gross Rated Heating Capacity defined in this object.\n";
    ss << "\\note If this field is left blank, the model assumes total indoor terminal unit heating\n";
    ss << "\\note capacity is equal to the Gross Rated Heating Capacity defined above.\n";
    ss << "A23, \\field Heating Part-Load Fraction Correlation Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note This curve defines the cycling losses when the heat pump compressor cycles on and off\n";
    ss << "\\note below the Minimum Heat Pump Part-Load Ratio specified in the following field.\n";
    ss << "N10, \\field Minimum Heat Pump Part-Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Enter the minimum heat pump part-load ratio (PLR). When the cooling or heating PLR is\n";
    ss << "\\note below this value, the heat pump compressor will cycle to meet the cooling or heating\n";
    ss << "\\note demand.\n";
    ss << "\\default 0.15\n";
    ss << "A24, \\field Zone Name for Master Thermostat Location\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note Enter the name of the zone where the master thermostat is located.\n";
    ss << "A25, \\field Master Thermostat Priority Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key LoadPriority\n";
    ss << "\\key ZonePriority\n";
    ss << "\\key ThermostatOffsetPriority\n";
    ss << "\\key MasterThermostatPriority\n";
    ss << "\\key Scheduled\n";
    ss << "\\default MasterThermostatPriority\n";
    ss << "\\note Choose a thermostat control logic scheme. If these control types fail to control zone\n";
    ss << "\\note temperature within a reasonable limit, consider using multiple VRF systems\n";
    ss << "A26, \\field Thermostat Priority Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note this field is required if Master Thermostat Priority Control Type is Scheduled.\n";
    ss << "\\note Schedule values of 0 denote cooling, 1 for heating, and all other values disable the system.\n";
    ss << "A27, \\field Zone Terminal Unit List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneTerminalUnitListNames\n";
    ss << "\\note Enter the name of a ZoneTerminalUnitList. This list connects zone terminal units to this\n";
    ss << "\\note heat pump.\n";
    ss << "A28, \\field Heat Pump Waste Heat Recovery\n";
    ss << "\\type choice\n";
    ss << "\\key No\n";
    ss << "\\key Yes\n";
    ss << "\\default No\n";
    ss << "\\note This field enables heat recovery operation within this VRF outdoor unit.\n";
    ss << "N11, \\field Equivalent Piping Length used for Piping Correction Factor in Cooling Mode\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\note Enter the equivalent length of the farthest terminal unit from the condenser\n";
    ss << "N12, \\field Vertical Height used for Piping Correction Factor\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\note Enter the height difference between the highest and lowest terminal unit\n";
    ss << "A29, \\field Piping Correction Factor for Length in Cooling Mode Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note PCF = a0 + a1*L + a2*L^2 + a3*L^3 + a4*H\n";
    ss << "\\note PCF = a0 + a1*L + a2*L^2 + a3*CR + a4*CR^2 + a5*(L)(CR)\n";
    ss << "\\note where L = length and CR = combination ratio\n";
    ss << "\\note specifies coefficients for a0, a1, a2, and a3 in the PCF equation\n";
    ss << "N13, \\field Piping Correction Factor for Height in Cooling Mode Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units 1/m\n";
    ss << "\\default 0\n";
    ss << "\\note PCF = a0 + a1*L + a2*L^2 + a3*L^3 + a4*H\n";
    ss << "\\note PCF = a0 + a1*L + a2*L^2 + a3*CR + a4*CR^2 + a5*(L)(CR) + a6*H\n";
    ss << "\\note where L = length, H = height, and CR = combination ratio\n";
    ss << "\\note specifies coefficient a4 (or a6 for biquadratic) in the PCF equation\n";
    ss << "N14, \\field Equivalent Piping Length used for Piping Correction Factor in Heating Mode\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\note Enter the equivalent length of the farthest terminal unit from the condenser\n";
    ss << "A30, \\field Piping Correction Factor for Length in Heating Mode Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note PCF = a0 + a1*L + a2*L^2 + a3*L^3 + a4*H\n";
    ss << "\\note PCF = a0 + a1*L + a2*L^2 + a3*CR + a4*CR^2 + a5*(L)(CR) + a6*H\n";
    ss << "\\note where L = length and CR = combination ratio\n";
    ss << "\\note specifies coefficients for a0, a1, a2, and a3 (or a0-a5 for biquadratic) in the PCF equation\n";
    ss << "N15, \\field Piping Correction Factor for Height in Heating Mode Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units 1/m\n";
    ss << "\\default 0\n";
    ss << "\\note PCF = a0 + a1*L + a2*L^2 + a3*L^3 + a4*H\n";
    ss << "\\note PCF = a0 + a1*L + a2*L^2 + a3*CR + a4*CR^2 + a5*(L)(CR) + a6*H\n";
    ss << "\\note where L = length, H = height, and CR = combination ratio\n";
    ss << "\\note specifies coefficient a4 (or a6 for biquadratic) in the PCF equation\n";
    ss << "N16, \\field Crankcase Heater Power per Compressor\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\default 33.0\n";
    ss << "\\note Enter the value of the resistive heater located in the compressor(s). This heater\n";
    ss << "\\note is used to warm the refrigerant and oil when the compressor is off.\n";
    ss << "N17, \\field Number of Compressors\n";
    ss << "\\type integer\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 2\n";
    ss << "\\note Enter the total number of compressor. This input is used only for crankcase\n";
    ss << "\\note heater calculations.\n";
    ss << "N18, \\field Ratio of Compressor Size to Total Compressor Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\default 0.5\n";
    ss << "\\note Enter the ratio of the first stage compressor to total compressor capacity.\n";
    ss << "\\note All other compressors are assumed to be equally sized. This inputs is used\n";
    ss << "\\note only for crankcase heater calculations.\n";
    ss << "N19, \\field Maximum Outdoor Dry-Bulb Temperature for Crankcase Heater\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 5.0\n";
    ss << "\\note Enter the maximum outdoor temperature above which the crankcase heaters are disabled.\n";
    ss << "A31, \\field Defrost Strategy\n";
    ss << "\\type choice\n";
    ss << "\\key ReverseCycle\n";
    ss << "\\key Resistive\n";
    ss << "\\default Resistive\n";
    ss << "\\note Select a defrost strategy. Reverse cycle reverses the operating mode from heating to cooling\n";
    ss << "\\note to melt frost formation on the condenser coil. The resistive strategy uses a resistive heater\n";
    ss << "\\note to melt the frost.\n";
    ss << "A32, \\field Defrost Control\n";
    ss << "\\type choice\n";
    ss << "\\key Timed\n";
    ss << "\\key OnDemand\n";
    ss << "\\default Timed\n";
    ss << "\\note Choose a defrost control type. Either use a fixed Timed defrost period or select\n";
    ss << "\\note OnDemand to defrost only when necessary.\n";
    ss << "A33, \\field Defrost Energy Input Ratio Modifier Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note A valid performance curve must be used if reversecycle defrost strategy is selected.\n";
    ss << "N20, \\field Defrost Time Period Fraction\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.058333\n";
    ss << "\\note Fraction of time in defrost mode.\n";
    ss << "\\note Only applicable if timed defrost control is specified.\n";
    ss << "N21, \\field Resistive Defrost Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Enter the size of the resistive defrost heating element.\n";
    ss << "\\note Only applicable if resistive defrost strategy is specified\n";
    ss << "\\ip-units W\n";
    ss << "N22, \\field Maximum Outdoor Dry-bulb Temperature for Defrost Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 5.0\n";
    ss << "\\note Enter the maximum outdoor temperature above which defrost operation is disabled.\n";
    ss << "A34, \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "\\key WaterCooled\n";
    ss << "\\default AirCooled\n";
    ss << "\\note Select either an air-cooled, evaporatively-cooled or water-cooled condenser.\n";
    ss << "A35, \\field Condenser Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Choose an outside air node name or leave this field blank to use weather data.\n";
    ss << "\\note If this field is blank, the Condenser Type is assumed to be AirCooled.\n";
    ss << "\\note This input must be specified if Condenser Type = WaterCooled.\n";
    ss << "A36, \\field Condenser Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter a water outlet node name if Condenser Type = WaterCooled.\n";
    ss << "\\note Leave this field blank if Condenser Type = Air or EvaporativelyCooled.\n";
    ss << "N23, \\field Water Condenser Volume Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\autosizable\n";
    ss << "\\note Only used when Condenser Type = WaterCooled.\n";
    ss << "N24, \\field Evaporative Condenser Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "\\note Enter the effectiveness of the evaporatively cooled condenser.\n";
    ss << "\\note This field is only used when the Condenser Type = EvaporativelyCooled.\n";
    ss << "N25, \\field Evaporative Condenser Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Used to calculate evaporative condenser water use.\n";
    ss << "\\note This field is only used when the Condenser Type = EvaporativelyCooled.\n";
    ss << "N26, \\field Evaporative Condenser Pump Rated Power Consumption\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Rated power consumed by the evaporative condenser's water pump.\n";
    ss << "\\note This field is only used when the Condenser Type = EvaporativelyCooled.\n";
    ss << "A37, \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "\\note A separate storage tank may be used to supply an evaporatively cooled condenser.\n";
    ss << "N27, \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled and for periods\n";
    ss << "\\note when the basin heater is available (field Basin Heater Operating Schedule Name).\n";
    ss << "\\note For this situation, the heater maintains the basin water temperature at the basin heater\n";
    ss << "\\note setpoint temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when the DX coil is off.\n";
    ss << "N28, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on.\n";
    ss << "A38, \\field Basin Heater Operating Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";
    ss << "A39, \\field Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\default Electricity\n";
    ss << "N29, \\field Minimum Outdoor Temperature in Heat Recovery Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note The minimum outdoor temperature below which heat\n";
    ss << "\\note recovery mode will not operate.\n";
    ss << "N30, \\field Maximum Outdoor Temperature in Heat Recovery Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note The maximum outdoor temperature above which heat\n";
    ss << "\\note recovery mode will not operate.\n";
    ss << "A40, \\field Heat Recovery Cooling Capacity Modifier Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Enter the name of a performance curve which represents\n";
    ss << "\\note the change in cooling capacity when heat recovery is active\n";
    ss << "\\note A default constant of 0.9 is used if this input is blank\n";
    ss << "N31, \\field Initial Heat Recovery Cooling Capacity Fraction\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\default 0.5\n";
    ss << "\\note Enter the fractional capacity available at the start\n";
    ss << "\\note of heat recovery mode. The capacity exponentially approaches\n";
    ss << "\\note the steady-state value according to the inputs for\n";
    ss << "\\note Heat Recovery Cooling Capacity Modifier and Heat Recovery\n";
    ss << "\\note Cooling Capacity Time Constant\n";
    ss << "N32, \\field Heat Recovery Cooling Capacity Time Constant\n";
    ss << "\\type real\n";
    ss << "\\units hr\n";
    ss << "\\default 0.15\n";
    ss << "\\note Enter the time constant used to model the transition\n";
    ss << "\\note from cooling only mode to heat recovery mode\n";
    ss << "A41, \\field Heat Recovery Cooling Energy Modifier Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Enter the name of a performance curve which represents\n";
    ss << "\\note the change in cooling energy when heat recovery is active\n";
    ss << "\\note A default constant of 1.1 is used if this input is blank\n";
    ss << "N33, \\field Initial Heat Recovery Cooling Energy Fraction\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\default 1.0\n";
    ss << "\\note Enter the fractional electric consumption rate at the start\n";
    ss << "\\note of heat recovery mode. The electric consumption rate exponentially\n";
    ss << "\\note approaches the steady-state value according to the inputs for\n";
    ss << "\\note Heat Recovery Cooling Energy Modifier and Heat Recovery\n";
    ss << "\\note Cooling Energy Time Constant\n";
    ss << "N34, \\field Heat Recovery Cooling Energy Time Constant\n";
    ss << "\\type real\n";
    ss << "\\units hr\n";
    ss << "\\default 0\n";
    ss << "\\note Enter the time constant used to model the transition\n";
    ss << "\\note from cooling only mode to heat recovery mode\n";
    ss << "A42, \\field Heat Recovery Heating Capacity Modifier Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Enter the name of a performance curve which represents\n";
    ss << "\\note the change in heating capacity when heat recovery is active\n";
    ss << "\\note A default constant of 1.1 is used if this input is blank\n";
    ss << "N35, \\field Initial Heat Recovery Heating Capacity Fraction\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\default 1\n";
    ss << "\\note Enter the fractional capacity available at the start\n";
    ss << "\\note of heat recovery mode. The capacity exponentially approaches\n";
    ss << "\\note the steady-state value according to the inputs for\n";
    ss << "\\note Heat Recovery Heating Capacity Modifier and Heat Recovery\n";
    ss << "\\note Heating Capacity Time Constant\n";
    ss << "N36, \\field Heat Recovery Heating Capacity Time Constant\n";
    ss << "\\type real\n";
    ss << "\\units hr\n";
    ss << "\\default 0.15\n";
    ss << "\\note Enter the time constant used to model the transition\n";
    ss << "\\note from cooling only mode to heat recovery mode\n";
    ss << "A43, \\field Heat Recovery Heating Energy Modifier Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Enter the name of a performance curve which represents\n";
    ss << "\\note the change in heating electric consumption rate when heat recovery is active\n";
    ss << "\\note A default constant of 1.1 is used if this input is blank\n";
    ss << "N37, \\field Initial Heat Recovery Heating Energy Fraction\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\default 1\n";
    ss << "\\note Enter the fractional electric consumption rate at the start\n";
    ss << "\\note of heat recovery mode. The electric consumption rate exponentially\n";
    ss << "\\note approaches the steady-state value according to the inputs for\n";
    ss << "\\note Heat Recovery Cooling Energy Modifier and Heat Recovery\n";
    ss << "\\note Cooling Energy Time Constant\n";
    ss << "N38; \\field Heat Recovery Heating Energy Time Constant\n";
    ss << "\\type real\n";
    ss << "\\units hr\n";
    ss << "\\default 0\n";
    ss << "\\note Enter the time constant used to model the transition\n";
    ss << "\\note from cooling only mode to heat recovery mode\n";

    IddObjectType objType(IddObjectType::AirConditioner_VariableRefrigerantFlow);
    OptionalIddObject oObj = IddObject::load("AirConditioner:VariableRefrigerantFlow",
                                             "Variable Refrigerant Flow Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirConditioner_VariableRefrigerantFlow);
  return object;
}

IddObject createAirConditioner_VariableRefrigerantFlow_FluidTemperatureControlIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirConditioner:VariableRefrigerantFlow:FluidTemperatureControl,\n";
    ss << "\\memo This is a key object in the new physics based VRF model applicable for Fluid\n";
    ss << "\\memo Temperature Control\n";
    ss << "\\memo It describes the Variable Refrigerant Flow system excluding the performance of indoor units\n";
    ss << "\\memo Indoor units are modeled separately, see ZoneHVAC:TerminalUnit:VariableRefrigerantFlow\n";
    ss << "\\min-fields 9\n";
    ss << "A1 , \\field Heat Pump Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note Enter a unique name for this variable refrigerant flow heat pump\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Enter the name of a schedule that defines the availability of the unit\n";
    ss << "\\note Schedule values of 0 denote the unit is off. All other values denote the unit is available\n";
    ss << "\\note If this field is left blank, the unit is available the entire simulation\n";
    ss << "A3 , \\field Zone Terminal Unit List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneTerminalUnitListNames\n";
    ss << "\\note Enter the name of a ZoneTerminalUnitList. This list connects zone terminal units to this\n";
    ss << "\\note heat pump\n";
    ss << "A4 , \\field Refrigerant Type\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FluidNames\n";
    ss << "\\default R410A\n";
    ss << "N1 , \\field Rated Evaporative Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 40000\n";
    ss << "\\note Enter the total evaporative capacity in watts at rated conditions\n";
    ss << "\\note This is the capacity corresponding to the max compressor speed at rated conditions\n";
    ss << "\\note The actual evaporative capacity is obtained by multiplying the\n";
    ss << "\\note rated capacity with the modification factor calculated by Evaporative\n";
    ss << "\\note Capacity Multiplier Function of Temperature Curve\n";
    ss << "N2 , \\field Rated Compressor Power Per Unit of Rated Evaporative Capacity\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.35\n";
    ss << "\\note Enter the rated compressor power per Watt of rated evaporative capacity [W/W]\n";
    ss << "\\note Rated compressor power corresponds to the max compressor speed at rated conditions\n";
    ss << "\\note The actual compressor power is obtained by multiplying the\n";
    ss << "\\note rated power with the modification factor calculated by Compressor\n";
    ss << "\\note Power Multiplier Function of Temperature Curve\n";
    ss << "N3 , \\field Minimum Outdoor Air Temperature in Cooling Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default -6.0\n";
    ss << "\\note Enter the minimum outdoor temperature allowed for cooling operation\n";
    ss << "\\note Cooling is disabled below this temperature\n";
    ss << "N4 , \\field Maximum Outdoor Air Temperature in Cooling Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 43.0\n";
    ss << "\\note Enter the maximum outdoor temperature allowed for cooling operation\n";
    ss << "\\note Cooling is disabled above this temperature\n";
    ss << "N5 , \\field Minimum Outdoor Air Temperature in Heating Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default -20.0\n";
    ss << "\\note Enter the minimum outdoor temperature allowed for heating operation\n";
    ss << "\\note Heating is disabled below this temperature\n";
    ss << "N6 , \\field Maximum Outdoor Air Temperature in Heating Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 16.0\n";
    ss << "\\note Enter the maximum outdoor temperature allowed for heating operation\n";
    ss << "\\note Heating is disabled below this temperature\n";
    ss << "N7 , \\field Reference Outdoor Unit Superheating\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 3\n";
    ss << "N8 , \\field Reference Outdoor Unit Subcooling\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 5\n";
    ss << "A5 , \\field Refrigerant Temperature Control Algorithm for Indoor Unit\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantTemp\n";
    ss << "\\key VariableTemp\n";
    ss << "\\default VariableTemp\n";
    ss << "N9 , \\field Reference Evaporating Temperature for Indoor Unit\n";
    ss << "\\note This field is used if Refrigerant Temperature Control Algorithm\n";
    ss << "\\note is ConstantTemp\n";
    ss << "\\note Evaporating temperature is the refrigerant temperature, not air temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 6.0\n";
    ss << "N10, \\field Reference Condensing Temperature for Indoor Unit\n";
    ss << "\\note This field is used if Refrigerant Temperature Control Algorithm\n";
    ss << "\\note is ConstantTemp\n";
    ss << "\\note Condensing temperature is the refrigerant temperature, not air temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 44.0\n";
    ss << "N11, \\field Variable Evaporating Temperature Minimum for Indoor Unit\n";
    ss << "\\note This field is used if Refrigerant Temperature Control Algorithm\n";
    ss << "\\note is VariableTemp\n";
    ss << "\\note Evaporating temperature is the refrigerant temperature, not air temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 4.0\n";
    ss << "N12, \\field Variable Evaporating Temperature Maximum for Indoor Unit\n";
    ss << "\\note This field is used if Refrigerant Temperature Control Algorithm\n";
    ss << "\\note is VariableTemp\n";
    ss << "\\note Evaporating temperature is the refrigerant temperature, not air temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 13.0\n";
    ss << "N13, \\field Variable Condensing Temperature Minimum for Indoor Unit\n";
    ss << "\\note This field is used if Refrigerant Temperature Control Algorithm\n";
    ss << "\\note is VariableTemp\n";
    ss << "\\note Condensing temperature is the refrigerant temperature, not air temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 42.0\n";
    ss << "N14, \\field Variable Condensing Temperature Maximum for Indoor Unit\n";
    ss << "\\note This field is used if Refrigerant Temperature Control Algorithm\n";
    ss << "\\note is VariableTemp\n";
    ss << "\\note Condensing temperature is the refrigerant temperature, not air temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 46.0\n";
    ss << "N15, \\field Outdoor Unit Fan Power Per Unit of Rated Evaporative Capacity\n";
    ss << "\\note Enter the outdoor unit fan power per Watt of rated evaporative capacity [W/W]\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 4.25E-3\n";
    ss << "\\type real\n";
    ss << "N16, \\field Outdoor Unit Fan Flow Rate Per Unit of Rated Evaporative Capacity\n";
    ss << "\\note This field is only used if the previous is set to autocalculate and performance input method is NominalCapacity\n";
    ss << "\\units m3/s-W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 7.50E-5\n";
    ss << "\\type real\n";
    ss << "A6 , \\field Outdoor Unit Evaporating Temperature Function of Superheating Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A7 , \\field Outdoor Unit Condensing Temperature Function of Subcooling Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "N17, \\field Diameter of Main Pipe Connecting Outdoor Unit to Indoor Units\n";
    ss << "\\note used to calculate the piping loss\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0762\n";
    ss << "N18, \\field Length of Main Pipe Connecting Outdoor Unit to Indoor Units\n";
    ss << "\\note used to calculate the heat loss of the main pipe\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 30.0\n";
    ss << "N19, \\field Equivalent Length of Main Pipe Connecting Outdoor Unit to Indoor Units\n";
    ss << "\\note used to calculate the refrigerant pressure drop of the main pipe\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 36.0\n";
    ss << "N20, \\field Height Difference Between Outdoor Unit and Indoor Units\n";
    ss << "\\note Difference between outdoor unit height and indoor unit height\n";
    ss << "\\note Positive means outdoor unit is higher than indoor unit\n";
    ss << "\\note Negative means outdoor unit is lower than indoor unit\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 5.0\n";
    ss << "N21, \\field Main Pipe Insulation Thickness\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.02\n";
    ss << "N22, \\field Main Pipe Insulation Thermal Conductivity\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.032\n";
    ss << "N23, \\field Crankcase Heater Power per Compressor\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\default 33.0\n";
    ss << "\\note Enter the value of the resistive heater located in the compressor(s). This heater\n";
    ss << "\\note is used to warm the refrigerant and oil when the compressor is off\n";
    ss << "N24, \\field Number of Compressors\n";
    ss << "\\type integer\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 2\n";
    ss << "\\note Enter the total number of compressor. This input is used only for crankcase\n";
    ss << "\\note heater calculations.\n";
    ss << "N25, \\field Ratio of Compressor Size to Total Compressor Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\default 0.5\n";
    ss << "\\note Enter the ratio of the first stage compressor to total compressor capacity\n";
    ss << "\\note All other compressors are assumed to be equally sized. This inputs is used\n";
    ss << "\\note only for crankcase heater calculations\n";
    ss << "N26, \\field Maximum Outdoor Dry-Bulb Temperature for Crankcase Heater\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 5.0\n";
    ss << "\\note Enter the maximum outdoor temperature above which the crankcase heaters are disabled\n";
    ss << "A8 , \\field Defrost Strategy\n";
    ss << "\\type choice\n";
    ss << "\\key ReverseCycle\n";
    ss << "\\key Resistive\n";
    ss << "\\default Resistive\n";
    ss << "\\note Select a defrost strategy.\n";
    ss << "\\note Reverse cycle reverses the operating mode from heating to\n";
    ss << "\\note cooling to melt frost formation on the condenser coil\n";
    ss << "\\note The resistive strategy uses a resistive heater\n";
    ss << "\\note to melt the frost.\n";
    ss << "A9 , \\field Defrost Control\n";
    ss << "\\type choice\n";
    ss << "\\key Timed\n";
    ss << "\\key OnDemand\n";
    ss << "\\default Timed\n";
    ss << "\\note Choose a defrost control type\n";
    ss << "\\note Either use a fixed Timed defrost period or select\n";
    ss << "\\note OnDemand to defrost only when necessary\n";
    ss << "A10, \\field Defrost Energy Input Ratio Modifier Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note A valid performance curve must be used if ReverseCycle defrost strategy is selected\n";
    ss << "N27, \\field Defrost Time Period Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.058333\n";
    ss << "\\note Fraction of time in defrost mode\n";
    ss << "\\note Only applicable if timed defrost control is specified\n";
    ss << "N28, \\field Resistive Defrost Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\note Enter the size of the resistive defrost heating element\n";
    ss << "\\note Only applicable if resistive defrost strategy is specified\n";
    ss << "\\ip-units W\n";
    ss << "N29, \\field Maximum Outdoor Dry-bulb Temperature for Defrost Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 5.0\n";
    ss << "\\note Enter the maximum outdoor temperature above which the defrost operation is disabled\n";
    ss << "N30, \\field Compressor maximum delta Pressure\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\default 4500000.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 50000000.0\n";
    ss << "N31, \\field Number of Compressor Loading Index Entries\n";
    ss << "\\type integer\n";
    ss << "\\default 2\n";
    ss << "\\minimum 2\n";
    ss << "\\maximum 9\n";
    ss << "\\note First index represents minimal capacity operation\n";
    ss << "\\note Last index represents full capacity operation\n";
    ss << "N32, \\field Compressor Speed at Loading Index 1\n";
    ss << "\\type real\n";
    ss << "\\note Minimum compressor speed\n";
    ss << "\\units rev/min\n";
    ss << "\\minimum> 0\n";
    ss << "A11, \\field Loading Index 1 Evaporative Capacity Multiplier Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiQuadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A12, \\field Loading Index 1 Compressor Power Multiplier Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiQuadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "N33, \\field Compressor Speed at Loading Index 2\n";
    ss << "\\type real\n";
    ss << "\\units rev/min\n";
    ss << "\\minimum> 0\n";
    ss << "A13, \\field Loading Index 2 Evaporative Capacity Multiplier Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiQuadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A14, \\field Loading Index 2 Compressor Power Multiplier Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiQuadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "N34, \\field Compressor Speed at Loading Index 3\n";
    ss << "\\type real\n";
    ss << "\\units rev/min\n";
    ss << "\\minimum> 0\n";
    ss << "A15, \\field Loading Index 3 Evaporative Capacity Multiplier Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiQuadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A16, \\field Loading Index 3 Compressor Power Multiplier Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiQuadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "N35, \\field Compressor Speed at Loading Index 4\n";
    ss << "\\type real\n";
    ss << "\\units rev/min\n";
    ss << "\\minimum> 0\n";
    ss << "A17, \\field Loading Index 4 Evaporative Capacity Multiplier Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiQuadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A18, \\field Loading Index 4 Compressor Power Multiplier Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiQuadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "N36, \\field Compressor Speed at Loading Index 5\n";
    ss << "\\type real\n";
    ss << "\\units rev/min\n";
    ss << "\\minimum> 0\n";
    ss << "A19, \\field Loading Index 5 Evaporative Capacity Multiplier Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiQuadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A20, \\field Loading Index 5 Compressor Power Multiplier Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiQuadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "N37, \\field Compressor Speed at Loading Index 6\n";
    ss << "\\type real\n";
    ss << "\\units rev/min\n";
    ss << "\\minimum> 0\n";
    ss << "A21, \\field Loading Index 6 Evaporative Capacity Multiplier Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiQuadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A22, \\field Loading Index 6 Compressor Power Multiplier Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiQuadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "N38, \\field Compressor Speed at Loading Index 7\n";
    ss << "\\type real\n";
    ss << "\\units rev/min\n";
    ss << "\\minimum> 0\n";
    ss << "A23, \\field Loading Index 7 Evaporative Capacity Multiplier Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiQuadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A24, \\field Loading Index 7 list\n";
    ss << "\\object-list BiQuadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "N39, \\field Compressor Speed at Loading Index 8\n";
    ss << "\\type real\n";
    ss << "\\units rev/min\n";
    ss << "\\minimum> 0\n";
    ss << "A25, \\field Loading Index 8 Evaporative Capacity Multiplier Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiQuadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A26, \\field Loading Index 8 Compressor Power Multiplier Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiQuadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "N40, \\field Compressor Speed at Loading Index 9\n";
    ss << "\\type real\n";
    ss << "\\units rev/min\n";
    ss << "\\minimum> 0\n";
    ss << "A27, \\field Loading Index 9 Evaporative Capacity Multiplier Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiQuadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A28; \\field Loading Index 9 Compressor Power Multiplier Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiQuadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";

    IddObjectType objType(IddObjectType::AirConditioner_VariableRefrigerantFlow_FluidTemperatureControl);
    OptionalIddObject oObj = IddObject::load("AirConditioner:VariableRefrigerantFlow:FluidTemperatureControl",
                                             "Variable Refrigerant Flow Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirConditioner_VariableRefrigerantFlow_FluidTemperatureControl);
  return object;
}

IddObject createZoneTerminalUnitListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneTerminalUnitList,\n";
    ss << "\\memo List of variable refrigerant flow (VRF) terminal units served by a given VRF condensing\n";
    ss << "\\memo unit. See ZoneHVAC:TerminalUnit:VariableRefrigerantFlow and\n";
    ss << "\\memo AirConditioner:VariableRefrigerantFlow.\n";
    ss << "\\min-fields 2\n";
    ss << "\\extensible:1 - repeat last field, remembering to remove ; from \"inner\" fields.\n";
    ss << "A1 ,    \\field Zone Terminal Unit List Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ZoneTerminalUnitListNames\n";
    ss << "A2 ;    \\field Zone Terminal Unit Name 1\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneTerminalUnitNames\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::ZoneTerminalUnitList);
    OptionalIddObject oObj = IddObject::load("ZoneTerminalUnitList",
                                             "Variable Refrigerant Flow Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneTerminalUnitList);
  return object;
}

IddObject createController_WaterCoilIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Controller:WaterCoil,\n";
    ss << "\\memo Controller for a water coil which is located directly in an air loop branch or\n";
    ss << "\\memo outdoor air equipment list. Controls the coil water flow to meet the specified\n";
    ss << "\\memo leaving air setpoint(s). Used with Coil:Heating:Water, Coil:Cooling:Water,\n";
    ss << "\\memo Coil:Cooling:Water:DetailedGeometry, and\n";
    ss << "\\memo CoilSystem:Cooling:Water:HeatexchangerAssisted.\n";
    ss << "\\min-fields 9\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference AirLoopControllers\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\key HumidityRatio\n";
    ss << "\\key TemperatureAndHumidityRatio\n";
    ss << "\\note keys HumidityRatio or TemperatureAndHumidityRatio\n";
    ss << "\\note requires a ZoneControl:Humidistat object along\n";
    ss << "\\note with SetpointManager:SingleZone:Humidity:Maximum,\n";
    ss << "\\note SetpointManager:MultiZone:MaximumHumidity:Average, or\n";
    ss << "\\note SetpointManager:Multizone:Humidity:Maximum object\n";
    ss << "A3 , \\field Action\n";
    ss << "\\type choice\n";
    ss << "\\key Normal\n";
    ss << "\\key Reverse\n";
    ss << "\\note Leave blank to have this automatically selected from coil type.\n";
    ss << "\\note Chilled water coils should be reverse action\n";
    ss << "\\note Hot water coils should be normal action\n";
    ss << "A4 , \\field Actuator Variable\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Flow\n";
    ss << "A5 , \\field Sensor Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6 , \\field Actuator Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Controller Convergence Tolerance\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "\\default autosize\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Maximum Actuated Flow\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "N3 ; \\field Minimum Actuated Flow\n";
    ss << "\\type real\n";
    ss << "\\default 0.0000001\n";
    ss << "\\units m3/s\n";

    IddObjectType objType(IddObjectType::Controller_WaterCoil);
    OptionalIddObject oObj = IddObject::load("Controller:WaterCoil",
                                             "Controllers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Controller_WaterCoil);
  return object;
}

IddObject createController_OutdoorAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Controller:OutdoorAir,\n";
    ss << "\\memo Controller to set the outdoor air flow rate for an air loop. Control options include\n";
    ss << "\\memo fixed, proportional, scheduled, economizer, and demand-controlled ventilation.\n";
    ss << "\\min-fields 16\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference AirLoopControllers\n";
    ss << "\\reference OAControllerNames\n";
    ss << "A2 , \\field Relief Air Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A3 , \\field Return Air Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A4 , \\field Mixed Air Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A5 , \\field Actuator Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "\\note Outdoor air inlet node entering the first pre-treat component if any\n";
    ss << "N1 , \\field Minimum Outdoor Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Maximum Outdoor Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "A6 , \\field Economizer Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key FixedDryBulb\n";
    ss << "\\key FixedEnthalpy\n";
    ss << "\\key DifferentialDryBulb\n";
    ss << "\\key DifferentialEnthalpy\n";
    ss << "\\key FixedDewPointAndDryBulb\n";
    ss << "\\key ElectronicEnthalpy\n";
    ss << "\\key DifferentialDryBulbAndEnthalpy\n";
    ss << "\\key NoEconomizer\n";
    ss << "\\default NoEconomizer\n";
    ss << "A7 , \\field Economizer Control Action Type\n";
    ss << "\\type choice\n";
    ss << "\\key ModulateFlow\n";
    ss << "\\key MinimumFlowWithBypass\n";
    ss << "\\default ModulateFlow\n";
    ss << "N3 , \\field Economizer Maximum Limit Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the maximum outdoor dry-bulb temperature limit for FixedDryBulb\n";
    ss << "\\note economizer control type. No input or blank input means this limit is\n";
    ss << "\\note not operative. Limit is applied regardless of economizer control type.\n";
    ss << "N4 , \\field Economizer Maximum Limit Enthalpy\n";
    ss << "\\type real\n";
    ss << "\\units J/kg\n";
    ss << "\\note Enter the maximum outdoor enthalpy limit for FixedEnthalpy economizer control type.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "N5 , \\field Economizer Maximum Limit Dewpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the maximum outdoor dewpoint temperature limit for FixedDewPointAndDryBulb\n";
    ss << "\\note economizer control type. No input or blank input means this limit is not operative.\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "A8 , \\field Electronic Enthalpy Limit Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Enter the name of a quadratic or cubic curve which defines the maximum outdoor\n";
    ss << "\\note humidity ratio (function of outdoor dry-bulb temperature) for ElectronicEnthalpy\n";
    ss << "\\note economizer control type. No input or blank input means this limit is not operative\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "N6 , \\field Economizer Minimum Limit Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the minimum outdoor dry-bulb temperature limit for economizer control.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "A9 , \\field Lockout Type\n";
    ss << "\\type choice\n";
    ss << "\\key NoLockout\n";
    ss << "\\key LockoutWithHeating\n";
    ss << "\\key LockoutWithCompressor\n";
    ss << "\\default NoLockout\n";
    ss << "A10, \\field Minimum Limit Type\n";
    ss << "\\type choice\n";
    ss << "\\key FixedMinimum\n";
    ss << "\\key ProportionalMinimum\n";
    ss << "\\default ProportionalMinimum\n";
    ss << "A11, \\field Minimum Outdoor Air Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values multiply the minimum outdoor air flow rate\n";
    ss << "A12, \\field Minimum Fraction of Outdoor Air Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note schedule values multiply the design/mixed air flow rate\n";
    ss << "A13, \\field Maximum Fraction of Outdoor Air Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note schedule values multiply the design/mixed air flow rate\n";
    ss << "A14, \\field Mechanical Ventilation Controller Name\n";
    ss << "\\note Enter the name of a Controller:MechanicalVentilation object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ControllerMechanicalVentNames\n";
    ss << "\\note Optional field for defining outdoor ventilation air based on flow rate per unit floor\n";
    ss << "\\note area and flow rate per person. Simplified method of demand-controlled ventilation.\n";
    ss << "A15, \\field Time of Day Economizer Control Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Optional schedule to simulate \"push-button\" type economizer control.\n";
    ss << "\\note Schedule values greater than 0 indicate time-of-day economizer control is enabled.\n";
    ss << "\\note Economizer control may be used with or without the high humidity control option.\n";
    ss << "\\note When used together, high humidity control has priority over economizer control.\n";
    ss << "\\note If the field Economizer Control Type = NoEconomizer, then this option is disabled.\n";
    ss << "A16, \\field High Humidity Control\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note Optional field to enable modified outdoor air flow rates based on zone relative humidity.\n";
    ss << "\\note Select Yes to modify outdoor air flow rate based on a zone humidistat.\n";
    ss << "\\note Select No to disable this feature.\n";
    ss << "\\note If the field Economizer Control Type = NoEconomizer, then this option is disabled.\n";
    ss << "A17, \\field Humidistat Control Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note Enter the name of the zone where the humidistat is located.\n";
    ss << "\\note This field is only used when the field High Humidity Control = Yes.\n";
    ss << "N7 , \\field High Humidity Outdoor Air Flow Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Enter the ratio of outdoor air to the maximum outdoor air flow rate when modified air\n";
    ss << "\\note flow rates are active based on high indoor humidity.\n";
    ss << "\\note The minimum value must be greater than 0.\n";
    ss << "\\note This field is only used when the field High Humidity Control = Yes.\n";
    ss << "A18, \\field Control High Indoor Humidity Based on Outdoor Humidity Ratio\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "\\note If No is selected, the outdoor air flow rate is modified any time indoor relative\n";
    ss << "\\note humidity is above the humidistat setpoint. If Yes is selected, the outdoor air\n";
    ss << "\\note flow rate is modified any time the indoor relative humidity is above the humidistat\n";
    ss << "\\note setpoint and the outdoor humidity ratio is less than the indoor humidity ratio.\n";
    ss << "\\note This field is only used when the field High Humidity Control = Yes.\n";
    ss << "A19; \\field Heat Recovery Bypass Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key BypassWhenWithinEconomizerLimits\n";
    ss << "\\key BypassWhenOAFlowGreaterThanMinimum\n";
    ss << "\\default BypassWhenWithinEconomizerLimits\n";
    ss << "\\note BypassWhenWithinEconomizerLimits specifies that heat recovery\n";
    ss << "\\note is active only when the economizer is off because conditions\n";
    ss << "\\note are outside the economizer control limits\n";
    ss << "\\note BypassWhenOAFlowGreaterThanMinimum specifies enhanced economizer\n";
    ss << "\\note controls to allow heat recovery when economizer is active\n";
    ss << "\\note (within limits) but the outdoor air flow rate is at the minimum.\n";

    IddObjectType objType(IddObjectType::Controller_OutdoorAir);
    OptionalIddObject oObj = IddObject::load("Controller:OutdoorAir",
                                             "Controllers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Controller_OutdoorAir);
  return object;
}

IddObject createController_MechanicalVentilationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Controller:MechanicalVentilation,\n";
    ss << "\\memo This object is used in conjunction with Controller:OutdoorAir to specify outdoor\n";
    ss << "\\memo ventilation air based on outdoor air specified in the DesignSpecification:OutdoorAir object\n";
    ss << "\\memo The Controller:OutdoorAir object is associated with a specific air loop, so the\n";
    ss << "\\memo outdoor air flow rates specified in Controller:MechanicalVentilation correspond to the zones\n";
    ss << "\\memo attached to that specific air loop.\n";
    ss << "\\min-fields 8\n";
    ss << "\\extensible:3 - repeat last three fields, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\memo Duplicate groups of Zone name, Design Specification Outdoor Air Object Name,\n";
    ss << "\\memo and Design Specification Zone Air Distribution Object Name to increase allowable number of entries\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ControllerMechanicalVentNames\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\note If this field is blank, the controller uses the values from the associated Controller:OutdoorAir.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values greater than 0 indicate mechanical ventilation is enabled\n";
    ss << "A3,  \\field Demand Controlled Ventilation\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A4,  \\field System Outdoor Air Method\n";
    ss << "\\type choice\n";
    ss << "\\key ZoneSum\n";
    ss << "\\key VentilationRateProcedure\n";
    ss << "\\key IndoorAirQualityProcedure\n";
    ss << "\\key ProportionalControlBasedOnDesignOccupancy\n";
    ss << "\\key ProportionalControlBasedonOccupancySchedule\n";
    ss << "\\key IndoorAirQualityProcedureGenericContaminant\n";
    ss << "\\default VentilationRateProcedure\n";
    ss << "N1,  \\field Zone Maximum Outdoor Air Fraction\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units dimensionless\n";
    ss << "A5,  \\field Zone 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneAndZoneListNames\n";
    ss << "\\note A zone name or a zone list name may be used here\n";
    ss << "A6,  \\field Design Specification Outdoor Air Object Name 1\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "A7;  \\field Design Specification Zone Air Distribution Object Name 1\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneAirDistributionNames\n";

    IddObjectType objType(IddObjectType::Controller_MechanicalVentilation);
    OptionalIddObject oObj = IddObject::load("Controller:MechanicalVentilation",
                                             "Controllers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Controller_MechanicalVentilation);
  return object;
}

IddObject createAirLoopHVAC_ControllerListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirLoopHVAC:ControllerList,\n";
    ss << "\\memo List controllers in order of control sequence\n";
    ss << "\\extensible:2\n";
    ss << "\\min-fields 3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ControllerLists\n";
    ss << "A2 , \\field Controller 1 Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Controller:WaterCoil\n";
    ss << "\\key Controller:OutdoorAir\n";
    ss << "\\begin-extensible\n";
    ss << "A3 ; \\field Controller 1 Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirLoopControllers\n";

    IddObjectType objType(IddObjectType::AirLoopHVAC_ControllerList);
    OptionalIddObject oObj = IddObject::load("AirLoopHVAC:ControllerList",
                                             "Controllers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirLoopHVAC_ControllerList);
  return object;
}

IddObject createAirLoopHVACIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirLoopHVAC,\n";
    ss << "\\min-fields 10\n";
    ss << "\\memo Defines a central forced air system.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AirPrimaryLoops\n";
    ss << "A2, \\field Controller List Name\n";
    ss << "\\note Enter the name of an AirLoopHVAC:ControllerList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ControllerLists\n";
    ss << "A3, \\field Availability Manager List Name\n";
    ss << "\\note Enter the name of an AvailabilityManagerAssignmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";
    ss << "N1, \\field Design Supply Air Flow Rate\n";
    ss << "\\default 0\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "A4, \\field Branch List Name\n";
    ss << "\\note Name of a BranchList containing all the branches in this air loop\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BranchLists\n";
    ss << "A5, \\field Connector List Name\n";
    ss << "\\note Name of a ConnectorList containing all the splitters and mixers in the loop\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectorLists\n";
    ss << "A6, \\field Supply Side Inlet Node Name\n";
    ss << "\\note Name of inlet node where return air enters the supply side of the air loop\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7, \\field Demand Side Outlet Node Name\n";
    ss << "\\note Name of outlet node where return air leaves the demand side and enters the supply side.\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A8, \\field Demand Side Inlet Node Names\n";
    ss << "\\note Name of a Node or NodeList containing the inlet node(s) supplying air to zone equipment.\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A9; \\field Supply Side Outlet Node Names\n";
    ss << "\\note Name of a Node or NodeList containing the outlet node(s) supplying air to the demand side.\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::AirLoopHVAC);
    OptionalIddObject oObj = IddObject::load("AirLoopHVAC",
                                             "Air Distribution",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirLoopHVAC);
  return object;
}

IddObject createAirLoopHVAC_OutdoorAirSystem_EquipmentListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirLoopHVAC:OutdoorAirSystem:EquipmentList,\n";
    ss << "\\memo List equipment in simulation order\n";
    ss << "\\extensible:2\n";
    ss << "\\min-fields 3\n";
    ss << "\\max-fields 19\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AirLoopOAEquipmentLists\n";
    ss << "A2 , \\field Component 1 Object Type\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "A3 ; \\field Component 1 Name\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::AirLoopHVAC_OutdoorAirSystem_EquipmentList);
    OptionalIddObject oObj = IddObject::load("AirLoopHVAC:OutdoorAirSystem:EquipmentList",
                                             "Air Distribution",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirLoopHVAC_OutdoorAirSystem_EquipmentList);
  return object;
}

IddObject createAirLoopHVAC_OutdoorAirSystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirLoopHVAC:OutdoorAirSystem,\n";
    ss << "\\memo Outdoor air subsystem for an AirLoopHVAC. Includes an outdoor air mixing box and\n";
    ss << "\\memo optional outdoor air conditioning equipment such as heat recovery, preheat, and precool\n";
    ss << "\\memo coils. From the perspective of the primary air loop the outdoor air system is treated\n";
    ss << "\\memo as a single component.\n";
    ss << "\\min-fields 3\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2, \\field Controller List Name\n";
    ss << "\\note Enter the name of an AirLoopHVAC:ControllerList object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ControllerLists\n";
    ss << "A3, \\field Outdoor Air Equipment List Name\n";
    ss << "\\note Enter the name of an AirLoopHVAC:OutdoorAirSystem:EquipmentList object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirLoopOAEquipmentLists\n";
    ss << "A4; \\field Availability Manager List Name\n";
    ss << "\\note Enter the name of an AvailabilityManagerAssignmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";

    IddObjectType objType(IddObjectType::AirLoopHVAC_OutdoorAirSystem);
    OptionalIddObject oObj = IddObject::load("AirLoopHVAC:OutdoorAirSystem",
                                             "Air Distribution",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirLoopHVAC_OutdoorAirSystem);
  return object;
}

IddObject createOutdoorAir_MixerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OutdoorAir:Mixer,\n";
    ss << "\\memo Outdoor air mixer. Node names cannot be duplicated within a single OutdoorAir:Mixer\n";
    ss << "\\memo object or across all outdoor air mixers.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference OutdoorAirMixers\n";
    ss << "A2, \\field Mixed Air Node Name\n";
    ss << "\\note Name of Mixed Air Node\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3, \\field Outdoor Air Stream Node Name\n";
    ss << "\\note Name of Outdoor Air Stream Node\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4, \\field Relief Air Stream Node Name\n";
    ss << "\\note Name of Relief Air Stream Node\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5; \\field Return Air Stream Node Name\n";
    ss << "\\note Name of Return Air Stream Node\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::OutdoorAir_Mixer);
    OptionalIddObject oObj = IddObject::load("OutdoorAir:Mixer",
                                             "Air Distribution",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OutdoorAir_Mixer);
  return object;
}

IddObject createAirLoopHVAC_ZoneSplitterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirLoopHVAC:ZoneSplitter,\n";
    ss << "\\extensible:1 Just duplicate last field and comments (changing numbering, please)\n";
    ss << "\\min-fields 3\n";
    ss << "\\memo Split one air stream into N outlet streams (currently 500 per air loop, but extensible).  Node names\n";
    ss << "\\memo cannot be duplicated within a single zone splitter (AirLoopHVAC:ZoneSplitter) list.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SupplyPathComponentNames\n";
    ss << "A2, \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3; \\field Outlet 1 Node Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::AirLoopHVAC_ZoneSplitter);
    OptionalIddObject oObj = IddObject::load("AirLoopHVAC:ZoneSplitter",
                                             "Air Distribution",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirLoopHVAC_ZoneSplitter);
  return object;
}

IddObject createAirLoopHVAC_SupplyPlenumIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirLoopHVAC:SupplyPlenum,\n";
    ss << "\\extensible:1 Just duplicate last field and comments (changing numbering, please)\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo Connects 1 zone inlet air stream, through zone supply plenum, to one or more outlets.\n";
    ss << "\\memo Node names cannot be duplicated within a single supply plenum list.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SupplyPathComponentNames\n";
    ss << "A2, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A3, \\field Zone Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4, \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5; \\field Outlet 1 Node Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::AirLoopHVAC_SupplyPlenum);
    OptionalIddObject oObj = IddObject::load("AirLoopHVAC:SupplyPlenum",
                                             "Air Distribution",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirLoopHVAC_SupplyPlenum);
  return object;
}

IddObject createAirLoopHVAC_SupplyPathIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirLoopHVAC:SupplyPath,\n";
    ss << "\\extensible:2 Just duplicate last two fields and comments (changing numbering, please)\n";
    ss << "\\min-fields 4\n";
    ss << "\\memo A supply path can only contain AirLoopHVAC:ZoneSplitter and AirLoopHVAC:SupplyPlenum objects\n";
    ss << "\\memo which may be in series or parallel.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Supply Air Path Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3, \\field Component 1 Object Type\n";
    ss << "\\begin-extensible\n";
    ss << "\\note Supply path components must be listed in flow order.\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key AirLoopHVAC:ZoneSplitter\n";
    ss << "\\key AirLoopHVAC:SupplyPlenum\n";
    ss << "A4; \\field Component 1 Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SupplyPathComponentNames\n";

    IddObjectType objType(IddObjectType::AirLoopHVAC_SupplyPath);
    OptionalIddObject oObj = IddObject::load("AirLoopHVAC:SupplyPath",
                                             "Air Distribution",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirLoopHVAC_SupplyPath);
  return object;
}

IddObject createAirLoopHVAC_ZoneMixerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirLoopHVAC:ZoneMixer,\n";
    ss << "\\extensible:1 Just duplicate last field and comments (changing numbering, please)\n";
    ss << "\\min-fields 3\n";
    ss << "\\memo Mix N inlet air streams into one (currently 500 per air loop, but extensible).  Node names cannot\n";
    ss << "\\memo be duplicated within a single zone mixer (AirLoopHVAC:ZoneMixer) list.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ZoneMixers\n";
    ss << "\\reference ReturnPathComponentNames\n";
    ss << "A2, \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3; \\field Inlet 1 Node Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::AirLoopHVAC_ZoneMixer);
    OptionalIddObject oObj = IddObject::load("AirLoopHVAC:ZoneMixer",
                                             "Air Distribution",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirLoopHVAC_ZoneMixer);
  return object;
}

IddObject createAirLoopHVAC_ReturnPlenumIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirLoopHVAC:ReturnPlenum,\n";
    ss << "\\extensible:1 Just duplicate last field and comments (changing numbering, please)\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo Connects N zone inlet air streams, through zone return plenum, to outlet\n";
    ss << "\\memo (currently 500 per air loop)\n";
    ss << "\\memo Node names cannot be duplicated within a single plenum list.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ReturnPathComponentNames\n";
    ss << "A2, \\field Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A3, \\field Zone Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4, \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5, \\field Induced Air Outlet Node or NodeList Name\n";
    ss << "\\type node\n";
    ss << "A6; \\field Inlet 1 Node Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::AirLoopHVAC_ReturnPlenum);
    OptionalIddObject oObj = IddObject::load("AirLoopHVAC:ReturnPlenum",
                                             "Air Distribution",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirLoopHVAC_ReturnPlenum);
  return object;
}

IddObject createAirLoopHVAC_ReturnPathIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirLoopHVAC:ReturnPath,\n";
    ss << "\\extensible:2 Just duplicate last two fields and comments (changing numbering, please)\n";
    ss << "\\min-fields 4\n";
    ss << "\\memo A return air path can only contain one AirLoopHVAC:ZoneMixer\n";
    ss << "\\memo and one or more AirLoopHVAC:ReturnPlenum objects.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Return Air Path Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3, \\field Component 1 Object Type\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key AirLoopHVAC:ZoneMixer\n";
    ss << "\\key AirLoopHVAC:ReturnPlenum\n";
    ss << "A4; \\field Component 1 Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ReturnPathComponentNames\n";

    IddObjectType objType(IddObjectType::AirLoopHVAC_ReturnPath);
    OptionalIddObject oObj = IddObject::load("AirLoopHVAC:ReturnPath",
                                             "Air Distribution",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirLoopHVAC_ReturnPath);
  return object;
}

IddObject createBranchIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Branch,\n";
    ss << "\\extensible:5 Just duplicate last 5 fields and comments (changing numbering, please)\n";
    ss << "\\memo List components on the branch in simulation and connection order\n";
    ss << "\\memo Note: this should NOT include splitters or mixers which define\n";
    ss << "\\memo endpoints of branches\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference Branches\n";
    ss << "N1, \\field Maximum Flow Rate\n";
    ss << "\\default 0\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "A2, \\field Pressure Drop Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PressureDropCurves\n";
    ss << "\\object-list ExponentCurves\n";
    ss << "\\object-list LinearOrQuadraticCurves\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Optional field to include this branch in plant pressure drop calculations\n";
    ss << "\\note This field is only relevant for branches in PlantLoops and CondenserLoops\n";
    ss << "\\note Air loops do not account for pressure drop using this field\n";
    ss << "\\note Valid curve types are: Curve:Functional:PressureDrop or\n";
    ss << "\\note one of Curve:{Linear,Quadratic,Cubic,Exponent}')\n";
    ss << "A3, \\field Component 1 Object Type\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "A4, \\field Component 1 Name\n";
    ss << "\\required-field\n";
    ss << "A5, \\field Component 1 Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6, \\field Component 1 Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7; \\field Component 1 Branch Control Type\n";
    ss << "\\note field is no longer used\n";

    IddObjectType objType(IddObjectType::Branch);
    OptionalIddObject oObj = IddObject::load("Branch",
                                             "Node-Branch Management",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Branch);
  return object;
}

IddObject createBranchListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "BranchList,\n";
    ss << "\\extensible:1 Just duplicate last field and comments (changing numbering, please)\n";
    ss << "\\min-fields 2\n";
    ss << "\\memo Branches MUST be listed in Flow order: Inlet branch, then parallel branches, then Outlet branch.\n";
    ss << "\\memo Branches are simulated in the order listed.  Branch names cannot be duplicated within a single branch list.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference BranchLists\n";
    ss << "A2; \\field Branch 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Branches\n";

    IddObjectType objType(IddObjectType::BranchList);
    OptionalIddObject oObj = IddObject::load("BranchList",
                                             "Node-Branch Management",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::BranchList);
  return object;
}

IddObject createConnector_SplitterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Connector:Splitter,\n";
    ss << "\\min-fields 3\n";
    ss << "\\extensible:1 Just duplicate last field and comments (changing numbering, please)\n";
    ss << "\\memo Split one air/water stream into N outlet streams.  Branch names cannot be duplicated\n";
    ss << "\\memo within a single Splitter list.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Inlet Branch Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Branches\n";
    ss << "A3; \\field Outlet Branch 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Branches\n";

    IddObjectType objType(IddObjectType::Connector_Splitter);
    OptionalIddObject oObj = IddObject::load("Connector:Splitter",
                                             "Node-Branch Management",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Connector_Splitter);
  return object;
}

IddObject createConnector_MixerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Connector:Mixer,\n";
    ss << "\\min-fields 3\n";
    ss << "\\extensible:1 Just duplicate last field and comments (changing numbering, please)\n";
    ss << "\\memo Mix N inlet air/water streams into one.  Branch names cannot be duplicated within\n";
    ss << "\\memo a single mixer list.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Outlet Branch Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Branches\n";
    ss << "A3 ; \\field Inlet Branch 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Branches\n";

    IddObjectType objType(IddObjectType::Connector_Mixer);
    OptionalIddObject oObj = IddObject::load("Connector:Mixer",
                                             "Node-Branch Management",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Connector_Mixer);
  return object;
}

IddObject createConnectorListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ConnectorList,\n";
    ss << "\\memo only two connectors allowed per loop\n";
    ss << "\\memo if two entered, one must be Connector:Splitter and one must be Connector:Mixer\n";
    ss << "\\extensible:2\n";
    ss << "\\min-fields 3\n";
    ss << "\\max-fields 5\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectorLists\n";
    ss << "A2, \\field Connector 1 Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Connector:Splitter\n";
    ss << "\\key Connector:Mixer\n";
    ss << "\\begin-extensible\n";
    ss << "A3; \\field Connector 1 Name\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::ConnectorList);
    OptionalIddObject oObj = IddObject::load("ConnectorList",
                                             "Node-Branch Management",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ConnectorList);
  return object;
}

IddObject createNodeListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "NodeList,\n";
    ss << "\\min-fields 2\n";
    ss << "\\extensible:1 Just duplicate last field and comments (changing numbering, please)\n";
    ss << "\\memo This object is used in places where lists of nodes may be\n";
    ss << "\\memo needed, e.g. ZoneHVAC:EquipmentConnections field Zone Air Inlet Node or NodeList Name\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A2 ; \\field Node 1 Name\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::NodeList);
    OptionalIddObject oObj = IddObject::load("NodeList",
                                             "Node-Branch Management",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::NodeList);
  return object;
}

IddObject createOutdoorAir_NodeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OutdoorAir:Node,\n";
    ss << "\\memo This object sets the temperature and humidity conditions\n";
    ss << "\\memo for an outdoor air node.  It allows the height above ground to be\n";
    ss << "\\memo specified.  This object may be used more than once.\n";
    ss << "\\memo The same node name may not appear in both an OutdoorAir:Node object and\n";
    ss << "\\memo an OutdoorAir:NodeList object.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 ; \\field Height Above Ground\n";
    ss << "\\note A value less than zero indicates that the height will be ignored and the weather file conditions will be used.\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default -1.0\n";

    IddObjectType objType(IddObjectType::OutdoorAir_Node);
    OptionalIddObject oObj = IddObject::load("OutdoorAir:Node",
                                             "Node-Branch Management",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OutdoorAir_Node);
  return object;
}

IddObject createOutdoorAir_NodeListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OutdoorAir:NodeList,\n";
    ss << "\\extensible:1 Just duplicate last field and comments (changing numbering, please)\n";
    ss << "\\min-fields 1\n";
    ss << "\\memo This object sets the temperature and humidity conditions\n";
    ss << "\\memo for an outdoor air node using the weather data values.\n";
    ss << "\\memo to vary outdoor air node conditions with height above ground\n";
    ss << "\\memo use OutdoorAir:Node instead of this object.\n";
    ss << "\\memo This object may be used more than once.\n";
    ss << "\\memo The same node name may not appear in both an OutdoorAir:Node object and\n";
    ss << "\\memo an OutdoorAir:NodeList object.\n";
    ss << "A1 ; \\field Node or NodeList Name 1\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::OutdoorAir_NodeList);
    OptionalIddObject oObj = IddObject::load("OutdoorAir:NodeList",
                                             "Node-Branch Management",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OutdoorAir_NodeList);
  return object;
}

IddObject createPipe_AdiabaticIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Pipe:Adiabatic,\n";
    ss << "\\memo Passes Inlet Node state variables to Outlet Node state variables\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3; \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::Pipe_Adiabatic);
    OptionalIddObject oObj = IddObject::load("Pipe:Adiabatic",
                                             "Node-Branch Management",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Pipe_Adiabatic);
  return object;
}

IddObject createPipe_Adiabatic_SteamIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Pipe:Adiabatic:Steam,\n";
    ss << "\\memo Passes Inlet Node state variables to Outlet Node state variables\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3; \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::Pipe_Adiabatic_Steam);
    OptionalIddObject oObj = IddObject::load("Pipe:Adiabatic:Steam",
                                             "Node-Branch Management",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Pipe_Adiabatic_Steam);
  return object;
}

IddObject createPipe_IndoorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Pipe:Indoor,\n";
    ss << "\\memo Pipe model with transport delay and heat transfer to the environment.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3,  \\field Fluid Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A4,  \\field Fluid Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5,  \\field Environment Type\n";
    ss << "\\type choice\n";
    ss << "\\key Zone\n";
    ss << "\\key Schedule\n";
    ss << "\\default Zone\n";
    ss << "A6,  \\field Ambient Temperature Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A7,  \\field Ambient Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A8,  \\field Ambient Air Velocity Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1,  \\field Pipe Inside Diameter\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units in\n";
    ss << "N2;  \\field Pipe Length\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";

    IddObjectType objType(IddObjectType::Pipe_Indoor);
    OptionalIddObject oObj = IddObject::load("Pipe:Indoor",
                                             "Node-Branch Management",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Pipe_Indoor);
  return object;
}

IddObject createPipe_OutdoorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Pipe:Outdoor,\n";
    ss << "\\memo Pipe model with transport delay and heat transfer to the environment.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3,  \\field Fluid Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A4,  \\field Fluid Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5,  \\field Ambient Temperature Outdoor Air Node Name\n";
    ss << "\\type node\n";
    ss << "N1,  \\field Pipe Inside Diameter\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units in\n";
    ss << "N2;  \\field Pipe Length\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";

    IddObjectType objType(IddObjectType::Pipe_Outdoor);
    OptionalIddObject oObj = IddObject::load("Pipe:Outdoor",
                                             "Node-Branch Management",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Pipe_Outdoor);
  return object;
}

IddObject createPipe_UndergroundIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Pipe:Underground,\n";
    ss << "\\memo Buried Pipe model: For pipes buried at a depth less\n";
    ss << "\\memo than one meter, this is an alternative object to:\n";
    ss << "\\memo HeatExchanger:Surface\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3,  \\field Fluid Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A4,  \\field Fluid Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A5,  \\field Sun Exposure\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key SunExposed\n";
    ss << "\\key NoSun\n";
    ss << "N1,  \\field Pipe Inside Diameter\n";
    ss << "\\note pipe thickness is defined in the Construction object\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units in\n";
    ss << "N2,  \\field Pipe Length\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "A6,  \\field Soil Material Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A7,  \\field Undisturbed Ground Temperature Model Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Site:GroundTemperature:Undisturbed:FiniteDifference\n";
    ss << "\\key Site:GroundTemperature:Undisturbed:KusudaAchenbach\n";
    ss << "\\key Site:GroundTemperature:Undisturbed:Xing\n";
    ss << "A8;  \\field Undisturbed Ground Temperature Model Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UndisturbedGroundTempModels\n";

    IddObjectType objType(IddObjectType::Pipe_Underground);
    OptionalIddObject oObj = IddObject::load("Pipe:Underground",
                                             "Node-Branch Management",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Pipe_Underground);
  return object;
}

IddObject createPipingSystem_Underground_DomainIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PipingSystem:Underground:Domain,\n";
    ss << "\\memo The ground domain object for underground piping system simulation.\n";
    ss << "\\min-fields 31\n";
    ss << "\\extensible:1\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "N1,  \\field Xmax\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Domain extent in the local 'X' direction\n";
    ss << "N2,  \\field Ymax\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Domain extent in the local 'Y' direction\n";
    ss << "N3,  \\field Zmax\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Domain extent in the local 'Y' direction\n";
    ss << "N4,  \\field X-Direction Mesh Density Parameter\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 4\n";
    ss << "\\note If mesh type is symmetric geometric, this should be an even number.\n";
    ss << "A2,  \\field X-Direction Mesh Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Uniform\n";
    ss << "\\key SymmetricGeometric\n";
    ss << "N5,  \\field X-Direction Geometric Coefficient\n";
    ss << "\\note optional\n";
    ss << "\\type real\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1.3\n";
    ss << "\\maximum 2\n";
    ss << "\\note Only used if mesh type is symmetric geometric\n";
    ss << "N6,  \\field Y-Direction Mesh Density Parameter\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 4\n";
    ss << "\\note If mesh type is symmetric geometric, this should be an even number.\n";
    ss << "A3,  \\field Y-Direction Mesh Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Uniform\n";
    ss << "\\key SymmetricGeometric\n";
    ss << "N7,  \\field Y-Direction Geometric Coefficient\n";
    ss << "\\note optional\n";
    ss << "\\type real\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1.3\n";
    ss << "\\maximum 2\n";
    ss << "\\note Only used if mesh type is symmetric geometric\n";
    ss << "N8,  \\field Z-Direction Mesh Density Parameter\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 4\n";
    ss << "\\note If mesh type is symmetric geometric, this should be an even number.\n";
    ss << "A4,  \\field Z-Direction Mesh Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Uniform\n";
    ss << "\\key SymmetricGeometric\n";
    ss << "N9,  \\field Z-Direction Geometric Coefficient\n";
    ss << "\\note optional\n";
    ss << "\\type real\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1.3\n";
    ss << "\\maximum 2\n";
    ss << "\\note Only used if mesh type is symmetric geometric\n";
    ss << "N10, \\field Soil Thermal Conductivity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum> 0\n";
    ss << "N11, \\field Soil Density\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kg/m3\n";
    ss << "\\minimum> 0\n";
    ss << "N12, \\field Soil Specific Heat\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units J/kg-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\note This is a dry soil property, which is adjusted for freezing effects\n";
    ss << "\\note   by the simulation algorithm.\n";
    ss << "N13, \\field Soil Moisture Content Volume Fraction\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 100\n";
    ss << "\\default 30\n";
    ss << "N14, \\field Soil Moisture Content Volume Fraction at Saturation\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 100\n";
    ss << "\\default 50\n";
    ss << "A5,  \\field Undisturbed Ground Temperature Model Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Site:GroundTemperature:Undisturbed:FiniteDifference\n";
    ss << "\\key Site:GroundTemperature:Undisturbed:KusudaAchenbach\n";
    ss << "\\key Site:GroundTemperature:Undisturbed:Xing\n";
    ss << "A6,  \\field Undisturbed Ground Temperature Model Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UndisturbedGroundTempModels\n";
    ss << "A7,  \\field This Domain Includes Basement Surface Interaction\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note if Yes, then the following basement inputs are used\n";
    ss << "\\note if No, then the following basement inputs are *ignored*\n";
    ss << "N15, \\field Width of Basement Floor in Ground Domain\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\note Required only if Domain Has Basement Interaction\n";
    ss << "N16, \\field Depth of Basement Wall In Ground Domain\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\note Required only if Domain Has Basement Interaction\n";
    ss << "A8,  \\field Shift Pipe X Coordinates By Basement Width\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\note Required only if Domain Has Basement Interaction\n";
    ss << "A9,  \\field Name of Basement Wall Boundary Condition Model\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OSCMNames\n";
    ss << "\\note Required only if Domain Has Basement Interaction\n";
    ss << "A10,  \\field Name of Basement Floor Boundary Condition Model\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OSCMNames\n";
    ss << "\\note Required only if Domain Has Basement Interaction\n";
    ss << "N17, \\field Convergence Criterion for the Outer Cartesian Domain Iteration Loop\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.000001\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.001\n";
    ss << "N18, \\field Maximum Iterations in the Outer Cartesian Domain Iteration Loop\n";
    ss << "\\type integer\n";
    ss << "\\minimum 3\n";
    ss << "\\maximum 10000\n";
    ss << "\\default 500\n";
    ss << "N19, \\field Evapotranspiration Ground Cover Parameter\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.5\n";
    ss << "\\default 0.4\n";
    ss << "\\note This specifies the ground cover effects during evapotranspiration\n";
    ss << "\\note  calculations.  The value roughly represents the following cases:\n";
    ss << "\\note  = 0   : concrete or other solid, non-permeable ground surface material\n";
    ss << "\\note  = 0.5 : short grass, much like a manicured lawn\n";
    ss << "\\note  = 1   : standard reference state (12 cm grass)\n";
    ss << "\\note  = 1.5 : wild growth\n";
    ss << "N20, \\field Number of Pipe Circuits Entered for this Domain\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "A11;  \\field Pipe Circuit 1\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PipingSystemUndergroundCircuitNames\n";
    ss << "\\note Name of a pipe circuit to be simulated in this domain\n";

    IddObjectType objType(IddObjectType::PipingSystem_Underground_Domain);
    OptionalIddObject oObj = IddObject::load("PipingSystem:Underground:Domain",
                                             "Node-Branch Management",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PipingSystem_Underground_Domain);
  return object;
}

IddObject createPipingSystem_Underground_PipeCircuitIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PipingSystem:Underground:PipeCircuit,\n";
    ss << "\\memo The pipe circuit object in an underground piping system.\n";
    ss << "\\memo This object is simulated within an underground piping domain object\n";
    ss << "\\memo  and connected on a branch on a plant loop.\n";
    ss << "\\min-fields 15\n";
    ss << "\\extensible:1\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference PipingSystemUndergroundCircuitNames\n";
    ss << "N1,  \\field Pipe Thermal Conductivity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum> 0\n";
    ss << "N2,  \\field Pipe Density\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units kg/m3\n";
    ss << "\\minimum> 0\n";
    ss << "N3,  \\field Pipe Specific Heat\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units J/kg-K\n";
    ss << "\\minimum> 0\n";
    ss << "N4,  \\field Pipe Inner Diameter\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "N5,  \\field Pipe Outer Diameter\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "N6,  \\field Design Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0\n";
    ss << "A2,  \\field Circuit Inlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3,  \\field Circuit Outlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N7,  \\field Convergence Criterion for the Inner Radial Iteration Loop\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.000001\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.001\n";
    ss << "N8,  \\field Maximum Iterations in the Inner Radial Iteration Loop\n";
    ss << "\\type integer\n";
    ss << "\\minimum 3\n";
    ss << "\\maximum 10000\n";
    ss << "\\default 500\n";
    ss << "N9,  \\field Number of Soil Nodes in the Inner Radial Near Pipe Mesh Region\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 15\n";
    ss << "\\default 3\n";
    ss << "N10, \\field Radial Thickness of Inner Radial Near Pipe Mesh Region\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Required because it must be selected by user instead of being\n";
    ss << "\\note  inferred from circuit/domain object inputs.\n";
    ss << "N11, \\field Number of Pipe Segments Entered for this Pipe Circuit\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "A4;  \\field Pipe Segment 1\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PipingSystemUndergroundSegmentNames\n";
    ss << "\\note Name of a pipe segment to be included in this pipe circuit\n";

    IddObjectType objType(IddObjectType::PipingSystem_Underground_PipeCircuit);
    OptionalIddObject oObj = IddObject::load("PipingSystem:Underground:PipeCircuit",
                                             "Node-Branch Management",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PipingSystem_Underground_PipeCircuit);
  return object;
}

IddObject createPipingSystem_Underground_PipeSegmentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PipingSystem:Underground:PipeSegment,\n";
    ss << "\\memo The pipe segment to be used in an underground piping system\n";
    ss << "\\memo This object represents a single pipe leg positioned axially\n";
    ss << "\\memo  in the local z-direction, at a given x, y location in the domain\n";
    ss << "\\min-fields 4\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference PipingSystemUndergroundSegmentNames\n";
    ss << "N1,  \\field X Position\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\note This segment will be centered at this distance from the x=0\n";
    ss << "\\note  domain surface or the basement wall surface, based on whether\n";
    ss << "\\note  a basement exists in this domain and the selection of the\n";
    ss << "\\note  shift input field found in the domain object.\n";
    ss << "N2,  \\field Y Position\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\note This segment will be centered at this distance away from the\n";
    ss << "\\note  ground surface; thus this value represents the burial depth\n";
    ss << "\\note  of this pipe segment.\n";
    ss << "A3;  \\field Flow Direction\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key IncreasingZ\n";
    ss << "\\key DecreasingZ\n";
    ss << "\\note This segment will be simulated such that the flow is in the\n";
    ss << "\\note  selected direction.  This can allow for detailed analysis\n";
    ss << "\\note  of circuiting effects in a single domain.\n";

    IddObjectType objType(IddObjectType::PipingSystem_Underground_PipeSegment);
    OptionalIddObject oObj = IddObject::load("PipingSystem:Underground:PipeSegment",
                                             "Node-Branch Management",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PipingSystem_Underground_PipeSegment);
  return object;
}

IddObject createDuctIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Duct,\n";
    ss << "\\memo Passes inlet node state variables to outlet node state variables\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3; \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::Duct);
    OptionalIddObject oObj = IddObject::load("Duct",
                                             "Node-Branch Management",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Duct);
  return object;
}

IddObject createPump_VariableSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Pump:VariableSpeed,\n";
    ss << "\\memo This pump model is described in the ASHRAE secondary HVAC toolkit.\n";
    ss << "\\min-fields 14\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3 , \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Design Maximum Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0\n";
    ss << "N2 , \\field Design Pump Head\n";
    ss << "\\units Pa\n";
    ss << "\\default 179352\n";
    ss << "\\note default head is 60 feet\n";
    ss << "\\ip-units ftH2O\n";
    ss << "N3 , \\field Design Power Consumption\n";
    ss << "\\note When autosized the type of scaling factor is chosen in the input field Design Power Sizing Method\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "N4 , \\field Motor Efficiency\n";
    ss << "\\note This is the motor efficiency only. When the Design Power Consumption is autosized using PowerPerFlowPerPressure,\n";
    ss << "\\note the Design Shaft Power per Unit Flow Rate per Unit Head is used in addition to the motor efficiency.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N5 , \\field Fraction of Motor Inefficiencies to Fluid Stream\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N6 , \\field Coefficient 1 of the Part Load Performance Curve\n";
    ss << "\\default 0.0\n";
    ss << "N7 , \\field Coefficient 2 of the Part Load Performance Curve\n";
    ss << "\\default 1.0\n";
    ss << "N8 , \\field Coefficient 3 of the Part Load Performance Curve\n";
    ss << "\\default 0.0\n";
    ss << "N9 , \\field Coefficient 4 of the Part Load Performance Curve\n";
    ss << "\\default 0.0\n";
    ss << "N10, \\field Design Minimum Flow Rate\n";
    ss << "\\note When autosized the scaling factor is the input field Design Minimum Flow Rate Fraction\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\ip-units gal/min\n";
    ss << "A4 , \\field Pump Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Continuous\n";
    ss << "\\key Intermittent\n";
    ss << "\\default Continuous\n";
    ss << "A5 , \\field Pump Flow Rate Schedule Name\n";
    ss << "\\note Modifies the rated flow rate of the pump on a time basis. Default is\n";
    ss << "\\note that the pump is on and runs according to its other operational requirements\n";
    ss << "\\note specified above.  The schedule is for special pump operations.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6 , \\field Pump Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note This references any single independent variable polynomial curve in order to\n";
    ss << "\\note  do pressure vs. flow calculations for this pump.  The available types are then:\n";
    ss << "\\note  Linear, Quadratic, Cubic, and Quartic\n";
    ss << "\\note The non-dimensional pump pressure relationship is of the following form:\n";
    ss << "\\note  (psi = C4*phi^4 + C3*phi^3 + C2*phi^2 + C1*phi + C0)\n";
    ss << "\\note Where the non-dimensional variables are defined as:\n";
    ss << "\\note  delP = rho * ((N/60)^2) * (D^2) * psi\n";
    ss << "\\note  mdot = rho * (N/60) * (D^3) * phi\n";
    ss << "N11 , \\field Impeller Diameter\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\note \"D\" in above expression in field A6\n";
    ss << "A7 ,  \\field VFD Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key ManualControl\n";
    ss << "\\key PressureSetpointControl\n";
    ss << "A8 ,  \\field Pump rpm Schedule Name\n";
    ss << "\\note Modifies the rpm of the pump on a time basis. Default is\n";
    ss << "\\note that the pump is on and runs according to its other operational requirements\n";
    ss << "\\note specified above.  The schedule is for special pump operations.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A9 ,  \\field Minimum Pressure Schedule\n";
    ss << "\\units Pa\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A10,  \\field Maximum Pressure Schedule\n";
    ss << "\\units Pa\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A11,  \\field Minimum RPM Schedule\n";
    ss << "\\units Rotations Per Minute\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A12,  \\field Maximum RPM Schedule\n";
    ss << "\\units Rotations Per Minute\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A13,  \\field Zone Name\n";
    ss << "\\note optional, if used pump losses transfered to zone as internal gains\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N12,  \\field Skin Loss Radiative Fraction\n";
    ss << "\\note optional. If zone identified in previous field then this determines\n";
    ss << "\\note the split between convection and radiation for the skin losses\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A14,  \\field Design Power Sizing Method\n";
    ss << "\\note Used to indicate which sizing factor is used to calculate Design Power Consumption.\n";
    ss << "\\type choice\n";
    ss << "\\key PowerPerFlow\n";
    ss << "\\note PowerPerFlow indicates that Design Electric Power per Unit Flow Rate is used as scaling factor.\n";
    ss << "\\note Design Power Consumption = Design Maximum Flow Rate * scaling factor\n";
    ss << "\\key PowerPerFlowPerPressure\n";
    ss << "\\note PowerPerFlowPerPressure indicates that Design Shaft Power per Unit Flow Rate per Unit Head is used as scaling factor.\n";
    ss << "\\note Design Power Consumption = Design Maximum Flow Rate * Design Pump Head * scaling factor / Motor Efficiency\n";
    ss << "\\default PowerPerFlowPerPressure\n";
    ss << "N13,  \\field Design Electric Power per Unit Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\note Used to size Design Power Consumption from design flow rate\n";
    ss << "\\default 348701.1\n";
    ss << "\\units W/(m3/s)\n";
    ss << "\\ip-units W/(gal/min)\n";
    ss << "\\minimum> 0\n";
    ss << "N14,  \\field Design Shaft Power per Unit Flow Rate per Unit Head\n";
    ss << "\\type real\n";
    ss << "\\note Used to size Design Power Consumption from design flow rate for head and motor efficiency\n";
    ss << "\\default 1.282051282\n";
    ss << "\\note units W/((m3/s)-Pa)\n";
    ss << "\\note ip-units W/((gal/min)-ftH20)\n";
    ss << "\\minimum> 0\n";
    ss << "N15;  \\field Design Minimum Flow Rate Fraction\n";
    ss << "\\type real\n";
    ss << "\\note Used to size Design Minimum Flow Rate\n";
    ss << "\\default 0.0\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";

    IddObjectType objType(IddObjectType::Pump_VariableSpeed);
    OptionalIddObject oObj = IddObject::load("Pump:VariableSpeed",
                                             "Pumps",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Pump_VariableSpeed);
  return object;
}

IddObject createPump_ConstantSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Pump:ConstantSpeed,\n";
    ss << "\\memo This pump model is described in the ASHRAE secondary HVAC toolkit.\n";
    ss << "\\min-fields 9\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3 , \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Design Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0\n";
    ss << "N2 , \\field Design Pump Head\n";
    ss << "\\units Pa\n";
    ss << "\\default 179352\n";
    ss << "\\note default head is 60 feet\n";
    ss << "\\ip-units ftH2O\n";
    ss << "N3 , \\field Design Power Consumption\n";
    ss << "\\note When autosized the type of scaling factor is chosen in the input field Design Power Sizing Method\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "N4 , \\field Motor Efficiency\n";
    ss << "\\note This is the motor efficiency only. When the Design Power Consumption is autosized using PowerPerFlowPerPressure,\n";
    ss << "\\note the Design Shaft Power per Unit Flow Rate per Unit Head is used in addition to the motor efficiency.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N5 , \\field Fraction of Motor Inefficiencies to Fluid Stream\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "A4 , \\field Pump Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Continuous\n";
    ss << "\\key Intermittent\n";
    ss << "\\default Continuous\n";
    ss << "A5 , \\field Pump Flow Rate Schedule Name\n";
    ss << "\\note Modifies the rated flow rate of the pump on a time basis. Default is\n";
    ss << "\\note that the pump is on and runs according to its other operational requirements\n";
    ss << "\\note specified above.  The schedule is for special pump operations.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6 , \\field Pump Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note This references any single independent variable polynomial curve in order to\n";
    ss << "\\note  do pressure vs. flow calculations for this pump.  The available types are then:\n";
    ss << "\\note  Linear, Quadratic, Cubic, and Quartic\n";
    ss << "\\note The non-dimensional pump pressure relationship is of the following form:\n";
    ss << "\\note  (psi = C4*phi^4 + C3*phi^3 + C2*phi^2 + C1*phi + C0)\n";
    ss << "\\note Where the non-dimensional variables are defined as:\n";
    ss << "\\note  delP = rho * ((N/60)^2) * (D^2) * psi\n";
    ss << "\\note  mdot = rho * (N/60) * (D^3) * phi\n";
    ss << "N6 , \\field Impeller Diameter\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\note \"D\" in above expression in field A6\n";
    ss << "N7 , \\field Rotational Speed\n";
    ss << "\\units rev/min\n";
    ss << "\\type real\n";
    ss << "\\note \"N\" in above expression in field A6\n";
    ss << "A7,  \\field Zone Name\n";
    ss << "\\note optional, if used pump losses transfered to zone as internal gains\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N8,  \\field Skin Loss Radiative Fraction\n";
    ss << "\\note optional. If zone identified in previous field then this determines\n";
    ss << "\\note the split between convection and radiation for the skin losses\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A8,  \\field Design Power Sizing Method\n";
    ss << "\\note Used to indicate which sizing factor is used to calculate Design Power Consumption.\n";
    ss << "\\type choice\n";
    ss << "\\key PowerPerFlow\n";
    ss << "\\note PowerPerFlow indicates that Design Electric Power per Unit Flow Rate is used as scaling factor.\n";
    ss << "\\note Design Power Consumption = Design Maximum Flow Rate * scaling factor\n";
    ss << "\\key PowerPerFlowPerPressure\n";
    ss << "\\note PowerPerFlowPerPressure indicates that Design Shaft Power per Unit Flow Rate per Unit Head is used as scaling factor.\n";
    ss << "\\note Design Power Consumption = Design Maximum Flow Rate * Design Pump Head * scaling factor / Motor Efficiency\n";
    ss << "\\default PowerPerFlowPerPressure\n";
    ss << "N9,  \\field Design Electric Power per Unit Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\note Used to size Design Power Consumption from design flow rate\n";
    ss << "\\default 348701.1\n";
    ss << "\\units W/(m3/s)\n";
    ss << "\\ip-units W/(gal/min)\n";
    ss << "\\minimum> 0\n";
    ss << "N10; \\field Design Shaft Power per Unit Flow Rate per Unit Head\n";
    ss << "\\type real\n";
    ss << "\\note Used to size Design Power Consumption from design flow rate for head and motor efficiency\n";
    ss << "\\default 1.282051282\n";
    ss << "\\note units W/((m3/s)-Pa)\n";
    ss << "\\note ip-units W/((gal/min)-ftH20)\n";
    ss << "\\minimum> 0\n";

    IddObjectType objType(IddObjectType::Pump_ConstantSpeed);
    OptionalIddObject oObj = IddObject::load("Pump:ConstantSpeed",
                                             "Pumps",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Pump_ConstantSpeed);
  return object;
}

IddObject createPump_VariableSpeed_CondensateIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Pump:VariableSpeed:Condensate,\n";
    ss << "\\memo This pump model is described in the ASHRAE secondary HVAC toolkit.\n";
    ss << "\\memo Variable Speed Condensate pump for Steam Systems\n";
    ss << "\\min-fields 13\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3 , \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Design Steam Volume Flow Rate\n";
    ss << "\\note this is the volume of steam before condensation, the volume of condensate is much lower and calculated from steam density\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0\n";
    ss << "N2 , \\field Design Pump Head\n";
    ss << "\\units Pa\n";
    ss << "\\default 179352\n";
    ss << "\\note default head is 60 feet\n";
    ss << "\\ip-units ftH2O\n";
    ss << "N3 , \\field Design Power Consumption\n";
    ss << "\\note When autosized the type of scaling factor is chosen in the input field Design Power Sizing Method\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "N4 , \\field Motor Efficiency\n";
    ss << "\\note This is the motor efficiency only. When the Design Power Consumption is autosized using PowerPerFlowPerPressure,\n";
    ss << "\\note the Design Shaft Power per Unit Flow Rate per Unit Head is used in addition to the motor efficiency.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N5 , \\field Fraction of Motor Inefficiencies to Fluid Stream\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N6 , \\field Coefficient 1 of the Part Load Performance Curve\n";
    ss << "\\default 0.0\n";
    ss << "N7 , \\field Coefficient 2 of the Part Load Performance Curve\n";
    ss << "\\default 1.0\n";
    ss << "N8 , \\field Coefficient 3 of the Part Load Performance Curve\n";
    ss << "\\default 0.0\n";
    ss << "N9,  \\field Coefficient 4 of the Part Load Performance Curve\n";
    ss << "\\default 0.0\n";
    ss << "A4 , \\field Pump Flow Rate Schedule Name\n";
    ss << "\\note Modifies the rated flow rate of the pump on a time basis. Default is\n";
    ss << "\\note that the pump is on and runs according to its other operational requirements\n";
    ss << "\\note specified above.  The schedule is for special pump operations.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5 , \\field Zone Name\n";
    ss << "\\note optional, if used pump losses transfered to zone as internal gains\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N10, \\field Skin Loss Radiative Fraction\n";
    ss << "\\note optional. If zone identified in previous field then this determines\n";
    ss << "\\note the split between convection and radiation for the skin losses\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A6,  \\field Design Power Sizing Method\n";
    ss << "\\note Used to indicate which sizing factor is used to calculate Design Power Consumption.\n";
    ss << "\\type choice\n";
    ss << "\\key PowerPerFlow\n";
    ss << "\\note PowerPerFlow indicates that Design Electric Power per Unit Flow Rate is used as scaling factor.\n";
    ss << "\\note Design Power Consumption = Design Maximum Flow Rate * scaling factor\n";
    ss << "\\key PowerPerFlowPerPressure\n";
    ss << "\\note PowerPerFlowPerPressure indicates that Design Shaft Power per Unit Flow Rate per Unit Head is used as scaling factor.\n";
    ss << "\\note Design Power Consumption = Design Maximum Flow Rate * Design Pump Head * scaling factor / Motor Efficiency\n";
    ss << "\\default PowerPerFlowPerPressure\n";
    ss << "N11, \\field Design Electric Power per Unit Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\note Used to size Design Power Consumption from design flow rate\n";
    ss << "\\default 348701.1\n";
    ss << "\\units W/(m3/s)\n";
    ss << "\\ip-units W/(gal/min)\n";
    ss << "\\minimum> 0\n";
    ss << "N12; \\field Design Shaft Power per Unit Flow Rate per Unit Head\n";
    ss << "\\type real\n";
    ss << "\\note Used to size Design Power Consumption from design flow rate for head and motor efficiency\n";
    ss << "\\default 1.282051282\n";
    ss << "\\note units W/((m3/s)-Pa)\n";
    ss << "\\note ip-units W/((gal/min)-ftH20)\n";
    ss << "\\minimum> 0\n";

    IddObjectType objType(IddObjectType::Pump_VariableSpeed_Condensate);
    OptionalIddObject oObj = IddObject::load("Pump:VariableSpeed:Condensate",
                                             "Pumps",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Pump_VariableSpeed_Condensate);
  return object;
}

IddObject createHeaderedPumps_ConstantSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HeaderedPumps:ConstantSpeed,\n";
    ss << "\\memo This Headered pump object describes a pump bank with more than 1 pump in parallel\n";
    ss << "\\min-fields 9\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3 , \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Total Design Flow Rate\n";
    ss << "\\note If the field is not autosized set to the flow rate to\n";
    ss << "\\note the total flow when all pumps are running at full load\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0\n";
    ss << "N2 , \\field Number of Pumps in Bank\n";
    ss << "\\type integer\n";
    ss << "A4 , \\field Flow Sequencing Control Scheme\n";
    ss << "\\type choice\n";
    ss << "\\key Sequential\n";
    ss << "\\default Sequential\n";
    ss << "N3 , \\field Design Pump Head\n";
    ss << "\\units Pa\n";
    ss << "\\default 179352\n";
    ss << "\\note default head is 60 feet\n";
    ss << "\\ip-units ftH2O\n";
    ss << "N4 , \\field Design Power Consumption\n";
    ss << "\\note If the field is not autosized set to the power consumed by the pump bank\n";
    ss << "\\note when all the pumps are running at nominal flow\n";
    ss << "\\note When autosized the type of scaling factor is chosen in the input field Design Power Sizing Method\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "N5 , \\field Motor Efficiency\n";
    ss << "\\note This is the motor efficiency only. When the Design Power Consumption is autosized using PowerPerFlowPerPressure,\n";
    ss << "\\note the Design Shaft Power per Unit Flow Rate per Unit Head is used in addition to the motor efficiency.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N6 , \\field Fraction of Motor Inefficiencies to Fluid Stream\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "A5 , \\field Pump Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Continuous\n";
    ss << "\\key Intermittent\n";
    ss << "\\default Continuous\n";
    ss << "A6 , \\field Pump Flow Rate Schedule Name\n";
    ss << "\\note Modifies the rated flow rate of the pump on a time basis. Default is\n";
    ss << "\\note that the pump is on and runs according to its other operational requirements\n";
    ss << "\\note specified above.  The schedule is for special pump operations.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A7 , \\field Zone Name\n";
    ss << "\\note optional, if used pump losses transfered to zone as internal gains\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N7 , \\field Skin Loss Radiative Fraction\n";
    ss << "\\note optional. If zone identified in previous field then this determines\n";
    ss << "\\note the split between convection and radiation for the skin losses\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A8,  \\field Design Power Sizing Method\n";
    ss << "\\note Used to indicate which sizing factor is used to calculate Design Power Consumption.\n";
    ss << "\\type choice\n";
    ss << "\\key PowerPerFlow\n";
    ss << "\\note PowerPerFlow indicates that Design Electric Power per Unit Flow Rate is used as scaling factor.\n";
    ss << "\\note Design Power Consumption = Design Maximum Flow Rate * scaling factor\n";
    ss << "\\key PowerPerFlowPerPressure\n";
    ss << "\\note PowerPerFlowPerPressure indicates that Design Shaft Power per Unit Flow Rate per Unit Head is used as scaling factor.\n";
    ss << "\\note Design Power Consumption = Design Maximum Flow Rate * Design Pump Head * scaling factor / Motor Efficiency\n";
    ss << "\\default PowerPerFlowPerPressure\n";
    ss << "N8,  \\field Design Electric Power per Unit Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\note Used to size Design Power Consumption from design flow rate\n";
    ss << "\\default 348701.1\n";
    ss << "\\units W/(m3/s)\n";
    ss << "\\ip-units W/(gal/min)\n";
    ss << "\\minimum> 0\n";
    ss << "N9; \\field Design Shaft Power per Unit Flow Rate per Unit Head\n";
    ss << "\\type real\n";
    ss << "\\note Used to size Design Power Consumption from design flow rate for head and motor efficiency\n";
    ss << "\\default 1.282051282\n";
    ss << "\\note units W/((m3/s)-Pa)\n";
    ss << "\\note ip-units W/((gal/min)-ftH20)\n";
    ss << "\\minimum> 0\n";

    IddObjectType objType(IddObjectType::HeaderedPumps_ConstantSpeed);
    OptionalIddObject oObj = IddObject::load("HeaderedPumps:ConstantSpeed",
                                             "Pumps",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HeaderedPumps_ConstantSpeed);
  return object;
}

IddObject createHeaderedPumps_VariableSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HeaderedPumps:VariableSpeed,\n";
    ss << "\\memo This Headered pump object describes a pump bank with more than 1 pump in parallel\n";
    ss << "\\min-fields 14\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3 , \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Total Design Flow Rate\n";
    ss << "\\note If the field is not autosized set to the flow rate to\n";
    ss << "\\note the total flow when all pumps are running at full load\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0\n";
    ss << "N2 , \\field Number of Pumps in Bank\n";
    ss << "\\type integer\n";
    ss << "A4 , \\field Flow Sequencing Control Scheme\n";
    ss << "\\type choice\n";
    ss << "\\key Sequential\n";
    ss << "\\default Sequential\n";
    ss << "N3 , \\field Design Pump Head\n";
    ss << "\\units Pa\n";
    ss << "\\default 179352\n";
    ss << "\\note default head is 60 feet\n";
    ss << "\\ip-units ftH2O\n";
    ss << "N4 , \\field Design Power Consumption\n";
    ss << "\\note If the field is not autosized set to the power consumed by the pump bank\n";
    ss << "\\note when all the pumps are running at nominal flow\n";
    ss << "\\note When autosized the type of scaling factor is chosen in the input field Design Power Sizing Method\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "N5 , \\field Motor Efficiency\n";
    ss << "\\note This is the motor efficiency only. When the Design Power Consumption is autosized using PowerPerFlowPerPressure,\n";
    ss << "\\note the Design Shaft Power per Unit Flow Rate per Unit Head is used in addition to the motor efficiency.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N6 , \\field Fraction of Motor Inefficiencies to Fluid Stream\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N7 , \\field Coefficient 1 of the Part Load Performance Curve\n";
    ss << "\\default 0.0\n";
    ss << "N8 , \\field Coefficient 2 of the Part Load Performance Curve\n";
    ss << "\\default 1.0\n";
    ss << "N9, \\field Coefficient 3 of the Part Load Performance Curve\n";
    ss << "\\default 0.0\n";
    ss << "N10, \\field Coefficient 4 of the Part Load Performance Curve\n";
    ss << "\\default 0.0\n";
    ss << "N11, \\field Minimum Flow Rate Fraction\n";
    ss << "\\note This value can be zero and will be defaulted to that if not specified.\n";
    ss << "\\default 0.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A5 , \\field Pump Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Continuous\n";
    ss << "\\key Intermittent\n";
    ss << "\\default Continuous\n";
    ss << "A6 , \\field Pump Flow Rate Schedule Name\n";
    ss << "\\note Modifies the rated flow rate of the pump on a time basis. Default is\n";
    ss << "\\note that the pump is on and runs according to its other operational requirements\n";
    ss << "\\note specified above.  The schedule is for special pump operations.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A7 , \\field Zone Name\n";
    ss << "\\note optional, if used pump losses transfered to zone as internal gains\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N12, \\field Skin Loss Radiative Fraction\n";
    ss << "\\note optional. If zone identified in previous field then this determines\n";
    ss << "\\note the split between convection and radiation for the skin losses\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A8,  \\field Design Power Sizing Method\n";
    ss << "\\note Used to indicate which sizing factor is used to calculate Design Power Consumption.\n";
    ss << "\\type choice\n";
    ss << "\\key PowerPerFlow\n";
    ss << "\\note PowerPerFlow indicates that Design Electric Power per Unit Flow Rate is used as scaling factor.\n";
    ss << "\\note Design Power Consumption = Design Maximum Flow Rate * scaling factor\n";
    ss << "\\key PowerPerFlowPerPressure\n";
    ss << "\\note PowerPerFlowPerPressure indicates that Design Shaft Power per Unit Flow Rate per Unit Head is used as scaling factor.\n";
    ss << "\\note Design Power Consumption = Design Maximum Flow Rate * Design Pump Head * scaling factor / Motor Efficiency\n";
    ss << "\\default PowerPerFlowPerPressure\n";
    ss << "N13, \\field Design Electric Power per Unit Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\note Used to size Design Power Consumption from design flow rate\n";
    ss << "\\default 348701.1\n";
    ss << "\\units W/(m3/s)\n";
    ss << "\\ip-units W/(gal/min)\n";
    ss << "\\minimum> 0\n";
    ss << "N14; \\field Design Shaft Power per Unit Flow Rate per Unit Head\n";
    ss << "\\type real\n";
    ss << "\\note Used to size Design Power Consumption from design flow rate for head and motor efficiency\n";
    ss << "\\default 1.282051282\n";
    ss << "\\note units W/((m3/s)-Pa)\n";
    ss << "\\note ip-units W/((gal/min)-ftH20)\n";
    ss << "\\minimum> 0\n";

    IddObjectType objType(IddObjectType::HeaderedPumps_VariableSpeed);
    OptionalIddObject oObj = IddObject::load("HeaderedPumps:VariableSpeed",
                                             "Pumps",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HeaderedPumps_VariableSpeed);
  return object;
}

IddObject createTemperingValveIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "TemperingValve,\n";
    ss << "\\memo Temperature-controlled diversion valve used to divert flow around one or more plant\n";
    ss << "\\memo components such as a hot water heater. It can only be used on one of two branches\n";
    ss << "\\memo between a Splitter and a Mixer.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2, \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of a Node\n";
    ss << "A3, \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of a Node\n";
    ss << "A4, \\field Stream 2 Source Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of a Node\n";
    ss << "A5, \\field Temperature Setpoint Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of a Node\n";
    ss << "A6; \\field Pump Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::TemperingValve);
    OptionalIddObject oObj = IddObject::load("TemperingValve",
                                             "Plant-Condenser Flow Control",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::TemperingValve);
  return object;
}

IddObject createLoadProfile_PlantIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "LoadProfile:Plant,\n";
    ss << "\\memo Used to simulate a scheduled plant loop demand profile.  Load and flow rate are\n";
    ss << "\\memo specified using schedules. Positive values are heating loads, and negative values are\n";
    ss << "\\memo cooling loads. The actual load met is dependent on the performance of the supply\n";
    ss << "\\memo loop components.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3 , \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Load Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values are load in [W]\n";
    ss << "N1 , \\field Peak Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "A5 ; \\field Flow Rate Fraction Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::LoadProfile_Plant);
    OptionalIddObject oObj = IddObject::load("LoadProfile:Plant",
                                             "Non-Zone Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::LoadProfile_Plant);
  return object;
}

IddObject createSolarCollectorPerformance_FlatPlateIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SolarCollectorPerformance:FlatPlate,\n";
    ss << "\\memo Thermal and optical performance parameters for a single flat plate solar collector\n";
    ss << "\\memo module. These parameters are based on the testing methodologies described in ASHRAE\n";
    ss << "\\memo Standards 93 and 96 which are used Solar Rating and Certification Corporation (SRCC)\n";
    ss << "\\memo Directory of SRCC Certified Solar Collector Ratings. See EnergyPlus DataSets file\n";
    ss << "\\memo SolarCollectors.idf.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference FlatPlateSolarCollectorParameters\n";
    ss << "N1 , \\field Gross Area\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\units m2\n";
    ss << "A2,  \\field Test Fluid\n";
    ss << "\\type choice\n";
    ss << "\\key Water\n";
    ss << "\\default Water\n";
    ss << "N2,  \\field Test Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "A3 , \\field Test Correlation Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Inlet\n";
    ss << "\\key Average\n";
    ss << "\\key Outlet\n";
    ss << "N3 , \\field Coefficient 1 of Efficiency Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Y-intercept term\n";
    ss << "N4 , \\field Coefficient 2 of Efficiency Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\note 1st Order term\n";
    ss << "N5 , \\field Coefficient 3 of Efficiency Equation\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K2\n";
    ss << "\\note 2nd order term\n";
    ss << "N6 , \\field Coefficient 2 of Incident Angle Modifier\n";
    ss << "\\type real\n";
    ss << "\\note 1st order term\n";
    ss << "N7 ; \\field Coefficient 3 of Incident Angle Modifier\n";
    ss << "\\type real\n";
    ss << "\\note 2nd order term\n";

    IddObjectType objType(IddObjectType::SolarCollectorPerformance_FlatPlate);
    OptionalIddObject oObj = IddObject::load("SolarCollectorPerformance:FlatPlate",
                                             "Solar Collectors",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SolarCollectorPerformance_FlatPlate);
  return object;
}

IddObject createSolarCollector_FlatPlate_WaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SolarCollector:FlatPlate:Water,\n";
    ss << "\\memo Flat plate water solar collector (single glazed, unglazed, or evacuated tube).\n";
    ss << "\\memo Thermal and optical properties are taken from the referenced\n";
    ss << "\\memo SolarCollectorPerformance:FlatPlate object. Collector tilt, azimuth, and gross area\n";
    ss << "\\memo are taken from the referenced building surface or shading surface. The collector\n";
    ss << "\\memo surface participates normally in all shading calculations.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field SolarCollectorPerformance Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FlatPlateSolarCollectorParameters\n";
    ss << "A3 , \\field Surface Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllShadingAndHTSurfNames\n";
    ss << "A4 , \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 ; \\field Maximum Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";

    IddObjectType objType(IddObjectType::SolarCollector_FlatPlate_Water);
    OptionalIddObject oObj = IddObject::load("SolarCollector:FlatPlate:Water",
                                             "Solar Collectors",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SolarCollector_FlatPlate_Water);
  return object;
}

IddObject createSolarCollector_FlatPlate_PhotovoltaicThermalIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SolarCollector:FlatPlate:PhotovoltaicThermal,\n";
    ss << "\\memo Models hybrid photovoltaic-thermal (PVT) solar collectors that convert incident solar\n";
    ss << "\\memo energy into both electricity and useful thermal energy by heating air or water.\n";
    ss << "A1 , \\field Name\n";
    ss << "A2 , \\field Surface Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllShadingAndHTSurfNames\n";
    ss << "A3 , \\field Photovoltaic-Thermal Model Performance Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FlatPlatePVTParameters\n";
    ss << "A4 , \\field Photovoltaic Name\n";
    ss << "\\note Enter the name of a Generator:Photovoltaic object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PVGeneratorNames\n";
    ss << "A5 , \\field Thermal Working Fluid Type\n";
    ss << "\\type choice\n";
    ss << "\\key Water\n";
    ss << "\\key Air\n";
    ss << "A6 , \\field Water Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A7 , \\field Water Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A8 , \\field Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A9 , \\field Air Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N1 ; \\field Design Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";

    IddObjectType objType(IddObjectType::SolarCollector_FlatPlate_PhotovoltaicThermal);
    OptionalIddObject oObj = IddObject::load("SolarCollector:FlatPlate:PhotovoltaicThermal",
                                             "Solar Collectors",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SolarCollector_FlatPlate_PhotovoltaicThermal);
  return object;
}

IddObject createSolarCollector_IntegralCollectorStorageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SolarCollector:IntegralCollectorStorage,\n";
    ss << "\\memo Glazed solar collector with integral storage unit. Thermal and optical properties are\n";
    ss << "\\memo taken from the referenced SolarCollectorPerformance:IntegralCollectorStorage object.\n";
    ss << "\\memo Collector tilt, azimuth, and gross area are taken from the referenced building surface\n";
    ss << "\\memo or shading surface. The collector surface participates normally in all shading\n";
    ss << "\\memo calculations.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field IntegralCollectorStorageParameters Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CollectorStoragePerformance\n";
    ss << "A3 , \\field Surface Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllShadingAndHTSurfNames\n";
    ss << "A4 , \\field Bottom Surface Boundary Conditions Type\n";
    ss << "\\type choice\n";
    ss << "\\key OtherSideConditionsModel\n";
    ss << "\\key AmbientAir\n";
    ss << "\\default AmbientAir\n";
    ss << "A5 , \\field Boundary Condition Model Name\n";
    ss << "\\type alpha\n";
    ss << "\\note Enter the name of a SurfaceProperty:OtherSideConditionsModel\n";
    ss << "\\note object. Specified only if the boundary condition type is\n";
    ss << "\\note OtherSideConditionsModel, otherwise leave it blank\n";
    ss << "A6 , \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7 , \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 ; \\field Maximum Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";

    IddObjectType objType(IddObjectType::SolarCollector_IntegralCollectorStorage);
    OptionalIddObject oObj = IddObject::load("SolarCollector:IntegralCollectorStorage",
                                             "Solar Collectors",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SolarCollector_IntegralCollectorStorage);
  return object;
}

IddObject createSolarCollectorPerformance_IntegralCollectorStorageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SolarCollectorPerformance:IntegralCollectorStorage,\n";
    ss << "\\memo Thermal and optical performance parameters for a single glazed solar collector with\n";
    ss << "\\memo integral storage unit.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CollectorStoragePerformance\n";
    ss << "A2,  \\field ICS Collector Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key RectangularTank\n";
    ss << "\\note Currently only RectangularTank ICS collector type is available.\n";
    ss << "N1,  \\field Gross Area\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\units m2\n";
    ss << "N2,  \\field Collector Water Volume\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\units m3\n";
    ss << "\\ip-units gal\n";
    ss << "N3,  \\field Bottom Heat Loss Conductance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.40\n";
    ss << "\\units W/m2-K\n";
    ss << "\\note Heat loss conductance of the collector bottom insulation\n";
    ss << "N4,  \\field Side Heat Loss Conductance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.60\n";
    ss << "\\units W/m2-K\n";
    ss << "\\note heat loss conductance of the collector side insulation\n";
    ss << "N5,  \\field Aspect Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.5\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\default 0.8\n";
    ss << "\\units m\n";
    ss << "\\note This value is ratio of the width (short side) to length\n";
    ss << "\\note (long side of) of the collector.  Used to calculate the\n";
    ss << "\\note perimeter of the collector\n";
    ss << "N6,  \\field Collector Side Height\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum< 0.30\n";
    ss << "\\default 0.20\n";
    ss << "\\units m\n";
    ss << "\\note This value is used to estimate collector side area for the heat\n";
    ss << "\\note loss calculation through the collector side\n";
    ss << "N7,  \\field Thermal Mass of Absorber Plate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\units J/m2-K\n";
    ss << "\\note Calculated from the specific heat, density and thickness\n";
    ss << "\\note of the absorber plate.\n";
    ss << "N8,  \\field Number of Covers\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 2\n";
    ss << "\\default 2\n";
    ss << "\\note Number of transparent covers. Common practice is to use low-iron\n";
    ss << "\\note glass as the outer cover and very thin transparent sheet such as\n";
    ss << "\\note Teflon as the inner cover.\n";
    ss << "N9,  \\field Cover Spacing\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 0.20\n";
    ss << "\\default 0.05\n";
    ss << "\\units m\n";
    ss << "\\note The gap between the transparent covers and between the inner cover\n";
    ss << "\\note and the absorber plate\n";
    ss << "N10,  \\field Refractive Index of Outer Cover\n";
    ss << "\\type real\n";
    ss << "\\minimum 1.0\n";
    ss << "\\maximum 2.0\n";
    ss << "\\default 1.526\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Refractive index of outer cover. Typically low-iron glass is used\n";
    ss << "\\note as the outer cover material, and used as the default outer cover\n";
    ss << "\\note with a value of 1.526.\n";
    ss << "N11,  \\field Extinction Coefficient Times Thickness of Outer Cover\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.\n";
    ss << "\\default 0.045\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Clear glass has extinction coefficient of about 15 [1/m]\n";
    ss << "\\note and with thickness of 3.0mm, the product of the extinction\n";
    ss << "\\note coefficient and thickness becomes 0.045 (=15 * 0.003)\n";
    ss << "N12,  \\field Emissivity of Outer Cover\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\default 0.88\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Thermal emissivity of the outer cover, commonly glass is used as\n";
    ss << "\\note the out collector cover material.\n";
    ss << "N13,  \\field Refractive Index of Inner Cover\n";
    ss << "\\type real\n";
    ss << "\\minimum 1.0\n";
    ss << "\\maximum 2.0\n";
    ss << "\\default 1.37\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Typical material is very thin sheet of Teflon (PTFE). The default\n";
    ss << "\\note value is refractive index of Teflon.\n";
    ss << "N14, \\field Extinction Coefficient Times Thickness of the inner Cover\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.\n";
    ss << "\\default 0.008\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Default inner cover is very thin sheet of Teflon with\n";
    ss << "\\note extinction coefficient of approximately 40.0 and a thickness\n";
    ss << "\\note 0.2mm yields a default value of 0.008.\n";
    ss << "N15, \\field Emissivity of Inner Cover\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\default 0.88\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Thermal emissivity of the inner cover material\n";
    ss << "N16, \\field Absorptance of Absorber Plate\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\default 0.96\n";
    ss << "\\units dimensionless\n";
    ss << "\\note The absorber plate solar absorptance.  Copper is assumed as\n";
    ss << "\\note the default absorber plate.\n";
    ss << "N17; \\field Emissivity of Absorber Plate\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\default 0.30\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Thermal emissivity of the absorber plate\n";

    IddObjectType objType(IddObjectType::SolarCollectorPerformance_IntegralCollectorStorage);
    OptionalIddObject oObj = IddObject::load("SolarCollectorPerformance:IntegralCollectorStorage",
                                             "Solar Collectors",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SolarCollectorPerformance_IntegralCollectorStorage);
  return object;
}

IddObject createSolarCollector_UnglazedTranspiredIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SolarCollector:UnglazedTranspired,\n";
    ss << "\\memo Unglazed transpired solar collector (UTSC) used to condition outdoor air. This type of\n";
    ss << "\\memo collector is generally used to heat air drawn through perforated absorbers and also\n";
    ss << "\\memo recover heat conducted out through the underlying surface. This object represents a\n";
    ss << "\\memo single collector attached to one or more building or shading surfaces and to one or\n";
    ss << "\\memo more outdoor air systems.\n";
    ss << "\\min-fields 23\n";
    ss << "\\extensible:1 - repeat last field, remembering to remove ; from \"inner\" fields.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference UTSCNames\n";
    ss << "A2,  \\field Boundary Conditions Model Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OSCMNames\n";
    ss << "\\note Enter the name of a SurfaceProperty:OtherSideConditionsModel object\n";
    ss << "A3 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this collector. Schedule value > 0 means it is available.\n";
    ss << "\\note If this field is blank, the collector is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note required field if no SolarCollector:UnglazedTranspired:Multisystem\n";
    ss << "A5 , \\field Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note required field if no SolarCollector:UnglazedTranspired:Multisystem\n";
    ss << "A6,  \\field Setpoint Node Name\n";
    ss << "\\type node\n";
    ss << "\\note This node is where the mixed air setpoint is determined.\n";
    ss << "\\note required field if no SolarCollector:UnglazedTranspired:Multisystem\n";
    ss << "A7,  \\field Zone Node Name\n";
    ss << "\\type node\n";
    ss << "\\note This node is used to identify the affected zone\n";
    ss << "\\note required field if no SolarCollector:UnglazedTranspired:Multisystem\n";
    ss << "A8,  \\field Free Heating Setpoint Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1,  \\field Diameter of Perforations in Collector\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\units m\n";
    ss << "N2,  \\field Distance Between Perforations in Collector\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\units m\n";
    ss << "N3,  \\field Thermal Emissivity of Collector Surface\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\units dimensionless\n";
    ss << "N4,  \\field Solar Absorbtivity of Collector Surface\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\units dimensionless\n";
    ss << "N5, \\field Effective Overall Height of Collector\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N6,  \\field Effective Gap Thickness of Plenum Behind Collector\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.\n";
    ss << "\\units m\n";
    ss << "\\note if corrugated, use average depth\n";
    ss << "N7,  \\field Effective Cross Section Area of Plenum Behind Collector\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\units m2\n";
    ss << "\\note if corrugated, use average depth\n";
    ss << "A9,  \\field Hole Layout Pattern for Pitch\n";
    ss << "\\type choice\n";
    ss << "\\key Triangle\n";
    ss << "\\key Square\n";
    ss << "\\default Square\n";
    ss << "A10,  \\field Heat Exchange Effectiveness Correlation\n";
    ss << "\\type choice\n";
    ss << "\\key Kutscher1994\n";
    ss << "\\key VanDeckerHollandsBrunger2001\n";
    ss << "\\default Kutscher1994\n";
    ss << "N8,  \\field Ratio of Actual Collector Surface Area to Projected Surface Area\n";
    ss << "\\type real\n";
    ss << "\\note This parameter is used to help account for corrugations in the collector\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum 1.0\n";
    ss << "\\maximum 2.0\n";
    ss << "\\units dimensionless\n";
    ss << "A11, \\field Roughness of Collector\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key VeryRough\n";
    ss << "\\key Rough\n";
    ss << "\\key MediumRough\n";
    ss << "\\key MediumSmooth\n";
    ss << "\\key Smooth\n";
    ss << "\\key VerySmooth\n";
    ss << "N9, \\field Collector Thickness\n";
    ss << "\\type real\n";
    ss << "\\note Collector thickness is not required for Kutscher correlation\n";
    ss << "\\note Collector thickness is required for Van Decker et al. correlation\n";
    ss << "\\minimum 0.0005\n";
    ss << "\\maximum 0.007\n";
    ss << "\\units m\n";
    ss << "N10, \\field Effectiveness for Perforations with Respect to Wind\n";
    ss << "\\note Cv\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 0.25\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1.5\n";
    ss << "N11, \\field Discharge Coefficient for Openings with Respect to Buoyancy Driven Flow\n";
    ss << "\\note Cd\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 0.65\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.5\n";
    ss << "A12; \\field Surface 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllShadingAndHTSurfNames\n";

    IddObjectType objType(IddObjectType::SolarCollector_UnglazedTranspired);
    OptionalIddObject oObj = IddObject::load("SolarCollector:UnglazedTranspired",
                                             "Solar Collectors",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SolarCollector_UnglazedTranspired);
  return object;
}

IddObject createSolarCollectorPerformance_PhotovoltaicThermal_SimpleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SolarCollectorPerformance:PhotovoltaicThermal:Simple,\n";
    ss << "\\memo Thermal performance parameters for a hybrid photovoltaic-thermal (PVT) solar collector.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\reference FlatPlatePVTParameters\n";
    ss << "N1 , \\field Fraction of Surface Area with Active Thermal Collector\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A2 , \\field Thermal Conversion Efficiency Input Mode Type\n";
    ss << "\\type choice\n";
    ss << "\\key Fixed\n";
    ss << "\\key Scheduled\n";
    ss << "N2 , \\field Value for Thermal Conversion Efficiency if Fixed\n";
    ss << "\\note Efficiency = (thermal power generated [W])/(incident solar[W])\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A3 , \\field Thermal Conversion Efficiency Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N3 ; \\field Front Surface Emittance\n";
    ss << "\\type real\n";
    ss << "\\default 0.84\n";
    ss << "\\minimum> 0.00\n";
    ss << "\\maximum< 1.00\n";

    IddObjectType objType(IddObjectType::SolarCollectorPerformance_PhotovoltaicThermal_Simple);
    OptionalIddObject oObj = IddObject::load("SolarCollectorPerformance:PhotovoltaicThermal:Simple",
                                             "Solar Collectors",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SolarCollectorPerformance_PhotovoltaicThermal_Simple);
  return object;
}

IddObject createSolarCollector_UnglazedTranspired_MultisystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SolarCollector:UnglazedTranspired:Multisystem,\n";
    ss << "\\extensible:4 - repeat last four fields, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\memo quad-tuples of inlet, outlet, control, and zone nodes\n";
    ss << "\\memo for multiple different outdoor air systems attached to same collector\n";
    ss << "A1 , \\field Solar Collector Name\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the name of a SolarCollector:UnglazedTranspired object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UTSCNames\n";
    ss << "A2 , \\field Outdoor Air System 1 Collector Inlet Node\n";
    ss << "\\begin-extensible\n";
    ss << "\\type node\n";
    ss << "A3 , \\field Outdoor Air System 1 Collector Outlet Node\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Outdoor Air System 1 Mixed Air Node\n";
    ss << "\\type node\n";
    ss << "A5 ; \\field Outdoor Air System 1 Zone Node\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::SolarCollector_UnglazedTranspired_Multisystem);
    OptionalIddObject oObj = IddObject::load("SolarCollector:UnglazedTranspired:Multisystem",
                                             "Solar Collectors",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SolarCollector_UnglazedTranspired_Multisystem);
  return object;
}

IddObject createBoiler_HotWaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Boiler:HotWater,\n";
    ss << "\\min-fields 13\n";
    ss << "\\memo This boiler model is an adaptation of the empirical model from the Building\n";
    ss << "\\memo Loads and System Thermodynamics (BLAST) program.  Boiler performance\n";
    ss << "\\memo curves are generated by fitting catalog data to polynomial equations.\n";
    ss << "\\memo A constant efficiency boiler may be modeled by leaving the normalized\n";
    ss << "\\memo boiler efficiency curve name input blank.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference Boilers\n";
    ss << "A2 , \\field Fuel Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "N1 , \\field Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.0\n";
    ss << "N2 , \\field Nominal Thermal Efficiency\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note Based on the higher heating value of fuel.\n";
    ss << "A3 , \\field Efficiency Curve Temperature Evaluation Variable\n";
    ss << "\\type choice\n";
    ss << "\\key EnteringBoiler\n";
    ss << "\\key LeavingBoiler\n";
    ss << "A4 , \\field Normalized Boiler Efficiency Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\object-list BiVariateCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Linear, Quadratic and Cubic efficiency curves are solely a function of PLR.\n";
    ss << "\\note All other efficiency curve types are a function of PLR and boiler water temperature.\n";
    ss << "\\note Linear = C1 + C2*PLR\n";
    ss << "\\note Quadratic = C1 + C2*PLR + C3*PLR^2\n";
    ss << "\\note Cubic = C1 + C2*PLR + C3*PLR^2 + C4*PLR^3\n";
    ss << "\\note Biquadratic = C1 + C2*PLR + C3*PLR^2 + C4*T + C5*T^2 + C6*PLR*T\n";
    ss << "\\note QuadraticLinear = C1 + C2*PLR + C3*PLR^2 + (C4 + C5*PLR + C6*PLR^2)*T\n";
    ss << "\\note BiCubic = C1+C2*PLR+C3*PLR^2+C4*T+C5*T^2+C6*PLR*T+C7*PLR^3+C8*T^3+C9*PLR^2*T+C10*PLR*T^2\n";
    ss << "\\note TriQuadratic curves are not allowed.\n";
    ss << "\\note PLR = part-load ratio\n";
    ss << "\\note T = boiler water temperature (either entering or leaving).\n";
    ss << "N3 , \\field Design Water Outlet Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N4 , \\field Design Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "N5 , \\field Minimum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N6 , \\field Maximum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N7 , \\field Optimum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "A5 , \\field Boiler Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6 , \\field Boiler Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N8 , \\field Water Outlet Upper Temperature Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 99.9\n";
    ss << "A7 , \\field Boiler Flow Mode\n";
    ss << "\\note Select operating mode for fluid flow through the boiler. \"NotModulated\" is for\n";
    ss << "\\note either variable or constant pumping with flow controlled by the external plant system.\n";
    ss << "\\note \"ConstantFlow\" is for constant pumping with flow controlled by boiler to operate at\n";
    ss << "\\note full design flow rate.  \"LeavingSetpointModulated\" is for variable pumping with flow\n";
    ss << "\\note controlled by boiler to vary flow to target a leaving temperature setpoint.\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\key LeavingSetpointModulated\n";
    ss << "\\key NotModulated\n";
    ss << "\\default NotModulated\n";
    ss << "N9 , \\field Parasitic Electric Load\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "N10; \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::Boiler_HotWater);
    OptionalIddObject oObj = IddObject::load("Boiler:HotWater",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Boiler_HotWater);
  return object;
}

IddObject createBoiler_SteamIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Boiler:Steam,\n";
    ss << "\\memo This boiler model is an adaptation of the empirical model from the Building\n";
    ss << "\\memo Loads and System Thermodynamics (BLAST) program.  Boiler performance\n";
    ss << "\\memo curves are generated by fitting catalog data to third order\n";
    ss << "\\memo polynomial equations.  A constant efficiency boiler is modeled by setting\n";
    ss << "\\memo the fuel use coefficients as follows: N9=1, N10=0, N11=0\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Fuel Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "N1 , \\field Maximum Operating Pressure\n";
    ss << "\\units kPa\n";
    ss << "N2 , \\field Theoretical Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N3 , \\field Design Outlet Steam Temperature\n";
    ss << "\\units C\n";
    ss << "N4 , \\field Nominal Capacity\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "N5 , \\field Minimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N6 , \\field Maximum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N7 , \\field Optimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N8 , \\field Coefficient 1 of Fuel Use Function of Part Load Ratio Curve\n";
    ss << "N9 , \\field Coefficient 2 of Fuel Use Function of Part Load Ratio Curve\n";
    ss << "N10, \\field Coefficient 3 of Fuel Use Function of Part Load Ratio Curve\n";
    ss << "A3 , \\field Water Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Steam Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N11; \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::Boiler_Steam);
    OptionalIddObject oObj = IddObject::load("Boiler:Steam",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Boiler_Steam);
  return object;
}

IddObject createChiller_Electric_EIRIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Chiller:Electric:EIR,\n";
    ss << "\\min-fields 23\n";
    ss << "\\memo This chiller model is the empirical model from the DOE-2 building Energy\n";
    ss << "\\memo simulation program. Chiller performance at off-reference conditions is modeled\n";
    ss << "\\memo using three polynomial equations. Three curves objects are required.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\reference Chillers\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field Reference Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Reference COP\n";
    ss << "\\note Efficiency of the chiller compressor (cooling output/compressor energy input).\n";
    ss << "\\note Condenser fan power should not be included here.\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3 , \\field Reference Leaving Chilled Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\default 6.67\n";
    ss << "\\units C\n";
    ss << "N4 , \\field Reference Entering Condenser Fluid Temperature\n";
    ss << "\\type real\n";
    ss << "\\default 29.4\n";
    ss << "\\units C\n";
    ss << "N5 , \\field Reference Chilled Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N6 , \\field Reference Condenser Fluid Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\note This field is only used for Condenser Type = AirCooled or EvaporativelyCooled\n";
    ss << "\\note when Heat Recovery is specified\n";
    ss << "A2 , \\field Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\note Cooling capacity as a function of CW supply temp and entering condenser temp\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*CWS + c*CWS**2 + d*ECT + e*ECT**2 + f*CWS*ECT\n";
    ss << "\\note CWS = supply (leaving) chilled water temperature(C)\n";
    ss << "\\note ECT = entering condenser fluid temperature(C)\n";
    ss << "A3 , \\field Electric Input to Cooling Output Ratio Function of Temperature Curve Name\n";
    ss << "\\note Electric Input Ratio (EIR) as a function of temperature\n";
    ss << "\\note EIR = 1/COP\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*CWS + c*CWS**2 + d*ECT + e*ECT**2 + f*CWS*ECT\n";
    ss << "\\note CWS = supply (leaving) chilled water temperature(C)\n";
    ss << "\\note ECT = entering condenser fluid temperature(C)\n";
    ss << "A4 , \\field Electric Input to Cooling Output Ratio Function of Part Load Ratio Curve Name\n";
    ss << "\\note Electric Input Ratio (EIR) as a function of Part Load Ratio (PLR)\n";
    ss << "\\note EIR = 1/COP\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2 is typical, other univariate curves may be used\n";
    ss << "\\note PLR = part load ratio (cooling load/steady state capacity)\n";
    ss << "N7 , \\field Minimum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\note Part load ratio below which the chiller starts cycling on/off to meet the load.\n";
    ss << "\\note Must be less than or equal to Maximum Part Load Ratio.\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.1\n";
    ss << "N8 , \\field Maximum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\note Maximum allowable part load ratio. Must be greater than or equal to Minimum Part Load Ratio.\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N9 , \\field Optimum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\note Optimum part load ratio where the chiller is most efficient.\n";
    ss << "\\note Must be greater than or equal to the Minimum Part Load Ratio\n";
    ss << "\\note and less than or equal to the Maximum Part Load Ratio.\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N10, \\field Minimum Unloading Ratio\n";
    ss << "\\type real\n";
    ss << "\\note Part load ratio where the chiller can no longer unload and false loading begins.\n";
    ss << "\\note Minimum unloading ratio must be greater than or equal to the Minimum Part Load Ratio\n";
    ss << "\\note and less than or equal to the Maximum Part Load Ratio.\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.2\n";
    ss << "A5 , \\field Chilled Water Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A6 , \\field Chilled Water Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A7 , \\field Condenser Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Not required if air-cooled or evaporatively-cooled\n";
    ss << "A8 , \\field Condenser Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Not required if air-cooled or evaporatively-cooled\n";
    ss << "A9 , \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key WaterCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "\\default WaterCooled\n";
    ss << "N11, \\field Condenser Fan Power Ratio\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Use for air-cooled or evaporatively-cooled condensers.\n";
    ss << "\\note Ratio of condenser fan power to reference chiller capacity\n";
    ss << "N12, \\field Fraction of Compressor Electric Consumption Rejected by Condenser\n";
    ss << "\\type real\n";
    ss << "\\note Fraction of compressor electrical energy that must be rejected by the condenser.\n";
    ss << "\\note Enter a value of 1.0 when modeling hermetic chillers.\n";
    ss << "\\note For open chillers, enter the compressor motor efficiency.\n";
    ss << "\\note This value should be greater than 0.6 for practical applications.\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "N13, \\field Leaving Chilled Water Lower Temperature Limit\n";
    ss << "\\type real\n";
    ss << "\\default 2.0\n";
    ss << "\\units C\n";
    ss << "A10, \\field Chiller Flow Mode\n";
    ss << "\\note Select operating mode for fluid flow through the chiller. \"NotModulated\" is for\n";
    ss << "\\note either variable or constant pumping with flow controlled by the external plant system.\n";
    ss << "\\note \"ConstantFlow\" is for constant pumping with flow controlled by chiller to operate at\n";
    ss << "\\note full design flow rate.  \"LeavingSetpointModulated\" is for variable pumping with flow\n";
    ss << "\\note controlled by chiller to vary flow to target a leaving temperature setpoint.\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\key LeavingSetpointModulated\n";
    ss << "\\key NotModulated\n";
    ss << "\\default NotModulated\n";
    ss << "N14, \\field Design Heat Recovery Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\note If non-zero, then the heat recovery inlet and outlet node names must be entered.\n";
    ss << "\\note Heat recovery is only available with Condenser Type = WaterCooled.\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\autosizable\n";
    ss << "A11, \\field Heat Recovery Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A12, \\field Heat Recovery Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N15, \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N16, \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled and for periods\n";
    ss << "\\note when the basin heater is available (field Basin Heater Operating Schedule Name).\n";
    ss << "\\note For this situation, the heater maintains the basin water temperature at the basin heater\n";
    ss << "\\note setpoint temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when the chiller is not operating.\n";
    ss << "N17, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on.\n";
    ss << "A13, \\field Basin Heater Operating Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";
    ss << "N18, \\field Condenser Heat Recovery Relative Capacity Fraction\n";
    ss << "\\note This optional field is the fraction of total rejected heat that can be recovered at full load\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A14, \\field Heat Recovery Inlet High Temperature Limit Schedule Name\n";
    ss << "\\note This optional schedule of temperatures will turn off heat recovery if inlet exceeds the value\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A15; \\field Heat Recovery Leaving Temperature Setpoint Node Name\n";
    ss << "\\note This optional field provides control over the heat recovery\n";
    ss << "\\note Using this triggers a model more suited to series bundle and chillers with higher temperature heat recovery\n";
    ss << "\\note If this field is not used, the bundles are modeled as being in parallel\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::Chiller_Electric_EIR);
    OptionalIddObject oObj = IddObject::load("Chiller:Electric:EIR",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Chiller_Electric_EIR);
  return object;
}

IddObject createChiller_Electric_ReformulatedEIRIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Chiller:Electric:ReformulatedEIR,\n";
    ss << "\\min-fields 22\n";
    ss << "\\memo This chiller model is an empirical model, a reformulated version of Chiller:Electric:EIR\n";
    ss << "\\memo where the performance is a function of condenser leaving fluid Temperature instead of\n";
    ss << "\\memo condenser entering fluid Temperature. Chiller performance at off-reference conditions is\n";
    ss << "\\memo modeled using three polynomial equations. Three curve objects are required.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\reference Chillers\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field Reference Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Reference COP\n";
    ss << "\\note Efficiency of the chiller compressor (cooling output/compressor energy input).\n";
    ss << "\\note Condenser fan power should not be included here.\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3 , \\field Reference Leaving Chilled Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\default 6.67\n";
    ss << "\\units C\n";
    ss << "N4 , \\field Reference Leaving Condenser Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\default 35.0\n";
    ss << "\\units C\n";
    ss << "N5 , \\field Reference Chilled Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N6 , \\field Reference Condenser Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "A2 , \\field Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\note Cooling capacity as a function of supply (leaving) chilled water temperature\n";
    ss << "\\note and leaving condenser fluid temperature\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note Table:TwoIndependentVariables object can also be used\n";
    ss << "\\note curve = a + b*CWS + c*CWS**2 + d*LCT + e*LCT**2 + f*CWS*LCT\n";
    ss << "\\note CWS = supply (leaving) chilled water temperature(C)\n";
    ss << "\\note LCT = leaving condenser fluid temperature(C)\n";
    ss << "A3 , \\field Electric Input to Cooling Output Ratio Function of Temperature Curve Name\n";
    ss << "\\note Electric Input Ratio (EIR) as a function of supply (leaving) chilled water temperature\n";
    ss << "\\note and leaving condenser fluid temperature.   EIR = 1/COP.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*CWS + c*CWS**2 + d*LCT + e*LCT**2 + f*CWS*LCT\n";
    ss << "\\note CWS = supply (leaving) chilled water temperature(C)\n";
    ss << "\\note LCT = leaving condenser fluid temperature(C)\n";
    ss << "A4 , \\field Electric Input to Cooling Output Ratio Function of Part Load Ratio Curve Type\n";
    ss << "\\note Two curve types are available:\n";
    ss << "\\note Type LeavingCondenserWaterTemperature: based on the leaving condenser water temperature.\n";
    ss << "\\note Type Lift: based on the normalized lift, which is the temperature difference between the\n";
    ss << "\\note leaving condenser water temperature and the leaving evaporator water temperature.\n";
    ss << "\\type choice\n";
    ss << "\\key LeavingCondenserWaterTemperature\n";
    ss << "\\key Lift\n";
    ss << "\\default LeavingCondenserWaterTemperature\n";
    ss << "A5 , \\field Electric Input to Cooling Output Ratio Function of Part Load Ratio Curve Name\n";
    ss << "\\note Electric Input Ratio (EIR) as a function of Part Load Ratio (PLR)\n";
    ss << "\\note EIR = 1/COP\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BicubicCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\object-list ChillerPartLoadWithLiftCurves\n";
    ss << "\\object-list MultiVariateTables\n";
    ss << "\\note The form of this curve is based on the input for\n";
    ss << "\\note Electric Input to Cooling Output RatioFunction of Part Load Ratio Curve Type\n";
    ss << "\\note Type=LeavingCondenserWaterTemperature: Calculated based on LCT and PLR\n";
    ss << "\\note Curve object type should be Curve:Bicubic or Table:TwoIndependentVariables\n";
    ss << "\\note Bicubic curve = a + b*LCT + c*LCT**2 + d*PLR + e*PLR**2 + f*LCT*PLR + g*0 + h*PLR**3\n";
    ss << "\\note + i*0 + j*0\n";
    ss << "\\note PLR = part load ratio (cooling load/steady state capacity)\n";
    ss << "\\note LCT = leaving condenser fluid temperature(C)\n";
    ss << "\\note Type=Lift: Calculated based on dT*, Tdev* and PLR\n";
    ss << "\\note Curve object type should be Curve:ChillerPartLoadWithLiftCurves or Table:MultiVariableLookup\n";
    ss << "\\note ChillerPartLoadWithLiftCurves curve = a + b*(dT*) + c*(dT*)**2 + d*PLR + e*PLR**2 + f*(dT*)*PLR + g*(dT*)**3\n";
    ss << "\\note + h*PLR**3 + i*(dT*)**2*PLR + j*(dT*)*PLR**2 + k*(dT*)**2*PLR**2 + l*(Tdev*)*PLR**3\n";
    ss << "\\note x = dT* = normalized fractional Lift = dT / dTref\n";
    ss << "\\note y = PLR = part load ratio (cooling load/steady state capacity)\n";
    ss << "\\note z = Tdev* = normalized Tdev = Tdev / dTref\n";
    ss << "\\note Where:\n";
    ss << "\\note dT = Lift = Leaving Condenser Water Temperature - Leaving Chilled Water Temperature\n";
    ss << "\\note dTref = dT at the reference condition\n";
    ss << "\\note Tdev = Leaving Chilled Water Temperature - Reference Chilled Water Temperature\n";
    ss << "N7 , \\field Minimum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\note Part load ratio below which the chiller starts cycling on/off to meet the load.\n";
    ss << "\\note Must be less than or equal to Maximum Part Load Ratio.\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.1\n";
    ss << "N8 , \\field Maximum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\note Maximum allowable part load ratio. Must be greater than or equal to Minimum Part Load Ratio.\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N9 , \\field Optimum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\note Optimum part load ratio where the chiller is most efficient.\n";
    ss << "\\note Must be greater than or equal to the Minimum Part Load Ratio\n";
    ss << "\\note and less than or equal to the Maximum Part Load Ratio.\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N10, \\field Minimum Unloading Ratio\n";
    ss << "\\type real\n";
    ss << "\\note Part load ratio where the chiller can no longer unload and false loading begins.\n";
    ss << "\\note Minimum unloading ratio must be greater than or equal to the Minimum Part Load Ratio\n";
    ss << "\\note and less than or equal to the Maximum Part Load Ratio.\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.2\n";
    ss << "A6 , \\field Chilled Water Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A7 , \\field Chilled Water Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A8 , \\field Condenser Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A9 , \\field Condenser Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "N11, \\field Fraction of Compressor Electric Consumption Rejected by Condenser\n";
    ss << "\\type real\n";
    ss << "\\note Fraction of compressor electrical energy that must be rejected by the condenser.\n";
    ss << "\\note Enter a value of 1.0 when modeling hermetic chillers.\n";
    ss << "\\note For open chillers, enter the compressor motor efficiency.\n";
    ss << "\\note This value should be greater than 0.6 for practical applications.\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "N12, \\field Leaving Chilled Water Lower Temperature Limit\n";
    ss << "\\type real\n";
    ss << "\\default 2.0\n";
    ss << "\\units C\n";
    ss << "A10, \\field Chiller Flow Mode Type\n";
    ss << "\\note Select operating mode for fluid flow through the chiller. \"NotModulated\" is for\n";
    ss << "\\note either variable or constant pumping with flow controlled by the external plant system.\n";
    ss << "\\note \"ConstantFlow\" is for constant pumping with flow controlled by chiller to operate at\n";
    ss << "\\note full design flow rate.  \"LeavingSetpointModulated\" is for variable pumping with flow\n";
    ss << "\\note controlled by chiller to vary flow to target a leaving temperature setpoint.\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\key LeavingSetpointModulated\n";
    ss << "\\key NotModulated\n";
    ss << "\\default NotModulated\n";
    ss << "N13, \\field Design Heat Recovery Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\note If non-zero, then the heat recovery inlet and outlet node names must be entered.\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\autosizable\n";
    ss << "A11, \\field Heat Recovery Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A12, \\field Heat Recovery Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N14, \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N15, \\field Condenser Heat Recovery Relative Capacity Fraction\n";
    ss << "\\note This optional field is the fraction of total rejected heat that can be recovered at full load\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A13, \\field Heat Recovery Inlet High Temperature Limit Schedule Name\n";
    ss << "\\note This optional schedule of temperatures will turn off heat recovery if inlet exceeds the value\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A14; \\field Heat Recovery Leaving Temperature Setpoint Node Name\n";
    ss << "\\note This optional field provides control over the heat recovery\n";
    ss << "\\note Using this triggers a model more suited to series bundle and chillers with higher temperature heat recovery\n";
    ss << "\\note If this field is not used, the bundles are modeled as being in parallel\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::Chiller_Electric_ReformulatedEIR);
    OptionalIddObject oObj = IddObject::load("Chiller:Electric:ReformulatedEIR",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Chiller_Electric_ReformulatedEIR);
  return object;
}

IddObject createChiller_ElectricIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Chiller:Electric,\n";
    ss << "\\min-fields 27\n";
    ss << "\\memo This chiller model is the empirical model from the Building Loads\n";
    ss << "\\memo and System Thermodynamics (BLAST) program.  Chiller performance\n";
    ss << "\\memo curves are generated by fitting catalog data to third order\n";
    ss << "\\memo polynomial equations.  Three sets of coefficients are required.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference Chillers\n";
    ss << "A2 , \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key WaterCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "\\default AirCooled\n";
    ss << "N1 , \\field Nominal Capacity\n";
    ss << "\\units W\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.0\n";
    ss << "N2 , \\field Nominal COP\n";
    ss << "\\required-field\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "A3 , \\field Chilled Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Chilled Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Condenser Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A6 , \\field Condenser Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N3 , \\field Minimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N4 , \\field Maximum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N5 , \\field Optimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N6 , \\field Design Condenser Inlet Temperature\n";
    ss << "\\units C\n";
    ss << "N7 , \\field Temperature Rise Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "N8 , \\field Design Chilled Water Outlet Temperature\n";
    ss << "\\units C\n";
    ss << "N9 , \\field Design Chilled Water Flow Rate\n";
    ss << "\\note  For variable volume this is the maximum flow & for constant flow this is the flow.\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "N10, \\field Design Condenser Fluid Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\note This field is only used for Condenser Type = AirCooled or EvaporativelyCooled\n";
    ss << "\\note when Heat Recovery is specified\n";
    ss << "N11, \\field Coefficient 1 of Capacity Ratio Curve\n";
    ss << "N12, \\field Coefficient 2 of Capacity Ratio Curve\n";
    ss << "N13, \\field Coefficient 3 of Capacity Ratio Curve\n";
    ss << "N14, \\field Coefficient 1 of Power Ratio Curve\n";
    ss << "N15, \\field Coefficient 2 of Power Ratio Curve\n";
    ss << "N16, \\field Coefficient 3 of Power Ratio Curve\n";
    ss << "N17, \\field Coefficient 1 of Full Load Ratio Curve\n";
    ss << "N18, \\field Coefficient 2 of Full Load Ratio Curve\n";
    ss << "N19, \\field Coefficient 3 of Full Load Ratio Curve\n";
    ss << "N20, \\field Chilled Water Outlet Temperature Lower Limit\n";
    ss << "\\units C\n";
    ss << "A7,  \\field Chiller Flow Mode\n";
    ss << "\\note Select operating mode for fluid flow through the chiller. \"NotModulated\" is for\n";
    ss << "\\note either variable or constant pumping with flow controlled by the external plant system.\n";
    ss << "\\note \"ConstantFlow\" is for constant pumping with flow controlled by chiller to operate at\n";
    ss << "\\note full design flow rate.  \"LeavingSetpointModulated\" is for variable pumping with flow\n";
    ss << "\\note controlled by chiller to vary flow to target a leaving temperature setpoint.\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\key LeavingSetpointModulated\n";
    ss << "\\key NotModulated\n";
    ss << "\\default NotModulated\n";
    ss << "N21, \\field Design Heat Recovery Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note If non-zero, then the heat recovery inlet and outlet node names must be entered.\n";
    ss << "\\note Heat recovery is only available with Condenser Type = WaterCooled.\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\autosizable\n";
    ss << "A8 , \\field Heat Recovery Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A9 , \\field Heat Recovery Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N22, \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N23, \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled and for periods\n";
    ss << "\\note when the basin heater is available (field Basin Heater Operating Schedule Name).\n";
    ss << "\\note For this situation, the heater maintains the basin water temperature at the basin heater\n";
    ss << "\\note setpoint temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when the chiller is not operating.\n";
    ss << "N24, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on.\n";
    ss << "A10, \\field Basin Heater Operating Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";
    ss << "N25, \\field Condenser Heat Recovery Relative Capacity Fraction\n";
    ss << "\\note This optional field is the fraction of total rejected heat that can be recovered at full load\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A11, \\field Heat Recovery Inlet High Temperature Limit Schedule Name\n";
    ss << "\\note This optional schedule of temperatures will turn off heat recovery if inlet exceeds the value\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A12; \\field Heat Recovery Leaving Temperature Setpoint Node Name\n";
    ss << "\\note This optional field provides control over the heat recovery\n";
    ss << "\\note Using this triggers a model more suited to series bundle and chillers with higher temperature heat recovery\n";
    ss << "\\note If this field is not used, the bundles are modeled as being in parallel\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::Chiller_Electric);
    OptionalIddObject oObj = IddObject::load("Chiller:Electric",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Chiller_Electric);
  return object;
}

IddObject createChiller_Absorption_IndirectIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Chiller:Absorption:Indirect,\n";
    ss << "\\min-fields 17\n";
    ss << "\\memo This indirect absorption chiller model is an enhanced model from the\n";
    ss << "\\memo Building Loads and System Thermodynamics (BLAST) program.  Chiller\n";
    ss << "\\memo performance curves are generated by fitting catalog data to third order\n";
    ss << "\\memo polynomial equations. The chiller capacity is a function of condenser,\n";
    ss << "\\memo chilled water, and generator temperatures. The heat input is a function\n";
    ss << "\\memo of part-load ratio, condenser temperature, and chilled water temperature.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference Chillers\n";
    ss << "N1 , \\field Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Nominal Pumping Power\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "A2 , \\field Chilled Water Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A3 , \\field Chilled Water Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A4 , \\field Condenser Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A5 , \\field Condenser Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field Minimum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "N4 , \\field Maximum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "N5 , \\field Optimum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "N6 , \\field Design Condenser Inlet Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 30.0\n";
    ss << "\\note Used only when condenser flow rate is autosized.\n";
    ss << "N7 , \\field Condenser Inlet Temperature Lower Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 15.0\n";
    ss << "\\note Provides warnings when entering condenser temperature is below minimum.\n";
    ss << "\\note Capacity is not adjusted when entering condenser temperature is below minimum.\n";
    ss << "N8 , \\field Chilled Water Outlet Temperature Lower Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 5.0\n";
    ss << "\\note Capacity is adjusted when leaving chilled water temperature is below minimum.\n";
    ss << "N9 , \\field Design Chilled Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\default autosize\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\note For variable flow this is the max flow & for constant flow this is the flow.\n";
    ss << "N10, \\field Design Condenser Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default autosize\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "A6 , \\field Chiller Flow Mode\n";
    ss << "\\note Select operating mode for fluid flow through the chiller. \"NotModulated\" is for\n";
    ss << "\\note either variable or constant pumping with flow controlled by the external plant system.\n";
    ss << "\\note \"ConstantFlow\" is for constant pumping with flow controlled by chiller to operate at\n";
    ss << "\\note full design flow rate.  \"LeavingSetpointModulated\" is for variable pumping with flow\n";
    ss << "\\note controlled by chiller to vary flow to target a leaving temperature setpoint.\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\key LeavingSetpointModulated\n";
    ss << "\\key NotModulated\n";
    ss << "\\default NotModulated\n";
    ss << "A7,  \\field Generator Heat Input Function of Part Load Ratio Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A8,  \\field Pump Electric Input Function of Part Load Ratio Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A9 , \\field Generator Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter the generator inlet node name which connects this chiller to a\n";
    ss << "\\note steam or hot water plant, otherwise leave this field blank.\n";
    ss << "\\note Generator nodes are used to model heat input to the chiller.\n";
    ss << "A10, \\field Generator Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter the generator outlet node name which connects this chiller to a\n";
    ss << "\\note steam or hot water plant, otherwise leave this field blank.\n";
    ss << "\\note Generator nodes are used to model heat input to the chiller.\n";
    ss << "A11, \\field Capacity Correction Function of Condenser Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Curve which shows the change in normalized capacity to changes in condenser temperature.\n";
    ss << "A12, \\field Capacity Correction Function of Chilled Water Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Curve which shows the change in normalized capacity to changes in leaving chilled water temperature.\n";
    ss << "A13, \\field Capacity Correction Function of Generator Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Used when generator fluid type is hot water\n";
    ss << "\\note Curve which shows the change in normalized capacity to changes in generator temperature.\n";
    ss << "A14, \\field Generator Heat Input Correction Function of Condenser Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Curve which shows the change in normalized heat input to changes in condenser temperature.\n";
    ss << "A15, \\field Generator Heat Input Correction Function of Chilled Water Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Curve which shows the change in normalized heat input to changes in leaving chilled water temperature.\n";
    ss << "A16, \\field Generator Heat Source Type\n";
    ss << "\\type choice\n";
    ss << "\\key HotWater\n";
    ss << "\\key Steam\n";
    ss << "\\default Steam\n";
    ss << "\\note The Generator side of the chiller can be connected to a hot water or steam plant where the\n";
    ss << "\\note generator inlet and outlet nodes are connected to a plant loop. If the generator is not\n";
    ss << "\\note connected to a plant loop, and the generator inlet/outlet nodes are not used, this field should be\n";
    ss << "\\note specified as steam or left blank. When a plant is not used, the model assumes steam as the heat source.\n";
    ss << "N11, \\field Design Generator Fluid Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\autosizable\n";
    ss << "\\note  For variable flow this is the max flow and for constant flow this is the flow.\n";
    ss << "N12, \\field Temperature Lower Limit Generator Inlet\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 0.0\n";
    ss << "\\note Provides warnings when entering generator temperature is below minimum.\n";
    ss << "\\note Capacity is not adjusted when entering generator temperature is below minimum.\n";
    ss << "N13, \\field Degree of Subcooling in Steam Generator\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 20.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note This field is not used when the generator inlet/outlet nodes are not specified or\n";
    ss << "\\note the generator is connected to a hot water loop.\n";
    ss << "N14, \\field Degree of Subcooling in Steam Condensate Loop\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This field is not used when the generator inlet/outlet nodes are not specified or\n";
    ss << "\\note the generator is connected to a hot water loop.\n";
    ss << "N15; \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::Chiller_Absorption_Indirect);
    OptionalIddObject oObj = IddObject::load("Chiller:Absorption:Indirect",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Chiller_Absorption_Indirect);
  return object;
}

IddObject createChiller_AbsorptionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Chiller:Absorption,\n";
    ss << "\\min-fields 23\n";
    ss << "\\memo This indirect absorption chiller model is the empirical model from the\n";
    ss << "\\memo Building Loads and System Thermodynamics (BLAST) program.  Chiller\n";
    ss << "\\memo performance curves are generated by fitting catalog data to third order\n";
    ss << "\\memo polynomial equations.  Two sets of coefficients are required.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\reference Chillers\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Nominal Pumping Power\n";
    ss << "\\units W\n";
    ss << "\\required-field\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "A2 , \\field Chilled Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3 , \\field Chilled Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Condenser Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Condenser Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N3 , \\field Minimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N4 , \\field Maximum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N5 , \\field Optimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N6 , \\field Design Condenser Inlet Temperature\n";
    ss << "\\units C\n";
    ss << "N7 , \\field Design Chilled Water Flow Rate\n";
    ss << "\\note  For variable volume this is the max flow & for constant flow this is the flow.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N8 , \\field Design Condenser Water Flow Rate\n";
    ss << "\\note  The steam use coefficients below specify the\n";
    ss << "\\note  steam use as a fraction of chiller operating capacity\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N9 , \\field Coefficient 1 of the Hot Water or Steam Use Part Load Ratio Curve\n";
    ss << "N10, \\field Coefficient 2 of the Hot Water or Steam Use Part Load Ratio Curve\n";
    ss << "N11, \\field Coefficient 3 of the Hot Water or Steam Use Part Load Ratio Curve\n";
    ss << "N12, \\field Coefficient 1 of the Pump Electric Use Part Load Ratio Curve\n";
    ss << "\\note  The pump electric use coefficients specify the\n";
    ss << "\\note  pumping power as a Fraction of Nominal pumping power\n";
    ss << "N13, \\field Coefficient 2 of the Pump Electric Use Part Load Ratio Curve\n";
    ss << "N14, \\field Coefficient 3 of the Pump Electric Use Part Load Ratio Curve\n";
    ss << "N15, \\field Chilled Water Outlet Temperature Lower Limit\n";
    ss << "\\units C\n";
    ss << "A6 , \\field Generator Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A7 , \\field Generator Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A8 , \\field Chiller Flow Mode\n";
    ss << "\\note Select operating mode for fluid flow through the chiller. \"NotModulated\" is for\n";
    ss << "\\note either variable or constant pumping with flow controlled by the external plant system.\n";
    ss << "\\note \"ConstantFlow\" is for constant pumping with flow controlled by chiller to operate at\n";
    ss << "\\note full design flow rate.  \"LeavingSetpointModulated\" is for variable pumping with flow\n";
    ss << "\\note controlled by chiller to vary flow to target a leaving temperature setpoint.\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\key LeavingSetpointModulated\n";
    ss << "\\key NotModulated\n";
    ss << "\\default NotModulated\n";
    ss << "A9 , \\field Generator Heat Source Type\n";
    ss << "\\type choice\n";
    ss << "\\key Steam\n";
    ss << "\\key HotWater\n";
    ss << "\\default Steam\n";
    ss << "\\note The Generator side of the chiller can be connected to a hot water or steam plant where the\n";
    ss << "\\note generator inlet and outlet nodes are connected to a plant loop. If the generator is not\n";
    ss << "\\note connected to a plant loop, and the generator inlet/outlet nodes are not used, this field should be\n";
    ss << "\\note specified as steam or left blank. When a plant is not used, the model assumes steam as the heat source.\n";
    ss << "N16, \\field Design Generator Fluid Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0.0\n";
    ss << "N17, \\field Degree of Subcooling in Steam Generator\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 1.0\n";
    ss << "\\note This field is not used when the generator inlet/outlet nodes are not specified or\n";
    ss << "\\note the generator is connected to a hot water loop.\n";
    ss << "N18; \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::Chiller_Absorption);
    OptionalIddObject oObj = IddObject::load("Chiller:Absorption",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Chiller_Absorption);
  return object;
}

IddObject createChiller_ConstantCOPIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Chiller:ConstantCOP,\n";
    ss << "\\min-fields 12\n";
    ss << "\\memo This constant COP chiller model provides a means of quickly specifying a\n";
    ss << "\\memo Chiller where performance data is not available.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\reference Chillers\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0.0\n";
    ss << "N2 , \\field Nominal COP\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3 , \\field Design Chilled Water Flow Rate\n";
    ss << "\\note  For variable volume this is the maximum flow and for constant flow this is the flow.\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.0\n";
    ss << "N4 , \\field Design Condenser Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note This field is not used for Condenser Type = AirCooled or EvaporativelyCooled\n";
    ss << "A2 , \\field Chilled Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3 , \\field Chilled Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Condenser Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Condenser Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A6 , \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key WaterCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "\\default AirCooled\n";
    ss << "A7 , \\field Chiller Flow Mode\n";
    ss << "\\note Select operating mode for fluid flow through the chiller. \"NotModulated\" is for\n";
    ss << "\\note either variable or constant pumping with flow controlled by the external plant system.\n";
    ss << "\\note \"ConstantFlow\" is for constant pumping with flow controlled by chiller to operate at\n";
    ss << "\\note full design flow rate.  \"LeavingSetpointModulated\" is for variable pumping with flow\n";
    ss << "\\note controlled by chiller to vary flow to target a leaving temperature setpoint.\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\key LeavingSetpointModulated\n";
    ss << "\\key NotModulated\n";
    ss << "\\default NotModulated\n";
    ss << "N5 , \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N6 , \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled and for periods\n";
    ss << "\\note when the basin heater is available (field Basin Heater Operating Schedule Name).\n";
    ss << "\\note For this situation, the heater maintains the basin water temperature at the basin heater\n";
    ss << "\\note setpoint temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when the chiller is not operating.\n";
    ss << "N7 , \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on.\n";
    ss << "A8 ; \\field Basin Heater Operating Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";

    IddObjectType objType(IddObjectType::Chiller_ConstantCOP);
    OptionalIddObject oObj = IddObject::load("Chiller:ConstantCOP",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Chiller_ConstantCOP);
  return object;
}

IddObject createChiller_EngineDrivenIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Chiller:EngineDriven,\n";
    ss << "\\min-fields 43\n";
    ss << "\\memo This chiller model is the empirical model from the Building Loads\n";
    ss << "\\memo and System Thermodynamics (BLAST) program.  Chiller performance\n";
    ss << "\\memo curves are generated by fitting catalog data to third order\n";
    ss << "\\memo polynomial equations.  Three sets of coefficients are required.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\reference Chillers\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key WaterCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "\\default AirCooled\n";
    ss << "N1 , \\field Nominal Capacity\n";
    ss << "\\units W\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.0\n";
    ss << "N2 , \\field Nominal COP\n";
    ss << "\\required-field\n";
    ss << "\\units W/W\n";
    ss << "\\note Nominal Refrigeration Cycle COP\n";
    ss << "\\minimum> 0.0\n";
    ss << "A3 , \\field Chilled Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Chilled Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Condenser Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A6 , \\field Condenser Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N3 , \\field Minimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N4 , \\field Maximum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N5 , \\field Optimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N6 , \\field Design Condenser Inlet Temperature\n";
    ss << "\\units C\n";
    ss << "N7 , \\field Temperature Rise Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "N8 , \\field Design Chilled Water Outlet Temperature\n";
    ss << "\\units C\n";
    ss << "N9 , \\field Design Chilled Water Flow Rate\n";
    ss << "\\note  For variable volume this is the maximum flow and for constant flow this is the flow.\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "N10, \\field Design Condenser Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note This field is not used for Condenser Type = AirCooled or EvaporativelyCooled\n";
    ss << "N11, \\field Coefficient 1 of Capacity Ratio Curve\n";
    ss << "N12, \\field Coefficient 2 of Capacity Ratio Curve\n";
    ss << "N13, \\field Coefficient 3 of Capacity Ratio Curve\n";
    ss << "N14, \\field Coefficient 1 of Power Ratio Curve\n";
    ss << "N15, \\field Coefficient 2 of Power Ratio Curve\n";
    ss << "N16, \\field Coefficient 3 of Power Ratio Curve\n";
    ss << "N17, \\field Coefficient 1 of Full Load Ratio Curve\n";
    ss << "N18, \\field Coefficient 2 of Full Load Ratio Curve\n";
    ss << "N19, \\field Coefficient 3 of Full Load Ratio Curve\n";
    ss << "N20, \\field Chilled Water Outlet Temperature Lower Limit\n";
    ss << "\\units C\n";
    ss << "\\note  Special EngineDriven Chiller Parameters Below\n";
    ss << "A7, \\field Fuel Use Curve Name\n";
    ss << "\\note Curve is a function of Part Load Ratio (PLR)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note PLR = Ratio of evaporator heat transfer rate to nominal capacity\n";
    ss << "A8, \\field Jacket Heat Recovery Curve Name\n";
    ss << "\\note Curve is a function of Part Load Ratio (PLR)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note PLR = Ratio of evaporator heat transfer rate to nominal capacity\n";
    ss << "A9, \\field Lube Heat Recovery Curve Name\n";
    ss << "\\note Curve is a function of Part Load Ratio (PLR)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note PLR = Ratio of evaporator heat transfer rate to nominal capacity\n";
    ss << "A10, \\field Total Exhaust Energy Curve Name\n";
    ss << "\\note Curve is a function of Part Load Ratio (PLR)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note PLR = Ratio of evaporator heat transfer rate to nominal capacity\n";
    ss << "A11, \\field Exhaust Temperature Curve Name\n";
    ss << "\\note Curve is a function of Part Load Ratio (PLR)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note PLR = Ratio of evaporator heat transfer rate to nominal capacity\n";
    ss << "N21, \\field Coefficient 1 of U-Factor Times Area Curve\n";
    ss << "\\note curve = C1 * (nominal capacity)**C2\n";
    ss << "N22, \\field Coefficient 2 of U-Factor Times Area Curve\n";
    ss << "\\note curve = C1 * (nominal capacity)**C2\n";
    ss << "N23, \\field Maximum Exhaust Flow per Unit of Power Output\n";
    ss << "\\units (kg/s)/W\n";
    ss << "\\minimum 0.0\n";
    ss << "N24, \\field Design Minimum Exhaust Temperature\n";
    ss << "\\units C\n";
    ss << "A12, \\field Fuel Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "N25, \\field Fuel Higher Heating Value\n";
    ss << "\\units kJ/kg\n";
    ss << "N26, \\field Design Heat Recovery Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note If non-zero, then the heat recovery inlet and outlet node names must be entered.\n";
    ss << "\\ip-units gal/min\n";
    ss << "A13, \\field Heat Recovery Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A14, \\field Heat Recovery Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A15, \\field Chiller Flow Mode\n";
    ss << "\\note Select operating mode for fluid flow through the chiller. \"NotModulated\" is for\n";
    ss << "\\note either variable or constant pumping with flow controlled by the external plant system.\n";
    ss << "\\note \"ConstantFlow\" is for constant pumping with flow controlled by chiller to operate at\n";
    ss << "\\note full design flow rate.  \"LeavingSetpointModulated\" is for variable pumping with flow\n";
    ss << "\\note controlled by chiller to vary flow to target a leaving temperature setpoint.\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\key LeavingSetpointModulated\n";
    ss << "\\key NotModulated\n";
    ss << "\\default NotModulated\n";
    ss << "N27, \\field Maximum Temperature for Heat Recovery at Heat Recovery Outlet Node\n";
    ss << "\\units C\n";
    ss << "\\maximum 100.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 60.0\n";
    ss << "N28, \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N29, \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled and for periods\n";
    ss << "\\note when the basin heater is available (field Basin Heater Operating Schedule Name).\n";
    ss << "\\note For this situation, the heater maintains the basin water temperature at the basin heater\n";
    ss << "\\note setpoint temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when the chiller is not operating.\n";
    ss << "N30, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on.\n";
    ss << "A16; \\field Basin Heater Operating Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";

    IddObjectType objType(IddObjectType::Chiller_EngineDriven);
    OptionalIddObject oObj = IddObject::load("Chiller:EngineDriven",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Chiller_EngineDriven);
  return object;
}

IddObject createChiller_CombustionTurbineIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Chiller:CombustionTurbine,\n";
    ss << "\\min-fields 56\n";
    ss << "\\memo This chiller model is the empirical model from the Building Loads\n";
    ss << "\\memo and System Thermodynamics (BLAST) program.  Chiller performance\n";
    ss << "\\memo curves are generated by fitting catalog data to third order\n";
    ss << "\\memo polynomial equations.  Three sets of coefficients are required.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference Chillers\n";
    ss << "A2 , \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key WaterCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "\\default AirCooled\n";
    ss << "N1 , \\field Nominal Capacity\n";
    ss << "\\units W\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.0\n";
    ss << "N2 , \\field Nominal COP\n";
    ss << "\\required-field\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "A3 , \\field Chilled Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Chilled Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Condenser Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A6 , \\field Condenser Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N3 , \\field Minimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N4 , \\field Maximum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N5 , \\field Optimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N6 , \\field Design Condenser Inlet Temperature\n";
    ss << "\\units C\n";
    ss << "N7 , \\field Temperature Rise Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "N8 , \\field Design Chilled Water Outlet Temperature\n";
    ss << "\\units C\n";
    ss << "N9 , \\field Design Chilled Water Flow Rate\n";
    ss << "\\note  For variable volume this is the max flow & for constant flow this is the flow.\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "N10, \\field Design Condenser Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note This field is not used for Condenser Type = AirCooled or EvaporativelyCooled\n";
    ss << "N11, \\field Coefficient 1 of Capacity Ratio Curve\n";
    ss << "N12, \\field Coefficient 2 of Capacity Ratio Curve\n";
    ss << "N13, \\field Coefficient 3 of Capacity Ratio Curve\n";
    ss << "N14, \\field Coefficient 1 of Power Ratio Curve\n";
    ss << "N15, \\field Coefficient 2 of Power Ratio Curve\n";
    ss << "N16, \\field Coefficient 3 of Power Ratio Curve\n";
    ss << "N17, \\field Coefficient 1 of Full Load Ratio Curve\n";
    ss << "N18, \\field Coefficient 2 of Full Load Ratio Curve\n";
    ss << "N19, \\field Coefficient 3 of Full Load Ratio Curve\n";
    ss << "N20, \\field Chilled Water Outlet Temperature Lower Limit\n";
    ss << "\\units C\n";
    ss << "\\note  Special Gas Turbine Chiller Parameters Below\n";
    ss << "N21, \\field Coefficient 1 of Fuel Input Curve\n";
    ss << "N22, \\field Coefficient 2 of Fuel Input Curve\n";
    ss << "N23, \\field Coefficient 3 of Fuel Input Curve\n";
    ss << "N24, \\field Coefficient 1 of Temperature Based Fuel Input Curve\n";
    ss << "N25, \\field Coefficient 2 of Temperature Based Fuel Input Curve\n";
    ss << "N26, \\field Coefficient 3 of Temperature Based Fuel Input Curve\n";
    ss << "N27, \\field Coefficient 1 of Exhaust Flow Curve\n";
    ss << "N28, \\field Coefficient 2 of Exhaust Flow Curve\n";
    ss << "N29, \\field Coefficient 3 of Exhaust Flow Curve\n";
    ss << "N30, \\field Coefficient 1 of Exhaust Gas Temperature Curve\n";
    ss << "N31, \\field Coefficient 2 of Exhaust Gas Temperature Curve\n";
    ss << "N32, \\field Coefficient 3 of Exhaust Gas Temperature Curve\n";
    ss << "N33, \\field Coefficient 1 of Temperature Based Exhaust Gas Temperature Curve\n";
    ss << "N34, \\field Coefficient 2 of Temperature Based Exhaust Gas Temperature Curve\n";
    ss << "N35, \\field Coefficient 3 of Temperature Based Exhaust Gas Temperature Curve\n";
    ss << "N36, \\field Coefficient 1 of Recovery Lube Heat Curve\n";
    ss << "N37, \\field Coefficient 2 of Recovery Lube Heat Curve\n";
    ss << "N38, \\field Coefficient 3 of Recovery Lube Heat Curve\n";
    ss << "N39, \\field Coefficient 1 of U-Factor Times Area Curve\n";
    ss << "N40, \\field Coefficient 2 of U-Factor Times Area Curve\n";
    ss << "\\note typical value .9\n";
    ss << "\\maximum 2\n";
    ss << "N41, \\field Gas Turbine Engine Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "N42, \\field Maximum Exhaust Flow per Unit of Power Output\n";
    ss << "\\units (kg/s)/W\n";
    ss << "N43, \\field Design Steam Saturation Temperature\n";
    ss << "\\units C\n";
    ss << "N44, \\field Fuel Higher Heating Value\n";
    ss << "\\units kJ/kg\n";
    ss << "N45, \\field Design Heat Recovery Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note If non-zero, then the heat recovery inlet and outlet node names must be entered.\n";
    ss << "\\ip-units gal/min\n";
    ss << "A7 , \\field Heat Recovery Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A8 , \\field Heat Recovery Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A9 , \\field Chiller Flow Mode\n";
    ss << "\\note Select operating mode for fluid flow through the chiller. \"NotModulated\" is for\n";
    ss << "\\note either variable or constant pumping with flow controlled by the external plant system.\n";
    ss << "\\note \"ConstantFlow\" is for constant pumping with flow controlled by chiller to operate at\n";
    ss << "\\note full design flow rate.  \"LeavingSetpointModulated\" is for variable pumping with flow\n";
    ss << "\\note controlled by chiller to vary flow to target a leaving temperature setpoint.\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\key LeavingSetpointModulated\n";
    ss << "\\key NotModulated\n";
    ss << "\\default NotModulated\n";
    ss << "A10, \\field Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\default NaturalGas\n";
    ss << "N46, \\field Heat Recovery Maximum Temperature\n";
    ss << "\\units C\n";
    ss << "\\maximum 100.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 80.0\n";
    ss << "N47, \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N48, \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled and for periods\n";
    ss << "\\note when the basin heater is available (field Basin Heater Operating Schedule Name).\n";
    ss << "\\note For this situation, The heater maintains the basin water temperature at the basin heater\n";
    ss << "\\note setpoint temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when the chiller is not operating.\n";
    ss << "N49, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on.\n";
    ss << "A11; \\field Basin Heater Operating Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";

    IddObjectType objType(IddObjectType::Chiller_CombustionTurbine);
    OptionalIddObject oObj = IddObject::load("Chiller:CombustionTurbine",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Chiller_CombustionTurbine);
  return object;
}

IddObject createChillerHeater_Absorption_DirectFiredIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ChillerHeater:Absorption:DirectFired,\n";
    ss << "\\min-fields 35\n";
    ss << "\\memo Direct fired gas absorption chiller-heater using performance curves similar to DOE-2\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field Nominal Cooling Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N2 , \\field Heating to Cooling Capacity Ratio\n";
    ss << "\\note A positive fraction that represents the ratio of the\n";
    ss << "\\note heating capacity divided by the cooling capacity at rated conditions.\n";
    ss << "\\minimum  0\n";
    ss << "\\default  0.8\n";
    ss << "N3 , \\field Fuel Input to Cooling Output Ratio\n";
    ss << "\\note The positive fraction that represents the ratio of the\n";
    ss << "\\note instantaneous fuel used divided by the cooling capacity at rated conditions.\n";
    ss << "\\minimum> 0\n";
    ss << "\\default  0.97\n";
    ss << "N4   ,  \\field Fuel Input to Heating Output Ratio\n";
    ss << "\\note The positive fraction that represents the ratio of the\n";
    ss << "\\note instantaneous fuel used divided by the nominal heating capacity.\n";
    ss << "\\minimum  0\n";
    ss << "\\default  1.25\n";
    ss << "N5   ,  \\field Electric Input to Cooling Output Ratio\n";
    ss << "\\note The positive fraction that represents the ratio of the\n";
    ss << "\\note instantaneous electricity used divided by the cooling capacity at rated conditions.\n";
    ss << "\\note If the chiller is both heating and cooling only the cooling electricity is used.\n";
    ss << "\\minimum  0\n";
    ss << "\\default  0.01\n";
    ss << "N6   ,  \\field Electric Input to Heating Output Ratio\n";
    ss << "\\note The positive fraction that represents the ratio of the\n";
    ss << "\\note instantaneous electricity used divided by the nominal heating capacity.\n";
    ss << "\\note If the chiller is both heating and cooling only the cooling electricity is used.\n";
    ss << "\\minimum  0\n";
    ss << "\\default  0\n";
    ss << "A2   ,  \\field Chilled Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3   ,  \\field Chilled Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4   ,  \\field Condenser Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5   ,  \\field Condenser Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6   ,  \\field Hot Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7   ,  \\field Hot Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N7   ,  \\field Minimum Part Load Ratio\n";
    ss << "\\note The positive fraction that represents the minimum cooling output possible when\n";
    ss << "\\note operated continually at rated temperature conditions divided by the nominal\n";
    ss << "\\note cooling capacity at those same conditions.  If the load on the chiller is below\n";
    ss << "\\note this fraction the chiller will cycle.\n";
    ss << "\\minimum> 0\n";
    ss << "\\default  0.1\n";
    ss << "N8   ,  \\field Maximum Part Load Ratio\n";
    ss << "\\note The positive fraction that represents the maximum cooling output possible at\n";
    ss << "\\note rated temperature conditions divided by the nominal cooling capacity at those\n";
    ss << "\\note same conditions.  If greater than 1.0, the chiller is typically thought of as\n";
    ss << "\\note capable of being overloaded.\n";
    ss << "\\minimum  0.5\n";
    ss << "\\default  1.0\n";
    ss << "N9   ,  \\field Optimum Part Load Ratio\n";
    ss << "\\note The positive fraction that represents the optimal cooling output at rated\n";
    ss << "\\note temperature conditions divided by the nominal cooling capacity at those same\n";
    ss << "\\note conditions.  It represents the most desirable operating point for the chiller.\n";
    ss << "\\minimum> 0\n";
    ss << "\\default  1.0\n";
    ss << "N10  ,  \\field Design Entering Condenser Water Temperature\n";
    ss << "\\note The temperature of the water entering the condenser of the chiller when\n";
    ss << "\\note operating at design conditions.  This is usually based on the temperature\n";
    ss << "\\note delivered by the cooling tower in a water cooled application.\n";
    ss << "\\default 29\n";
    ss << "\\units C\n";
    ss << "N11  ,  \\field Design Leaving Chilled Water Temperature\n";
    ss << "\\note The temperature of the water leaving the evaporator of the chiller when\n";
    ss << "\\note operating at design conditions also called the chilled water supply temperature\n";
    ss << "\\note or leaving chilled water temperature.\n";
    ss << "\\default 7\n";
    ss << "\\units C\n";
    ss << "N12 ,   \\field Design Chilled Water Flow Rate\n";
    ss << "\\note  For variable volume this is the max flow & for constant flow this is the flow.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N13  ,  \\field Design Condenser Water Flow Rate\n";
    ss << "\\note The water flow rate at design conditions through the condenser.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\note This field is not used for Condenser Type = AirCooled\n";
    ss << "N14  ,  \\field Design Hot Water Flow Rate\n";
    ss << "\\note The water flow rate at design conditions through the heater side.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "A8   ,  \\field Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\note The CoolCapFT curve represents the fraction of the cooling capacity of the chiller as it\n";
    ss << "\\note varies by temperature.  The curve is normalized so that at design conditions the\n";
    ss << "\\note value of the curve should be 1.0.  This is a biquadratic curve with the\n";
    ss << "\\note input variables being the leaving chilled water temperature and either\n";
    ss << "\\note the entering or leaving condenser water temperature.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A9   ,  \\field Fuel Input to Cooling Output Ratio Function of Temperature Curve Name\n";
    ss << "\\note The curve represents the fraction of the fuel input to the chiller at full load as\n";
    ss << "\\note it varies by temperature.  The curve is normalized so that at design conditions the\n";
    ss << "\\note value of the curve should be 1.0.  This is a biquadratic curve with the\n";
    ss << "\\note input variables being the leaving chilled water temperature and either\n";
    ss << "\\note the entering or leaving condenser water temperature.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A10  ,  \\field Fuel Input to Cooling Output Ratio Function of Part Load Ratio Curve Name\n";
    ss << "\\note The curve represents the fraction of the fuel input to the chiller as the load on\n";
    ss << "\\note the chiller varies but the operating temperatures remain at the design values.\n";
    ss << "\\note The curve is normalized so that at full load the value of the curve should be 1.0.\n";
    ss << "\\note The curve is usually linear or quadratic.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A11  ,  \\field Electric Input to Cooling Output Ratio Function of Temperature Curve Name\n";
    ss << "\\note The curve represents the fraction of the electricity to the chiller at full load as\n";
    ss << "\\note it varies by temperature.  The curve is normalized so that at design conditions the\n";
    ss << "\\note value of the curve should be 1.0.  This is a biquadratic curve with the\n";
    ss << "\\note input variables being the leaving chilled water temperature and either\n";
    ss << "\\note the entering or leaving condenser water temperature.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A12  ,  \\field Electric Input to Cooling Output Ratio Function of Part Load Ratio Curve Name\n";
    ss << "\\note The curve represents the fraction of the electricity to the chiller as the load on\n";
    ss << "\\note the chiller varies but the operating temperatures remain at the design values.\n";
    ss << "\\note The curve is normalized so that at full load the value of the curve should be 1.0.\n";
    ss << "\\note The curve is usually linear or quadratic.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A13  ,  \\field Heating Capacity Function of Cooling Capacity Curve Name\n";
    ss << "\\note The curve represents how the heating capacity of the chiller varies with cooling\n";
    ss << "\\note capacity when the chiller is simultaneous heating and cooling.  The curve is normalized\n";
    ss << "\\note so an input of 1.0 represents the nominal cooling capacity and an output of 1.0\n";
    ss << "\\note represents the full heating capacity (see the Heating to cooling capacity ratio input)\n";
    ss << "\\note The curve is usually linear or quadratic.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A14  ,  \\field Fuel Input to Heat Output Ratio During Heating Only Operation Curve Name\n";
    ss << "\\note When the chiller is operating as only a heater, this curve is used to represent the\n";
    ss << "\\note fraction of fuel used as the heating load varies.  It is normalized so that a value\n";
    ss << "\\note of 1.0 is the full heating capacity.  The curve is usually linear or quadratic and\n";
    ss << "\\note will probably be similar to a boiler curve for most chillers.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A15  ,  \\field Temperature Curve Input Variable\n";
    ss << "\\type choice\n";
    ss << "\\key LeavingCondenser\n";
    ss << "\\key EnteringCondenser\n";
    ss << "\\default EnteringCondenser\n";
    ss << "\\note Sets the second independent variable in the three temperature dependent performance\n";
    ss << "\\note curves to either the leaving or entering condenser water temperature.  Manufacturers\n";
    ss << "\\note express the performance of their chillers using either the leaving condenser water\n";
    ss << "\\note temperature (to the tower) or the entering condenser water temperature (from the tower).\n";
    ss << "A16  ,  \\field Condenser Type\n";
    ss << "\\note The condenser can either be air cooled or connected to a cooling tower.\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key WaterCooled\n";
    ss << "\\default WaterCooled\n";
    ss << "N15  ,  \\field Chilled Water Temperature Lower Limit\n";
    ss << "\\note The chilled water supply temperature below which the chiller\n";
    ss << "\\note will shut off.\n";
    ss << "\\units C\n";
    ss << "\\default 2.0\n";
    ss << "N16  ,  \\field Fuel Higher Heating Value\n";
    ss << "\\note Not currently used.\n";
    ss << "\\units kJ/kg\n";
    ss << "\\default 0.0\n";
    ss << "A17  ,  \\field Chiller Flow Mode\n";
    ss << "\\deprecated\n";
    ss << "A18  ,  \\field Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\default NaturalGas\n";
    ss << "N17  ;  \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::ChillerHeater_Absorption_DirectFired);
    OptionalIddObject oObj = IddObject::load("ChillerHeater:Absorption:DirectFired",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ChillerHeater_Absorption_DirectFired);
  return object;
}

IddObject createChillerHeater_Absorption_DoubleEffectIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ChillerHeater:Absorption:DoubleEffect,\n";
    ss << "\\min-fields 34\n";
    ss << "\\memo Exhaust fired absorption chiller-heater using performance curves similar to DOE-2\n";
    ss << "A1,  \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field Nominal Cooling Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units W\n";
    ss << "N2 , \\field Heating to Cooling Capacity Ratio\n";
    ss << "\\note A positive fraction that represents the ratio of the\n";
    ss << "\\note heating capacity divided by the cooling capacity at rated conditions.\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.8\n";
    ss << "N3 , \\field Thermal Energy Input to Cooling Output Ratio\n";
    ss << "\\note The positive fraction that represents the ratio of the\n";
    ss << "\\note instantaneous fuel used divided by the cooling capacity at rated conditions.\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.97\n";
    ss << "N4 , \\field Thermal Energy Input to Heating Output Ratio\n";
    ss << "\\note The positive fraction that represents the ratio of the\n";
    ss << "\\note instantaneous fuel used divided by the nominal heating capacity.\n";
    ss << "\\minimum 0\n";
    ss << "\\default 1.25\n";
    ss << "N5 , \\field Electric Input to Cooling Output Ratio\n";
    ss << "\\note The positive fraction that represents the ratio of the\n";
    ss << "\\note instantaneous electricity used divided by the cooling capacity at rated conditions.\n";
    ss << "\\note If the chiller is both heating and cooling only the cooling electricity is used.\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.01\n";
    ss << "N6 , \\field Electric Input to Heating Output Ratio\n";
    ss << "\\note The positive fraction that represents the ratio of the\n";
    ss << "\\note instantaneous electricity used divided by the nominal heating capacity.\n";
    ss << "\\note If the chiller is both heating and cooling only the cooling electricity is used.\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "A2 , \\field Chilled Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3 , \\field Chilled Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Condenser Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Condenser Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6 , \\field Hot Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7 , \\field Hot Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N7 , \\field Minimum Part Load Ratio\n";
    ss << "\\note The positive fraction that represents the minimum cooling output possible when\n";
    ss << "\\note operated continually at rated temperature conditions divided by the nominal\n";
    ss << "\\note cooling capacity at those same conditions.  If the load on the chiller is below\n";
    ss << "\\note this fraction the chiller will cycle.\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.1\n";
    ss << "N8 , \\field Maximum Part Load Ratio\n";
    ss << "\\note The positive fraction that represents the maximum cooling output possible at\n";
    ss << "\\note rated temperature conditions divided by the nominal cooling capacity at those\n";
    ss << "\\note same conditions.  If greater than 1.0, the chiller is typically thought of as\n";
    ss << "\\note capable of being overloaded.\n";
    ss << "\\minimum 0.5\n";
    ss << "\\default 1.0\n";
    ss << "N9 , \\field Optimum Part Load Ratio\n";
    ss << "\\note The positive fraction that represents the optimal cooling output at rated\n";
    ss << "\\note temperature conditions divided by the nominal cooling capacity at those same\n";
    ss << "\\note conditions.  It represents the most desirable operating point for the chiller.\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1.0\n";
    ss << "N10, \\field Design Entering Condenser Water Temperature\n";
    ss << "\\note The temperature of the water entering the condenser of the chiller when\n";
    ss << "\\note operating at design conditions.  This is usually based on the temperature\n";
    ss << "\\note delivered by the cooling tower in a water cooled application.\n";
    ss << "\\default 29\n";
    ss << "\\units C\n";
    ss << "N11, \\field Design Leaving Chilled Water Temperature\n";
    ss << "\\note The temperature of the water leaving the evaporator of the chiller when\n";
    ss << "\\note operating at design conditions also called the chilled water supply temperature\n";
    ss << "\\note or leaving chilled water temperature.\n";
    ss << "\\default 7\n";
    ss << "\\units C\n";
    ss << "N12, \\field Design Chilled Water Flow Rate\n";
    ss << "\\note  For variable volume this is the max flow & for constant flow this is the flow.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N13, \\field Design Condenser Water Flow Rate\n";
    ss << "\\note The water flow rate at design conditions through the condenser.\n";
    ss << "\\note This field is not used for Condenser Type = AirCooled\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N14, \\field Design Hot Water Flow Rate\n";
    ss << "\\note The water flow rate at design conditions through the heater side.\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "A8 , \\field Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\note The CoolCapFT curve represents the fraction of the cooling capacity of the chiller as it\n";
    ss << "\\note varies by temperature.  The curve is normalized so that at design conditions the\n";
    ss << "\\note value of the curve should be 1.0.  This is a biquadratic curve with the\n";
    ss << "\\note input variables being the leaving chilled water temperature and either\n";
    ss << "\\note the entering or leaving condenser water temperature.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A9 , \\field Fuel Input to Cooling Output Ratio Function of Temperature Curve Name\n";
    ss << "\\note The curve represents the fraction of the fuel input to the chiller at full load as\n";
    ss << "\\note it varies by temperature.  The curve is normalized so that at design conditions the\n";
    ss << "\\note value of the curve should be 1.0.  This is a biquadratic curve with the\n";
    ss << "\\note input variables being the leaving chilled water temperature and either\n";
    ss << "\\note the entering or leaving condenser water temperature.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A10, \\field Fuel Input to Cooling Output Ratio Function of Part Load Ratio Curve Name\n";
    ss << "\\note The curve represents the fraction of the fuel input to the chiller as the load on\n";
    ss << "\\note the chiller varies but the operating temperatures remain at the design values.\n";
    ss << "\\note The curve is normalized so that at full load the value of the curve should be 1.0.\n";
    ss << "\\note The curve is usually linear or quadratic.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A11, \\field Electric Input to Cooling Output Ratio Function of Temperature Curve Name\n";
    ss << "\\note The curve represents the fraction of the electricity to the chiller at full load as\n";
    ss << "\\note it varies by temperature.  The curve is normalized so that at design conditions the\n";
    ss << "\\note value of the curve should be 1.0.  This is a biquadratic curve with the\n";
    ss << "\\note input variables being the leaving chilled water temperature and either\n";
    ss << "\\note the entering or leaving condenser water temperature.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A12, \\field Electric Input to Cooling Output Ratio Function of Part Load Ratio Curve Name\n";
    ss << "\\note The curve represents the fraction of the electricity to the chiller as the load on\n";
    ss << "\\note the chiller varies but the operating temperatures remain at the design values.\n";
    ss << "\\note The curve is normalized so that at full load the value of the curve should be 1.0.\n";
    ss << "\\note The curve is usually linear or quadratic.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A13, \\field Heating Capacity Function of Cooling Capacity Curve Name\n";
    ss << "\\note The curve represents how the heating capacity of the chiller varies with cooling\n";
    ss << "\\note capacity when the chiller is simultaneous heating and cooling.  The curve is normalized\n";
    ss << "\\note so an input of 1.0 represents the nominal cooling capacity and an output of 1.0\n";
    ss << "\\note represents the full heating capacity (see the Heating to cooling capacity ratio input)\n";
    ss << "\\note The curve is usually linear or quadratic.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A14, \\field Fuel Input to Heat Output Ratio During Heating Only Operation Curve Name\n";
    ss << "\\note When the chiller is operating as only a heater, this curve is used to represent the\n";
    ss << "\\note fraction of fuel used as the heating load varies.  It is normalized so that a value\n";
    ss << "\\note of 1.0 is the full heating capacity.  The curve is usually linear or quadratic and\n";
    ss << "\\note will probably be similar to a boiler curve for most chillers.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A15, \\field Temperature Curve Input Variable\n";
    ss << "\\type choice\n";
    ss << "\\key LeavingCondenser\n";
    ss << "\\key EnteringCondenser\n";
    ss << "\\default EnteringCondenser\n";
    ss << "\\note Sets the second independent variable in the three temperature dependent performance\n";
    ss << "\\note curves to either the leaving or entering condenser water temperature.  Manufacturers\n";
    ss << "\\note express the performance of their chillers using either the leaving condenser water\n";
    ss << "\\note temperature (to the tower) or the entering condenser water temperature (from the tower).\n";
    ss << "A16, \\field Condenser Type\n";
    ss << "\\note The condenser can either be air cooled or connected to a cooling tower.\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key WaterCooled\n";
    ss << "\\default WaterCooled\n";
    ss << "N15, \\field Chilled Water Temperature Lower Limit\n";
    ss << "\\note The chilled water supply temperature below which the chiller\n";
    ss << "\\note will shut off.\n";
    ss << "\\units C\n";
    ss << "\\default 2.0\n";
    ss << "A17, \\field Exhaust Source Object Type\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Generator:MicroTurbine\n";
    ss << "A18, \\field Exhaust Source Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MicroTurbineGeneratorNames\n";
    ss << "N16; \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::ChillerHeater_Absorption_DoubleEffect);
    OptionalIddObject oObj = IddObject::load("ChillerHeater:Absorption:DoubleEffect",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ChillerHeater_Absorption_DoubleEffect);
  return object;
}

IddObject createHeatPump_WaterToWater_EquationFit_HeatingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HeatPump:WaterToWater:EquationFit:Heating,\n";
    ss << "\\memo simple water-water hp curve-fit model\n";
    ss << "\\min-fields 19\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Source Side Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3,  \\field Source Side Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Load Side Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5,  \\field Load Side Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,  \\field Rated Load Side Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N2,  \\field Rated Source Side Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N3,  \\field Rated Heating Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W\n";
    ss << "N4,  \\field Rated Heating Power Consumption\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W\n";
    ss << "N5,  \\field Heating Capacity Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N6,  \\field Heating Capacity Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N7,  \\field Heating Capacity Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N8,  \\field Heating Capacity Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N9,  \\field Heating Capacity Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N10, \\field Heating Compressor Power Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N11, \\field Heating Compressor Power Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N12, \\field Heating Compressor Power Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N13, \\field Heating Compressor Power Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N14; \\field Heating Compressor Power Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::HeatPump_WaterToWater_EquationFit_Heating);
    OptionalIddObject oObj = IddObject::load("HeatPump:WaterToWater:EquationFit:Heating",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HeatPump_WaterToWater_EquationFit_Heating);
  return object;
}

IddObject createHeatPump_WaterToWater_EquationFit_CoolingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HeatPump:WaterToWater:EquationFit:Cooling,\n";
    ss << "\\memo simple water-water heat pump curve-fit model\n";
    ss << "\\min-fields 19\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Source Side Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3,  \\field Source Side Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,  \\field Load Side Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5,  \\field Load Side Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,  \\field Rated Load Side Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N2,  \\field Rated Source Side Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N3,  \\field Rated Cooling Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W\n";
    ss << "N4,  \\field Rated Cooling Power Consumption\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W\n";
    ss << "N5,  \\field Cooling Capacity Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N6,  \\field Cooling Capacity Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N7,  \\field Cooling Capacity Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N8,  \\field Cooling Capacity Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N9,  \\field Cooling Capacity Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N10, \\field Cooling Compressor Power Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N11, \\field Cooling Compressor Power Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N12, \\field Cooling Compressor Power Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N13, \\field Cooling Compressor Power Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N14; \\field Cooling Compressor Power Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::HeatPump_WaterToWater_EquationFit_Cooling);
    OptionalIddObject oObj = IddObject::load("HeatPump:WaterToWater:EquationFit:Cooling",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HeatPump_WaterToWater_EquationFit_Cooling);
  return object;
}

IddObject createHeatPump_WaterToWater_ParameterEstimation_CoolingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HeatPump:WaterToWater:ParameterEstimation:Cooling,\n";
    ss << "\\memo OSU parameter estimation model\n";
    ss << "\\min-fields 20\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,\\field Source Side Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3,\\field Source Side Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,\\field Load Side Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5,\\field Load Side Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,\\field Nominal COP\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0\n";
    ss << "N2,\\field Nominal Capacity\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "N3,\\field Minimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N4,\\field Maximum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N5,\\field Optimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N6,\\field Load Side Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N7,\\field Source Side Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N8,\\field Load Side Heat Transfer Coefficient\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0\n";
    ss << "N9,\\field Source Side Heat Transfer Coefficient\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0\n";
    ss << "N10,\\field Piston Displacement\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "N11,\\field Compressor Clearance Factor\n";
    ss << "\\minimum> 0\n";
    ss << "N12,\\field Compressor Suction and Discharge Pressure Drop\n";
    ss << "\\units Pa\n";
    ss << "\\minimum> 0\n";
    ss << "N13,\\field Superheating\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0\n";
    ss << "N14,\\field Constant Part of Electromechanical Power Losses\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "N15,\\field Loss Factor\n";
    ss << "\\note Used to define electromechanical loss that is proportional\n";
    ss << "\\note to the theoretical power %\n";
    ss << "\\minimum> 0\n";
    ss << "N16,\\field High Pressure Cut Off\n";
    ss << "\\units Pa\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 500000000\n";
    ss << "N17;\\field Low Pressure Cut Off\n";
    ss << "\\units Pa\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::HeatPump_WaterToWater_ParameterEstimation_Cooling);
    OptionalIddObject oObj = IddObject::load("HeatPump:WaterToWater:ParameterEstimation:Cooling",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HeatPump_WaterToWater_ParameterEstimation_Cooling);
  return object;
}

IddObject createHeatPump_WaterToWater_ParameterEstimation_HeatingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HeatPump:WaterToWater:ParameterEstimation:Heating,\n";
    ss << "\\memo OSU parameter estimation model\n";
    ss << "\\min-fields 20\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,\\field Source Side Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3,\\field Source Side Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4,\\field Load Side Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5,\\field Load Side Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,\\field Nominal COP\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0\n";
    ss << "N2,\\field Nominal Capacity\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "N3,\\field Minimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N4,\\field Maximum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N5,\\field Optimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N6,\\field Load Side Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N7,\\field Source Side Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N8,\\field Load Side Heat Transfer Coefficient\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0\n";
    ss << "N9,\\field Source Side Heat Transfer Coefficient\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0\n";
    ss << "N10,\\field Piston Displacement\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "N11,\\field Compressor Clearance Factor\n";
    ss << "\\minimum> 0\n";
    ss << "N12,\\field Compressor Suction and Discharge Pressure Drop\n";
    ss << "\\units Pa\n";
    ss << "\\minimum> 0\n";
    ss << "N13,\\field Superheating\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0\n";
    ss << "N14,\\field Constant Part of Electromechanical Power Losses\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "N15,\\field Loss Factor\n";
    ss << "\\note Used to define electromechanical loss that is proportional\n";
    ss << "\\note to the theoretical power %\n";
    ss << "\\minimum> 0\n";
    ss << "N16,\\field High Pressure Cut Off\n";
    ss << "\\units Pa\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 500000000\n";
    ss << "N17;\\field Low Pressure Cut Off\n";
    ss << "\\units Pa\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::HeatPump_WaterToWater_ParameterEstimation_Heating);
    OptionalIddObject oObj = IddObject::load("HeatPump:WaterToWater:ParameterEstimation:Heating",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HeatPump_WaterToWater_ParameterEstimation_Heating);
  return object;
}

IddObject createDistrictCoolingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "DistrictCooling,\n";
    ss << "\\memo Centralized source of chilled water, such as a district cooling system.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Chilled Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3 , \\field Chilled Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Nominal Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "A4 ; \\field Capacity Fraction Schedule Name\n";
    ss << "\\note Schedule values are multiplied by Nominal Capacity for current capacity\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::DistrictCooling);
    OptionalIddObject oObj = IddObject::load("DistrictCooling",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::DistrictCooling);
  return object;
}

IddObject createDistrictHeatingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "DistrictHeating,\n";
    ss << "\\memo Centralized source of hot water, such as a district heating system.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Hot Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3 , \\field Hot Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Nominal Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "A4 ; \\field Capacity Fraction Schedule Name\n";
    ss << "\\note Schedule values are multiplied by Nominal Capacity for current capacity\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::DistrictHeating);
    OptionalIddObject oObj = IddObject::load("DistrictHeating",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::DistrictHeating);
  return object;
}

IddObject createPlantComponent_TemperatureSourceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PlantComponent:TemperatureSource,\n";
    ss << "\\memo Simulates an object of pre-determined (constant or scheduled) source temperature\n";
    ss << "\\memo The object introduces fluid into the plant loop at the specified temperature and\n";
    ss << "\\memo  at the same flow rate as the fluid enters the component\n";
    ss << "\\memo Fluid entering the component vanishes equivalent to the relief air in an air system\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note Component Name\n";
    ss << "A2 , \\field Inlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of the source inlet node\n";
    ss << "A3 , \\field Outlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of the source outlet node\n";
    ss << "N1 , \\field Design Volume Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note The design volumetric flow rate for this source\n";
    ss << "\\ip-units gal/min\n";
    ss << "A4 , \\field Temperature Specification Type\n";
    ss << "\\type choice\n";
    ss << "\\key Constant\n";
    ss << "\\key Scheduled\n";
    ss << "N2 , \\field Source Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Used if Temperature Specification Type = Constant\n";
    ss << "A5 ; \\field Source Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\units C\n";
    ss << "\\note Used if Temperature Specification Type = Scheduled\n";

    IddObjectType objType(IddObjectType::PlantComponent_TemperatureSource);
    OptionalIddObject oObj = IddObject::load("PlantComponent:TemperatureSource",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PlantComponent_TemperatureSource);
  return object;
}

IddObject createCentralHeatPumpSystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "CentralHeatPumpSystem,\n";
    ss << "\\min-fields 14\n";
    ss << "\\memo This chiller bank can contain multiple chiller heaters and heat pump performance objects.\n";
    ss << "\\memo Its function is to encapsulate the extra controls needed to turn individual modules on/off\n";
    ss << "\\memo and whether they are to operate in cooling-only, heating-only or simultaneous cooling/heating\n";
    ss << "\\memo mode and whether to connect the source water to the evaporator or condenser side.\n";
    ss << "\\extensible:4\n";
    ss << "A1,  \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Control Method\n";
    ss << "\\type choice\n";
    ss << "\\key SmartMixing\n";
    ss << "\\default SmartMixing\n";
    ss << "A3,  \\field Cooling Loop Inlet Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A4,  \\field Cooling Loop Outlet Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A5,  \\field Source Loop Inlet Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A6,  \\field Source Loop Outlet Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A7,  \\field Heating Loop Inlet Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A8,  \\field Heating Loop Outlet Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "N1,  \\field Ancillary Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Power as demanded from any auxiliary controls\n";
    ss << "A9,  \\field Ancillary Operation Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This value from this schedule is multiplied times the Ancillary Power\n";
    ss << "A10, \\field Chiller Heater Modules Performance Component Object Type 1\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key ChillerHeaterPerformance:Electric:EIR\n";
    ss << "A11, \\field Chiller Heater Modules Performance Component Name 1\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ChillerHeaterEIRNames\n";
    ss << "A12, \\field Chiller Heater Modules Control Schedule Name 1\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\required-field\n";
    ss << "N2;  \\field Number of Chiller Heater Modules 1\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";

    IddObjectType objType(IddObjectType::CentralHeatPumpSystem);
    OptionalIddObject oObj = IddObject::load("CentralHeatPumpSystem",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::CentralHeatPumpSystem);
  return object;
}

IddObject createChillerHeaterPerformance_Electric_EIRIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ChillerHeaterPerformance:Electric:EIR,\n";
    ss << "\\min-fields 29\n";
    ss << "\\memo This chiller model is a generic chiller-heater where the cooling mode performance is a\n";
    ss << "\\memo function of condenser entering or leaving fluid temperature and the heating mode performance\n";
    ss << "\\memo is typically a function of condenser leaving fluid temperature. Performance at off-reference\n";
    ss << "\\memo conditions is modeled using three polynomial equations per mode. Six curve objects are required.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ChillerHeaterEIRNames\n";
    ss << "N1 , \\field Reference Cooling Mode Evaporator Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Reference Cooling Mode COP\n";
    ss << "\\note Efficiency of the chiller compressor (cooling output/compressor energy input).\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3 , \\field Reference Cooling Mode Leaving Chilled Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\default 6.67\n";
    ss << "\\units C\n";
    ss << "N4 , \\field Reference Cooling Mode Entering Condenser Fluid Temperature\n";
    ss << "\\type real\n";
    ss << "\\default 29.44\n";
    ss << "\\units C\n";
    ss << "N5 , \\field Reference Cooling Mode Leaving Condenser Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\default 35.0\n";
    ss << "\\units C\n";
    ss << "N6 , \\field Reference Heating Mode Cooling Capacity Ratio\n";
    ss << "\\note During simultaneous cooling-heating mode, this ratio is relative to the Reference Cooling Mode Cooling Capacity\n";
    ss << "\\note (Evaporator capacity at simul clg-htg mode ref condition)/ (Evaporator capacity at cooling mode ref condition)\n";
    ss << "\\type real\n";
    ss << "\\default 0.75\n";
    ss << "N7 , \\field Reference Heating Mode Cooling Power Input Ratio\n";
    ss << "\\note During simultaneous cooling-heating mode, this ratio is relative to the Reference Cooling Mode COP\n";
    ss << "\\note (Power at simultaneous clg-htg mode reference condition)/ (Power at cooling mode reference condition)\n";
    ss << "\\type real\n";
    ss << "\\default 1.38\n";
    ss << "\\minimum> 0.0\n";
    ss << "N8 , \\field Reference Heating Mode Leaving Chilled Water Temperature\n";
    ss << "\\note During simultaneous cooling-heating mode\n";
    ss << "\\type real\n";
    ss << "\\default 6.67\n";
    ss << "\\units C\n";
    ss << "N9 , \\field Reference Heating Mode Leaving Condenser Water Temperature\n";
    ss << "\\note During simultaneous cooling-heating mode\n";
    ss << "\\type real\n";
    ss << "\\default 49\n";
    ss << "\\units C\n";
    ss << "N10, \\field Reference Heating Mode Entering Condenser Fluid Temperature\n";
    ss << "\\type real\n";
    ss << "\\default 29.44\n";
    ss << "\\units C\n";
    ss << "N11, \\field Heating Mode Entering Chilled Water Temperature Low Limit\n";
    ss << "\\note During simultaneous cooling-heating mode\n";
    ss << "\\type real\n";
    ss << "\\default 12.22\n";
    ss << "\\units C\n";
    ss << "A2 , \\field Chilled Water Flow Mode Type\n";
    ss << "\\note Sets chilled water flow rate to either constant or variable.\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\key VariableFlow\n";
    ss << "\\default ConstantFlow\n";
    ss << "N12, \\field Design Chilled Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N13, \\field Design Condenser Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N14, \\field Design Hot Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N15, \\field Compressor Motor Efficiency\n";
    ss << "\\type real\n";
    ss << "\\note Fraction of compressor electrical energy that must be rejected by the condenser.\n";
    ss << "\\note Enter 1.0 or leave this field blank for a hermetic compressor.\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A3 , \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key WaterCooled\n";
    ss << "\\default WaterCooled\n";
    ss << "A4 , \\field Cooling Mode Temperature Curve Condenser Water Independent Variable\n";
    ss << "\\type choice\n";
    ss << "\\key EnteringCondenser\n";
    ss << "\\key LeavingCondenser\n";
    ss << "\\default EnteringCondenser\n";
    ss << "\\note Sets the second independent variable in the three temperature dependent performance\n";
    ss << "\\note curves to either the leaving or entering condenser water temperature. Manufacturers\n";
    ss << "\\note express the performance of their chillers using either the leaving condenser water\n";
    ss << "\\note temperature (to the tower) or the entering condenser water temperature (from the tower).\n";
    ss << "\\note Cooling mode is generally a stronger function of Entering Condenser Fluid Temperature\n";
    ss << "A5 , \\field Cooling Mode Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\note Cooling capacity as a function of leaving chilled water temperature\n";
    ss << "\\note and either entering or leaving condenser fluid temperature\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*CWS + c*CWS**2 + d*TCond + e*TCond**2 + f*CWS*TCond\n";
    ss << "\\note    If ClgModeCondWaterCurveInputVariable = EnteringCondenser, TCond = ECT\n";
    ss << "\\note    If ClgModeCondWaterCurveInputVariable = LeavingCondenser, TCond = LCT\n";
    ss << "\\note CWS = supply (leaving) chilled water temperature(C)\n";
    ss << "\\note LCT = leaving condenser fluid temperature(C)\n";
    ss << "\\note ECT = entering condenser fluid temperature(C)\n";
    ss << "A6 , \\field Cooling Mode Electric Input to Cooling Output Ratio Function of Temperature Curve Name\n";
    ss << "\\note Electric Input Ratio (EIR) as a function of supply (leaving) chilled water temperature\n";
    ss << "\\note and leaving condenser fluid temperature.   EIR = 1/COP.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*CWS + c*CWS**2 + d*TCond + e*TCond**2 + f*CWS*TCond\n";
    ss << "\\note If ClgModeCondWaterCurveInputVariable = EnteringCondenser, TCond = ECT\n";
    ss << "\\note If ClgModeCondWaterCurveInputVariable = LeavingCondenser, TCond = LCT\n";
    ss << "\\note CWS = supply (leaving) chilled water temperature(C)\n";
    ss << "\\note LCT = leaving condenser fluid temperature(C)\n";
    ss << "\\note ECT = entering condenser fluid temperature(C)\n";
    ss << "A7 , \\field Cooling Mode Electric Input to Cooling Output Ratio Function of Part Load Ratio Curve Name\n";
    ss << "\\note Electric Input Ratio (EIR) as a function of Part Load Ratio (PLR)\n";
    ss << "\\note EIR = 1/COP\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BicubicCurves\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note  Bicubic = a + b*TCond + c*TCond**2 + d*PLR + e*PLR**2 + f*TCond*PLR +g*0 + h*PLR**3+i*0+j*0\n";
    ss << "\\note    If ClgModeCondWaterCurveInputVariable = EnteringCondenser, TCond = ECT\n";
    ss << "\\note    If ClgModeCondWaterCurveInputVariable = LeavingCondenser, TCond = LCT\n";
    ss << "\\note    Normally, a bicubic curve here should be in terms of LCT rather than ECT\n";
    ss << "\\note    Also, a bicubic curve is more applicable for variable-speed compressor motor drives\n";
    ss << "\\note or\n";
    ss << "\\note  Quadratic = a + b*PLR + c*PLR**2\n";
    ss << "\\note PLR = part load ratio (cooling load/steady-state capacity)\n";
    ss << "\\note LCT = leaving condenser fluid temperature(C)\n";
    ss << "\\note ECT = entering condenser fluid temperature(C)\n";
    ss << "N16, \\field Cooling Mode Cooling Capacity Optimum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\note Optimum part load ratio where the chiller is most efficient.\n";
    ss << "\\note Must be greater than or equal to the Minimum Part Load Ratio\n";
    ss << "\\note and less than or equal to the Maximum Part Load Ratio.\n";
    ss << "\\note The Min/Max PLR are taken from their associated EIR-FPLR curve references.\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "A8 , \\field Heating Mode Temperature Curve Condenser Water Independent Variable\n";
    ss << "\\type choice\n";
    ss << "\\key EnteringCondenser\n";
    ss << "\\key LeavingCondenser\n";
    ss << "\\default LeavingCondenser\n";
    ss << "\\note Sets the second independent variable in the three temperature dependent performance\n";
    ss << "\\note curves to either the leaving or entering condenser water temperature. Manufacturers\n";
    ss << "\\note express the performance of their chillers using either the leaving condenser water\n";
    ss << "\\note temperature (to the tower) or the entering condenser water temperature (from the tower).\n";
    ss << "\\note Heating mode (or Simul Clg/Htg Load) should be a function of Leaving Condenser Fluid Temperature\n";
    ss << "\\note Only use EnteringCondenser as a last resort in case no performance data exists for LeavingCondenser\n";
    ss << "A9 , \\field Heating Mode Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\note Evaporator (cooling) capacity as a function of leaving chilled water temperature\n";
    ss << "\\note and leaving condenser fluid temperature when in heating or simultaneous cool/heat mode\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*CWS + c*CWS**2 + d*TCond + e*TCond**2 + f*CWS*TCond\n";
    ss << "\\note    If independent variable = EnteringCondenser, TCond = ECT\n";
    ss << "\\note    If independent variable = LeavingCondenser, TCond = LCT\n";
    ss << "\\note CWS = supply (leaving) chilled water temperature(C)\n";
    ss << "\\note LCT = leaving condenser fluid temperature(C)\n";
    ss << "\\note ECT = entering condenser fluid temperature(C)\n";
    ss << "A10, \\field Heating Mode Electric Input to Cooling Output Ratio Function of Temperature Curve Name\n";
    ss << "\\note Electric Input Ratio (EIR) as a function of leaving chilled water temperature when in heating or simultaneous cool/heat mode\n";
    ss << "\\note and leaving condenser fluid temperature.   EIR = 1/COP.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*CWS + c*CWS**2 + d*TCond + e*TCond**2 + f*CWS*TCond\n";
    ss << "\\note    If independent variable = EnteringCondenser, TCond = ECT\n";
    ss << "\\note    If independent variable = LeavingCondenser, TCond = LCT\n";
    ss << "\\note CWS = leaving chilled water temperature(C)\n";
    ss << "\\note LCT = leaving condenser fluid temperature(C)\n";
    ss << "\\note ECT = entering condenser fluid temperature(C)\n";
    ss << "A11, \\field Heating Mode Electric Input to Cooling Output Ratio Function of Part Load Ratio Curve Name\n";
    ss << "\\note Electric Input Ratio (EIR) as a function of Part Load Ratio (PLR) when in heating or simultaneous cool/heat mode\n";
    ss << "\\note EIR = 1/COP\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BicubicCurves\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note  Bicubic = a + b*LCT + c*LCT**2 + d*PLR + e*PLR**2 + f*LCT*PLR + g*0 + h*PLR**3 + i*0 + j*0\n";
    ss << "\\note    Normally, a bicubic curve here should be in terms of LCT rather than ECT\n";
    ss << "\\note    Also, a bicubic curve is more applicable for variable-speed compressor motor drives\n";
    ss << "\\note or\n";
    ss << "\\note  Quadratic = a + b*PLR + c*PLR**2\n";
    ss << "\\note PLR = part load ratio (cooling load/steady-state capacity)\n";
    ss << "\\note LCT = leaving condenser fluid temperature(C)\n";
    ss << "\\note ECT = entering condenser fluid temperature(C)\n";
    ss << "N17, \\field Heating Mode Cooling Capacity Optimum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\note Optimum part load ratio where the chiller is most efficient when in heating or simultaneous cool/heat mode.\n";
    ss << "\\note Must be greater than or equal to the Minimum Part Load Ratio\n";
    ss << "\\note and less than or equal to the Maximum Part Load Ratio.\n";
    ss << "\\note The Min/Max PLR are taken from their associated EIR-FPLR curve references.\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N18; \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::ChillerHeaterPerformance_Electric_EIR);
    OptionalIddObject oObj = IddObject::load("ChillerHeaterPerformance:Electric:EIR",
                                             "Plant Heating and Cooling Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ChillerHeaterPerformance_Electric_EIR);
  return object;
}

IddObject createCoolingTower_SingleSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "CoolingTower:SingleSpeed,\n";
    ss << "\\min-fields 16\n";
    ss << "\\memo This tower model is based on Merkel's theory, which is also the basis\n";
    ss << "\\memo for the tower model in ASHRAE's HVAC1 Toolkit. The open wet cooling tower\n";
    ss << "\\memo is modeled as a counter flow heat exchanger with a single-speed fan drawing air\n";
    ss << "\\memo through the tower (induced-draft configuration).\n";
    ss << "\\memo Added fluid bypass as an additional capacity control. 8/2008.\n";
    ss << "\\memo For a multi-cell tower, the capacity and air/water flow rate inputs are for the entire tower.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingTowers\n";
    ss << "\\note Tower Name\n";
    ss << "A2 , \\field Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of tower water inlet node\n";
    ss << "A3 , \\field Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of tower water outlet node\n";
    ss << "N1 , \\field Design Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Leave field blank if tower performance input method is NominalCapacity\n";
    ss << "\\ip-units gal/min\n";
    ss << "N2 , \\field Design Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N3 , \\field Design Fan Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\note This is the fan motor electric input power\n";
    ss << "N4 , \\field Design U-Factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 2100000.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Leave field blank if tower performance input method is NominalCapacity\n";
    ss << "N5 , \\field Free Convection Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "N6 , \\field Free Convection Air Flow Rate Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.1\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate.\n";
    ss << "N7 , \\field Free Convection U-Factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 300000.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "N8 , \\field Free Convection U-Factor Times Area Value Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.1\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate and\n";
    ss << "\\note the Performance Input Method is UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "A4 , \\field Performance Input Method\n";
    ss << "\\type choice\n";
    ss << "\\key UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\key NominalCapacity\n";
    ss << "\\default UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\note User can define tower thermal performance by specifying the tower UA,\n";
    ss << "\\note the Design Air Flow Rate and the Design Water Flow Rate,\n";
    ss << "\\note or by specifying the tower nominal capacity\n";
    ss << "N9 , \\field Heat Rejection Capacity and Nominal Capacity Sizing Ratio\n";
    ss << "\\type real\n";
    ss << "\\default 1.25\n";
    ss << "N10, \\field Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Nominal tower capacity with entering water at 35C (95F), leaving water at\n";
    ss << "\\note 29.44C (85F), entering air at 25.56C (78F) wet-bulb temperature and 35C (95F)\n";
    ss << "\\note dry-bulb temperature. Design water flow rate assumed to be 5.382E-8 m3/s per watt\n";
    ss << "\\note (3 gpm/ton). Nominal tower capacity times (1.25) gives the actual tower\n";
    ss << "\\note heat rejection at these operating conditions.\n";
    ss << "N11, \\field Free Convection Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Tower capacity in free convection regime with entering water at 35C (95F),\n";
    ss << "\\note leaving water at 29.44C (85F), entering air at 25.56C (78F) wet-bulb temperature\n";
    ss << "\\note and 35C (95F) dry-bulb temperature. Design water flow rate assumed to be\n";
    ss << "\\note 5.382E-8 m3/s per watt of nominal tower capacity (3 gpm/ton). Tower free\n";
    ss << "\\note convection capacity times (1.25) gives the actual tower heat rejection at these\n";
    ss << "\\note operating conditions.\n";
    ss << "N12, \\field Free Convection Nominal Capacity Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.1\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate\n";
    ss << "N13, \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This heater maintains the basin water temperature at the basin heater setpoint\n";
    ss << "\\note temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when water is not flowing through the tower.\n";
    ss << "N14, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on\n";
    ss << "A5 , \\field Basin Heater Operating Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";
    ss << "A6 , \\field Evaporation Loss Mode\n";
    ss << "\\type choice\n";
    ss << "\\key LossFactor\n";
    ss << "\\key SaturatedExit\n";
    ss << "N15, \\field Evaporation Loss Factor\n";
    ss << "\\type real\n";
    ss << "\\units percent/K\n";
    ss << "\\note Rate of water evaporation from the cooling tower and lost to the outdoor air [%/K]\n";
    ss << "\\note Evaporation loss is calculated as percentage of the circulating condenser water rate\n";
    ss << "\\note Value entered here is percent-per-degree K of temperature drop in the condenser water\n";
    ss << "\\note Typical values are from 0.15 to 0.27 [%/K].\n";
    ss << "\\default 0.2\n";
    ss << "N16, \\field Drift Loss Percent\n";
    ss << "\\type real\n";
    ss << "\\default 0.008\n";
    ss << "\\units percent\n";
    ss << "\\note Rate of drift loss as a percentage of circulating condenser water flow rate\n";
    ss << "\\note Typical values are between 0.002 and 0.2% The default value is 0.008%\n";
    ss << "A7 , \\field Blowdown Calculation Mode\n";
    ss << "\\type choice\n";
    ss << "\\key ConcentrationRatio\n";
    ss << "\\key ScheduledRate\n";
    ss << "N17, \\field Blowdown Concentration Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 3.0\n";
    ss << "\\note Characterizes the rate of blowdown in the cooling tower.\n";
    ss << "\\note Blowdown is water intentionally drained from the tower in order to offset the build up\n";
    ss << "\\note of solids in the water that would otherwise occur because of evaporation.\n";
    ss << "\\note Ratio of solids in the blowdown water to solids in the make up water.\n";
    ss << "\\note Typical values for tower operation are 3 to 5.  The default value is 3.\n";
    ss << "A8 , \\field Blowdown Makeup Water Usage Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Makeup water usage due to blowdown results from occasionally draining a small amount\n";
    ss << "\\note of water in the tower basin to purge scale or other contaminants to reduce their\n";
    ss << "\\note concentration in order to maintain an acceptable level of water quality.\n";
    ss << "\\note Schedule values should reflect water usage in m3/s.\n";
    ss << "A9 , \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A10, \\field Outdoor Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of an outdoor air node\n";
    ss << "A11, \\field Capacity Control\n";
    ss << "\\type choice\n";
    ss << "\\key FanCycling\n";
    ss << "\\key FluidBypass\n";
    ss << "\\default FanCycling\n";
    ss << "N18, \\field Number of Cells\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";
    ss << "A12, \\field Cell Control\n";
    ss << "\\type Choice\n";
    ss << "\\key MinimalCell\n";
    ss << "\\key MaximalCell\n";
    ss << "\\default MinimalCell\n";
    ss << "N19, \\field Cell Minimum  Water Flow Rate Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.33\n";
    ss << "\\note The allowable minimal fraction of the nominal flow rate per cell\n";
    ss << "N20, \\field Cell Maximum Water Flow Rate Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 1\n";
    ss << "\\default 2.5\n";
    ss << "\\note The allowable maximal fraction of the nominal flow rate per cell\n";
    ss << "N21; \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::CoolingTower_SingleSpeed);
    OptionalIddObject oObj = IddObject::load("CoolingTower:SingleSpeed",
                                             "Condenser Equipment and Heat Exchangers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::CoolingTower_SingleSpeed);
  return object;
}

IddObject createCoolingTower_TwoSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "CoolingTower:TwoSpeed,\n";
    ss << "\\min-fields 24\n";
    ss << "\\memo This tower model is based on Merkel's theory, which is also the basis\n";
    ss << "\\memo for the tower model in ASHRAE's HVAC1 Toolkit. The open wet cooling tower\n";
    ss << "\\memo is modeled as a counter flow heat exchanger with a two-speed fan drawing air\n";
    ss << "\\memo through the tower (induced-draft configuration).\n";
    ss << "\\memo For a multi-cell tower, the capacity and air/water flow rate inputs are for the entire tower.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingTowers\n";
    ss << "\\note Tower Name\n";
    ss << "A2 , \\field Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of tower Water Inlet Node\n";
    ss << "A3 , \\field Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of tower Water Outlet Node\n";
    ss << "N1 , \\field Design Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Leave field blank if Tower Performance Input Method is NominalCapacity\n";
    ss << "\\ip-units gal/min\n";
    ss << "N2 , \\field High Fan Speed Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N3 , \\field High Fan Speed Fan Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\note This is the fan motor electric input power at high speed\n";
    ss << "N4 , \\field High Fan Speed U-Factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 2100000.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Leave field blank if Tower Performance Input Method is NominalCapacity\n";
    ss << "N5 , \\field Low Fan Speed Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Low speed air flow rate must be less than high speed air flow rate\n";
    ss << "\\note Low speed air flow rate must be greater than free convection air flow rate\n";
    ss << "N6 , \\field Low Fan Speed Air Flow Rate Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate.\n";
    ss << "N7 , \\field Low Fan Speed Fan Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\ip-units W\n";
    ss << "\\note This is the fan motor electric input power at low speed\n";
    ss << "N8 , \\field Low Fan Speed Fan Power Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.16\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate.\n";
    ss << "N9 , \\field Low Fan Speed U-Factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 300000.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Leave field blank if tower Performance Input Method is NominalCapacity\n";
    ss << "\\note Low speed tower UA must be less than high speed tower UA\n";
    ss << "\\note Low speed tower UA must be greater than free convection tower UA\n";
    ss << "N10, \\field Low Fan Speed U-Factor Times Area Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.6\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate and\n";
    ss << "\\note the Performance Input Method is UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "N11, \\field Free Convection Regime Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "N12, \\field Free Convection Regime Air Flow Rate Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.1\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate.\n";
    ss << "N13, \\field Free Convection Regime U-Factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 300000.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Leave field blank if Tower Performance Input Method is NominalCapacity\n";
    ss << "N14, \\field Free Convection U-Factor Times Area Value Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.1\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate and\n";
    ss << "\\note the Performance Input Method is UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "A4 , \\field Performance Input Method\n";
    ss << "\\type choice\n";
    ss << "\\key UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\key NominalCapacity\n";
    ss << "\\default UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\note User can define tower thermal performance by specifying the tower UA,\n";
    ss << "\\note the Design Air Flow Rate and the Design Water Flow Rate,\n";
    ss << "\\note or by specifying the tower nominal capacity\n";
    ss << "N15, \\field Heat Rejection Capacity and Nominal Capacity Sizing Ratio\n";
    ss << "\\type real\n";
    ss << "\\default 1.25\n";
    ss << "N16, \\field High Speed Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Nominal tower capacity with entering water at 35C (95F), leaving water at\n";
    ss << "\\note 29.44C (85F), entering air at 25.56C (78F) wet-bulb temperature and 35C (95F)\n";
    ss << "\\note dry-bulb temperature, with the tower fan operating at high speed. Design water\n";
    ss << "\\note flow rate assumed to be 5.382E-8 m3/s per watt(3 gpm/ton). Nominal tower capacity\n";
    ss << "\\note times the Heat Rejection Capacity and Nominal Capacity Sizing Ratio (e.g. 1.25)\n";
    ss << "\\note gives the actual tower heat rejection at these operating conditions.\n";
    ss << "N17, \\field Low Speed Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Nominal tower capacity with entering water at 35C (95F), leaving water at\n";
    ss << "\\note 29.44C (85F), entering air at 25.56C (78F) wet-bulb temperature and 35C (95F)\n";
    ss << "\\note dry-bulb temperature, with the tower fan operating at low speed. Design water flow\n";
    ss << "\\note rate assumed to be 5.382E-8 m3/s per watt of tower high-speed nominal capacity\n";
    ss << "\\note (3 gpm/ton). Nominal tower capacity times the Heat Rejection Capacity and Nominal\n";
    ss << "\\note Capacity Sizing Ratio (e.g. 1.25) gives the actual tower heat\n";
    ss << "\\note rejection at these operating conditions.\n";
    ss << "N18, \\field Low Speed Nominal Capacity Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate\n";
    ss << "N19, \\field Free Convection Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Tower capacity in free convection regime with entering water at 35C (95F),\n";
    ss << "\\note leaving water at 29.44C (85F), entering air at 25.56C (78F) wet-bulb temperature\n";
    ss << "\\note and 35C (95F) dry-bulb temperature. Design water flow rate assumed to be\n";
    ss << "\\note 5.382E-8 m3/s per watt of tower high-speed nominal capacity (3 gpm/ton). Tower\n";
    ss << "\\note free convection capacity times the Heat Rejection Capacity and Nominal Capacity Sizing Ratio\n";
    ss << "\\note (e.g. 1.25)  gives the actual tower heat rejection at these operating conditions\n";
    ss << "N20, \\field Free Convection Nominal Capacity Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.1\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate\n";
    ss << "N21, \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This heater maintains the basin water temperature at the basin heater setpoint\n";
    ss << "\\note temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when water is not flowing through the tower.\n";
    ss << "N22, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on\n";
    ss << "A5 , \\field Basin Heater Operating Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";
    ss << "A6 , \\field Evaporation Loss Mode\n";
    ss << "\\type choice\n";
    ss << "\\key LossFactor\n";
    ss << "\\key SaturatedExit\n";
    ss << "N23, \\field Evaporation Loss Factor\n";
    ss << "\\type real\n";
    ss << "\\units percent/K\n";
    ss << "\\note Rate of water evaporated from the cooling tower and lost to the outdoor air [%/K]\n";
    ss << "\\note Evaporation loss is calculated as percentage of the circulating condenser water rate\n";
    ss << "\\note Value entered here is percent-per-degree K of temperature drop in the condenser water\n";
    ss << "\\note Typical values are from 0.15 to 0.27 [%/K].\n";
    ss << "\\default 0.2\n";
    ss << "N24, \\field Drift Loss Percent\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\default 0.008\n";
    ss << "\\note Rate of drift loss as a percentage of circulating condenser water flow rate\n";
    ss << "\\note Typical values are between 0.002 and 0.2% The default value is 0.008%\n";
    ss << "A7 , \\field Blowdown Calculation Mode\n";
    ss << "\\type choice\n";
    ss << "\\key ConcentrationRatio\n";
    ss << "\\key ScheduledRate\n";
    ss << "N25, \\field Blowdown Concentration Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 3.0\n";
    ss << "\\note Characterizes the rate of blowdown in the cooling tower.\n";
    ss << "\\note Blowdown is water intentionally drained from the tower in order to offset the build up\n";
    ss << "\\note of solids in the water that would otherwise occur because of evaporation.\n";
    ss << "\\note Ratio of solids in the blowdown water to solids in the make up water.\n";
    ss << "\\note Typical values for tower operation are 3 to 5.  The default value is 3.\n";
    ss << "A8 , \\field Blowdown Makeup Water Usage Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Makeup water usage due to blowdown results from occasionally draining some amount\n";
    ss << "\\note of water in the tower basin to purge scale or other contaminants to reduce their\n";
    ss << "\\note concentration in order to maintain an acceptable level of water quality.\n";
    ss << "\\note Schedule values should reflect water usage in m3/s.\n";
    ss << "A9 , \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A10 , \\field Outdoor Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of an outdoor air node\n";
    ss << "N26, \\field Number of Cells\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";
    ss << "A11, \\field Cell Control\n";
    ss << "\\type choice\n";
    ss << "\\key MinimalCell\n";
    ss << "\\key MaximalCell\n";
    ss << "\\default MinimalCell\n";
    ss << "N27, \\field Cell Minimum  Water Flow Rate Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.33\n";
    ss << "\\note The allowable minimal fraction of the nominal flow rate per cell\n";
    ss << "N28, \\field Cell Maximum Water Flow Rate Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 1\n";
    ss << "\\default 2.5\n";
    ss << "\\note The allowable maximal fraction of the nominal flow rate per cell\n";
    ss << "N29; \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::CoolingTower_TwoSpeed);
    OptionalIddObject oObj = IddObject::load("CoolingTower:TwoSpeed",
                                             "Condenser Equipment and Heat Exchangers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::CoolingTower_TwoSpeed);
  return object;
}

IddObject createCoolingTower_VariableSpeed_MerkelIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "CoolingTower:VariableSpeed:Merkel,\n";
    ss << "\\min-fields 24\n";
    ss << "\\memo This tower model is based on Merkel's theory, which is also the basis\n";
    ss << "\\memo for the tower model in ASHRAE's HVAC1 Toolkit. The open wet cooling tower\n";
    ss << "\\memo is modeled as a counter flow heat exchanger with a variable-speed fan drawing air\n";
    ss << "\\memo through the tower (induced-draft configuration).\n";
    ss << "\\memo For a multi-cell tower, the capacity and air/water flow rate inputs are for the entire tower.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingTowers\n";
    ss << "\\note Tower Name\n";
    ss << "A2 , \\field Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of tower water inlet node\n";
    ss << "A3 , \\field Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of tower water outlet node\n";
    ss << "A4 , \\field Performance Input Method\n";
    ss << "\\type choice\n";
    ss << "\\key UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\key NominalCapacity\n";
    ss << "\\default NominalCapacity\n";
    ss << "\\note User can define tower thermal performance by specifying the tower UA,\n";
    ss << "\\note the Design Air Flow Rate and the Design Water Flow Rate,\n";
    ss << "\\note or by specifying the tower nominal capacity\n";
    ss << "N1,  \\field Heat Rejection Capacity and Nominal Capacity Sizing Ratio\n";
    ss << "\\type real\n";
    ss << "\\default 1.25\n";
    ss << "N2,  \\field Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Nominal tower capacity with entering water at 35C (95F), leaving water at\n";
    ss << "\\note 29.44C (85F), entering air at 25.56C (78F) wet-bulb temperature and 35C (95F)\n";
    ss << "\\note dry-bulb temperature, with the tower fan operating at Design Air Flow Rate (full speed). Design water\n";
    ss << "\\note flow rate is as set in Design Water Flow Rate per Unit of Nominal Capacity. Nominal tower capacity\n";
    ss << "\\note times the Heat Rejection Capacity and Nominal Capacity Sizing Ratio (e.g. 1.25)\n";
    ss << "\\note gives the actual tower heat rejection at these operating conditions.\n";
    ss << "N3,  \\field Free Convection Nominal Capacity\n";
    ss << "\\note required field when performance method is NominalCapacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Tower capacity in free convection regime with entering water at 35C (95F),\n";
    ss << "\\note leaving water at 29.44C (85F), entering air at 25.56C (78F) wet-bulb temperature\n";
    ss << "\\note and 35C (95F) dry-bulb temperature. Design water flow rate is as set\n";
    ss << "\\note  in Design Water Flow Rate per Unit of Nominal Capacity. Tower\n";
    ss << "\\note free convection capacity times the Heat Rejection Capacity and Nominal Capacity Sizing Ratio\n";
    ss << "\\note (e.g. 1.25)  gives the actual tower heat rejection at these operating conditions\n";
    ss << "N4,  \\field Free Convection Nominal Capacity Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.1\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate\n";
    ss << "N5 , \\field Design Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N6 , \\field Design Water Flow Rate per Unit of Nominal Capacity\n";
    ss << "\\note This field is only used if the previous is set to autocalculate and performance input method is NominalCapacity\n";
    ss << "\\units m3/s-W\n";
    ss << "\\ip-units gal/min-W\n";
    ss << "\\default 5.382E-8\n";
    ss << "\\type real\n";
    ss << "N7 , \\field Design Air Flow Rate\n";
    ss << "\\note This is the air flow rate at full fan speed\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "N8 , \\field Design Air Flow Rate Per Unit of Nominal Capacity\n";
    ss << "\\note This field is only used if the previous is set to autocalculate\n";
    ss << "\\units m3/s-W\n";
    ss << "\\default 2.76316E-5\n";
    ss << "\\type real\n";
    ss << "\\note When field is left blank the default scaling factor is adjusted for elevation to increase volume flow at altitude\n";
    ss << "\\note When field has a value the scaling factor is used without adjusting for elevation\n";
    ss << "N9 , \\field Minimum Air Flow Rate Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.1\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.2\n";
    ss << "\\note Enter the minimum air flow rate ratio. This is typically determined by the variable\n";
    ss << "\\note speed drive that controls the fan motor speed. Valid entries are from 0.1 to 0.5.\n";
    ss << "N10, \\field Design Fan Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\ip-units W\n";
    ss << "\\note This is the fan motor electric input power at high speed\n";
    ss << "N11, \\field Design Fan Power Per Unit of Nominal Capacity\n";
    ss << "\\note This field is only used if the previous is set to autocalculate\n";
    ss << "\\note [W/W] Watts of fan power per Watt of tower nominal capacity\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 0.0105\n";
    ss << "\\type real\n";
    ss << "A5 , \\field Fan Power Modifier Function of Air Flow Rate Ratio Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note cubic curve = a + b*AFR + c*AFR**2 + d*AFR**3\n";
    ss << "\\note quartic curve = a + b*AFR + c*AFR**2 + d*AFR**3 + e*AFR**4\n";
    ss << "\\note x = AFR = Ratio of current operating air flow rate to Design Air Flow Rate\n";
    ss << "N12, \\field Free Convection Regime Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "N13, \\field Free Convection Regime Air Flow Rate Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.1\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate.\n";
    ss << "N14, \\field Design Air Flow Rate U-Factor Times Area Value\n";
    ss << "\\note required field when performance method is UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\note when performance method is NominalCapacity the program will solve for this UA\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\autosizable\n";
    ss << "N15, \\field Free Convection Regime U-Factor Times Area Value\n";
    ss << "\\note required field when performance input method is UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 300000.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Leave field blank if performance input method is NominalCapacity\n";
    ss << "N16, \\field Free Convection U-Factor Times Area Value Sizing Factor\n";
    ss << "\\note required field when performance input method is UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\type real\n";
    ss << "\\default 0.1\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate and\n";
    ss << "\\note the performance input method is UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "A6 , \\field U-Factor Times Area Modifier Function of Air Flow Ratio Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\note This curve describes how tower's design UA changes with variable air flow rate\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note cubic curve = a + b*AFR + c*AFR**2 + d*AFR**3\n";
    ss << "\\note quartic curve = a + b*AFR + c*AFR**2 + d*AFR**3 + e*AFR**4\n";
    ss << "\\note x = AFR = Ratio of current operating air flow rate to Design Air Flow Rate\n";
    ss << "A7 , \\field U-Factor Times Area Modifier Function of Wetbulb Temperature Difference Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\note curve describes how tower UA changes with outdoor air wet-bulb temperature difference from design wet-bulb\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note cubic curve = a + b*DeltaWB + c*DeltaWB**2 + d*DeltaWB**3\n";
    ss << "\\note quartic curve = a + b*DeltaWB + c*DeltaWB**2 + d*DeltaWB**3 + e*DeltaWB**4\n";
    ss << "\\note x = DeltaWB = (design wet-bulb temperature in C - current wet-bulb temperature in C)\n";
    ss << "\\note where design wet-bulb temperature of entering air is 25.56C (78F)\n";
    ss << "A8 , \\field U-Factor Times Area Modifier Function of Water Flow Ratio Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\note curve describes how tower UA changes with the flow rate of condenser water through the tower\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Any curve or table with one independent variable can be used\n";
    ss << "\\note cubic curve = a + b*WFR + c*WFR**2 + d*WFR**3\n";
    ss << "\\note quartic curve = a + b*WFR + c*WFR**2 + d*WFR**3 + e*WFR**4\n";
    ss << "\\note x = WFR = Ratio of current operating water flow rate to Design Water Flow Rate\n";
    ss << "N17, \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This heater maintains the basin water temperature at the basin heater setpoint\n";
    ss << "\\note temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when water is not flowing through the tower.\n";
    ss << "N18, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on\n";
    ss << "A9 , \\field Basin Heater Operating Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";
    ss << "A10, \\field Evaporation Loss Mode\n";
    ss << "\\type choice\n";
    ss << "\\key LossFactor\n";
    ss << "\\key SaturatedExit\n";
    ss << "N19, \\field Evaporation Loss Factor\n";
    ss << "\\type real\n";
    ss << "\\units percent/K\n";
    ss << "\\note Rate of water evaporated from the cooling tower and lost to the outdoor air [%/K]\n";
    ss << "\\note Evaporation loss is calculated as percentage of the circulating condenser water rate\n";
    ss << "\\note Value entered here is percent-per-degree K of temperature drop in the condenser water\n";
    ss << "\\note Typical values are from 0.15 to 0.27 [%/K].\n";
    ss << "\\default 0.2\n";
    ss << "N20, \\field Drift Loss Percent\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\default 0.008\n";
    ss << "\\note Rate of drift loss as a percentage of circulating condenser water flow rate\n";
    ss << "\\note Typical values are between 0.002 and 0.2% The default value is 0.008%\n";
    ss << "A11 , \\field Blowdown Calculation Mode\n";
    ss << "\\type choice\n";
    ss << "\\key ConcentrationRatio\n";
    ss << "\\key ScheduledRate\n";
    ss << "N21, \\field Blowdown Concentration Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 3.0\n";
    ss << "\\note Characterizes the rate of blowdown in the cooling tower.\n";
    ss << "\\note Blowdown is water intentionally drained from the tower in order to offset the build up\n";
    ss << "\\note of solids in the water that would otherwise occur because of evaporation.\n";
    ss << "\\note Ratio of solids in the blowdown water to solids in the make up water.\n";
    ss << "\\note Typical values for tower operation are 3 to 5.  The default value is 3.\n";
    ss << "A12, \\field Blowdown Makeup Water Usage Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Makeup water usage due to blowdown results from occasionally draining some amount\n";
    ss << "\\note of water in the tower basin to purge scale or other contaminants to reduce their\n";
    ss << "\\note concentration in order to maintain an acceptable level of water quality.\n";
    ss << "\\note Schedule values should reflect water usage in m3/s.\n";
    ss << "A13, \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A14, \\field Outdoor Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of an outdoor air node\n";
    ss << "N22, \\field Number of Cells\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";
    ss << "A15, \\field Cell Control\n";
    ss << "\\type choice\n";
    ss << "\\key MinimalCell\n";
    ss << "\\key MaximalCell\n";
    ss << "\\default MinimalCell\n";
    ss << "N23, \\field Cell Minimum  Water Flow Rate Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.33\n";
    ss << "\\note The allowable minimal fraction of the nominal flow rate per cell\n";
    ss << "N24, \\field Cell Maximum Water Flow Rate Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 1\n";
    ss << "\\default 2.5\n";
    ss << "\\note The allowable maximal fraction of the nominal flow rate per cell\n";
    ss << "N25; \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::CoolingTower_VariableSpeed_Merkel);
    OptionalIddObject oObj = IddObject::load("CoolingTower:VariableSpeed:Merkel",
                                             "Condenser Equipment and Heat Exchangers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::CoolingTower_VariableSpeed_Merkel);
  return object;
}

IddObject createCoolingTower_VariableSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "CoolingTower:VariableSpeed,\n";
    ss << "\\min-fields 15\n";
    ss << "\\memo This open wet tower model is based on purely empirical algorithms derived from manufacturer's\n";
    ss << "\\memo performance data or field measurements. The user can select from two existing\n";
    ss << "\\memo algorithms (CoolTools or YorkCalc), or they can enter their own correlation for\n";
    ss << "\\memo approach temperature by using a variable speed tower model coefficient object.\n";
    ss << "\\memo For a multi-cell tower, the capacity and air/water flow rate inputs are for the entire tower.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingTowers\n";
    ss << "\\note Tower Name\n";
    ss << "A2 , \\field Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of tower water inlet node\n";
    ss << "A3 , \\field Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of tower water outlet node\n";
    ss << "A4 , \\field Model Type\n";
    ss << "\\type choice\n";
    ss << "\\key CoolToolsCrossFlow\n";
    ss << "\\key CoolToolsUserDefined\n";
    ss << "\\key YorkCalc\n";
    ss << "\\key YorkCalcUserDefined\n";
    ss << "\\default YorkCalc\n";
    ss << "\\note Determines the coefficients and form of the equation for calculating\n";
    ss << "\\note approach temperature\n";
    ss << "A5 , \\field Model Coefficient Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list VariableSpeedTowerCoefficient\n";
    ss << "\\note Name of the tower model coefficient object.\n";
    ss << "\\note Used only when tower Model Type is either CoolToolsUserDefined or YorkCalcUserDefined.\n";
    ss << "N1 , \\field Design Inlet Air Wet-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 25.6\n";
    ss << "\\minimum 20.0\n";
    ss << "\\note Enter the tower's design inlet air wet-bulb temperature\n";
    ss << "N2 , \\field Design Approach Temperature\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 3.9\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the approach temperature corresponding to the design inlet air\n";
    ss << "\\note wet-bulb temperature and design range temperature.\n";
    ss << "\\note Design approach temp = outlet water temperature minus inlet air wet-bulb temperature\n";
    ss << "\\note at design conditions.\n";
    ss << "N3 , \\field Design Range Temperature\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 5.6\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the range temperature corresponding to the design inlet air\n";
    ss << "\\note wet-bulb temperature and design approach temperature.\n";
    ss << "\\note Design range = inlet water temperature minus outlet water temperature\n";
    ss << "\\note at design conditions.\n";
    ss << "N4 , \\field Design Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\note Water flow rate through the tower at design conditions\n";
    ss << "N5 , \\field Design Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Design (maximum) air flow rate through the tower\n";
    ss << "N6 , \\field Design Fan Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\note Enter the fan motor electric input power at design (max) air flow through the tower\n";
    ss << "\\note Standard conversion for horsepower is 1 HP = 745.7 W\n";
    ss << "A6 , \\field Fan Power Ratio Function of Air Flow Rate Ratio Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note FPR = a + b*AFR + c*AFR**2 + d*AFR**3\n";
    ss << "\\note FPR = fraction of the design fan power\n";
    ss << "\\note AFR = fraction of the design air flow rate\n";
    ss << "\\note If left blank, then fan power is assumed to be proportional to\n";
    ss << "\\note (air flow rate ratio)^3\n";
    ss << "N7 , \\field Minimum Air Flow Rate Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.2\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.2\n";
    ss << "\\note Enter the minimum air flow rate ratio. This is typically determined by the variable\n";
    ss << "\\note speed drive that controls the fan motor speed. Valid entries are from 0.2 to 0.5.\n";
    ss << "N8 , \\field Fraction of Tower Capacity in Free Convection Regime\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.2\n";
    ss << "\\default 0.125\n";
    ss << "\\note Enter the fraction of tower capacity in the free convection regime. This is the\n";
    ss << "\\note fraction of the tower capacity, at the current inlet air wet-bulb temperature,\n";
    ss << "\\note that is available when the tower fan is off. Manufacturers typically estimate the\n";
    ss << "\\note free convection capacity at approximately 10-15%. Values are entered as a fraction\n";
    ss << "\\note and can range from 0 to 0.2.\n";
    ss << "N9 , \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This heater maintains the basin water temperature at the basin heater setpoint\n";
    ss << "\\note temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when water is not flowing through the tower.\n";
    ss << "N10, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on\n";
    ss << "A7 , \\field Basin Heater Operating Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";
    ss << "A8 , \\field Evaporation Loss Mode\n";
    ss << "\\type choice\n";
    ss << "\\key LossFactor\n";
    ss << "\\key SaturatedExit\n";
    ss << "N11, \\field Evaporation Loss Factor\n";
    ss << "\\type real\n";
    ss << "\\units percent/K\n";
    ss << "\\note Rate of water evaporated from the cooling tower and lost to the outdoor air [%/K]\n";
    ss << "\\note Evaporation loss is calculated as percentage of the circulating condenser water rate\n";
    ss << "\\note Value entered here is percent-per-degree K of temperature drop in the condenser water\n";
    ss << "\\note Typical values are from 0.15 to 0.27 [percent/K].\n";
    ss << "\\default 0.2\n";
    ss << "N12, \\field Drift Loss Percent\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\note Rate of drift loss as a percentage of circulating condenser water flow rate\n";
    ss << "\\note Typical values are between 0.002 and 0.2% The default value is 0.008%\n";
    ss << "A9 , \\field Blowdown Calculation Mode\n";
    ss << "\\type choice\n";
    ss << "\\key ConcentrationRatio\n";
    ss << "\\key ScheduledRate\n";
    ss << "N13, \\field Blowdown Concentration Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 3.0\n";
    ss << "\\note Characterizes the rate of blowdown in the cooling tower.\n";
    ss << "\\note Blowdown is water intentionally drained from the tower in order to offset the build up\n";
    ss << "\\note of solids in the water that would otherwise occur because of evaporation.\n";
    ss << "\\note Ratio of solids in the blowdown water to solids in the make up water.\n";
    ss << "\\note Typical values for tower operation are 3 to 5.  The default value is 3.\n";
    ss << "A10, \\field Blowdown Makeup Water Usage Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Makeup water usage due to blowdown results from occasionally draining a small amount\n";
    ss << "\\note of water in the tower basin to purge scale or other contaminants to reduce their\n";
    ss << "\\note concentration in order to maintain an acceptable level of water quality.\n";
    ss << "\\note Schedule values should reflect water usage in m3/s.\n";
    ss << "A11, \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A12, \\field Outdoor Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of an outdoor air node\n";
    ss << "N14, \\field Number of Cells\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";
    ss << "A13, \\field Cell Control\n";
    ss << "\\type choice\n";
    ss << "\\key MinimalCell\n";
    ss << "\\key MaximalCell\n";
    ss << "\\default MinimalCell\n";
    ss << "N15, \\field Cell Minimum  Water Flow Rate Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.33\n";
    ss << "\\note The allowable minimal fraction of the nominal flow rate per cell\n";
    ss << "N16, \\field Cell Maximum Water Flow Rate Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 1\n";
    ss << "\\default 2.5\n";
    ss << "\\note The allowable maximal fraction of the nominal flow rate per cell\n";
    ss << "N17; \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::CoolingTower_VariableSpeed);
    OptionalIddObject oObj = IddObject::load("CoolingTower:VariableSpeed",
                                             "Condenser Equipment and Heat Exchangers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::CoolingTower_VariableSpeed);
  return object;
}

IddObject createCoolingTowerPerformance_CoolToolsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "CoolingTowerPerformance:CoolTools,\n";
    ss << "\\min-fields 44\n";
    ss << "\\memo This object is used to define coefficients for the approach temperature\n";
    ss << "\\memo correlation for a variable speed cooling tower when tower Model Type is\n";
    ss << "\\memo specified as CoolToolsUserDefined in the object CoolingTower:VariableSpeed.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference VariableSpeedTowerCoefficient\n";
    ss << "N1 , \\field Minimum Inlet Air Wet-Bulb Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Minimum valid inlet air wet-bulb temperature for this approach\n";
    ss << "\\note temperature correlation.\n";
    ss << "N2 , \\field Maximum Inlet Air Wet-Bulb Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Maximum valid inlet air wet-bulb temperature for this approach\n";
    ss << "\\note temperature correlation.\n";
    ss << "N3 , \\field Minimum Range Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Minimum valid range temperature for this approach temperature\n";
    ss << "\\note correlation.\n";
    ss << "N4 , \\field Maximum Range Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Maximum valid range temperature for this approach temperature\n";
    ss << "\\note correlation.\n";
    ss << "N5 , \\field Minimum Approach Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Minimum valid approach temperature for this correlation.\n";
    ss << "N6 , \\field Maximum Approach Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Maximum valid approach temperature for this correlation.\n";
    ss << "N7 , \\field Minimum Water Flow Rate Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note Minimum valid water flow rate ratio for this approach\n";
    ss << "\\note temperature correlation.\n";
    ss << "N8 , \\field Maximum Water Flow Rate Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note Maximum valid water flow rate ratio for this approach\n";
    ss << "\\note temperature correlation.\n";
    ss << "N9 , \\field Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N10, \\field Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N11, \\field Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N12, \\field Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N13, \\field Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N14, \\field Coefficient 6\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N15, \\field Coefficient 7\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N16, \\field Coefficient 8\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N17, \\field Coefficient 9\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N18, \\field Coefficient 10\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N19, \\field Coefficient 11\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N20, \\field Coefficient 12\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N21, \\field Coefficient 13\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N22, \\field Coefficient 14\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N23, \\field Coefficient 15\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N24, \\field Coefficient 16\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N25, \\field Coefficient 17\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N26, \\field Coefficient 18\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N27, \\field Coefficient 19\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N28, \\field Coefficient 20\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N29, \\field Coefficient 21\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N30, \\field Coefficient 22\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N31, \\field Coefficient 23\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N32, \\field Coefficient 24\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N33, \\field Coefficient 25\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N34, \\field Coefficient 26\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N35, \\field Coefficient 27\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N36, \\field Coefficient 28\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N37, \\field Coefficient 29\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N38, \\field Coefficient 30\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N39, \\field Coefficient 31\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N40, \\field Coefficient 32\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N41, \\field Coefficient 33\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N42, \\field Coefficient 34\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N43; \\field Coefficient 35\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::CoolingTowerPerformance_CoolTools);
    OptionalIddObject oObj = IddObject::load("CoolingTowerPerformance:CoolTools",
                                             "Condenser Equipment and Heat Exchangers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::CoolingTowerPerformance_CoolTools);
  return object;
}

IddObject createCoolingTowerPerformance_YorkCalcIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "CoolingTowerPerformance:YorkCalc,\n";
    ss << "\\min-fields 37\n";
    ss << "\\memo This object is used to define coefficients for the approach temperature\n";
    ss << "\\memo correlation for a variable speed cooling tower when tower Model Type is\n";
    ss << "\\memo specified as YorkCalcUserDefined in the object CoolingTower:VariableSpeed.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference VariableSpeedTowerCoefficient\n";
    ss << "N1 , \\field Minimum Inlet Air Wet-Bulb Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Minimum valid inlet air wet-bulb temperature for this approach\n";
    ss << "\\note temperature correlation.\n";
    ss << "N2 , \\field Maximum Inlet Air Wet-Bulb Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Maximum valid inlet air wet-bulb temperature for this approach\n";
    ss << "\\note temperature correlation.\n";
    ss << "N3 , \\field Minimum Range Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Minimum valid range temperature for this approach temperature\n";
    ss << "\\note correlation.\n";
    ss << "N4 , \\field Maximum Range Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Maximum valid range temperature for this approach temperature\n";
    ss << "\\note correlation.\n";
    ss << "N5 , \\field Minimum Approach Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Minimum valid approach temperature for this correlation.\n";
    ss << "N6 , \\field Maximum Approach Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Maximum valid approach temperature for this correlation.\n";
    ss << "N7 , \\field Minimum Water Flow Rate Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note Minimum valid water flow rate ratio for this approach\n";
    ss << "\\note temperature correlation.\n";
    ss << "N8 , \\field Maximum Water Flow Rate Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note Maximum valid water flow rate ratio for this approach\n";
    ss << "\\note temperature correlation.\n";
    ss << "N9 , \\field Maximum Liquid to Gas Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note Maximum liquid (water) to gas (air) ratio for this approach\n";
    ss << "\\note temperature correlation.\n";
    ss << "N10, \\field Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N11, \\field Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N12, \\field Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N13, \\field Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N14, \\field Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N15, \\field Coefficient 6\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N16, \\field Coefficient 7\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N17, \\field Coefficient 8\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N18, \\field Coefficient 9\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N19, \\field Coefficient 10\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N20, \\field Coefficient 11\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N21, \\field Coefficient 12\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N22, \\field Coefficient 13\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N23, \\field Coefficient 14\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N24, \\field Coefficient 15\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N25, \\field Coefficient 16\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N26, \\field Coefficient 17\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N27, \\field Coefficient 18\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N28, \\field Coefficient 19\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N29, \\field Coefficient 20\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N30, \\field Coefficient 21\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N31, \\field Coefficient 22\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N32, \\field Coefficient 23\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N33, \\field Coefficient 24\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N34, \\field Coefficient 25\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N35, \\field Coefficient 26\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N36; \\field Coefficient 27\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::CoolingTowerPerformance_YorkCalc);
    OptionalIddObject oObj = IddObject::load("CoolingTowerPerformance:YorkCalc",
                                             "Condenser Equipment and Heat Exchangers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::CoolingTowerPerformance_YorkCalc);
  return object;
}

IddObject createEvaporativeFluidCooler_SingleSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EvaporativeFluidCooler:SingleSpeed,\n";
    ss << "\\min-fields 10\n";
    ss << "\\memo This model is based on Merkel's theory, which is also the basis\n";
    ss << "\\memo for the cooling tower model in EnergyPlus. The Evaporative fluid cooler\n";
    ss << "\\memo is modeled as a counter flow heat exchanger.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note Fluid Cooler Name\n";
    ss << "A2 , \\field Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of Fluid Cooler water inlet node\n";
    ss << "A3 , \\field Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of Fluid Cooler water outlet node\n";
    ss << "N1 , \\field Design Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Design Air Flow Rate Fan Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\note This is the fan motor electric input power\n";
    ss << "N3 , \\field Design Spray Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "A4 , \\field Performance Input Method\n";
    ss << "\\type choice\n";
    ss << "\\key UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\key StandardDesignCapacity\n";
    ss << "\\key UserSpecifiedDesignCapacity\n";
    ss << "\\note User can define fluid cooler thermal performance by specifying the fluid cooler UA\n";
    ss << "\\note and the Design Water Flow Rate, or by specifying the fluid cooler Standard Design\n";
    ss << "\\note Capacity or by specifying Design Capacity for Non standard conditions.\n";
    ss << "A5 , \\field Outdoor Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of an outdoor air node\n";
    ss << "N4 , \\field Heat Rejection Capacity and Nominal Capacity Sizing Ratio\n";
    ss << "\\type real\n";
    ss << "\\default 1.25\n";
    ss << "N5 , \\field Standard Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Standard design capacity with entering water at 35C (95F), leaving water at\n";
    ss << "\\note 29.44C (85F), entering air at 25.56C (78F) wet-bulb temperature and 35C (95F)\n";
    ss << "\\note dry-bulb temperature. Design water flow rate assumed to be 5.382E-8 m3/s per watt\n";
    ss << "\\note (3 gpm/ton). Standard design capacity times the Heat Rejection Capacity and\n";
    ss << "\\note Nominal Capacity Sizing Ratio (e.g. 1.25) gives the actual fluid cooler\n";
    ss << "\\note heat rejection at these operating conditions.\n";
    ss << "\\note Only used for Performance Input Method = StandardDesignCapacity;\n";
    ss << "\\note for other input methods, this field is ignored.\n";
    ss << "\\note The standard conditions mentioned above for Standard design capacity are already\n";
    ss << "\\note specified in the EnergyPlus. So the input fields such as design entering water\n";
    ss << "\\note temp., design entering air wet-bulb and dry-bulb temp. and design water flow rate, if\n";
    ss << "\\note provided in the input, will be ignored for the StandardDesignCapacity performance input\n";
    ss << "\\note method. Also, the standard conditions are for water as a fluid type so this performance input\n";
    ss << "\\note method can only be used with water as a fluid type (as specified in CondenserLoop object).\n";
    ss << "N6 , \\field Design Air Flow Rate U-factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 2100000.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Only used for Performance Input Method = UFactorTimesAreaAndDesignWaterFlowRate;\n";
    ss << "\\note for other Performance Input Methods, this field is ignored.\n";
    ss << "N7 , \\field Design Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\note Input value is ignored if fluid cooler Performance Input Method= StandardDesignCapacity.\n";
    ss << "N8 , \\field User Specified Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Only used for Performance Input Method = UserSpecifiedDesignCapacity;\n";
    ss << "\\note for other Performance Input Methods, this field is ignored.\n";
    ss << "N9 , \\field Design Entering Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Only used for Performance Input Method = UserSpecifiedDesignCapacity;\n";
    ss << "\\note for other Performance Input Methods, this field is ignored.\n";
    ss << "\\note Design Entering Water Temperature must be greater than Design Entering Air Temperature.\n";
    ss << "N10, \\field Design Entering Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Only used for Performance Input Method = UserSpecifiedDesignCapacity;\n";
    ss << "\\note for other Performance Input Methods, this field is ignored.\n";
    ss << "\\note Design Entering Air Temperature must be greater than Design Entering Air Wet-bulb\n";
    ss << "\\note Temperature.\n";
    ss << "N11, \\field Design Entering Air Wet-bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Only used for Performance Input Method = UserSpecifiedDesignCapacity;\n";
    ss << "\\note for other Performance Input Methods, this field is ignored.\n";
    ss << "\\note Design Entering Air Wet-bulb Temperature must be less than Design Entering Air\n";
    ss << "\\note Temperature.\n";
    ss << "A6 , \\field Capacity Control\n";
    ss << "\\type choice\n";
    ss << "\\key FanCycling\n";
    ss << "\\key FluidBypass\n";
    ss << "\\default FanCycling\n";
    ss << "N12, \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "A7 , \\field Evaporation Loss Mode\n";
    ss << "\\type choice\n";
    ss << "\\key LossFactor\n";
    ss << "\\key SaturatedExit\n";
    ss << "\\default SaturatedExit\n";
    ss << "N13, \\field Evaporation Loss Factor\n";
    ss << "\\type real\n";
    ss << "\\units percent/K\n";
    ss << "\\note Rate of water evaporation from the Fluid Cooler and lost to the outdoor air [%/K]\n";
    ss << "\\note Empirical correlation is used to calculate default loss factor if it not explicitly provided.\n";
    ss << "N14, \\field Drift Loss Percent\n";
    ss << "\\type real\n";
    ss << "\\default 0.008\n";
    ss << "\\units percent\n";
    ss << "\\note Rate of drift loss as a percentage of circulating spray water flow rate\n";
    ss << "\\note Default value for this field in under investigation. For now Cooling towers drift loss\n";
    ss << "\\note percent default value is taken here.\n";
    ss << "A8 , \\field Blowdown Calculation Mode\n";
    ss << "\\type choice\n";
    ss << "\\key ConcentrationRatio\n";
    ss << "\\key ScheduledRate\n";
    ss << "\\default ConcentrationRatio\n";
    ss << "N15, \\field Blowdown Concentration Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 3.0\n";
    ss << "\\note Characterizes the rate of blowdown in the Evaporative Fluid Cooler.\n";
    ss << "\\note Blowdown is water intentionally drained from the basin in order to offset the build\n";
    ss << "\\note up of solids in the water that would otherwise occur because of evaporation.\n";
    ss << "\\note Ratio of solids in the blowdown water to solids in the make up water.\n";
    ss << "\\note Default value for this field in under investigation. For now Cooling towers\n";
    ss << "\\note Blowdown Concentration Ratio percent default value is taken here.\n";
    ss << "A9 , \\field Blowdown Makeup Water Usage Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Makeup water usage due to blowdown results from occasionally draining a small\n";
    ss << "\\note amount of water in the Fluid Cooler basin to purge scale or other contaminants to\n";
    ss << "\\note reduce their concentration in order to maintain an acceptable level of water quality.\n";
    ss << "\\note Schedule values should reflect water usage in m3/s.\n";
    ss << "A10; \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";

    IddObjectType objType(IddObjectType::EvaporativeFluidCooler_SingleSpeed);
    OptionalIddObject oObj = IddObject::load("EvaporativeFluidCooler:SingleSpeed",
                                             "Condenser Equipment and Heat Exchangers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EvaporativeFluidCooler_SingleSpeed);
  return object;
}

IddObject createEvaporativeFluidCooler_TwoSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EvaporativeFluidCooler:TwoSpeed,\n";
    ss << "\\min-fields 23\n";
    ss << "\\memo This model is based on Merkel's theory, which is also the basis\n";
    ss << "\\memo for the cooling tower model in EnergyPlus. The Evaporative fluid cooler\n";
    ss << "\\memo is modeled as a counter flow heat exchanger.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note fluid cooler name\n";
    ss << "A2 , \\field Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of fluid cooler water inlet node\n";
    ss << "A3 , \\field Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of fluid cooler water outlet node\n";
    ss << "N1 , \\field High Fan Speed Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field High Fan Speed Fan Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\note This is the fan motor electric input power at high speed\n";
    ss << "N3 , \\field Low Fan Speed Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Low speed air flow rate must be less than high speed air flow rate\n";
    ss << "N4 , \\field Low Fan Speed Air Flow Rate Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate\n";
    ss << "N5 , \\field Low Fan Speed Fan Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\ip-units W\n";
    ss << "\\note This is the fan motor electric input power at low speed\n";
    ss << "N6 , \\field Low Fan Speed Fan Power Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.16\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate.\n";
    ss << "N7 , \\field Design Spray Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "A4 , \\field Performance Input Method\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\key StandardDesignCapacity\n";
    ss << "\\key UserSpecifiedDesignCapacity\n";
    ss << "\\note User can define fluid cooler thermal performance by specifying the fluid cooler UA\n";
    ss << "\\note and the Design Water Flow Rate, or by specifying the fluid cooler Standard Design\n";
    ss << "\\note Capacity or by specifying Design Capacity for Non standard conditions.\n";
    ss << "A5 , \\field Outdoor Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of an outdoor air node\n";
    ss << "N8 , \\field Heat Rejection Capacity and Nominal Capacity Sizing Ratio\n";
    ss << "\\type real\n";
    ss << "\\default 1.25\n";
    ss << "N9 , \\field High Speed Standard Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Standard design capacity with entering water at 35C (95F), leaving water at\n";
    ss << "\\note 29.44C (85F), entering air at 25.56C (78F) wet-bulb temperature and 35C (95F)\n";
    ss << "\\note dry-bulb temperature. Design water flow rate assumed to be 5.382E-8 m3/s per watt\n";
    ss << "\\note (3 gpm/ton). Standard design capacity times the Heat Rejection Capacity and\n";
    ss << "\\note Nominal Capacity Sizing Ratio (e.g. 1.25) gives the actual fluid cooler\n";
    ss << "\\note heat rejection at these operating conditions.\n";
    ss << "\\note Only used for Performance Input Method = StandardDesignCapacity;\n";
    ss << "\\note for other input methods, this field is ignored.\n";
    ss << "\\note The standard conditions mentioned above for Standard design capacity are already\n";
    ss << "\\note specified in the EnergyPlus. So the input fields such as design entering water\n";
    ss << "\\note temp., design entering air wet-bulb and dry-bulb temp. and design water flow rate, if\n";
    ss << "\\note provided in the input, will be ignored for the StandardDesignCapacity performance input\n";
    ss << "\\note method. Also, the standard conditions are for water as a fluid type so this performance input\n";
    ss << "\\note method can only be used with water as a fluid type (as specified in CondenserLoop object).\n";
    ss << "N10 , \\field Low Speed Standard Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Standard design capacity with entering water at 35C (95F), leaving water at\n";
    ss << "\\note 29.44C (85F), entering air at 25.56C (78F) wet-bulb temperature and 35C (95F)\n";
    ss << "\\note dry-bulb temperature. Design water flow rate assumed to be 5.382E-8 m3/s per watt\n";
    ss << "\\note (3 gpm/ton). Standard design capacity times the Heat Rejection Capacity and\n";
    ss << "\\note Nominal Capacity Sizing Ratio (e.g. 1.25) gives the actual fluid cooler\n";
    ss << "\\note heat rejection at these operating conditions.\n";
    ss << "\\note Only used for Performance Input Method = StandardDesignCapacity;\n";
    ss << "\\note for other input methods, this field is ignored.\n";
    ss << "\\note The standard conditions mentioned above for Standard design capacity are already\n";
    ss << "\\note specified in the EnergyPlus. So the input fields such as design entering water\n";
    ss << "\\note temp., design entering air wet-bulb and dry-bulb temp. and design water flow rate, if\n";
    ss << "\\note provided in the input, will be ignored for the StandardDesignCapacity performance input\n";
    ss << "\\note method. Also, the standard conditions are for water as a fluid type so this performance input\n";
    ss << "\\note method can only be used with water as a fluid type (as specified in CondenserLoop object).\n";
    ss << "N11, \\field Low Speed Standard Capacity Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate\n";
    ss << "N12, \\field High Fan Speed U-factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 2100000.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Only used for Performance Input Method = UFactorTimesAreaAndDesignWaterFlowRate;\n";
    ss << "\\note for other Performance Input Methods, this field is ignored.\n";
    ss << "N13, \\field Low Fan Speed U-factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 300000.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Only used for Performance Input Method = UFactorTimesAreaAndDesignWaterFlowRate;\n";
    ss << "\\note for other input methods, this field is ignored.\n";
    ss << "\\note Low speed fluid cooler UA must be less than high speed fluid cooler UA\n";
    ss << "N14, \\field Low Fan Speed U-Factor Times Area Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.6\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate and\n";
    ss << "\\note the Performance Input Method is UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "N15, \\field Design Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\note Input value is ignored if fluid cooler Performance Input Method= StandardDesignCapacity\n";
    ss << "N16, \\field High Speed User Specified Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Only used for Performance Input Method = UserSpecifiedDesignCapacity;\n";
    ss << "\\note for other Performance Input Methods, this field is ignored.\n";
    ss << "N17, \\field Low Speed User Specified Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Only used for Performance Input Method = UserSpecifiedDesignCapacity;\n";
    ss << "\\note for other Performance Input Methods, this field is ignored.\n";
    ss << "N18, \\field Low Speed User Specified Design Capacity Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate\n";
    ss << "N19, \\field Design Entering Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Only used for Performance Input Method = UserSpecifiedDesignCapacity;\n";
    ss << "\\note for other Performance Input Methods, this field is ignored.\n";
    ss << "\\note Design Entering Water Temperature must be greater than Design Entering Air Temperature.\n";
    ss << "N20, \\field Design Entering Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Only used for Performance Input Method = UserSpecifiedDesignCapacity;\n";
    ss << "\\note for other Performance Input Methods, this field is ignored.\n";
    ss << "\\note Design Entering Air Temperature must be greater than Design Entering Air Wet-bulb\n";
    ss << "\\note Temperature.\n";
    ss << "N21, \\field Design Entering Air Wet-bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Only used for Performance Input Method = UserSpecifiedDesignCapacity;\n";
    ss << "\\note for other Performance Input Methods, this field is ignored.\n";
    ss << "\\note Design Entering Air Wet-bulb Temperature must be less than Design Entering Air\n";
    ss << "\\note Temperature.\n";
    ss << "N22, \\field High Speed Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "A6 , \\field Evaporation Loss Mode\n";
    ss << "\\type choice\n";
    ss << "\\key LossFactor\n";
    ss << "\\key SaturatedExit\n";
    ss << "\\default SaturatedExit\n";
    ss << "N23, \\field Evaporation Loss Factor\n";
    ss << "\\type real\n";
    ss << "\\units percent/K\n";
    ss << "\\note Rate of water evaporation from the Fluid Cooler and lost to the outdoor air [%/K]\n";
    ss << "\\note Empirical correlation is used to calculate default loss factor if it not explicitly provided.\n";
    ss << "N24, \\field Drift Loss Percent\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\default 0.008\n";
    ss << "\\note Default value is under investigation. For now cooling towers default value is taken.\n";
    ss << "A7 , \\field Blowdown Calculation Mode\n";
    ss << "\\type choice\n";
    ss << "\\key ConcentrationRatio\n";
    ss << "\\key ScheduledRate\n";
    ss << "\\default ConcentrationRatio\n";
    ss << "N25, \\field Blowdown Concentration Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 3.0\n";
    ss << "\\note Characterizes the rate of blowdown in the Evaporative Fluid Cooler.\n";
    ss << "\\note Blowdown is water intentionally drained from the Evaporative Fluid Cooler in order to offset the\n";
    ss << "\\note build up of solids in the water that would otherwise occur because of evaporation.\n";
    ss << "\\note Ratio of solids in the blowdown water to solids in the make up water.\n";
    ss << "\\note Default value is under investigation. For now cooling towers default value is taken.\n";
    ss << "A8 , \\field Blowdown Makeup Water Usage Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Makeup water usage due to blowdown results from occasionally draining some amount\n";
    ss << "\\note of water in the Evaporative Fluid Cooler basin to purge scale or other contaminants to reduce\n";
    ss << "\\note their concentration in order to maintain an acceptable level of water quality.\n";
    ss << "\\note Schedule values should reflect water usage in m3/s.\n";
    ss << "A9 ; \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";

    IddObjectType objType(IddObjectType::EvaporativeFluidCooler_TwoSpeed);
    OptionalIddObject oObj = IddObject::load("EvaporativeFluidCooler:TwoSpeed",
                                             "Condenser Equipment and Heat Exchangers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EvaporativeFluidCooler_TwoSpeed);
  return object;
}

IddObject createFluidCooler_SingleSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FluidCooler:SingleSpeed,\n";
    ss << "\\min-fields 12\n";
    ss << "\\memo The fluid cooler is modeled as a cross flow heat exchanger (both streams unmixed) with\n";
    ss << "\\memo single-speed fans (induced draft configuration).\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note fluid cooler name\n";
    ss << "A2 , \\field Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of fluid cooler water inlet node\n";
    ss << "A3 , \\field Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of fluid cooler water outlet node\n";
    ss << "A4 , \\field Performance Input Method\n";
    ss << "\\type choice\n";
    ss << "\\key UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\key NominalCapacity\n";
    ss << "\\default NominalCapacity\n";
    ss << "\\note User can define fluid cooler thermal performance by specifying the fluid cooler UA\n";
    ss << "\\note and the Design Water Flow Rate, or by specifying the fluid cooler nominal capacity\n";
    ss << "N1 , \\field Design Air Flow Rate U-factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 2100000.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Leave field blank if fluid cooler Performance Input Method is NominalCapacity\n";
    ss << "N2 , \\field Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Nominal fluid cooler capacity\n";
    ss << "N3 , \\field Design Entering Water Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Design Entering Water Temperature must be specified for both the performance input methods and\n";
    ss << "\\note its value must be greater than Design Entering Air Temperature.\n";
    ss << "N4 , \\field Design Entering Air Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Design Entering Air Temperature must be specified for both the performance input methods and\n";
    ss << "\\note its value must be greater than Design Entering Air Wet-bulb Temperature.\n";
    ss << "N5 , \\field Design Entering Air Wetbulb Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Design Entering Air Wet-bulb Temperature must be specified for both the performance input methods and\n";
    ss << "\\note its value must be less than Design Entering Air Temperature.\n";
    ss << "N6 , \\field Design Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N7 , \\field Design Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N8 , \\field Design Air Flow Rate Fan Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\note This is the fan motor electric input power\n";
    ss << "A5 ; \\field Outdoor Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of an outdoor air node\n";

    IddObjectType objType(IddObjectType::FluidCooler_SingleSpeed);
    OptionalIddObject oObj = IddObject::load("FluidCooler:SingleSpeed",
                                             "Condenser Equipment and Heat Exchangers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FluidCooler_SingleSpeed);
  return object;
}

IddObject createFluidCooler_TwoSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FluidCooler:TwoSpeed,\n";
    ss << "\\min-fields 20\n";
    ss << "\\memo The fluid cooler is modeled as a cross flow heat exchanger (both streams unmixed) with\n";
    ss << "\\memo two-speed fans (induced draft configuration).\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note fluid cooler name\n";
    ss << "A2 , \\field Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of fluid cooler water inlet node\n";
    ss << "A3 , \\field Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of fluid cooler water outlet node\n";
    ss << "A4 , \\field Performance Input Method\n";
    ss << "\\type choice\n";
    ss << "\\key UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\key NominalCapacity\n";
    ss << "\\default NominalCapacity\n";
    ss << "\\note User can define fluid cooler thermal performance by specifying the fluid cooler UA\n";
    ss << "\\note and the Design Water Flow Rate, or by specifying the fluid cooler nominal capacity\n";
    ss << "N1 , \\field High Fan Speed U-factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 2100000.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Leave field blank if fluid cooler Performance Input Method is NominalCapacity\n";
    ss << "N2 , \\field Low Fan Speed U-factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 300000.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Leave field blank if fluid cooler Performance Input Method is NominalCapacity\n";
    ss << "\\note Low speed fluid cooler UA must be less than high speed fluid cooler UA\n";
    ss << "\\note Low speed fluid cooler UA must be greater than free convection fluid cooler UA\n";
    ss << "N3,  \\field Low Fan Speed U-Factor Times Area Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.6\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate and\n";
    ss << "\\note the Performance Input Method is UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "N4, \\field High Speed Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Nominal fluid cooler capacity at high fan speed\n";
    ss << "N5, \\field Low Speed Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Nominal fluid cooler capacity at low fan speed\n";
    ss << "N6,  \\field Low Speed Nominal Capacity Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate and\n";
    ss << "\\note the Performance Input Method is NominalCapacity\n";
    ss << "N7 , \\field Design Entering Water Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Design Entering Water Temperature must be specified for both the performance input methods and\n";
    ss << "\\note its value must be greater than Design Entering Air Temperature.\n";
    ss << "N8 , \\field Design Entering Air Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Design Entering Air Temperature must be specified for both the performance input methods and\n";
    ss << "\\note its value must be greater than Design Entering Air Wet-bulb Temperature.\n";
    ss << "N9 , \\field Design Entering Air Wet-bulb Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Design Entering Air Wet-bulb Temperature must be specified for both the performance input methods and\n";
    ss << "\\note its value must be less than Design Entering Air Temperature.\n";
    ss << "N10, \\field Design Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N11, \\field High Fan Speed Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Air Flow Rate at High Fan Speed must be greater than Air Flow Rate at Low Fan Speed\n";
    ss << "N12, \\field High Fan Speed Fan Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\note This is the fan motor electric input power at high speed\n";
    ss << "N13, \\field Low Fan Speed Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Air Flow Rate at Low Fan Speed must be less than Air Flow Rate at High Fan Speed\n";
    ss << "N14, \\field Low Fan Speed Air Flow Rate Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate.\n";
    ss << "N15, \\field Low Fan Speed Fan Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\ip-units W\n";
    ss << "\\note This is the fan motor electric input power at low speed\n";
    ss << "N16, \\field Low Fan Speed Fan Power Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.16\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate.\n";
    ss << "A5 ; \\field Outdoor Air Inlet Node Name\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::FluidCooler_TwoSpeed);
    OptionalIddObject oObj = IddObject::load("FluidCooler:TwoSpeed",
                                             "Condenser Equipment and Heat Exchangers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FluidCooler_TwoSpeed);
  return object;
}

IddObject createGroundHeatExchanger_VerticalIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatExchanger:Vertical,\n";
    ss << "\\extensible:2\n";
    ss << "\\min-fields 20\n";
    ss << "\\memo Variable short time step vertical ground heat exchanger model based on\n";
    ss << "\\memo Yavuztruk, C., J.D.Spitler. 1999. A Short Time Step response Factor Model for\n";
    ss << "\\memo Vertical Ground Loop Heat Exchangers\n";
    ss << "\\memo The Fluid Type in the associated condenser loop must be same for which the\n";
    ss << "\\memo g-functions below are calculated.\n";
    ss << "A1,   \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,   \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3,   \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,   \\field Design Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N2,   \\field Number of Bore Holes\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3,   \\field Bore Hole Length\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m\n";
    ss << "N4,   \\field Bore Hole Radius\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m\n";
    ss << "N5,   \\field Ground Thermal Conductivity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W/m-K\n";
    ss << "N6,   \\field Ground Thermal Heat Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units J/m3-K\n";
    ss << "N7,   \\field Ground Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units C\n";
    ss << "N8,   \\field Grout Thermal Conductivity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W/m-K\n";
    ss << "N9,   \\field Pipe Thermal Conductivity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W/m-K\n";
    ss << "N10,  \\field Pipe Out Diameter\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m\n";
    ss << "\\ip-units in\n";
    ss << "N11,  \\field U-Tube Distance\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m\n";
    ss << "N12,  \\field Pipe Thickness\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m\n";
    ss << "\\ip-units in\n";
    ss << "N13,  \\field Maximum Length of Simulation\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units years\n";
    ss << "N14,  \\field G-Function Reference Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 0.0005\n";
    ss << "N15,  \\field Number of Data Pairs of the G Function\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 100\n";
    ss << "N16, \\field G-Function Ln(T/Ts) Value 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\begin-extensible\n";
    ss << "N17; \\field G-Function G Value 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::GroundHeatExchanger_Vertical);
    OptionalIddObject oObj = IddObject::load("GroundHeatExchanger:Vertical",
                                             "Condenser Equipment and Heat Exchangers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatExchanger_Vertical);
  return object;
}

IddObject createGroundHeatExchanger_PondIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatExchanger:Pond,\n";
    ss << "\\memo A model of a shallow pond with immersed pipe loops.\n";
    ss << "\\memo Typically used in hybrid geothermal systems and included in the condenser loop.\n";
    ss << "\\memo This component may also be used as a simple solar collector.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Fluid Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A3 , \\field Fluid Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Pond Depth\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "N2 , \\field Pond Area\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m2\n";
    ss << "\\minimum> 0\n";
    ss << "N3 , \\field Hydronic Tubing Inside Diameter\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units in\n";
    ss << "N4 , \\field Hydronic Tubing Outside Diameter\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units in\n";
    ss << "N5 , \\field Hydronic Tubing Thermal Conductivity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum> 0\n";
    ss << "N6 , \\field Ground Thermal Conductivity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum> 0\n";
    ss << "N7 , \\field Number of Tubing Circuits\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "N8 ; \\field Length of Each Tubing Circuit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0\n";

    IddObjectType objType(IddObjectType::GroundHeatExchanger_Pond);
    OptionalIddObject oObj = IddObject::load("GroundHeatExchanger:Pond",
                                             "Condenser Equipment and Heat Exchangers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatExchanger_Pond);
  return object;
}

IddObject createGroundHeatExchanger_SurfaceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatExchanger:Surface,\n";
    ss << "\\memo A hydronic surface/panel consisting of a multi-layer construction with embedded rows of tubes.\n";
    ss << "\\memo Typically used in hybrid geothermal systems and included in the condenser loop.\n";
    ss << "\\memo This component may also be used as a simple solar collector.\n";
    ss << "\\memo The bottom surface may be defined as ground-coupled or exposed to wind (eg. bridge deck).\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Construction Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3 , \\field Fluid Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A4 , \\field Fluid Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Hydronic Tubing Inside Diameter\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units in\n";
    ss << "N2 , \\field Number of Tubing Circuits\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "N3 , \\field Hydronic Tube Spacing\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "N4 , \\field Surface Length\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "N5 , \\field Surface Width\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "A5 ; \\field Lower Surface Environment\n";
    ss << "\\type choice\n";
    ss << "\\key Ground\n";
    ss << "\\key Exposed\n";
    ss << "\\default Ground\n";

    IddObjectType objType(IddObjectType::GroundHeatExchanger_Surface);
    OptionalIddObject oObj = IddObject::load("GroundHeatExchanger:Surface",
                                             "Condenser Equipment and Heat Exchangers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatExchanger_Surface);
  return object;
}

IddObject createGroundHeatExchanger_HorizontalTrenchIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatExchanger:HorizontalTrench,\n";
    ss << "\\memo This models a horizontal heat exchanger placed in a series of trenches\n";
    ss << "\\memo The model uses the PipingSystem:Underground underlying algorithms,\n";
    ss << "\\memo but provides a more usable input interface.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A3 , \\field Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field Design Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0\n";
    ss << "N2 , \\field Trench Length in Pipe Axial Direction\n";
    ss << "\\note This is the total pipe axial length of the heat exchanger\n";
    ss << "\\note If all pipe trenches are parallel, this is the length of a\n";
    ss << "\\note single trench.  If a single, long run of pipe is used with one\n";
    ss << "\\note trench, this is the full length of the pipe run.\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units ft\n";
    ss << "\\default 50\n";
    ss << "N3 , \\field Number of Trenches\n";
    ss << "\\note This is the number of horizontal legs that will be used\n";
    ss << "\\note in the entire heat exchanger, one pipe per trench\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";
    ss << "N4 , \\field Horizontal Spacing Between Pipes\n";
    ss << "\\note This represents the average horizontal spacing between any two\n";
    ss << "\\note trenches for heat exchangers that have multiple trenches\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1.0\n";
    ss << "N5 , \\field Pipe Inner Diameter\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units in\n";
    ss << "\\default 0.016\n";
    ss << "N6 , \\field Pipe Outer Diameter\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units in\n";
    ss << "\\default 0.026\n";
    ss << "N7 , \\field Burial Depth\n";
    ss << "\\note This is the burial depth of the pipes, or the trenches\n";
    ss << "\\note containing the pipes\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units ft\n";
    ss << "\\default 1.5\n";
    ss << "N8 , \\field Soil Thermal Conductivity\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1.08\n";
    ss << "N9 , \\field Soil Density\n";
    ss << "\\type real\n";
    ss << "\\units kg/m3\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 962\n";
    ss << "N10, \\field Soil Specific Heat\n";
    ss << "\\type real\n";
    ss << "\\units J/kg-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 2576\n";
    ss << "N11, \\field Pipe Thermal Conductivity\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.3895\n";
    ss << "N12, \\field Pipe Density\n";
    ss << "\\type real\n";
    ss << "\\units kg/m3\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 641\n";
    ss << "N13, \\field Pipe Specific Heat\n";
    ss << "\\type real\n";
    ss << "\\units J/kg-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 2405\n";
    ss << "N14, \\field Soil Moisture Content Percent\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 100\n";
    ss << "\\default 30\n";
    ss << "N15, \\field Soil Moisture Content Percent at Saturation\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 100\n";
    ss << "\\default 50\n";
    ss << "A4,  \\field Undisturbed Ground Temperature Model Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Site:GroundTemperature:Undisturbed:FiniteDifference\n";
    ss << "\\key Site:GroundTemperature:Undisturbed:KusudaAchenbach\n";
    ss << "\\key Site:GroundTemperature:Undisturbed:Xing\n";
    ss << "A5,  \\field Undisturbed Ground Temperature Model Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UndisturbedGroundTempModels\n";
    ss << "N16; \\field Evapotranspiration Ground Cover Parameter\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.5\n";
    ss << "\\default 0.4\n";
    ss << "\\note This specifies the ground cover effects during evapotranspiration\n";
    ss << "\\note  calculations.  The value roughly represents the following cases:\n";
    ss << "\\note  = 0   : concrete or other solid, non-permeable ground surface material\n";
    ss << "\\note  = 0.5 : short grass, much like a manicured lawn\n";
    ss << "\\note  = 1   : standard reference state (12 cm grass)\n";
    ss << "\\note  = 1.5 : wild growth\n";

    IddObjectType objType(IddObjectType::GroundHeatExchanger_HorizontalTrench);
    OptionalIddObject oObj = IddObject::load("GroundHeatExchanger:HorizontalTrench",
                                             "Condenser Equipment and Heat Exchangers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatExchanger_HorizontalTrench);
  return object;
}

IddObject createGroundHeatExchanger_SlinkyIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "GroundHeatExchanger:Slinky,\n";
    ss << "\\memo This models a slinky horizontal heat exchanger\n";
    ss << "\\memo placed in a series of trenches\n";
    ss << "\\memo The model uses the model developed by:\n";
    ss << "\\memo Xiong, Z., D.E. Fisher, and J.D. Spitler. 2015.\n";
    ss << "\\memo Development and Validation of a Slinky Ground Heat\n";
    ss << "\\memo Exchanger Model. Applied Energy 141: 57-69.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A3 , \\field Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.002\n";
    ss << "N2 , \\field Soil Thermal Conductivity\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1.08\n";
    ss << "N3 , \\field Soil Density\n";
    ss << "\\type real\n";
    ss << "\\units kg/m3\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 962\n";
    ss << "N4,  \\field Soil Specific Heat\n";
    ss << "\\type real\n";
    ss << "\\units J/kg-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 2576\n";
    ss << "N5,  \\field Pipe Thermal Conductivity\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.4\n";
    ss << "N6,  \\field Pipe Density\n";
    ss << "\\type real\n";
    ss << "\\units kg/m3\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 641\n";
    ss << "N7,  \\field Pipe Specific Heat\n";
    ss << "\\type real\n";
    ss << "\\units J/kg-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 2405\n";
    ss << "N8 , \\field Pipe Outer Diameter\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units in\n";
    ss << "\\default 0.02667\n";
    ss << "N9 , \\field Pipe Thickness\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units in\n";
    ss << "\\default 0.002413\n";
    ss << "A4 , \\field Heat Exchanger Configuration\n";
    ss << "\\note This is the orientation of the heat exchanger\n";
    ss << "\\type choice\n";
    ss << "\\key Vertical\n";
    ss << "\\key Horizontal\n";
    ss << "N10 ,\\field Coil Diameter\n";
    ss << "\\note This is the diameter of the heat exchanger coil\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units ft\n";
    ss << "\\default 1.0\n";
    ss << "N11, \\field Coil Pitch\n";
    ss << "\\note This is the center-to-center distance between coils\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units ft\n";
    ss << "\\default 0.20\n";
    ss << "N12, \\field Trench Depth\n";
    ss << "\\note This is the distance from the ground surface to the\n";
    ss << "\\note trench bottom\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units ft\n";
    ss << "\\default 1.8\n";
    ss << "N13, \\field Trench Length\n";
    ss << "\\note This is the total length of a single trench\n";
    ss << "\\note This assumes the heat exchanger runs the full length\n";
    ss << "\\note of the trench\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units ft\n";
    ss << "\\default 10\n";
    ss << "N14, \\field Number of Trenches\n";
    ss << "\\note This is the number of parallel trenches that\n";
    ss << "\\note has a heat exchanger, one per trench\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";
    ss << "N15, \\field Horizontal Spacing Between Pipes\n";
    ss << "\\note This represents the average horizontal spacing\n";
    ss << "\\note between any two\n";
    ss << "\\note trenches for heat exchangers that have multiple trenches\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units ft\n";
    ss << "\\default 2.0\n";
    ss << "A5,  \\field Undisturbed Ground Temperature Model Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Site:GroundTemperature:Undisturbed:FiniteDifference\n";
    ss << "\\key Site:GroundTemperature:Undisturbed:KusudaAchenbach\n";
    ss << "\\key Site:GroundTemperature:Undisturbed:Xing\n";
    ss << "A6,  \\field Undisturbed Ground Temperature Model Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UndisturbedGroundTempModels\n";
    ss << "N16; \\field Maximum Length of Simulation\n";

    IddObjectType objType(IddObjectType::GroundHeatExchanger_Slinky);
    OptionalIddObject oObj = IddObject::load("GroundHeatExchanger:Slinky",
                                             "Condenser Equipment and Heat Exchangers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::GroundHeatExchanger_Slinky);
  return object;
}

IddObject createHeatExchanger_FluidToFluidIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "HeatExchanger:FluidToFluid,\n";
    ss << "\\memo A fluid/fluid heat exchanger designed to couple the supply side of one loop to the demand side of another loop\n";
    ss << "\\memo Loops can be either plant or condenser loops but no air side connections are allowed\n";
    ss << "\\min-fields 14\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\note default is that heat exchanger is on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Loop Demand Side Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "\\note This connection is to the demand side of a loop and is the inlet to the heat exchanger\n";
    ss << "A4 , \\field Loop Demand Side Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "\\note This connection is to the demand side of a loop\n";
    ss << "N1 , \\field Loop Demand Side Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\autosizable\n";
    ss << "A5 , \\field Loop Supply Side Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A6 , \\field Loop Supply Side Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "N2 , \\field Loop Supply Side Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\autosizable\n";
    ss << "A7 , \\field Heat Exchange Model Type\n";
    ss << "\\type choice\n";
    ss << "\\key CrossFlowBothUnMixed\n";
    ss << "\\key CrossFlowBothMixed\n";
    ss << "\\key CrossFlowSupplyMixedDemandUnMixed\n";
    ss << "\\key CrossFlowSupplyUnMixedDemandMixed\n";
    ss << "\\key ParallelFlow\n";
    ss << "\\key CounterFlow\n";
    ss << "\\key Ideal\n";
    ss << "\\default Ideal\n";
    ss << "N3 , \\field Heat Exchanger U-Factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "A8 , \\field Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key UncontrolledOn\n";
    ss << "\\key OperationSchemeModulated\n";
    ss << "\\key OperationSchemeOnOff\n";
    ss << "\\key HeatingSetpointModulated\n";
    ss << "\\key HeatingSetpointOnOff\n";
    ss << "\\key CoolingSetpointModulated\n";
    ss << "\\key CoolingSetpointOnOff\n";
    ss << "\\key DualDeadbandSetpointModulated\n";
    ss << "\\key DualDeadbandSetpointOnOff\n";
    ss << "\\key CoolingDifferentialOnOff\n";
    ss << "\\key CoolingSetpointOnOffWithComponentOverride\n";
    ss << "\\default UncontrolledOn\n";
    ss << "A9 , \\field Heat Exchanger Setpoint Node Name\n";
    ss << "\\note Setpoint node is needed with any Control Type that is \"*Setpoint*\"\n";
    ss << "\\type node\n";
    ss << "N4 , \\field Minimum Temperature Difference to Activate Heat Exchanger\n";
    ss << "\\note Tolerance between control temperatures used to determine if heat exchanger should run.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 50\n";
    ss << "\\default 0.01\n";
    ss << "\\units deltaC\n";
    ss << "A10, \\field Heat Transfer Metering End Use Type\n";
    ss << "\\note This field controls end use reporting for heat transfer meters\n";
    ss << "\\type choice\n";
    ss << "\\key FreeCooling\n";
    ss << "\\key HeatRecovery\n";
    ss << "\\key HeatRejection\n";
    ss << "\\key HeatRecoveryForCooling\n";
    ss << "\\key HeatRecoveryForHeating\n";
    ss << "\\key LoopToLoop\n";
    ss << "\\default LoopToLoop\n";
    ss << "A11, \\field Component Override Loop Supply Side Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note This field is only used if Control Type is set to CoolingSetpointOnOffWithComponentOverride\n";
    ss << "A12, \\field Component Override Loop Demand Side Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note This field is only used if Control Type is set to CoolingSetpointOnOffWithComponentOverride\n";
    ss << "A13, \\field Component Override Cooling Control Temperature Mode\n";
    ss << "\\type choice\n";
    ss << "\\key WetBulbTemperature\n";
    ss << "\\key DryBulbTemperature\n";
    ss << "\\key Loop\n";
    ss << "\\default Loop\n";
    ss << "\\note This field is only used if Control Type is set to CoolingSetpointOnOffWithComponentOverride\n";
    ss << "N5 , \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized flow rates for this device\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N6 , \\field Operation Minimum Temperature Limit\n";
    ss << "\\note Lower limit on inlet temperatures, heat exchanger will not operate if either inlet is below this limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N7 ; \\field Operation Maximum Temperature Limit\n";
    ss << "\\note Upper limit on inlet temperatures, heat exchanger will not operate if either inlet is above this limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";

    IddObjectType objType(IddObjectType::HeatExchanger_FluidToFluid);
    OptionalIddObject oObj = IddObject::load("HeatExchanger:FluidToFluid",
                                             "Condenser Equipment and Heat Exchangers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::HeatExchanger_FluidToFluid);
  return object;
}

IddObject createWaterHeater_MixedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WaterHeater:Mixed,\n";
    ss << "\\memo Water heater with well-mixed, single-node water tank. May be used to model a tankless\n";
    ss << "\\memo water heater (small tank volume), a hot water storage tank (zero heater capacity), or\n";
    ss << "\\memo a heat pump water heater (see WaterHeater:HeatPump:PumpedCondenser.)\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WaterHeaterNames\n";
    ss << "\\reference WaterHeaterMixedNames\n";
    ss << "N1 , \\field Tank Volume\n";
    ss << "\\autosizable\n";
    ss << "\\type real\n";
    ss << "\\units m3\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\ip-units gal\n";
    ss << "A2 , \\field Setpoint Temperature Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N2 , \\field Deadband Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N3 , \\field Maximum Temperature Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "A3 , \\field Heater Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Cycle\n";
    ss << "\\key Modulate\n";
    ss << "\\default Cycle\n";
    ss << "N4 , \\field Heater Maximum Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "N5 , \\field Heater Minimum Capacity\n";
    ss << "\\note Only used when Heater Control Type is set to Modulate\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "N6 , \\field Heater Ignition Minimum Flow Rate\n";
    ss << "\\note Not yet implemented\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N7 , \\field Heater Ignition Delay\n";
    ss << "\\note Not yet implemented\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "A4 , \\field Heater Fuel Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\key Steam\n";
    ss << "\\key DistrictHeating\n";
    ss << "N8 , \\field Heater Thermal Efficiency\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A5 , \\field Part Load Factor Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "N9 , \\field Off Cycle Parasitic Fuel Consumption Rate\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "A6 , \\field Off Cycle Parasitic Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\key Steam\n";
    ss << "\\key DistrictHeating\n";
    ss << "N10, \\field Off Cycle Parasitic Heat Fraction to Tank\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N11, \\field On Cycle Parasitic Fuel Consumption Rate\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "A7 , \\field On Cycle Parasitic Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\key Steam\n";
    ss << "\\key DistrictHeating\n";
    ss << "N12, \\field On Cycle Parasitic Heat Fraction to Tank\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "A8 , \\field Ambient Temperature Indicator\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Schedule\n";
    ss << "\\key Zone\n";
    ss << "\\key Outdoors\n";
    ss << "A9 , \\field Ambient Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A10, \\field Ambient Temperature Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A11, \\field Ambient Temperature Outdoor Air Node Name\n";
    ss << "\\type node\n";
    ss << "\\note required for Ambient Temperature Indicator=Outdoors\n";
    ss << "N13, \\field Off Cycle Loss Coefficient to Ambient Temperature\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "N14, \\field Off Cycle Loss Fraction to Zone\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "N15, \\field On Cycle Loss Coefficient to Ambient Temperature\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "N16, \\field On Cycle Loss Fraction to Zone\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "N17, \\field Peak Use Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Only used if Use Side Node connections are blank\n";
    ss << "A12, \\field Use Flow Rate Fraction Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Only used if Use Side Node connections are blank\n";
    ss << "A13, \\field Cold Water Supply Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Only used if Use Side Node connections are blank\n";
    ss << "\\note Defaults to water temperatures calculated by Site:WaterMainsTemperature object\n";
    ss << "A14, \\field Use Side Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A15, \\field Use Side Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N18, \\field Use Side Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A16, \\field Source Side Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A17, \\field Source Side Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N19, \\field Source Side Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "N20, \\field Use Side Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "N21, \\field Source Side Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "N22, \\field Indirect Water Heating Recovery Time\n";
    ss << "\\type real\n";
    ss << "\\default 1.5\n";
    ss << "\\note Parameter for autosizing design flow rates for indirectly heated water tanks\n";
    ss << "\\note Time required to raise temperature of entire tank from 14.4C to 57.2C\n";
    ss << "\\units hr\n";
    ss << "\\minimum> 0.0\n";
    ss << "A18, \\field Source Side Flow Control Mode\n";
    ss << "\\type choice\n";
    ss << "\\key StorageTank\n";
    ss << "\\key IndirectHeatPrimarySetpoint\n";
    ss << "\\key IndirectHeatAlternateSetpoint\n";
    ss << "\\default IndirectHeatPrimarySetpoint\n";
    ss << "\\note StorageTank mode always requests flow unless tank is at its Maximum Temperature Limit\n";
    ss << "\\note IndirectHeatPrimarySetpoint mode requests flow whenever primary setpoint calls for heat\n";
    ss << "\\note IndirectHeatAlternateSetpoint mode requests flow whenever alternate indirect setpoint calls for heat\n";
    ss << "A19; \\field Indirect Alternate Setpoint Temperature Schedule Name\n";
    ss << "\\note This field is only used if the previous is set to IndirectHeatAlternateSetpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::WaterHeater_Mixed);
    OptionalIddObject oObj = IddObject::load("WaterHeater:Mixed",
                                             "Water Heaters and Thermal Storage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WaterHeater_Mixed);
  return object;
}

IddObject createWaterHeater_StratifiedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WaterHeater:Stratified,\n";
    ss << "\\memo Water heater with stratified, multi-node water tank. May be used to model a tankless\n";
    ss << "\\memo water heater (small tank volume), a hot water storage tank (zero heater capacity), or\n";
    ss << "\\memo a heat pump water heater (see WaterHeater:HeatPump:*.)\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WaterHeaterNames\n";
    ss << "\\reference WaterHeaterStratifiedNames\n";
    ss << "A2 , \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";
    ss << "N1 , \\field Tank Volume\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units gal\n";
    ss << "N2 , \\field Tank Height\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Height is measured in the axial direction for horizontal cylinders\n";
    ss << "A3 , \\field Tank Shape\n";
    ss << "\\type choice\n";
    ss << "\\key VerticalCylinder\n";
    ss << "\\key HorizontalCylinder\n";
    ss << "\\key Other\n";
    ss << "\\default VerticalCylinder\n";
    ss << "N3 , \\field Tank Perimeter\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Only used if Tank Shape is Other\n";
    ss << "N4 , \\field Maximum Temperature Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "A4 , \\field Heater Priority Control\n";
    ss << "\\type choice\n";
    ss << "\\key MasterSlave\n";
    ss << "\\key Simultaneous\n";
    ss << "\\default MasterSlave\n";
    ss << "A5 , \\field Heater 1 Setpoint Temperature Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N5 , \\field Heater 1 Deadband Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N6 , \\field Heater 1 Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N7 , \\field Heater 1 Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "A6 , \\field Heater 2 Setpoint Temperature Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N8 , \\field Heater 2 Deadband Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N9 , \\field Heater 2 Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "N10, \\field Heater 2 Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "A7 , \\field Heater Fuel Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\key Steam\n";
    ss << "\\key DistrictHeating\n";
    ss << "N11, \\field Heater Thermal Efficiency\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N12, \\field Off Cycle Parasitic Fuel Consumption Rate\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "A8 , \\field Off Cycle Parasitic Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\key Steam\n";
    ss << "\\key DistrictHeating\n";
    ss << "N13, \\field Off Cycle Parasitic Heat Fraction to Tank\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N14, \\field Off Cycle Parasitic Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N15, \\field On Cycle Parasitic Fuel Consumption Rate\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "A9 , \\field On Cycle Parasitic Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\key Steam\n";
    ss << "\\key DistrictHeating\n";
    ss << "N16, \\field On Cycle Parasitic Heat Fraction to Tank\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N17, \\field On Cycle Parasitic Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "A10, \\field Ambient Temperature Indicator\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Schedule\n";
    ss << "\\key Zone\n";
    ss << "\\key Outdoors\n";
    ss << "A11, \\field Ambient Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A12, \\field Ambient Temperature Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A13, \\field Ambient Temperature Outdoor Air Node Name\n";
    ss << "\\type node\n";
    ss << "\\note required for Ambient Temperature Indicator=Outdoors\n";
    ss << "N18, \\field Uniform Skin Loss Coefficient per Unit Area to Ambient Temperature\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum 0.0\n";
    ss << "N19, \\field Skin Loss Fraction to Zone\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "N20, \\field Off Cycle Flue Loss Coefficient to Ambient Temperature\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "N21, \\field Off Cycle Flue Loss Fraction to Zone\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "N22, \\field Peak Use Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Only used if Use Side Node connections are blank\n";
    ss << "A14, \\field Use Flow Rate Fraction Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note If blank, defaults to 1.0 at all times\n";
    ss << "\\note Only used if use side node connections are blank\n";
    ss << "A15, \\field Cold Water Supply Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Only used if use side node connections are blank\n";
    ss << "\\note Defaults to water temperatures calculated by Site:WaterMainsTemperature object\n";
    ss << "A16, \\field Use Side Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A17, \\field Use Side Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N23, \\field Use Side Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note The use side effectiveness in the stratified tank model is a simplified analogy of\n";
    ss << "\\note a heat exchanger's effectiveness. This effectiveness is equal to the fraction of\n";
    ss << "\\note use mass flow rate that directly mixes with the tank fluid. And one minus the\n";
    ss << "\\note effectiveness is the fraction that bypasses the tank. The use side mass flow rate\n";
    ss << "\\note that bypasses the tank is mixed with the fluid or water leaving the stratified tank.\n";
    ss << "N24, \\field Use Side Inlet Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Defaults to bottom of tank\n";
    ss << "N25, \\field Use Side Outlet Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\default Autocalculate\n";
    ss << "\\note Defaults to top of tank\n";
    ss << "A18, \\field Source Side Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A19, \\field Source Side Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N26, \\field Source Side Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note The source side effectiveness in the stratified tank model is a simplified analogy of\n";
    ss << "\\note a heat exchanger's effectiveness. This effectiveness is equal to the fraction of\n";
    ss << "\\note source mass flow rate that directly mixes with the tank fluid. And one minus the\n";
    ss << "\\note effectiveness is the fraction that bypasses the tank. The source side mass flow rate\n";
    ss << "\\note that bypasses the tank is mixed with the fluid or water leaving the stratified tank.\n";
    ss << "N27, \\field Source Side Inlet Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\default Autocalculate\n";
    ss << "\\note Defaults to top of tank\n";
    ss << "N28, \\field Source Side Outlet Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Defaults to bottom of tank\n";
    ss << "A20, \\field Inlet Mode\n";
    ss << "\\type choice\n";
    ss << "\\key Fixed\n";
    ss << "\\key Seeking\n";
    ss << "\\default Fixed\n";
    ss << "N29, \\field Use Side Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "N30, \\field Source Side Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "N31, \\field Indirect Water Heating Recovery Time\n";
    ss << "\\type real\n";
    ss << "\\default 1.5\n";
    ss << "\\note Parameter for autosizing design flow rates for indirectly heated water tanks\n";
    ss << "\\note time required to raise temperature of entire tank from 14.4C to 57.2C\n";
    ss << "\\units hr\n";
    ss << "\\minimum> 0.0\n";
    ss << "N32, \\field Number of Nodes\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "\\default 1\n";
    ss << "N33, \\field Additional Destratification Conductivity\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N34, \\field Node 1 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N35, \\field Node 2 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N36, \\field Node 3 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N37, \\field Node 4 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N38, \\field Node 5 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N39, \\field Node 6 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N40, \\field Node 7 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N41, \\field Node 8 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N42, \\field Node 9 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N43, \\field Node 10 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N44, \\field Node 11 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N45, \\field Node 12 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "A21, \\field Source Side Flow Control Mode\n";
    ss << "\\type choice\n";
    ss << "\\key StorageTank\n";
    ss << "\\key IndirectHeatPrimarySetpoint\n";
    ss << "\\key IndirectHeatAlternateSetpoint\n";
    ss << "\\default IndirectHeatPrimarySetpoint\n";
    ss << "\\note StorageTank mode always requests flow unless tank is at its Maximum Temperature Limit\n";
    ss << "\\note IndirectHeatPrimarySetpoint mode requests flow whenever primary setpoint for heater 1 calls for heat\n";
    ss << "\\note IndirectHeatAlternateSetpoint mode requests flow whenever alternate indirect setpoint calls for heat\n";
    ss << "A22; \\field Indirect Alternate Setpoint Temperature Schedule Name\n";
    ss << "\\note This field is only used if the previous is set to IndirectHeatAlternateSetpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::WaterHeater_Stratified);
    OptionalIddObject oObj = IddObject::load("WaterHeater:Stratified",
                                             "Water Heaters and Thermal Storage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WaterHeater_Stratified);
  return object;
}

IddObject createWaterHeater_SizingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WaterHeater:Sizing,\n";
    ss << "\\min-fields 4\n";
    ss << "\\memo This input object is used with WaterHeater:Mixed or\n";
    ss << "\\memo with WaterHeater:Stratified to autosize tank volume and heater capacity\n";
    ss << "\\memo This object is not needed if water heaters are not autosized.\n";
    ss << "A1 , \\field WaterHeater Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterHeaterNames\n";
    ss << "A2 , \\field Design Mode\n";
    ss << "\\type choice\n";
    ss << "\\key PeakDraw\n";
    ss << "\\key ResidentialHUD-FHAMinimum\n";
    ss << "\\key PerPerson\n";
    ss << "\\key PerFloorArea\n";
    ss << "\\key PerUnit\n";
    ss << "\\key PerSolarCollectorArea\n";
    ss << "N1 , \\field Time Storage Can Meet Peak Draw\n";
    ss << "\\type real\n";
    ss << "\\units hr\n";
    ss << "\\note Only used for Design Mode = PeakDraw\n";
    ss << "\\minimum 0.0\n";
    ss << "N2 , \\field Time for Tank Recovery\n";
    ss << "\\type real\n";
    ss << "\\units hr\n";
    ss << "\\note Only used for Design Mode = PeakDraw\n";
    ss << "\\minimum 0.0\n";
    ss << "N3 , \\field Nominal Tank Volume for Autosizing Plant Connections\n";
    ss << "\\type real\n";
    ss << "\\units m3\n";
    ss << "\\ip-units gal\n";
    ss << "\\note Only used if Design Mode = PeakDraw and the water heater also\n";
    ss << "\\note has autosized flow rates for connections on the demand side of a plant loop\n";
    ss << "N4 , \\field Number of Bedrooms\n";
    ss << "\\type integer\n";
    ss << "\\note Only used for Design Mode = ResidentialHUD-FHAMinimum\n";
    ss << "\\minimum 1\n";
    ss << "N5 , \\field Number of Bathrooms\n";
    ss << "\\type integer\n";
    ss << "\\note Only used for Design Mode = ResidentialHUD-FHAMinimum\n";
    ss << "\\minimum 1\n";
    ss << "N6 , \\field Storage Capacity per Person\n";
    ss << "\\type real\n";
    ss << "\\units m3/Person\n";
    ss << "\\ip-units gal/Person\n";
    ss << "\\note Only used for Design Mode = PerPerson\n";
    ss << "\\minimum 0.0\n";
    ss << "N7 , \\field Recovery Capacity per Person\n";
    ss << "\\type real\n";
    ss << "\\units m3/hr-person\n";
    ss << "\\ip-units gal/hr-person\n";
    ss << "\\note Only used for Design Mode = PerPerson\n";
    ss << "\\minimum 0.0\n";
    ss << "N8 , \\field Storage Capacity per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units m3/m2\n";
    ss << "\\ip-units gal/ft2\n";
    ss << "\\note Only used for Design Mode = PerFloorArea\n";
    ss << "\\minimum 0.0\n";
    ss << "N9 , \\field Recovery Capacity per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units m3/hr-m2\n";
    ss << "\\ip-units gal/hr-ft2\n";
    ss << "\\note Only used for Design Mode = PerFloorArea\n";
    ss << "\\minimum 0.0\n";
    ss << "N10 , \\field Number of Units\n";
    ss << "\\type real\n";
    ss << "\\note Only used for Design Mode = PerUnit\n";
    ss << "N11 , \\field Storage Capacity per Unit\n";
    ss << "\\units m3\n";
    ss << "\\ip-units gal\n";
    ss << "\\type real\n";
    ss << "\\note Only used for Design Mode = PerUnit\n";
    ss << "\\minimum 0.0\n";
    ss << "N12 , \\field Recovery Capacity PerUnit\n";
    ss << "\\units m3/hr\n";
    ss << "\\ip-units gal/hr\n";
    ss << "\\type real\n";
    ss << "\\note Only used for Design Mode = PerUnit\n";
    ss << "\\minimum 0.0\n";
    ss << "N13 ,\\field Storage Capacity per Collector Area\n";
    ss << "\\units m3/m2\n";
    ss << "\\ip-units gal/ft2\n";
    ss << "\\type real\n";
    ss << "\\note Only used for Design Mode = PerSolarCollectorArea\n";
    ss << "\\minimum 0.0\n";
    ss << "N14 ; \\field Height Aspect Ratio\n";
    ss << "\\type real\n";
    ss << "\\note only used if for WaterHeater:Stratified\n";
    ss << "\\minimum 0.0\n";

    IddObjectType objType(IddObjectType::WaterHeater_Sizing);
    OptionalIddObject oObj = IddObject::load("WaterHeater:Sizing",
                                             "Water Heaters and Thermal Storage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WaterHeater_Sizing);
  return object;
}

IddObject createWaterHeater_HeatPump_PumpedCondenserIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WaterHeater:HeatPump:PumpedCondenser,\n";
    ss << "\\min-fields 32\n";
    ss << "\\memo This object models an air-source heat pump for water heating where the water is pumped out of the tank,\n";
    ss << "\\memo through a heating coil and returned to the tank.\n";
    ss << "\\memo For wrapped condenser HPWHs, see WaterHeater:HeatPump:WrappedCondenser.\n";
    ss << "\\memo WaterHeater:HeatPump:PumpedCondenser is a compound object that references other component objects -\n";
    ss << "\\memo Coil:WaterHeating:AirToWaterHeatPump:*, Fan:OnOff, WaterHeater:Mixed or WaterHeater:Stratified\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note Unique name for this instance of a heat pump water heater.\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values of 0 denote the heat pump compressor is off and the parasitic electric\n";
    ss << "\\note energy is also off.\n";
    ss << "A3,  \\field Compressor Setpoint Temperature Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defines the cut-out temperature where the heat pump compressor turns off.\n";
    ss << "\\note The heat pump compressor setpoint temperature should always be greater\n";
    ss << "\\note than the water tank's heater (element or burner) setpoint temperature.\n";
    ss << "N1 , \\field Dead Band Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 20\n";
    ss << "\\default 5.0\n";
    ss << "\\note Setpoint temperature minus the dead band temperature difference defines\n";
    ss << "\\note the cut-in temperature where the heat pump compressor turns on.\n";
    ss << "\\note The water tank's heater (element or burner) setpoint temperature\n";
    ss << "\\note should always be less than the heat pump compressor cut-in temperature.\n";
    ss << "A4 , \\field Condenser Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Should match the field Source Outlet Node Name in the water heater tank object.\n";
    ss << "\\note Should also match the Condenser Water Inlet Node Name in the associated\n";
    ss << "\\note DX coil object.\n";
    ss << "A5 , \\field Condenser Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Should match the field Source Inlet Node Name in water heater tank object.\n";
    ss << "\\note Should also match the Condenser Water Outlet Node Name in the associated\n";
    ss << "\\note DX Coil object.\n";
    ss << "N2 , \\field Condenser Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Actual water flow rate through the heat pump's water coil (condenser).\n";
    ss << "\\note If autocalculated, the water flow rate is set equal to 4.487E-8 m3/s/W times\n";
    ss << "\\note the rated heating capacity of the heat pump's DX coil.\n";
    ss << "N3 , \\field Evaporator Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Actual air flow rate across the heat pump's air coil (evaporator).\n";
    ss << "\\note If autocalculated, the air flow rate is set equal to 5.035E-5 m3/s/W times\n";
    ss << "\\note the rated heating capacity of the heat pump's DX coil.\n";
    ss << "A6 , \\field Inlet Air Configuration\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Schedule\n";
    ss << "\\key ZoneAirOnly\n";
    ss << "\\key OutdoorAirOnly\n";
    ss << "\\key ZoneAndOutdoorAir\n";
    ss << "\\note Defines the configuration of the airflow path through the air coil and fan section.\n";
    ss << "A7 , \\field Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Zone air exhaust node name if Inlet Air Configuration is ZoneAirOnly or\n";
    ss << "\\note ZoneAndOutdoorAir.\n";
    ss << "\\note Simply a unique Node Name if Inlet Air Configuration is Schedule.\n";
    ss << "\\note Otherwise, leave field blank.\n";
    ss << "A8 , \\field Air Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Zone Air Inlet Node Name if Inlet Air Configuration is ZoneAirOnly or\n";
    ss << "\\note ZoneAndOutdoorAir.\n";
    ss << "\\note Simply a unique Node Name if Inlet Air Configuration is Schedule.\n";
    ss << "\\note Otherwise, leave field blank.\n";
    ss << "A9 , \\field Outdoor Air Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Outdoor air node name if inlet air configuration is ZoneAndOutdoorAir\n";
    ss << "\\note or OutdoorAirOnly, otherwise leave field blank.\n";
    ss << "A10, \\field Exhaust Air Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Simply a unique Node Name if Inlet Air Configuration is ZoneAndOutdoorAir\n";
    ss << "\\note or OutdoorAirOnly, otherwise leave field blank.\n";
    ss << "A11, \\field Inlet Air Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Used only if Inlet Air Configuration is Schedule, otherwise leave blank.\n";
    ss << "\\note Schedule values should be degrees C.\n";
    ss << "A12, \\field Inlet Air Humidity Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Used only if Inlet Air Configuration is Schedule, otherwise leave blank.\n";
    ss << "\\note Schedule values are entered as a fraction (e.g. 0.5 is equal to 50%RH)\n";
    ss << "A13, \\field Inlet Air Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note Used only if Inlet Air Configuration is ZoneAirOnly or ZoneAndOutdoorAir.\n";
    ss << "\\note Otherwise, leave field blank.\n";
    ss << "A14, \\field Tank Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key WaterHeater:Mixed\n";
    ss << "\\key WaterHeater:Stratified\n";
    ss << "\\default WaterHeater:Mixed\n";
    ss << "\\note Specify the type of water heater tank used by this heat pump water heater.\n";
    ss << "A15, \\field Tank Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterHeaterNames\n";
    ss << "\\note Needs to match the name used in the corresponding Water Heater object.\n";
    ss << "A16, \\field Tank Use Side Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Used only when the heat pump water heater is connected to a plant loop,\n";
    ss << "\\note otherwise leave blank. Needs to match the name used in the corresponding\n";
    ss << "\\note Water Heater object when connected to a plant loop.\n";
    ss << "A17, \\field Tank Use Side Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Used only when the heat pump water heater is connected to a plant loop,\n";
    ss << "\\note otherwise leave blank. Needs to match the name used in the corresponding\n";
    ss << "\\note Water Heater object when connected to a plant loop.\n";
    ss << "A18, \\field DX Coil Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:WaterHeating:AirToWaterHeatPump:Pumped\n";
    ss << "\\key Coil:WaterHeating:AirToWaterHeatPump:VariableSpeed\n";
    ss << "\\default Coil:WaterHeating:AirToWaterHeatPump:Pumped\n";
    ss << "\\note Specify the type of DX coil used by this heat pump water heater. The only\n";
    ss << "\\note valid choice is Coil:WaterHeating:AirToWaterHeatPump:Pumped and Coil:WaterHeating:AirToWaterHeatPump:VariableSpeed.\n";
    ss << "A19, \\field DX Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatPumpWaterHeaterDXCoilsPumped\n";
    ss << "\\object-list HeatPumpWaterHeaterDXCoilsVariableSpeed\n";
    ss << "\\note Must match the name used in the corresponding Coil:WaterHeating:AirToWaterHeatPump:* object.\n";
    ss << "N4 , \\field Minimum Inlet Air Temperature for Compressor Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -5\n";
    ss << "\\default 10\n";
    ss << "\\note Heat pump compressor will not operate when the inlet air dry-bulb temperature\n";
    ss << "\\note is below this value.\n";
    ss << "N5 , \\field Maximum Inlet Air Temperature for Compressor Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 94\n";
    ss << "\\minimum 26\n";
    ss << "\\maximum 94\n";
    ss << "\\note Heat pump compressor will not operate when the inlet air dry-bulb temperature\n";
    ss << "\\note is above this value.\n";
    ss << "A20, \\field Compressor Location\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Schedule\n";
    ss << "\\key Zone\n";
    ss << "\\key Outdoors\n";
    ss << "\\note If Zone is selected, Inlet Air Configuration must be ZoneAirOnly or\n";
    ss << "\\note ZoneAndOutdoorAir. If Schedule is selected, then you must provide a\n";
    ss << "\\note Compressor Ambient Temperature Schedule Name below.\n";
    ss << "A21, \\field Compressor Ambient Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Used only if Compressor Location is Schedule, otherwise leave field blank.\n";
    ss << "A22, \\field Fan Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\default Fan:OnOff\n";
    ss << "\\note Specify the type of fan used by this heat pump water heater. The only\n";
    ss << "\\note valid choice is Fan:OnOff.\n";
    ss << "A23, \\field Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansOnOff\n";
    ss << "\\note Needs to match the name used in the corresponding Fan:OnOff object.\n";
    ss << "A24, \\field Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default DrawThrough\n";
    ss << "\\note BlowThrough means the fan is located before the air coil (upstream).\n";
    ss << "\\note DrawThrough means the fan is located after the air coil (downstream).\n";
    ss << "N6 , \\field On Cycle Parasitic Electric Load\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Parasitic electric power consumed when the heat pump compressor operates.\n";
    ss << "\\note Does not contribute to water heating but can impact the zone air heat balance.\n";
    ss << "N7 , \\field Off Cycle Parasitic Electric Load\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Parasitic electric power consumed when the heat pump compressor is off.\n";
    ss << "\\note Does not contribute to water heating but can impact the zone air heat balance.\n";
    ss << "\\note Off-cycle parasitic power is 0 when the availability schedule is 0.\n";
    ss << "A25, \\field Parasitic Heat Rejection Location\n";
    ss << "\\type choice\n";
    ss << "\\key Zone\n";
    ss << "\\key Outdoors\n";
    ss << "\\default Outdoors\n";
    ss << "\\note This field determines if the parasitic electric load impacts the zone air\n";
    ss << "\\note heat balance. If Zone is selected, Inlet Air Configuration must be\n";
    ss << "\\note ZoneAirOnly or ZoneAndOutdoorAir.\n";
    ss << "A26, \\field Inlet Air Mixer Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Required only if Inlet Air Configuration is ZoneAndOutdoorAir, otherwise\n";
    ss << "\\note leave field blank.\n";
    ss << "A27, \\field Outlet Air Splitter Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Required only if Inlet Air Configuration is ZoneAndOutdoorAir, otherwise\n";
    ss << "\\note leave field blank.\n";
    ss << "A28, \\field Inlet Air Mixer Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Required only if Inlet Air Configuration is ZoneAndOutdoorAir, otherwise\n";
    ss << "\\note leave field blank. Schedule values define whether the heat pump draws its\n";
    ss << "\\note inlet air from the zone, outdoors or a combination of zone and outdoor air.\n";
    ss << "\\note A schedule value of 0 denotes inlet air is drawn only from the zone.\n";
    ss << "\\note A schedule value of 1 denotes inlet air is drawn only from outdoors.\n";
    ss << "\\note Schedule values between 0 and 1 denote a mixture of zone and outdoor air\n";
    ss << "\\note proportional to the schedule value (i.e. 0.4 = 40% outdoor air, 60% zone air).\n";
    ss << "A29, \\field Tank Element Control Logic\n";
    ss << "\\type choice\n";
    ss << "\\key MutuallyExlcusive\n";
    ss << "\\key Simultaneous\n";
    ss << "\\default Simultaneous\n";
    ss << "\\note MutuallyExclusive means that once the tank heating element is active the\n";
    ss << "\\note heat pump is shut down until setpoint is reached.\n";
    ss << "\\note Simultaneous (default) means that both the tank heating element and\n";
    ss << "\\note heat pump are used at the same time recover the tank temperature.\n";
    ss << "N8,  \\field Control Sensor 1 Height In Stratified Tank\n";
    ss << "\\note Used to indicate height of control sensor for Tank Object Type = WaterHeater:Stratified\n";
    ss << "\\note If left blank, it will default to the height of Heater1\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "N9,  \\field Control Sensor 1 Weight\n";
    ss << "\\note Weight to give Control Sensor 1 temperature\n";
    ss << "\\note The weight of Control Sensor 2 will be 1 - (wt. of control sensor 1)\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "N10; \\field Control Sensor 2 Height In Stratified Tank\n";
    ss << "\\note Used to indicate height of control sensor for Tank Object Type = WaterHeater:Stratified\n";
    ss << "\\note If left blank, it will default to the height of Heater2\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";

    IddObjectType objType(IddObjectType::WaterHeater_HeatPump_PumpedCondenser);
    OptionalIddObject oObj = IddObject::load("WaterHeater:HeatPump:PumpedCondenser",
                                             "Water Heaters and Thermal Storage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WaterHeater_HeatPump_PumpedCondenser);
  return object;
}

IddObject createWaterHeater_HeatPump_WrappedCondenserIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WaterHeater:HeatPump:WrappedCondenser,\n";
    ss << "\\min-fields 31\n";
    ss << "\\memo This object models an air-source heat pump for water heating where the heating coil is wrapped around\n";
    ss << "\\memo the tank, which is typical of residential HPWHs.\n";
    ss << "\\memo For pumped condenser HPWHs, see WaterHeater:HeatPump:PumpedCondenser.\n";
    ss << "\\memo WaterHeater:HeatPump:WrappedCondenser is a compound object that references other component objects -\n";
    ss << "\\memo Coil:WaterHeating:AirToWaterHeatPump:Pumped, Fan:OnOff, WaterHeater:Mixed\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note Unique name for this instance of a heat pump water heater.\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values of 0 denote the heat pump compressor is off and the parasitic electric\n";
    ss << "\\note energy is also off.\n";
    ss << "A3,  \\field Compressor Setpoint Temperature Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defines the cut-out temperature where the heat pump compressor turns off.\n";
    ss << "\\note The heat pump compressor setpoint temperature should always be greater\n";
    ss << "\\note than the water tank's heater (element or burner) setpoint temperature.\n";
    ss << "N1 , \\field Dead Band Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 20\n";
    ss << "\\default 5.0\n";
    ss << "\\note Setpoint temperature minus the dead band temperature difference defines\n";
    ss << "\\note the cut-in temperature where the heat pump compressor turns on.\n";
    ss << "\\note The water tank's heater (element or burner) setpoint temperature\n";
    ss << "\\note should always be less than the heat pump compressor cut-in temperature.\n";
    ss << "N2,  \\field Condenser Bottom Location\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note Distance from the bottom of the tank to the bottom of the wrapped condenser.\n";
    ss << "N3,  \\field Condenser Top Location\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0\n";
    ss << "\\note Distance from the bottom of the tank to the top of the wrapped condenser.\n";
    ss << "N4 , \\field Evaporator Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Actual air flow rate across the heat pump's air coil (evaporator).\n";
    ss << "\\note If autocalculated, the air flow rate is set equal to 5.035E-5 m3/s/W times\n";
    ss << "\\note the rated heating capacity of the heat pump's DX coil.\n";
    ss << "A4 , \\field Inlet Air Configuration\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Schedule\n";
    ss << "\\key ZoneAirOnly\n";
    ss << "\\key OutdoorAirOnly\n";
    ss << "\\key ZoneAndOutdoorAir\n";
    ss << "\\note Defines the configuration of the airflow path through the air coil and fan section.\n";
    ss << "A5 , \\field Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Zone air exhaust node name if Inlet Air Configuration is ZoneAirOnly or\n";
    ss << "\\note ZoneAndOutdoorAir.\n";
    ss << "\\note Simply a unique Node Name if Inlet Air Configuration is Schedule.\n";
    ss << "\\note Otherwise, leave field blank.\n";
    ss << "A6 , \\field Air Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Zone Air Inlet Node Name if Inlet Air Configuration is ZoneAirOnly or\n";
    ss << "\\note ZoneAndOutdoorAir.\n";
    ss << "\\note Simply a unique Node Name if Inlet Air Configuration is Schedule.\n";
    ss << "\\note Otherwise, leave field blank.\n";
    ss << "A7 , \\field Outdoor Air Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Outdoor air node name if inlet air configuration is ZoneAndOutdoorAir\n";
    ss << "\\note or OutdoorAirOnly, otherwise leave field blank.\n";
    ss << "A8 , \\field Exhaust Air Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Simply a unique Node Name if Inlet Air Configuration is ZoneAndOutdoorAir\n";
    ss << "\\note or OutdoorAirOnly, otherwise leave field blank.\n";
    ss << "A9 , \\field Inlet Air Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Used only if Inlet Air Configuration is Schedule, otherwise leave blank.\n";
    ss << "\\note Schedule values should be degrees C.\n";
    ss << "A10, \\field Inlet Air Humidity Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Used only if Inlet Air Configuration is Schedule, otherwise leave blank.\n";
    ss << "\\note Schedule values are entered as a fraction (e.g. 0.5 is equal to 50%RH)\n";
    ss << "A11, \\field Inlet Air Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note Used only if Inlet Air Configuration is ZoneAirOnly or ZoneAndOutdoorAir.\n";
    ss << "\\note Otherwise, leave field blank.\n";
    ss << "A12, \\field Tank Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key WaterHeater:Stratified\n";
    ss << "\\default WaterHeater:Stratified\n";
    ss << "\\note Specify the type of water heater tank used by this heat pump water heater.\n";
    ss << "A13, \\field Tank Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterHeaterStratifiedNames\n";
    ss << "\\note Needs to match the name used in the corresponding Water Heater object.\n";
    ss << "\\note Must be a WaterHeater:Stratified tank.\n";
    ss << "A14, \\field Tank Use Side Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Used only when the heat pump water heater is connected to a plant loop,\n";
    ss << "\\note otherwise leave blank. Needs to match the name used in the corresponding\n";
    ss << "\\note Water Heater object when connected to a plant loop.\n";
    ss << "A15, \\field Tank Use Side Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Used only when the heat pump water heater is connected to a plant loop,\n";
    ss << "\\note otherwise leave blank. Needs to match the name used in the corresponding\n";
    ss << "\\note Water Heater object when connected to a plant loop.\n";
    ss << "A16, \\field DX Coil Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Coil:WaterHeating:AirToWaterHeatPump:Wrapped\n";
    ss << "\\default Coil:WaterHeating:AirToWaterHeatPump:Wrapped\n";
    ss << "\\note Specify the type of DX coil used by this heat pump water heater. The only\n";
    ss << "\\note valid choice is Coil:WaterHeating:AirToWaterHeatPump:Wrapped\n";
    ss << "A17, \\field DX Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatPumpWaterHeaterDXCoilsWrapped\n";
    ss << "\\note Must match the name used in the corresponding Coil:WaterHeating:AirToWaterHeatPump:Wrapped object.\n";
    ss << "N5 , \\field Minimum Inlet Air Temperature for Compressor Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -5\n";
    ss << "\\default 10\n";
    ss << "\\note Heat pump compressor will not operate when the inlet air dry-bulb temperature\n";
    ss << "\\note is below this value.\n";
    ss << "N6 , \\field Maximum Inlet Air Temperature for Compressor Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 48.88888888889\n";
    ss << "\\minimum 26\n";
    ss << "\\maximum 94\n";
    ss << "\\note Heat pump compressor will not operate when the inlet air dry-bulb temperature\n";
    ss << "\\note is above this value.\n";
    ss << "A18, \\field Compressor Location\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Schedule\n";
    ss << "\\key Zone\n";
    ss << "\\key Outdoors\n";
    ss << "\\note If Zone is selected, Inlet Air Configuration must be ZoneAirOnly or\n";
    ss << "\\note ZoneAndOutdoorAir. If Schedule is selected, then you must provide a\n";
    ss << "\\note Compressor Ambient Temperature Schedule Name below.\n";
    ss << "A19, \\field Compressor Ambient Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Used only if Compressor Location is Schedule, otherwise leave field blank.\n";
    ss << "A20, \\field Fan Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\default Fan:OnOff\n";
    ss << "\\note Specify the type of fan used by this heat pump water heater. The only\n";
    ss << "\\note valid choice is Fan:OnOff.\n";
    ss << "A21, \\field Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansOnOff\n";
    ss << "\\note Needs to match the name used in the corresponding Fan:OnOff object.\n";
    ss << "A22, \\field Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default DrawThrough\n";
    ss << "\\note BlowThrough means the fan is located before the air coil (upstream).\n";
    ss << "\\note DrawThrough means the fan is located after the air coil (downstream).\n";
    ss << "N7 , \\field On Cycle Parasitic Electric Load\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Parasitic electric power consumed when the heat pump compressor operates.\n";
    ss << "\\note Does not contribute to water heating but can impact the zone air heat balance.\n";
    ss << "N8 , \\field Off Cycle Parasitic Electric Load\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Parasitic electric power consumed when the heat pump compressor is off.\n";
    ss << "\\note Does not contribute to water heating but can impact the zone air heat balance.\n";
    ss << "\\note Off-cycle parasitic power is 0 when the availability schedule is 0.\n";
    ss << "A23, \\field Parasitic Heat Rejection Location\n";
    ss << "\\type choice\n";
    ss << "\\key Zone\n";
    ss << "\\key Outdoors\n";
    ss << "\\default Outdoors\n";
    ss << "\\note This field determines if the parasitic electric load impacts the zone air\n";
    ss << "\\note heat balance. If Zone is selected, Inlet Air Configuration must be\n";
    ss << "\\note ZoneAirOnly or ZoneAndOutdoorAir.\n";
    ss << "A24, \\field Inlet Air Mixer Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Required only if Inlet Air Configuration is ZoneAndOutdoorAir, otherwise\n";
    ss << "\\note leave field blank.\n";
    ss << "A25, \\field Outlet Air Splitter Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Required only if Inlet Air Configuration is ZoneAndOutdoorAir, otherwise\n";
    ss << "\\note leave field blank.\n";
    ss << "A26, \\field Inlet Air Mixer Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Required only if Inlet Air Configuration is ZoneAndOutdoorAir, otherwise\n";
    ss << "\\note leave field blank. Schedule values define whether the heat pump draws its\n";
    ss << "\\note inlet air from the zone, outdoors or a combination of zone and outdoor air.\n";
    ss << "\\note A schedule value of 0 denotes inlet air is drawn only from the zone.\n";
    ss << "\\note A schedule value of 1 denotes inlet air is drawn only from outdoors.\n";
    ss << "\\note Schedule values between 0 and 1 denote a mixture of zone and outdoor air\n";
    ss << "\\note proportional to the schedule value.\n";
    ss << "A27, \\field Tank Element Control Logic\n";
    ss << "\\type choice\n";
    ss << "\\key MutuallyExlcusive\n";
    ss << "\\key Simultaneous\n";
    ss << "\\default Simultaneous\n";
    ss << "\\note MutuallyExclusive means that once the tank heating element is active the\n";
    ss << "\\note heat pump is shut down until setpoint is reached.\n";
    ss << "\\note Simultaneous (default) means that both the tank heating element and\n";
    ss << "\\note heat pump are used at the same time recover the tank temperature.\n";
    ss << "N9,  \\field Control Sensor 1 Height In Stratified Tank\n";
    ss << "\\note Used to indicate height of control sensor if Tank Object Type is WaterHeater:Stratified\n";
    ss << "\\note If left blank, it will default to the height of Heater1\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "N10, \\field Control Sensor 1 Weight\n";
    ss << "\\note Weight to give Control Sensor 1 temperature\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "N11; \\field Control Sensor 2 Height In Stratified Tank\n";
    ss << "\\note Used to indicate height of control sensor if Tank Object Type is WaterHeater:Stratified\n";
    ss << "\\note If left blank, it will default to the height of Heater2\n";
    ss << "\\note The weight of this control sensor will be 1 - (wt. of control sensor 1)\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";

    IddObjectType objType(IddObjectType::WaterHeater_HeatPump_WrappedCondenser);
    OptionalIddObject oObj = IddObject::load("WaterHeater:HeatPump:WrappedCondenser",
                                             "Water Heaters and Thermal Storage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WaterHeater_HeatPump_WrappedCondenser);
  return object;
}

IddObject createThermalStorage_Ice_SimpleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ThermalStorage:Ice:Simple,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo This ice storage model is a simplified model\n";
    ss << "\\memo It requires a setpoint placed on the Chilled Water Side Outlet Node\n";
    ss << "\\memo It should be placed in the chilled water supply side outlet branch\n";
    ss << "\\memo followed by a pipe.\n";
    ss << "\\memo Use the PlantEquipmentOperation:ComponentSetpoint plant operation scheme.\n";
    ss << "A1, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference IceThermalStorageEquipment\n";
    ss << "A2, \\field Ice Storage Type\n";
    ss << "\\note IceOnCoilInternal = Ice-on-Coil, internal melt\n";
    ss << "\\note IceOnCoilExternal = Ice-on-Coil, external melt\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key IceOnCoilInternal\n";
    ss << "\\key IceOnCoilExternal\n";
    ss << "N1, \\field Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units GJ\n";
    ss << "\\ip-units ton-hrs\n";
    ss << "A3, \\field Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A4; \\field Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::ThermalStorage_Ice_Simple);
    OptionalIddObject oObj = IddObject::load("ThermalStorage:Ice:Simple",
                                             "Water Heaters and Thermal Storage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ThermalStorage_Ice_Simple);
  return object;
}

IddObject createThermalStorage_Ice_DetailedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ThermalStorage:Ice:Detailed,\n";
    ss << "\\min-fields 14\n";
    ss << "\\memo This input syntax is intended to describe a thermal storage system that\n";
    ss << "\\memo includes smaller containers filled with water that are placed in a larger\n";
    ss << "\\memo tank or series of tanks.\n";
    ss << "\\memo The model uses polynomial equations to describe the system performance.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference IceThermalStorageEquipment\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Capacity\n";
    ss << "\\note This includes only the latent storage capacity\n";
    ss << "\\units GJ\n";
    ss << "\\required-field\n";
    ss << "A3 , \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Discharging Curve Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key QuadraticLinear\n";
    ss << "\\key CubicLinear\n";
    ss << "A6 , \\field Discharging Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticLinearCurves\n";
    ss << "\\object-list CubicLinearCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A7 , \\field Charging Curve Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key QuadraticLinear\n";
    ss << "\\key CubicLinear\n";
    ss << "A8 , \\field Charging Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticLinearCurves\n";
    ss << "\\object-list CubicLinearCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "N2 , \\field Timestep of the Curve Data\n";
    ss << "\\units hr\n";
    ss << "N3 , \\field Parasitic Electric Load During Discharging\n";
    ss << "\\units dimensionless\n";
    ss << "N4 , \\field Parasitic Electric Load During Charging\n";
    ss << "\\units dimensionless\n";
    ss << "N5 , \\field Tank Loss Coefficient\n";
    ss << "\\note This is the fraction the total storage capacity that is lost or melts\n";
    ss << "\\note each hour\n";
    ss << "\\units dimensionless\n";
    ss << "N6 , \\field Freezing Temperature of Storage Medium\n";
    ss << "\\note This temperature is typically 0C for water.\n";
    ss << "\\note Simply changing this temperature without adjusting the performance\n";
    ss << "\\note parameters input above is inappropriate and not advised.\n";
    ss << "\\units C\n";
    ss << "\\default 0.0\n";
    ss << "A9 ; \\field Thaw Process Indicator\n";
    ss << "\\note This field determines whether the system uses internal or external melt\n";
    ss << "\\note during discharging.  This will then have an impact on charging performance.\n";
    ss << "\\type choice\n";
    ss << "\\key InsideMelt\n";
    ss << "\\key OutsideMelt\n";
    ss << "\\default OutsideMelt\n";

    IddObjectType objType(IddObjectType::ThermalStorage_Ice_Detailed);
    OptionalIddObject oObj = IddObject::load("ThermalStorage:Ice:Detailed",
                                             "Water Heaters and Thermal Storage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ThermalStorage_Ice_Detailed);
  return object;
}

IddObject createThermalStorage_ChilledWater_MixedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ThermalStorage:ChilledWater:Mixed,\n";
    ss << "\\memo Chilled water storage with a well-mixed, single-node tank. The chilled water is\n";
    ss << "\\memo \"used\" by drawing from the \"Use Side\" of the water tank.  The tank is indirectly\n";
    ss << "\\memo charged by circulating cold water through the \"Source Side\" of the water tank.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "N1 , \\field Tank Volume\n";
    ss << "\\type real\n";
    ss << "\\units m3\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.1\n";
    ss << "\\ip-units gal\n";
    ss << "A2 , \\field Setpoint Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N2 , \\field Deadband Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.5\n";
    ss << "N3 , \\field Minimum Temperature Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N4 , \\field Nominal Cooling Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "A3 , \\field Ambient Temperature Indicator\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Schedule\n";
    ss << "\\key Zone\n";
    ss << "\\key Outdoors\n";
    ss << "A4 , \\field Ambient Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5 , \\field Ambient Temperature Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A6 , \\field Ambient Temperature Outdoor Air Node Name\n";
    ss << "\\type node\n";
    ss << "\\note required when field Ambient Temperature Indicator=Outdoors\n";
    ss << "N5 , \\field Heat Gain Coefficient from Ambient Temperature\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "A7 , \\field Use Side Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A8 , \\field Use Side Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N6 , \\field Use Side Heat Transfer Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A9 , \\field Use Side Availability Schedule Name\n";
    ss << "\\note Availability schedule name for use side. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N7 , \\field Use Side Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "A10, \\field Source Side Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A11, \\field Source Side Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N8, \\field Source Side Heat Transfer Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A12, \\field Source Side Availability Schedule Name\n";
    ss << "\\note Availability schedule name for source side. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N9 , \\field Source Side Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "N10; \\field Tank Recovery Time\n";
    ss << "\\type real\n";
    ss << "\\default 4.0\n";
    ss << "\\note Parameter for autosizing design flow rates for indirectly cooled water tanks\n";
    ss << "\\note time required to lower temperature of entire tank from 14.4C to 9.0C\n";
    ss << "\\units hr\n";
    ss << "\\minimum> 0.0\n";

    IddObjectType objType(IddObjectType::ThermalStorage_ChilledWater_Mixed);
    OptionalIddObject oObj = IddObject::load("ThermalStorage:ChilledWater:Mixed",
                                             "Water Heaters and Thermal Storage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ThermalStorage_ChilledWater_Mixed);
  return object;
}

IddObject createThermalStorage_ChilledWater_StratifiedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ThermalStorage:ChilledWater:Stratified,\n";
    ss << "\\memo Chilled water storage with a stratified, multi-node tank. The chilled water is\n";
    ss << "\\memo \"used\" by drawing from the \"Use Side\" of the water tank.  The tank is indirectly\n";
    ss << "\\memo charged by circulating cold water through the \"Source Side\" of the water tank.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "N1 , \\field Tank Volume\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units gal\n";
    ss << "N2 , \\field Tank Height\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Height is measured in the axial direction for horizontal cylinders\n";
    ss << "A2 , \\field Tank Shape\n";
    ss << "\\type choice\n";
    ss << "\\key VerticalCylinder\n";
    ss << "\\key HorizontalCylinder\n";
    ss << "\\key Other\n";
    ss << "\\default VerticalCylinder\n";
    ss << "N3 , \\field Tank Perimeter\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Only used if Tank Shape is Other\n";
    ss << "A3 , \\field Setpoint Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N4 , \\field Deadband Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N5,  \\field Temperature Sensor Height\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "N6 , \\field Minimum Temperature Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N7 , \\field Nominal Cooling Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "A4 , \\field Ambient Temperature Indicator\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Schedule\n";
    ss << "\\key Zone\n";
    ss << "\\key Outdoors\n";
    ss << "A5 , \\field Ambient Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6 , \\field Ambient Temperature Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A7 , \\field Ambient Temperature Outdoor Air Node Name\n";
    ss << "\\type node\n";
    ss << "\\note required for Ambient Temperature Indicator=Outdoors\n";
    ss << "N8, \\field Uniform Skin Loss Coefficient per Unit Area to Ambient Temperature\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum 0.0\n";
    ss << "A8 , \\field Use Side Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A9, \\field Use Side Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N9 , \\field Use Side Heat Transfer Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note The use side effectiveness in the stratified tank model is a simplified analogy of\n";
    ss << "\\note a heat exchanger's effectiveness. This effectiveness is equal to the fraction of\n";
    ss << "\\note use mass flow rate that directly mixes with the tank fluid. And one minus the\n";
    ss << "\\note effectiveness is the fraction that bypasses the tank. The use side mass flow rate\n";
    ss << "\\note that bypasses the tank is mixed with the fluid or water leaving the stratified tank.\n";
    ss << "A10, \\field Use Side Availability Schedule Name\n";
    ss << "\\note Availability schedule name for use side. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N10 , \\field Use Side Inlet Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "\\note Defaults to top of tank\n";
    ss << "N11, \\field Use Side Outlet Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Defaults to bottom of tank\n";
    ss << "N12, \\field Use Side Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "A11, \\field Source Side Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A12, \\field Source Side Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N13, \\field Source Side Heat Transfer Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note The source side effectiveness in the stratified tank model is a simplified analogy of\n";
    ss << "\\note a heat exchanger's effectiveness. This effectiveness is equal to the fraction of\n";
    ss << "\\note source mass flow rate that directly mixes with the tank fluid. And one minus the\n";
    ss << "\\note effectiveness is the fraction that bypasses the tank. The source side mass flow rate\n";
    ss << "\\note that bypasses the tank is mixed with the fluid or water leaving the stratified tank.\n";
    ss << "A13, \\field Source Side Availability Schedule Name\n";
    ss << "\\note Availability schedule name for use side. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N14, \\field Source Side Inlet Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Defaults to bottom of tank\n";
    ss << "N15, \\field Source Side Outlet Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "\\note Defaults to top of tank\n";
    ss << "N16, \\field Source Side Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "N17, \\field Tank Recovery Time\n";
    ss << "\\type real\n";
    ss << "\\default 4.0\n";
    ss << "\\note Parameter for autosizing design flow rates for indirectly cooled water tanks\n";
    ss << "\\note time required to lower temperature of entire tank from 14.4C to 9.0C\n";
    ss << "\\units hr\n";
    ss << "\\minimum> 0.0\n";
    ss << "A14, \\field Inlet Mode\n";
    ss << "\\type choice\n";
    ss << "\\key Fixed\n";
    ss << "\\key Seeking\n";
    ss << "\\default Fixed\n";
    ss << "N18, \\field Number of Nodes\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 10\n";
    ss << "\\default 1\n";
    ss << "N19, \\field Additional Destratification Conductivity\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N20, \\field Node 1 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N21, \\field Node 2 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N22, \\field Node 3 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N23, \\field Node 4 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N24, \\field Node 5 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N25, \\field Node 6 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N26, \\field Node 7 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N27, \\field Node 8 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N28, \\field Node 9 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "N29; \\field Node 10 Additional Loss Coefficient\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::ThermalStorage_ChilledWater_Stratified);
    OptionalIddObject oObj = IddObject::load("ThermalStorage:ChilledWater:Stratified",
                                             "Water Heaters and Thermal Storage",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ThermalStorage_ChilledWater_Stratified);
  return object;
}

IddObject createPlantLoopIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PlantLoop,\n";
    ss << "\\memo Defines a central plant loop.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference PlantLoops\n";
    ss << "A2 , \\field Fluid Type\n";
    ss << "\\type choice\n";
    ss << "\\key Water\n";
    ss << "\\key Steam\n";
    ss << "\\key UserDefinedFluidType\n";
    ss << "\\default Water\n";
    ss << "A3 , \\field User Defined Fluid Type\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FluidAndGlycolNames\n";
    ss << "\\note This field is only required when Fluid Type is UserDefinedFluidType\n";
    ss << "A4 , \\field Plant Equipment Operation Scheme Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PlantOperationSchemes\n";
    ss << "A5 , \\field Loop Temperature Setpoint Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Maximum Loop Temperature\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "N2 , \\field Minimum Loop Temperature\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "N3 , \\field Maximum Loop Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N4 , \\field Minimum Loop Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N5 , \\field Plant Loop Volume\n";
    ss << "\\type real\n";
    ss << "\\units m3\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default Autocalculate\n";
    ss << "\\ip-units gal\n";
    ss << "A6,  \\field Plant Side Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7,  \\field Plant Side Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A8,  \\field Plant Side Branch List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BranchLists\n";
    ss << "A9,  \\field Plant Side Connector List Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectorLists\n";
    ss << "A10, \\field Demand Side Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A11, \\field Demand Side Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A12, \\field Demand Side Branch List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BranchLists\n";
    ss << "A13, \\field Demand Side Connector List Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectorLists\n";
    ss << "A14, \\field Load Distribution Scheme\n";
    ss << "\\type choice\n";
    ss << "\\key Optimal\n";
    ss << "\\key SequentialLoad\n";
    ss << "\\key UniformLoad\n";
    ss << "\\key UniformPLR\n";
    ss << "\\key SequentialUniformPLR\n";
    ss << "\\default SequentialLoad\n";
    ss << "A15, \\field Availability Manager List Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";
    ss << "A16, \\field Plant Loop Demand Calculation Scheme\n";
    ss << "\\type choice\n";
    ss << "\\key SingleSetpoint\n";
    ss << "\\key DualSetpointDeadband\n";
    ss << "\\default SingleSetpoint\n";
    ss << "A17,  \\field Common Pipe Simulation\n";
    ss << "\\note Specifies a primary-secondary loop configuration. The plant side is the\n";
    ss << "\\note primary loop, and the demand side is the secondary loop.\n";
    ss << "\\note A secondary supply pump is required on the demand side.\n";
    ss << "\\note None = Primary-only, no secondary simulation\n";
    ss << "\\note CommonPipe = Primary-secondary with no temperature control at primary-secondary interface\n";
    ss << "\\note TwoWayCommonPipe = Primary-secondary with control of secondary supply temperature or\n";
    ss << "\\note primary return temperature (requires a setpoint be placed on the\n";
    ss << "\\note plant side or demand side inlet node).\n";
    ss << "\\type choice\n";
    ss << "\\key CommonPipe\n";
    ss << "\\key TwoWayCommonPipe\n";
    ss << "\\key None\n";
    ss << "\\default None\n";
    ss << "A18;  \\field Pressure Simulation Type\n";
    ss << "\\type choice\n";
    ss << "\\key PumpPowerCorrection\n";
    ss << "\\key LoopFlowCorrection\n";
    ss << "\\key None\n";
    ss << "\\default None\n";

    IddObjectType objType(IddObjectType::PlantLoop);
    OptionalIddObject oObj = IddObject::load("PlantLoop",
                                             "Plant-Condenser Loops",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PlantLoop);
  return object;
}

IddObject createCondenserLoopIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "CondenserLoop,\n";
    ss << "\\memo Defines a central plant condenser loop. CondenserLoop and PlantLoop are nearly\n";
    ss << "\\memo identical except some components and operation schemes are applicable to only one\n";
    ss << "\\memo loop type or the other.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference PlantLoops\n";
    ss << "A2 , \\field Fluid Type\n";
    ss << "\\type choice\n";
    ss << "\\key Water\n";
    ss << "\\key UserDefinedFluidType\n";
    ss << "\\default Water\n";
    ss << "A3 , \\field User Defined Fluid Type\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FluidAndGlycolNames\n";
    ss << "\\note This field is only required when Fluid Type is UserDefinedFluidType\n";
    ss << "A4 , \\field Condenser Equipment Operation Scheme Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CondenserOperationSchemes\n";
    ss << "A5 , \\field Condenser Loop Temperature Setpoint Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Maximum Loop Temperature\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "N2 , \\field Minimum Loop Temperature\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "N3 , \\field Maximum Loop Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N4 , \\field Minimum Loop Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N5,  \\field Condenser Loop Volume\n";
    ss << "\\type real\n";
    ss << "\\units m3\n";
    ss << "\\autocalculatable\n";
    ss << "\\default Autocalculate\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units gal\n";
    ss << "A6,  \\field Condenser Side Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7,  \\field Condenser Side Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A8,  \\field Condenser Side Branch List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BranchLists\n";
    ss << "A9,  \\field Condenser Side Connector List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectorLists\n";
    ss << "A10, \\field Demand Side Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A11, \\field Demand Side Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A12, \\field Condenser Demand Side Branch List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BranchLists\n";
    ss << "A13, \\field Condenser Demand Side Connector List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectorLists\n";
    ss << "A14, \\field Load Distribution Scheme\n";
    ss << "\\type choice\n";
    ss << "\\key Optimal\n";
    ss << "\\key SequentialLoad\n";
    ss << "\\key UniformLoad\n";
    ss << "\\key UniformPLR\n";
    ss << "\\key SequentialUniformPLR\n";
    ss << "\\default SequentialLoad\n";
    ss << "A15; \\field Pressure Simulation Type\n";
    ss << "\\type choice\n";
    ss << "\\key PumpPowerCorrection\n";
    ss << "\\key LoopFlowCorrection\n";
    ss << "\\key None\n";
    ss << "\\default None\n";

    IddObjectType objType(IddObjectType::CondenserLoop);
    OptionalIddObject oObj = IddObject::load("CondenserLoop",
                                             "Plant-Condenser Loops",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::CondenserLoop);
  return object;
}

IddObject createPlantEquipmentListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PlantEquipmentList,\n";
    ss << "\\memo List plant equipment in order of operating priority, 1st in list will be used 1st, etc\n";
    ss << "\\memo Use only plant equipment in this list.\n";
    ss << "\\memo If no equipment object types and equipment names are specified, then the corresponding\n";
    ss << "\\memo PlantEquipmentOperation:* object will assume all available plant equipment for the loop\n";
    ss << "\\memo should be OFF (not operate) within the specified lower/upper limit.\n";
    ss << "\\extensible:2\n";
    ss << "\\min-fields 1\n";
    ss << "\\max-fields 21\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference PlantAndCondenserEquipmentLists\n";
    ss << "A2 , \\field Equipment 1 Object Type\n";
    ss << "\\begin-extensible\n";
    ss << "A3 ; \\field Equipment 1 Name\n";

    IddObjectType objType(IddObjectType::PlantEquipmentList);
    OptionalIddObject oObj = IddObject::load("PlantEquipmentList",
                                             "Plant-Condenser Control",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PlantEquipmentList);
  return object;
}

IddObject createCondenserEquipmentListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "CondenserEquipmentList,\n";
    ss << "\\memo List condenser equipment in order of operating priority, 1st in list will be used 1st, etc\n";
    ss << "\\memo Use only condenser equipment in this list.\n";
    ss << "\\memo If no equipment object types and equipment names are specified, then the corresponding\n";
    ss << "\\memo PlantEquipmentOperation:* object will assume all available condenser equipment for the loop\n";
    ss << "\\memo should be OFF (not operate) within the specified lower/upper limit.\n";
    ss << "\\extensible:2\n";
    ss << "\\min-fields 1\n";
    ss << "\\max-fields 21\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference PlantAndCondenserEquipmentLists\n";
    ss << "\\reference CondenserEquipmentLists\n";
    ss << "A2 , \\field Equipment 1 Object Type\n";
    ss << "\\begin-extensible\n";
    ss << "A3 ; \\field Equipment 1 Name\n";

    IddObjectType objType(IddObjectType::CondenserEquipmentList);
    OptionalIddObject oObj = IddObject::load("CondenserEquipmentList",
                                             "Plant-Condenser Control",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::CondenserEquipmentList);
  return object;
}

IddObject createPlantEquipmentOperation_UncontrolledIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PlantEquipmentOperation:Uncontrolled,\n";
    ss << "\\memo Plant equipment operation scheme for uncontrolled operation. Specifies a group of\n";
    ss << "\\memo equipment that runs if the loop is active, unless turned off by the loop flow resolver\n";
    ss << "\\memo to maintain continuity in the fluid loop.\n";
    ss << "\\min-fields 2\n";
    ss << "A1 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "A2 ;\\field Equipment List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PlantAndCondenserEquipmentLists\n";

    IddObjectType objType(IddObjectType::PlantEquipmentOperation_Uncontrolled);
    OptionalIddObject oObj = IddObject::load("PlantEquipmentOperation:Uncontrolled",
                                             "Plant-Condenser Control",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PlantEquipmentOperation_Uncontrolled);
  return object;
}

IddObject createPlantEquipmentOperation_CoolingLoadIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PlantEquipmentOperation:CoolingLoad,\n";
    ss << "\\memo Plant equipment operation scheme for cooling load range operation. Specifies one or\n";
    ss << "\\memo more groups of equipment which are available to operate for successive cooling load\n";
    ss << "\\memo ranges.\n";
    ss << "\\extensible:3\n";
    ss << "\\min-fields 4\n";
    ss << "\\max-fields 31\n";
    ss << "A1 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "N1 ,\\field Load Range 1 Lower Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\begin-extensible\n";
    ss << "N2 ,\\field Load Range 1 Upper Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "A2 ;\\field Range 1 Equipment List Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PlantAndCondenserEquipmentLists\n";

    IddObjectType objType(IddObjectType::PlantEquipmentOperation_CoolingLoad);
    OptionalIddObject oObj = IddObject::load("PlantEquipmentOperation:CoolingLoad",
                                             "Plant-Condenser Control",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PlantEquipmentOperation_CoolingLoad);
  return object;
}

IddObject createPlantEquipmentOperation_HeatingLoadIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PlantEquipmentOperation:HeatingLoad,\n";
    ss << "\\memo Plant equipment operation scheme for heating load range operation. Specifies one or\n";
    ss << "\\memo more groups of equipment which are available to operate for successive heating load\n";
    ss << "\\memo ranges.\n";
    ss << "\\extensible:3\n";
    ss << "\\min-fields 4\n";
    ss << "\\max-fields 31\n";
    ss << "A1 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "N1 ,\\field Load Range 1 Lower Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\begin-extensible\n";
    ss << "N2 ,\\field Load Range 1 Upper Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "A2 ;\\field Range 1 Equipment List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PlantAndCondenserEquipmentLists\n";

    IddObjectType objType(IddObjectType::PlantEquipmentOperation_HeatingLoad);
    OptionalIddObject oObj = IddObject::load("PlantEquipmentOperation:HeatingLoad",
                                             "Plant-Condenser Control",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PlantEquipmentOperation_HeatingLoad);
  return object;
}

IddObject createPlantEquipmentOperation_OutdoorDryBulbIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PlantEquipmentOperation:OutdoorDryBulb,\n";
    ss << "\\memo Plant equipment operation scheme for outdoor dry-bulb temperature range operation.\n";
    ss << "\\memo Specifies one or more groups of equipment which are available to operate for\n";
    ss << "\\memo successive outdoor dry-bulb temperature ranges.\n";
    ss << "\\extensible:3\n";
    ss << "\\min-fields 4\n";
    ss << "\\max-fields 31\n";
    ss << "A1 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "N1 ,\\field Dry-Bulb Temperature Range 1 Lower Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -70\n";
    ss << "\\maximum 70\n";
    ss << "\\begin-extensible\n";
    ss << "N2 ,\\field Dry-Bulb Temperature Range 1 Upper Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -70\n";
    ss << "\\maximum 70\n";
    ss << "A2 ;\\field Range 1 Equipment List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PlantAndCondenserEquipmentLists\n";

    IddObjectType objType(IddObjectType::PlantEquipmentOperation_OutdoorDryBulb);
    OptionalIddObject oObj = IddObject::load("PlantEquipmentOperation:OutdoorDryBulb",
                                             "Plant-Condenser Control",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PlantEquipmentOperation_OutdoorDryBulb);
  return object;
}

IddObject createPlantEquipmentOperation_OutdoorWetBulbIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PlantEquipmentOperation:OutdoorWetBulb,\n";
    ss << "\\memo Plant equipment operation scheme for outdoor wet-bulb temperature range operation.\n";
    ss << "\\memo Specifies one or more groups of equipment which are available to operate for\n";
    ss << "\\memo successive outdoor wet-bulb temperature ranges.\n";
    ss << "\\extensible:3\n";
    ss << "\\min-fields 4\n";
    ss << "\\max-fields 31\n";
    ss << "A1 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "N1 ,\\field Wet-Bulb Temperature Range 1 Lower Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -70\n";
    ss << "\\maximum 70\n";
    ss << "\\begin-extensible\n";
    ss << "N2 ,\\field Wet-Bulb Temperature Range 1 Upper Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -70\n";
    ss << "\\maximum 70\n";
    ss << "A2 ;\\field Range 1 Equipment List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PlantAndCondenserEquipmentLists\n";

    IddObjectType objType(IddObjectType::PlantEquipmentOperation_OutdoorWetBulb);
    OptionalIddObject oObj = IddObject::load("PlantEquipmentOperation:OutdoorWetBulb",
                                             "Plant-Condenser Control",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PlantEquipmentOperation_OutdoorWetBulb);
  return object;
}

IddObject createPlantEquipmentOperation_OutdoorRelativeHumidityIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PlantEquipmentOperation:OutdoorRelativeHumidity,\n";
    ss << "\\memo Plant equipment operation scheme for outdoor relative humidity range operation.\n";
    ss << "\\memo Specifies one or more groups of equipment which are available to operate for\n";
    ss << "\\memo successive outdoor relative humidity ranges.\n";
    ss << "\\extensible:3\n";
    ss << "\\min-fields 4\n";
    ss << "\\max-fields 31\n";
    ss << "A1 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "N1 ,\\field Relative Humidity Range 1 Lower Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\begin-extensible\n";
    ss << "N2 ,\\field Relative Humidity Range 1 Upper Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "A2 ;\\field Range 1 Equipment List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PlantAndCondenserEquipmentLists\n";

    IddObjectType objType(IddObjectType::PlantEquipmentOperation_OutdoorRelativeHumidity);
    OptionalIddObject oObj = IddObject::load("PlantEquipmentOperation:OutdoorRelativeHumidity",
                                             "Plant-Condenser Control",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PlantEquipmentOperation_OutdoorRelativeHumidity);
  return object;
}

IddObject createPlantEquipmentOperation_OutdoorDewpointIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PlantEquipmentOperation:OutdoorDewpoint,\n";
    ss << "\\memo Plant equipment operation scheme for outdoor dewpoint temperature range operation.\n";
    ss << "\\memo Specifies one or more groups of equipment which are available to operate for\n";
    ss << "\\memo successive outdoor dewpoint temperature ranges.\n";
    ss << "\\extensible:3\n";
    ss << "\\min-fields 4\n";
    ss << "\\max-fields 31\n";
    ss << "A1 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "N1 ,\\field Dewpoint Temperature Range 1 Lower Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -70\n";
    ss << "\\maximum 70\n";
    ss << "\\begin-extensible\n";
    ss << "N2 ,\\field Dewpoint Temperature Range 1 Upper Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -70\n";
    ss << "\\maximum 70\n";
    ss << "A2 ;\\field Range 1 Equipment List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PlantAndCondenserEquipmentLists\n";

    IddObjectType objType(IddObjectType::PlantEquipmentOperation_OutdoorDewpoint);
    OptionalIddObject oObj = IddObject::load("PlantEquipmentOperation:OutdoorDewpoint",
                                             "Plant-Condenser Control",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PlantEquipmentOperation_OutdoorDewpoint);
  return object;
}

IddObject createPlantEquipmentOperation_ComponentSetpointIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PlantEquipmentOperation:ComponentSetpoint,\n";
    ss << "\\memo Plant equipment operation scheme for component setpoint operation. Specifies one or\n";
    ss << "\\memo pieces of equipment which are controlled to meet the temperature setpoint at the\n";
    ss << "\\memo component outlet node.\n";
    ss << "\\extensible:6\n";
    ss << "\\min-fields 7\n";
    ss << "\\max-fields 61\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "A2, \\field Equipment 1 Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\begin-extensible\n";
    ss << "A3, \\field Equipment 1 Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A4, \\field Demand Calculation 1 Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5, \\field Setpoint 1 Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1, \\field Component 1 Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "A6; \\field Operation 1 Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Heating\n";
    ss << "\\key Cooling\n";
    ss << "\\key Dual\n";

    IddObjectType objType(IddObjectType::PlantEquipmentOperation_ComponentSetpoint);
    OptionalIddObject oObj = IddObject::load("PlantEquipmentOperation:ComponentSetpoint",
                                             "Plant-Condenser Control",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PlantEquipmentOperation_ComponentSetpoint);
  return object;
}

IddObject createPlantEquipmentOperation_ThermalEnergyStorageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PlantEquipmentOperation:ThermalEnergyStorage,\n";
    ss << "\\memo Plant equipment operation scheme for simpler input to control thermal (ice)\n";
    ss << "\\memo energy storage systems.  It replaces a host of setpoint managers with simple,\n";
    ss << "\\memo single input values.  For more complex controls, use the ComponentSetpoint\n";
    ss << "\\memo scheme.\n";
    ss << "\\min-fields 7\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "A2, \\field On-Peak Schedule\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Charging Availability Schedule\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Non-Charging Chilled Water Temperature\n";
    ss << "\\note Single temperature for chiller outlet when not in cooling season\n";
    ss << "\\note or during on-peak cooling (discharge)\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N2, \\field Charging Chilled Water Temperature\n";
    ss << "\\note Single temperature for chiller outlet when off-peak during cooling\n";
    ss << "\\note season (charging)\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "A4, \\field Component 1 Object Type\n";
    ss << "\\note This field is the type of object and should either be a chiller or some\n";
    ss << "\\note ice storage equipment.\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key ThermalStorage:Ice:Simple\n";
    ss << "\\key ThermalStorage:Ice:Detailed\n";
    ss << "\\key Chiller:Electric:EIR\n";
    ss << "\\key Chiller:Electric:ReformulatedEIR\n";
    ss << "\\key Chiller:Electric\n";
    ss << "\\key Chiller:Absorption:Indirect\n";
    ss << "\\key Chiller:Absorption\n";
    ss << "\\key Chiller:ConstantCOP\n";
    ss << "\\key Chiller:EngineDriven\n";
    ss << "\\key Chiller:CombustionTurbine\n";
    ss << "A5, \\field Component 1 Name\n";
    ss << "\\note This field is the name of either the chiller or ice storage equipment\n";
    ss << "\\note on the loop.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list IceThermalStorageEquipment\n";
    ss << "\\object-list Chillers\n";
    ss << "A6, \\field Component 1 Demand Calculation Node Name\n";
    ss << "\\note This field is the name of the inlet node for the component defined in\n";
    ss << "\\note the two previous input fields.\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A7, \\field Component 1 Setpoint Node Name\n";
    ss << "\\note This field is the name of the outlet node for the component listed above.\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N3, \\field Component 1 Flow Rate\n";
    ss << "\\note This field is the flow rate for the component listed above.\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "A8, \\field Component 1 Operation Type\n";
    ss << "\\note This field is the operation type for the component listed above.  For this\n";
    ss << "\\note plant equipment operation scheme, \"Cooling\" should be selected for chiller\n";
    ss << "\\note equipment while ice storage equipment should be defined as \"Dual\".\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Heating\n";
    ss << "\\key Cooling\n";
    ss << "\\key Dual\n";
    ss << "A9, \\field Component 2 Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key ThermalStorage:Ice:Simple\n";
    ss << "\\key ThermalStorage:Ice:Detailed\n";
    ss << "\\key Chiller:Electric:EIR\n";
    ss << "\\key Chiller:Electric:ReformulatedEIR\n";
    ss << "\\key Chiller:Electric\n";
    ss << "\\key Chiller:Absorption:Indirect\n";
    ss << "\\key Chiller:Absorption\n";
    ss << "\\key Chiller:ConstantCOP\n";
    ss << "\\key Chiller:EngineDriven\n";
    ss << "\\key Chiller:CombustionTurbine\n";
    ss << "A10, \\field Component 2 Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list IceThermalStorageEquipment\n";
    ss << "\\object-list Chillers\n";
    ss << "A11, \\field Component 2 Demand Calculation Node Name\n";
    ss << "\\type node\n";
    ss << "A12, \\field Component 2 Setpoint Node Name\n";
    ss << "\\type node\n";
    ss << "N4,  \\field Component 2 Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "A13, \\field Component 2 Operation Type\n";
    ss << "\\type choice\n";
    ss << "\\key Heating\n";
    ss << "\\key Cooling\n";
    ss << "\\key Dual\n";
    ss << "A14, \\field Component 3 Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key ThermalStorage:Ice:Simple\n";
    ss << "\\key ThermalStorage:Ice:Detailed\n";
    ss << "\\key Chiller:Electric:EIR\n";
    ss << "\\key Chiller:Electric:ReformulatedEIR\n";
    ss << "\\key Chiller:Electric\n";
    ss << "\\key Chiller:Absorption:Indirect\n";
    ss << "\\key Chiller:Absorption\n";
    ss << "\\key Chiller:ConstantCOP\n";
    ss << "\\key Chiller:EngineDriven\n";
    ss << "\\key Chiller:CombustionTurbine\n";
    ss << "A15, \\field Component 3 Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list IceThermalStorageEquipment\n";
    ss << "\\object-list Chillers\n";
    ss << "A16, \\field Component 3 Demand Calculation Node Name\n";
    ss << "\\type node\n";
    ss << "A17, \\field Component 3 Setpoint Node Name\n";
    ss << "\\type node\n";
    ss << "N5,  \\field Component 3 Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "A18, \\field Component 3 Operation Type\n";
    ss << "\\type choice\n";
    ss << "\\key Heating\n";
    ss << "\\key Cooling\n";
    ss << "\\key Dual\n";
    ss << "A19, \\field Component 4 Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key ThermalStorage:Ice:Simple\n";
    ss << "\\key ThermalStorage:Ice:Detailed\n";
    ss << "\\key Chiller:Electric:EIR\n";
    ss << "\\key Chiller:Electric:ReformulatedEIR\n";
    ss << "\\key Chiller:Electric\n";
    ss << "\\key Chiller:Absorption:Indirect\n";
    ss << "\\key Chiller:Absorption\n";
    ss << "\\key Chiller:ConstantCOP\n";
    ss << "\\key Chiller:EngineDriven\n";
    ss << "\\key Chiller:CombustionTurbine\n";
    ss << "A20, \\field Component 4 Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list IceThermalStorageEquipment\n";
    ss << "\\object-list Chillers\n";
    ss << "A21, \\field Component 4 Demand Calculation Node Name\n";
    ss << "\\type node\n";
    ss << "A22, \\field Component 4 Setpoint Node Name\n";
    ss << "\\type node\n";
    ss << "N6,  \\field Component 4 Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "A23, \\field Component 4 Operation Type\n";
    ss << "\\type choice\n";
    ss << "\\key Heating\n";
    ss << "\\key Cooling\n";
    ss << "\\key Dual\n";
    ss << "A24, \\field Component 5 Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key ThermalStorage:Ice:Simple\n";
    ss << "\\key ThermalStorage:Ice:Detailed\n";
    ss << "\\key Chiller:Electric:EIR\n";
    ss << "\\key Chiller:Electric:ReformulatedEIR\n";
    ss << "\\key Chiller:Electric\n";
    ss << "\\key Chiller:Absorption:Indirect\n";
    ss << "\\key Chiller:Absorption\n";
    ss << "\\key Chiller:ConstantCOP\n";
    ss << "\\key Chiller:EngineDriven\n";
    ss << "\\key Chiller:CombustionTurbine\n";
    ss << "A25, \\field Component 5 Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list IceThermalStorageEquipment\n";
    ss << "\\object-list Chillers\n";
    ss << "A26, \\field Component 5 Demand Calculation Node Name\n";
    ss << "\\type node\n";
    ss << "A27, \\field Component 5 Setpoint Node Name\n";
    ss << "\\type node\n";
    ss << "N7,  \\field Component 5 Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "A28, \\field Component 5 Operation Type\n";
    ss << "\\type choice\n";
    ss << "\\key Heating\n";
    ss << "\\key Cooling\n";
    ss << "\\key Dual\n";
    ss << "A29, \\field Component 6 Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key ThermalStorage:Ice:Simple\n";
    ss << "\\key ThermalStorage:Ice:Detailed\n";
    ss << "\\key Chiller:Electric:EIR\n";
    ss << "\\key Chiller:Electric:ReformulatedEIR\n";
    ss << "\\key Chiller:Electric\n";
    ss << "\\key Chiller:Absorption:Indirect\n";
    ss << "\\key Chiller:Absorption\n";
    ss << "\\key Chiller:ConstantCOP\n";
    ss << "\\key Chiller:EngineDriven\n";
    ss << "\\key Chiller:CombustionTurbine\n";
    ss << "A30, \\field Component 6 Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list IceThermalStorageEquipment\n";
    ss << "\\object-list Chillers\n";
    ss << "A31, \\field Component 6 Demand Calculation Node Name\n";
    ss << "\\type node\n";
    ss << "A32, \\field Component 6 Setpoint Node Name\n";
    ss << "\\type node\n";
    ss << "N8,  \\field Component 6 Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "A33, \\field Component 6 Operation Type\n";
    ss << "\\type choice\n";
    ss << "\\key Heating\n";
    ss << "\\key Cooling\n";
    ss << "\\key Dual\n";
    ss << "A34, \\field Component 7 Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key ThermalStorage:Ice:Simple\n";
    ss << "\\key ThermalStorage:Ice:Detailed\n";
    ss << "\\key Chiller:Electric:EIR\n";
    ss << "\\key Chiller:Electric:ReformulatedEIR\n";
    ss << "\\key Chiller:Electric\n";
    ss << "\\key Chiller:Absorption:Indirect\n";
    ss << "\\key Chiller:Absorption\n";
    ss << "\\key Chiller:ConstantCOP\n";
    ss << "\\key Chiller:EngineDriven\n";
    ss << "\\key Chiller:CombustionTurbine\n";
    ss << "A35, \\field Component 7 Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list IceThermalStorageEquipment\n";
    ss << "\\object-list Chillers\n";
    ss << "A36, \\field Component 7 Demand Calculation Node Name\n";
    ss << "\\type node\n";
    ss << "A37, \\field Component 7 Setpoint Node Name\n";
    ss << "\\type node\n";
    ss << "N9,  \\field Component 7 Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "A38, \\field Component 7 Operation Type\n";
    ss << "\\type choice\n";
    ss << "\\key Heating\n";
    ss << "\\key Cooling\n";
    ss << "\\key Dual\n";
    ss << "A39, \\field Component 8 Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key ThermalStorage:Ice:Simple\n";
    ss << "\\key ThermalStorage:Ice:Detailed\n";
    ss << "\\key Chiller:Electric:EIR\n";
    ss << "\\key Chiller:Electric:ReformulatedEIR\n";
    ss << "\\key Chiller:Electric\n";
    ss << "\\key Chiller:Absorption:Indirect\n";
    ss << "\\key Chiller:Absorption\n";
    ss << "\\key Chiller:ConstantCOP\n";
    ss << "\\key Chiller:EngineDriven\n";
    ss << "\\key Chiller:CombustionTurbine\n";
    ss << "A40, \\field Component 8 Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list IceThermalStorageEquipment\n";
    ss << "\\object-list Chillers\n";
    ss << "A41, \\field Component 8 Demand Calculation Node Name\n";
    ss << "\\type node\n";
    ss << "A42, \\field Component 8 Setpoint Node Name\n";
    ss << "\\type node\n";
    ss << "N10, \\field Component 8 Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "A43, \\field Component 8 Operation Type\n";
    ss << "\\type choice\n";
    ss << "\\key Heating\n";
    ss << "\\key Cooling\n";
    ss << "\\key Dual\n";
    ss << "A44, \\field Component 9 Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key ThermalStorage:Ice:Simple\n";
    ss << "\\key ThermalStorage:Ice:Detailed\n";
    ss << "\\key Chiller:Electric:EIR\n";
    ss << "\\key Chiller:Electric:ReformulatedEIR\n";
    ss << "\\key Chiller:Electric\n";
    ss << "\\key Chiller:Absorption:Indirect\n";
    ss << "\\key Chiller:Absorption\n";
    ss << "\\key Chiller:ConstantCOP\n";
    ss << "\\key Chiller:EngineDriven\n";
    ss << "\\key Chiller:CombustionTurbine\n";
    ss << "A45, \\field Component 9 Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list IceThermalStorageEquipment\n";
    ss << "\\object-list Chillers\n";
    ss << "A46, \\field Component 9 Demand Calculation Node Name\n";
    ss << "\\type node\n";
    ss << "A47, \\field Component 9 Setpoint Node Name\n";
    ss << "\\type node\n";
    ss << "N11, \\field Component 9 Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "A48, \\field Component 9 Operation Type\n";
    ss << "\\type choice\n";
    ss << "\\key Heating\n";
    ss << "\\key Cooling\n";
    ss << "\\key Dual\n";
    ss << "A49, \\field Component 10 Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key ThermalStorage:Ice:Simple\n";
    ss << "\\key ThermalStorage:Ice:Detailed\n";
    ss << "\\key Chiller:Electric:EIR\n";
    ss << "\\key Chiller:Electric:ReformulatedEIR\n";
    ss << "\\key Chiller:Electric\n";
    ss << "\\key Chiller:Absorption:Indirect\n";
    ss << "\\key Chiller:Absorption\n";
    ss << "\\key Chiller:ConstantCOP\n";
    ss << "\\key Chiller:EngineDriven\n";
    ss << "\\key Chiller:CombustionTurbine\n";
    ss << "A50, \\field Component 10 Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list IceThermalStorageEquipment\n";
    ss << "\\object-list Chillers\n";
    ss << "A51, \\field Component 10 Demand Calculation Node Name\n";
    ss << "\\type node\n";
    ss << "A52, \\field Component 10 Setpoint Node Name\n";
    ss << "\\type node\n";
    ss << "N12, \\field Component 10 Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "A53; \\field Component 10 Operation Type\n";
    ss << "\\type choice\n";
    ss << "\\key Heating\n";
    ss << "\\key Cooling\n";
    ss << "\\key Dual\n";

    IddObjectType objType(IddObjectType::PlantEquipmentOperation_ThermalEnergyStorage);
    OptionalIddObject oObj = IddObject::load("PlantEquipmentOperation:ThermalEnergyStorage",
                                             "Plant-Condenser Control",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PlantEquipmentOperation_ThermalEnergyStorage);
  return object;
}

IddObject createPlantEquipmentOperation_OutdoorDryBulbDifferenceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PlantEquipmentOperation:OutdoorDryBulbDifference,\n";
    ss << "\\memo Plant equipment operation scheme for outdoor dry-bulb temperature difference\n";
    ss << "\\memo operation. Specifies one or more groups of equipment which are available to operate\n";
    ss << "\\memo for successive ranges based the difference between a reference node temperature and\n";
    ss << "\\memo the outdoor dry-bulb temperature.\n";
    ss << "\\extensible:3\n";
    ss << "\\min-fields 5\n";
    ss << "\\max-fields 32\n";
    ss << "A1 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "A2 ,\\field Reference Temperature Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,\\field Dry-Bulb Temperature Difference Range 1 Lower Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum -50.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\begin-extensible\n";
    ss << "N2,\\field Dry-Bulb Temperature Difference Range 1 Upper Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum -50.0\n";
    ss << "\\maximum 100.0\n";
    ss << "A3 ;\\field Range 1 Equipment List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PlantAndCondenserEquipmentLists\n";

    IddObjectType objType(IddObjectType::PlantEquipmentOperation_OutdoorDryBulbDifference);
    OptionalIddObject oObj = IddObject::load("PlantEquipmentOperation:OutdoorDryBulbDifference",
                                             "Plant-Condenser Control",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PlantEquipmentOperation_OutdoorDryBulbDifference);
  return object;
}

IddObject createPlantEquipmentOperation_OutdoorWetBulbDifferenceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PlantEquipmentOperation:OutdoorWetBulbDifference,\n";
    ss << "\\memo Plant equipment operation scheme for outdoor wet-bulb temperature difference\n";
    ss << "\\memo operation. Specifies one or more groups of equipment which are available to operate\n";
    ss << "\\memo for successive ranges based the difference between a reference node temperature and\n";
    ss << "\\memo the outdoor wet-bulb temperature.\n";
    ss << "\\extensible:3\n";
    ss << "\\min-fields 5\n";
    ss << "\\max-fields 32\n";
    ss << "A1 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "A2 ,\\field Reference Temperature Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,\\field Wet-Bulb Temperature Difference Range 1 Lower Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum -50.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\begin-extensible\n";
    ss << "N2,\\field Wet-Bulb Temperature Difference Range 1 Upper Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum -50.0\n";
    ss << "\\maximum 100.0\n";
    ss << "A3 ;\\field Range 1 Equipment List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PlantAndCondenserEquipmentLists\n";

    IddObjectType objType(IddObjectType::PlantEquipmentOperation_OutdoorWetBulbDifference);
    OptionalIddObject oObj = IddObject::load("PlantEquipmentOperation:OutdoorWetBulbDifference",
                                             "Plant-Condenser Control",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PlantEquipmentOperation_OutdoorWetBulbDifference);
  return object;
}

IddObject createPlantEquipmentOperation_OutdoorDewpointDifferenceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PlantEquipmentOperation:OutdoorDewpointDifference,\n";
    ss << "\\memo Plant equipment operation scheme for outdoor dewpoint temperature difference\n";
    ss << "\\memo operation. Specifies one or more groups of equipment which are available to operate\n";
    ss << "\\memo for successive ranges based the difference between a reference node temperature and\n";
    ss << "\\memo the outdoor dewpoint temperature.\n";
    ss << "\\extensible:3\n";
    ss << "\\min-fields 5\n";
    ss << "\\max-fields 32\n";
    ss << "A1 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "A2 ,\\field Reference Temperature Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1,\\field Dewpoint Temperature Difference Range 1 Lower Limit\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum -50.0\n";
    ss << "\\maximum 100.0\n";
    ss << "N2,\\field Dewpoint Temperature Difference Range 1 Upper Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum -50.0\n";
    ss << "\\maximum 100.0\n";
    ss << "A3 ;\\field Range 1 Equipment List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PlantAndCondenserEquipmentLists\n";

    IddObjectType objType(IddObjectType::PlantEquipmentOperation_OutdoorDewpointDifference);
    OptionalIddObject oObj = IddObject::load("PlantEquipmentOperation:OutdoorDewpointDifference",
                                             "Plant-Condenser Control",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PlantEquipmentOperation_OutdoorDewpointDifference);
  return object;
}

IddObject createPlantEquipmentOperationSchemesIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PlantEquipmentOperationSchemes,\n";
    ss << "\\memo Operation schemes are listed in \"priority\" order.  Note that each scheme\n";
    ss << "\\memo must address the entire load and/or condition ranges for the simulation.\n";
    ss << "\\memo The actual one selected for use will be the first that is \"Scheduled\"\n";
    ss << "\\memo on.  That is, if control scheme 1 is not \"on\" and control scheme 2\n";
    ss << "\\memo is -- then control scheme 2 is selected.\n";
    ss << "\\memo Only plant equipment should be listed on a Control Scheme for this item.\n";
    ss << "\\extensible:3\n";
    ss << "\\min-fields 4\n";
    ss << "\\max-fields 25\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference PlantOperationSchemes\n";
    ss << "A2 , \\field Control Scheme 1 Object Type\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key PlantEquipmentOperation:CoolingLoad\n";
    ss << "\\key PlantEquipmentOperation:HeatingLoad\n";
    ss << "\\key PlantEquipmentOperation:Uncontrolled\n";
    ss << "\\key PlantEquipmentOperation:ComponentSetpoint\n";
    ss << "\\key PlantEquipmentOperation:UserDefined\n";
    ss << "A3 , \\field Control Scheme 1 Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ControlSchemeList\n";
    ss << "A4 ; \\field Control Scheme 1 Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::PlantEquipmentOperationSchemes);
    OptionalIddObject oObj = IddObject::load("PlantEquipmentOperationSchemes",
                                             "Plant-Condenser Control",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PlantEquipmentOperationSchemes);
  return object;
}

IddObject createCondenserEquipmentOperationSchemesIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "CondenserEquipmentOperationSchemes,\n";
    ss << "\\memo Operation schemes are listed in \"priority\" order.  Note that each scheme\n";
    ss << "\\memo must address the entire load and/or condition ranges for the simulation.\n";
    ss << "\\memo The actual one selected for use will be the first that is \"Scheduled\"\n";
    ss << "\\memo on.  That is, if control scheme 1 is not \"on\" and control scheme 2\n";
    ss << "\\memo is -- then control scheme 2 is selected.\n";
    ss << "\\memo Only condenser equipment should be listed on a Control Scheme for this item.\n";
    ss << "\\extensible:3\n";
    ss << "\\min-fields 4\n";
    ss << "\\max-fields 25\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CondenserOperationSchemes\n";
    ss << "A2 , \\field Control Scheme 1 Object Type\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key PlantEquipmentOperation:Uncontrolled\n";
    ss << "\\key PlantEquipmentOperation:CoolingLoad\n";
    ss << "\\key PlantEquipmentOperation:HeatingLoad\n";
    ss << "\\key PlantEquipmentOperation:OutdoorDryBulb\n";
    ss << "\\key PlantEquipmentOperation:OutdoorWetBulb\n";
    ss << "\\key PlantEquipmentOperation:OutdoorRelativeHumidity\n";
    ss << "\\key PlantEquipmentOperation:OutdoorDewpoint\n";
    ss << "\\key PlantEquipmentOperation:OutdoorDryBulbDifference\n";
    ss << "\\key PlantEquipmentOperation:OutdoorWetBulbDifference\n";
    ss << "\\key PlantEquipmentOperation:OutdoorDewpointDifference\n";
    ss << "\\key PlantEquipmentOperation:UserDefined\n";
    ss << "A3 , \\field Control Scheme 1 Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ControlSchemeList\n";
    ss << "A4 ; \\field Control Scheme 1 Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::CondenserEquipmentOperationSchemes);
    OptionalIddObject oObj = IddObject::load("CondenserEquipmentOperationSchemes",
                                             "Plant-Condenser Control",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::CondenserEquipmentOperationSchemes);
  return object;
}

IddObject createEnergyManagementSystem_SensorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EnergyManagementSystem:Sensor,\n";
    ss << "\\memo Declares EMS variable as a sensor\n";
    ss << "\\memo a list of output variables and meters that can be reported are available after a run on\n";
    ss << "\\memo the report (.rdd) or meter dictionary file (.mdd) if the Output:VariableDictionary\n";
    ss << "\\memo has been requested.\n";
    ss << "\\min-fields 3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note This name becomes a variable for use in Erl programs\n";
    ss << "\\note no spaces allowed in name\n";
    ss << "A2 , \\field Output:Variable or Output:Meter Index Key Name\n";
    ss << "\\type alpha\n";
    ss << "A3 ; \\field Output:Variable or Output:Meter Name\n";
    ss << "\\required-field\n";
    ss << "\\type external-list\n";
    ss << "\\external-list autoRDDvariableMeter\n";

    IddObjectType objType(IddObjectType::EnergyManagementSystem_Sensor);
    OptionalIddObject oObj = IddObject::load("EnergyManagementSystem:Sensor",
                                             "Energy Management System (EMS)",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EnergyManagementSystem_Sensor);
  return object;
}

IddObject createEnergyManagementSystem_ActuatorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EnergyManagementSystem:Actuator,\n";
    ss << "\\memo Hardware portion of EMS used to set up actuators in the model\n";
    ss << "\\min-fields 4\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note This name becomes a variable for use in Erl programs\n";
    ss << "\\note no spaces allowed in name\n";
    ss << "A2 , \\field Actuated Component Unique Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A3 , \\field Actuated Component Type\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A4 ; \\field Actuated Component Control Type\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";

    IddObjectType objType(IddObjectType::EnergyManagementSystem_Actuator);
    OptionalIddObject oObj = IddObject::load("EnergyManagementSystem:Actuator",
                                             "Energy Management System (EMS)",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EnergyManagementSystem_Actuator);
  return object;
}

IddObject createEnergyManagementSystem_ProgramCallingManagerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EnergyManagementSystem:ProgramCallingManager,\n";
    ss << "\\extensible:1 - repeat last field, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\memo Input EMS program. a program needs a name\n";
    ss << "\\memo a description of when it should be called\n";
    ss << "\\memo and then lines of program code for EMS Runtime language\n";
    ss << "\\min-fields 3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ProgramNames\n";
    ss << "\\note no spaces allowed in name\n";
    ss << "A2 , \\field EnergyPlus Model Calling Point\n";
    ss << "\\type choice\n";
    ss << "\\key BeginNewEnvironment\n";
    ss << "\\key AfterNewEnvironmentWarmUpIsComplete\n";
    ss << "\\key BeginTimestepBeforePredictor\n";
    ss << "\\key AfterPredictorBeforeHVACManagers\n";
    ss << "\\key AfterPredictorAfterHVACManagers\n";
    ss << "\\key InsideHVACSystemIterationLoop\n";
    ss << "\\key EndOfZoneTimestepBeforeZoneReporting\n";
    ss << "\\key EndOfZoneTimestepAfterZoneReporting\n";
    ss << "\\key EndOfSystemTimestepBeforeHVACReporting\n";
    ss << "\\key EndOfSystemTimestepAfterHVACReporting\n";
    ss << "\\key EndOfZoneSizing\n";
    ss << "\\key EndOfSystemSizing\n";
    ss << "\\key AfterComponentInputReadIn\n";
    ss << "\\key UserDefinedComponentModel\n";
    ss << "\\key UnitarySystemSizing\n";
    ss << "A3 ; \\field Program Name 1\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\note no spaces allowed in name\n";
    ss << "\\object-list ErlProgramNames\n";

    IddObjectType objType(IddObjectType::EnergyManagementSystem_ProgramCallingManager);
    OptionalIddObject oObj = IddObject::load("EnergyManagementSystem:ProgramCallingManager",
                                             "Energy Management System (EMS)",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EnergyManagementSystem_ProgramCallingManager);
  return object;
}

IddObject createEnergyManagementSystem_ProgramIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EnergyManagementSystem:Program,\n";
    ss << "\\extensible:1 - repeat last field, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\memo This input defines an Erl program\n";
    ss << "\\memo Each field after the name is a line of EMS Runtime Language\n";
    ss << "\\min-fields 2\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ErlProgramNames\n";
    ss << "\\note no spaces allowed in name\n";
    ss << "A2 ; \\field Program Line 1\n";
    ss << "\\begin-extensible\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::EnergyManagementSystem_Program);
    OptionalIddObject oObj = IddObject::load("EnergyManagementSystem:Program",
                                             "Energy Management System (EMS)",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EnergyManagementSystem_Program);
  return object;
}

IddObject createEnergyManagementSystem_SubroutineIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EnergyManagementSystem:Subroutine,\n";
    ss << "\\extensible:1 - repeat last field, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\memo This input defines an Erl program subroutine\n";
    ss << "\\memo Each field after the name is a line of EMS Runtime Language\n";
    ss << "\\min-fields 2\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ErlProgramNames\n";
    ss << "\\note no spaces allowed in name\n";
    ss << "A2 ; \\field Program Line 1\n";
    ss << "\\begin-extensible\n";
    ss << "\\type alpha\n";

    IddObjectType objType(IddObjectType::EnergyManagementSystem_Subroutine);
    OptionalIddObject oObj = IddObject::load("EnergyManagementSystem:Subroutine",
                                             "Energy Management System (EMS)",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EnergyManagementSystem_Subroutine);
  return object;
}

IddObject createEnergyManagementSystem_GlobalVariableIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EnergyManagementSystem:GlobalVariable,\n";
    ss << "\\extensible:1 - repeat last field, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\memo Declares Erl variable as having global scope\n";
    ss << "\\memo No spaces allowed in names used for Erl variables\n";
    ss << "\\min-fields 1\n";
    ss << "A1 ; \\field Erl Variable 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note no spaces allowed in name\n";

    IddObjectType objType(IddObjectType::EnergyManagementSystem_GlobalVariable);
    OptionalIddObject oObj = IddObject::load("EnergyManagementSystem:GlobalVariable",
                                             "Energy Management System (EMS)",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EnergyManagementSystem_GlobalVariable);
  return object;
}

IddObject createEnergyManagementSystem_OutputVariableIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EnergyManagementSystem:OutputVariable,\n";
    ss << "\\memo This object sets up an EnergyPlus output variable from an Erl variable\n";
    ss << "\\min-fields 4\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "A2 , \\field EMS Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note must be an acceptable EMS variable\n";
    ss << "A3 , \\field Type of Data in Variable\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Averaged\n";
    ss << "\\key Summed\n";
    ss << "A4 , \\field Update Frequency\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key ZoneTimestep\n";
    ss << "\\key SystemTimestep\n";
    ss << "A5 , \\field EMS Program or Subroutine Name\n";
    ss << "\\type alpha\n";
    ss << "\\note optional for global scope variables, required for local scope variables\n";
    ss << "A6 ; \\field Units\n";
    ss << "\\note optional but will result in dimensionless units for blank\n";
    ss << "\\note EnergyPlus units are standard SI units\n";
    ss << "\\type alpha\n";

    IddObjectType objType(IddObjectType::EnergyManagementSystem_OutputVariable);
    OptionalIddObject oObj = IddObject::load("EnergyManagementSystem:OutputVariable",
                                             "Energy Management System (EMS)",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EnergyManagementSystem_OutputVariable);
  return object;
}

IddObject createEnergyManagementSystem_MeteredOutputVariableIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EnergyManagementSystem:MeteredOutputVariable,\n";
    ss << "\\memo This object sets up an EnergyPlus output variable from an Erl variable\n";
    ss << "\\min-fields 7\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "A2 , \\field EMS Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note must be an acceptable EMS variable, no spaces\n";
    ss << "A3 , \\field Update Frequency\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key ZoneTimestep\n";
    ss << "\\key SystemTimestep\n";
    ss << "A4 , \\field EMS Program or Subroutine Name\n";
    ss << "\\type alpha\n";
    ss << "\\note optional for global scope variables, required for local scope variables\n";
    ss << "A5 , \\field Resource Type\n";
    ss << "\\required-field\n";
    ss << "\\note choose the type of fuel, water, electricity, pollution or heat rate that should be metered.\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key Gasoline\n";
    ss << "\\key Diesel\n";
    ss << "\\key Coal\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Propane\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\key WaterUse\n";
    ss << "\\key OnSiteWaterProduced\n";
    ss << "\\key MainsWaterSupply\n";
    ss << "\\key RainWaterCollected\n";
    ss << "\\key WellWaterDrawn\n";
    ss << "\\key CondensateWaterCollected\n";
    ss << "\\key EnergyTransfer\n";
    ss << "\\key Steam\n";
    ss << "\\key DistrictCooling\n";
    ss << "\\key DistrictHeating\n";
    ss << "\\key ElectricityProducedOnSite\n";
    ss << "\\key SolarWaterHeating\n";
    ss << "\\key SolarAirHeating\n";
    ss << "A6 , \\field Group Type\n";
    ss << "\\note choose a general classification, building (internal services), HVAC (air systems), or plant (hydronic systems), or system\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Building\n";
    ss << "\\key HVAC\n";
    ss << "\\key Plant\n";
    ss << "\\key System\n";
    ss << "A7 , \\field End-Use Category\n";
    ss << "\\note choose how the metered output should be classified for end-use category\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Heating\n";
    ss << "\\key Cooling\n";
    ss << "\\key InteriorLights\n";
    ss << "\\key ExteriorLights\n";
    ss << "\\key InteriorEquipment\n";
    ss << "\\key ExteriorEquipment\n";
    ss << "\\key Fans\n";
    ss << "\\key Pumps\n";
    ss << "\\key HeatRejection\n";
    ss << "\\key Humidifier\n";
    ss << "\\key HeatRecovery\n";
    ss << "\\key WaterSystems\n";
    ss << "\\key Refrigeration\n";
    ss << "\\key OnSiteGeneration\n";
    ss << "\\key HeatingCoils\n";
    ss << "\\key CoolingCoils\n";
    ss << "\\key Chillers\n";
    ss << "\\key Boilers\n";
    ss << "\\key Baseboard\n";
    ss << "\\key HeatRecoveryForCooling\n";
    ss << "\\key HeatRecoveryForHeating\n";
    ss << "A8 , \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\note enter a user-defined subcategory for this metered output\n";
    ss << "A9 ; \\field Units\n";
    ss << "\\note optional but will result in dimensionless units for blank\n";
    ss << "\\note EnergyPlus units are standard SI units\n";
    ss << "\\type alpha\n";

    IddObjectType objType(IddObjectType::EnergyManagementSystem_MeteredOutputVariable);
    OptionalIddObject oObj = IddObject::load("EnergyManagementSystem:MeteredOutputVariable",
                                             "Energy Management System (EMS)",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EnergyManagementSystem_MeteredOutputVariable);
  return object;
}

IddObject createEnergyManagementSystem_TrendVariableIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EnergyManagementSystem:TrendVariable,\n";
    ss << "\\memo This object sets up an EMS trend variable from an Erl variable\n";
    ss << "\\memo A trend variable logs values across timesteps\n";
    ss << "\\min-fields 3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note no spaces allowed in name\n";
    ss << "A2 , \\field EMS Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note must be a global scope EMS variable\n";
    ss << "N1 ; \\field Number of Timesteps to be Logged\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";

    IddObjectType objType(IddObjectType::EnergyManagementSystem_TrendVariable);
    OptionalIddObject oObj = IddObject::load("EnergyManagementSystem:TrendVariable",
                                             "Energy Management System (EMS)",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EnergyManagementSystem_TrendVariable);
  return object;
}

IddObject createEnergyManagementSystem_InternalVariableIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EnergyManagementSystem:InternalVariable,\n";
    ss << "\\memo Declares EMS variable as an internal data variable\n";
    ss << "\\min-fields 3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note This name becomes a variable for use in Erl programs\n";
    ss << "\\note no spaces allowed in name\n";
    ss << "A2 , \\field Internal Data Index Key Name\n";
    ss << "\\type alpha\n";
    ss << "A3 ; \\field Internal Data Type\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";

    IddObjectType objType(IddObjectType::EnergyManagementSystem_InternalVariable);
    OptionalIddObject oObj = IddObject::load("EnergyManagementSystem:InternalVariable",
                                             "Energy Management System (EMS)",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EnergyManagementSystem_InternalVariable);
  return object;
}

IddObject createEnergyManagementSystem_CurveOrTableIndexVariableIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EnergyManagementSystem:CurveOrTableIndexVariable,\n";
    ss << "\\memo Declares EMS variable that identifies a curve or table\n";
    ss << "\\min-fields 2\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note This name becomes a variable for use in Erl programs\n";
    ss << "\\note no spaces allowed in name\n";
    ss << "A2 ; \\field Curve or Table Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllCurves\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::EnergyManagementSystem_CurveOrTableIndexVariable);
    OptionalIddObject oObj = IddObject::load("EnergyManagementSystem:CurveOrTableIndexVariable",
                                             "Energy Management System (EMS)",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EnergyManagementSystem_CurveOrTableIndexVariable);
  return object;
}

IddObject createEnergyManagementSystem_ConstructionIndexVariableIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EnergyManagementSystem:ConstructionIndexVariable,\n";
    ss << "\\memo Declares EMS variable that identifies a construction\n";
    ss << "\\min-fields 2\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note This name becomes a variable for use in Erl programs\n";
    ss << "\\note no spaces allowed in name\n";
    ss << "A2 ; \\field Construction Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::EnergyManagementSystem_ConstructionIndexVariable);
    OptionalIddObject oObj = IddObject::load("EnergyManagementSystem:ConstructionIndexVariable",
                                             "Energy Management System (EMS)",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EnergyManagementSystem_ConstructionIndexVariable);
  return object;
}

IddObject createExternalInterfaceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ExternalInterface,\n";
    ss << "\\memo This object activates the external interface of EnergyPlus. If the object\n";
    ss << "\\memo ExternalInterface is present, then all ExtnernalInterface:* objects will receive\n";
    ss << "\\memo their values from the BCVTB interface or from FMUs at each zone time step.\n";
    ss << "\\memo If this object is not present, then the values of these objects will be fixed at the\n";
    ss << "\\memo value declared in the \"initial value\" field of the corresponding object, and a\n";
    ss << "\\memo warning will be written to the EnergyPlus error file.\n";
    ss << "A1;  \\field Name of External Interface\n";
    ss << "\\note Name of External Interface\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key PtolemyServer\n";
    ss << "\\key FunctionalMockupUnitImport\n";
    ss << "\\key FunctionalMockupUnitExport\n";
    ss << "\\note Currently, the only valid entries are PtolemyServer, FunctionalMockupUnitImport, and FunctionalMockupUnitExport.\n";

    IddObjectType objType(IddObjectType::ExternalInterface);
    OptionalIddObject oObj = IddObject::load("ExternalInterface",
                                             "External Interface",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ExternalInterface);
  return object;
}

IddObject createExternalInterface_ScheduleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ExternalInterface:Schedule,\n";
    ss << "\\min-fields 3\n";
    ss << "\\memo A ExternalInterface:Schedule contains only one value,\n";
    ss << "\\memo which is used during the warm-up period and the system sizing.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ScheduleNames\n";
    ss << "A2 , \\field Schedule Type Limits Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleTypeLimitsNames\n";
    ss << "N1 ; \\field Initial Value\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\note Used during warm-up and system sizing.\n";

    IddObjectType objType(IddObjectType::ExternalInterface_Schedule);
    OptionalIddObject oObj = IddObject::load("ExternalInterface:Schedule",
                                             "External Interface",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ExternalInterface_Schedule);
  return object;
}

IddObject createExternalInterface_VariableIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ExternalInterface:Variable,\n";
    ss << "\\memo This input object is similar to EnergyManagementSystem:GlobalVariable. However, at\n";
    ss << "\\memo the beginning of each zone time step, its value is set to the value received from the\n";
    ss << "\\memo external interface. During the warm-up period and the system sizing, its value\n";
    ss << "\\memo is set to the value specified by the field \"initial value.\" This object can be used\n";
    ss << "\\memo to move data into Erl subroutines.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note This name becomes a variable for use in Erl programs\n";
    ss << "\\note no spaces allowed in name\n";
    ss << "N1 ; \\field Initial Value\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\note Used during warm-up and system sizing.\n";

    IddObjectType objType(IddObjectType::ExternalInterface_Variable);
    OptionalIddObject oObj = IddObject::load("ExternalInterface:Variable",
                                             "External Interface",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ExternalInterface_Variable);
  return object;
}

IddObject createExternalInterface_ActuatorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ExternalInterface:Actuator,\n";
    ss << "\\memo Hardware portion of EMS used to set up actuators in the model\n";
    ss << "\\min-fields 4\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note This name becomes a variable for use in Erl programs\n";
    ss << "\\note no spaces allowed in name\n";
    ss << "A2 , \\field Actuated Component Unique Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A3 , \\field Actuated Component Type\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A4 , \\field Actuated Component Control Type\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "N1 ; \\field Optional Initial Value\n";
    ss << "\\type real\n";
    ss << "\\note If specified, it is used during warm-up and system sizing.\n";
    ss << "\\note If not specified, then the actuator only overwrites the\n";
    ss << "\\note actuated component after the warm-up and system sizing.\n";

    IddObjectType objType(IddObjectType::ExternalInterface_Actuator);
    OptionalIddObject oObj = IddObject::load("ExternalInterface:Actuator",
                                             "External Interface",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ExternalInterface_Actuator);
  return object;
}

IddObject createExternalInterface_FunctionalMockupUnitImportIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ExternalInterface:FunctionalMockupUnitImport,\n";
    ss << "\\memo This object declares an FMU\n";
    ss << "A1 , \\field FMU File Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\reference FMUFileName\n";
    ss << "N1 , \\field FMU Timeout\n";
    ss << "\\note in milli-seconds\n";
    ss << "\\type real\n";
    ss << "\\units ms\n";
    ss << "\\default 0.0\n";
    ss << "N2 ; \\field FMU LoggingOn\n";
    ss << "\\type integer\n";
    ss << "\\default 0\n";

    IddObjectType objType(IddObjectType::ExternalInterface_FunctionalMockupUnitImport);
    OptionalIddObject oObj = IddObject::load("ExternalInterface:FunctionalMockupUnitImport",
                                             "External Interface",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ExternalInterface_FunctionalMockupUnitImport);
  return object;
}

IddObject createExternalInterface_FunctionalMockupUnitImport_From_VariableIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ExternalInterface:FunctionalMockupUnitImport:From:Variable,\n";
    ss << "\\memo This object declares an FMU input variable\n";
    ss << "\\min-fields 5\n";
    ss << "A1 , \\field Output:Variable Index Key Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Output:Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\type external-list\n";
    ss << "\\external-list autoRDDvariable\n";
    ss << "A3 , \\field FMU File Name\n";
    ss << "\\required-field\n";
    ss << "\\retaincase\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FMUFileName\n";
    ss << "A4 , \\field FMU Instance Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "A5 ; \\field FMU Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";

    IddObjectType objType(IddObjectType::ExternalInterface_FunctionalMockupUnitImport_From_Variable);
    OptionalIddObject oObj = IddObject::load("ExternalInterface:FunctionalMockupUnitImport:From:Variable",
                                             "External Interface",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ExternalInterface_FunctionalMockupUnitImport_From_Variable);
  return object;
}

IddObject createExternalInterface_FunctionalMockupUnitImport_To_ScheduleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ExternalInterface:FunctionalMockupUnitImport:To:Schedule,\n";
    ss << "\\memo This objects contains only one value, which is used during the first\n";
    ss << "\\memo call of EnergyPlus\n";
    ss << "\\min-fields 6\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ScheduleNames\n";
    ss << "A2 , \\field Schedule Type Limits Names\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleTypeLimitsNames\n";
    ss << "A3 , \\field FMU File Name\n";
    ss << "\\required-field\n";
    ss << "\\retaincase\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FMUFileName\n";
    ss << "A4 , \\field FMU Instance Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "A5 , \\field FMU Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "N1 ; \\field Initial Value\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\note Used during the first call of EnergyPlus.\n";

    IddObjectType objType(IddObjectType::ExternalInterface_FunctionalMockupUnitImport_To_Schedule);
    OptionalIddObject oObj = IddObject::load("ExternalInterface:FunctionalMockupUnitImport:To:Schedule",
                                             "External Interface",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ExternalInterface_FunctionalMockupUnitImport_To_Schedule);
  return object;
}

IddObject createExternalInterface_FunctionalMockupUnitImport_To_ActuatorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ExternalInterface:FunctionalMockupUnitImport:To:Actuator,\n";
    ss << "\\memo Hardware portion of EMS used to set up actuators in the model\n";
    ss << "\\memo that are dynamically updated from the FMU.\n";
    ss << "\\min-fields 8\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note This name becomes a read-only variable for use in Erl programs\n";
    ss << "\\note no spaces allowed in name\n";
    ss << "A2 , \\field Actuated Component Unique Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A3 , \\field Actuated Component Type\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A4 , \\field Actuated Component Control Type\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A5 , \\field FMU File Name\n";
    ss << "\\required-field\n";
    ss << "\\retaincase\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FMUFileName\n";
    ss << "A6 , \\field FMU Instance Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "A7 , \\field FMU Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "N1 ; \\field Initial Value\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\note Used during the first call of EnergyPlus.\n";

    IddObjectType objType(IddObjectType::ExternalInterface_FunctionalMockupUnitImport_To_Actuator);
    OptionalIddObject oObj = IddObject::load("ExternalInterface:FunctionalMockupUnitImport:To:Actuator",
                                             "External Interface",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ExternalInterface_FunctionalMockupUnitImport_To_Actuator);
  return object;
}

IddObject createExternalInterface_FunctionalMockupUnitImport_To_VariableIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ExternalInterface:FunctionalMockupUnitImport:To:Variable,\n";
    ss << "\\memo Declares Erl variable as having global scope\n";
    ss << "\\memo No spaces allowed in names used for Erl variables\n";
    ss << "\\min-fields 5\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note This name becomes a variable for use in Erl programs\n";
    ss << "\\note no spaces allowed in name\n";
    ss << "A2 , \\field FMU File Name\n";
    ss << "\\required-field\n";
    ss << "\\retaincase\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FMUFileName\n";
    ss << "A3 , \\field FMU Instance Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "A4 , \\field FMU Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "N1 ; \\field Initial Value\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\note Used during the first call of EnergyPlus.\n";

    IddObjectType objType(IddObjectType::ExternalInterface_FunctionalMockupUnitImport_To_Variable);
    OptionalIddObject oObj = IddObject::load("ExternalInterface:FunctionalMockupUnitImport:To:Variable",
                                             "External Interface",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ExternalInterface_FunctionalMockupUnitImport_To_Variable);
  return object;
}

IddObject createExternalInterface_FunctionalMockupUnitExport_From_VariableIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ExternalInterface:FunctionalMockupUnitExport:From:Variable,\n";
    ss << "\\memo This object declares an FMU input variable\n";
    ss << "\\min-fields 3\n";
    ss << "A1 , \\field Output:Variable Index Key Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Output:Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\type external-list\n";
    ss << "\\external-list autoRDDvariable\n";
    ss << "A3 ; \\field FMU Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";

    IddObjectType objType(IddObjectType::ExternalInterface_FunctionalMockupUnitExport_From_Variable);
    OptionalIddObject oObj = IddObject::load("ExternalInterface:FunctionalMockupUnitExport:From:Variable",
                                             "External Interface",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ExternalInterface_FunctionalMockupUnitExport_From_Variable);
  return object;
}

IddObject createExternalInterface_FunctionalMockupUnitExport_To_ScheduleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ExternalInterface:FunctionalMockupUnitExport:To:Schedule,\n";
    ss << "\\memo This objects contains only one value, which is used during the first\n";
    ss << "\\memo call of EnergyPlus\n";
    ss << "\\min-fields 4\n";
    ss << "A1 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ScheduleNames\n";
    ss << "A2 , \\field Schedule Type Limits Names\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleTypeLimitsNames\n";
    ss << "A3 , \\field FMU Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "N1 ; \\field Initial Value\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\note Used during the first call of EnergyPlus.\n";

    IddObjectType objType(IddObjectType::ExternalInterface_FunctionalMockupUnitExport_To_Schedule);
    OptionalIddObject oObj = IddObject::load("ExternalInterface:FunctionalMockupUnitExport:To:Schedule",
                                             "External Interface",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ExternalInterface_FunctionalMockupUnitExport_To_Schedule);
  return object;
}

IddObject createExternalInterface_FunctionalMockupUnitExport_To_ActuatorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ExternalInterface:FunctionalMockupUnitExport:To:Actuator,\n";
    ss << "\\memo Hardware portion of EMS used to set up actuators in the model\n";
    ss << "\\memo that are dynamically updated from the FMU.\n";
    ss << "\\min-fields 6\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note This name becomes a read-only variable for use in Erl programs\n";
    ss << "\\note no spaces allowed in name\n";
    ss << "A2 , \\field Actuated Component Unique Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A3 , \\field Actuated Component Type\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A4 , \\field Actuated Component Control Type\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A5 , \\field FMU Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "N1 ; \\field Initial Value\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\note Used during the first call of EnergyPlus.\n";

    IddObjectType objType(IddObjectType::ExternalInterface_FunctionalMockupUnitExport_To_Actuator);
    OptionalIddObject oObj = IddObject::load("ExternalInterface:FunctionalMockupUnitExport:To:Actuator",
                                             "External Interface",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ExternalInterface_FunctionalMockupUnitExport_To_Actuator);
  return object;
}

IddObject createExternalInterface_FunctionalMockupUnitExport_To_VariableIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ExternalInterface:FunctionalMockupUnitExport:To:Variable,\n";
    ss << "\\memo Declares Erl variable as having global scope\n";
    ss << "\\memo No spaces allowed in names used for Erl variables\n";
    ss << "\\min-fields 3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note This name becomes a variable for use in Erl programs\n";
    ss << "\\note no spaces allowed in name\n";
    ss << "A2 , \\field FMU Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "N1 ; \\field Initial Value\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\note Used during the first call of EnergyPlus.\n";

    IddObjectType objType(IddObjectType::ExternalInterface_FunctionalMockupUnitExport_To_Variable);
    OptionalIddObject oObj = IddObject::load("ExternalInterface:FunctionalMockupUnitExport:To:Variable",
                                             "External Interface",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ExternalInterface_FunctionalMockupUnitExport_To_Variable);
  return object;
}

IddObject createZoneHVAC_ForcedAir_UserDefinedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:ForcedAir:UserDefined,\n";
    ss << "\\memo Defines a generic zone air unit for custom modeling\n";
    ss << "\\memo using Energy Management System or External Interface\n";
    ss << "\\min-fields 8\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note This is the name of the zone unit\n";
    ss << "A2 , \\field Overall Model Simulation Program Calling Manager Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ProgramNames\n";
    ss << "A3 , \\field Model Setup and Sizing Program Calling Manager Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ProgramNames\n";
    ss << "A4 , \\field Primary Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Air inlet node for the unit must be a zone air exhaust Node.\n";
    ss << "A5 , \\field Primary Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Air outlet node for the unit must be a zone air inlet node.\n";
    ss << "A6,  \\field Secondary Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Inlet air used for heat rejection or air source\n";
    ss << "A7,  \\field Secondary Air Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Outlet air used for heat rejection or air source\n";
    ss << "N1 , \\field Number of Plant Loop Connections\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 3\n";
    ss << "\\required-field\n";
    ss << "A8 , \\field Plant Connection 1 Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A9, \\field Plant Connection 1 Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A10, \\field Plant Connection 2 Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A11, \\field Plant Connection 2 Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A12, \\field Plant Connection 3 Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A13, \\field Plant Connection 3 Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A14, \\field Supply Inlet Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "\\note Water use storage tank for alternate source of water consumed by device\n";
    ss << "A15, \\field Collection Outlet Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "\\note Water use storage tank for collection of condensate by device\n";
    ss << "A16; \\field Ambient Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note Used for modeling device losses to surrounding zone\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_ForcedAir_UserDefined);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:ForcedAir:UserDefined",
                                             "User Defined HVAC and Plant Component Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_ForcedAir_UserDefined);
  return object;
}

IddObject createAirTerminal_SingleDuct_UserDefinedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AirTerminal:SingleDuct:UserDefined,\n";
    ss << "\\memo Defines a generic single duct air terminal unit for custom modeling\n";
    ss << "\\memo using Energy Management System or External Interface\n";
    ss << "\\min-fields 8\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note This is the name of the air terminal\n";
    ss << "A2 , \\field Overall Model Simulation Program Calling Manager Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ProgramNames\n";
    ss << "A3 , \\field Model Setup and Sizing Program Calling Manager Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ProgramNames\n";
    ss << "A4 , \\field Primary Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Air inlet node for the unit must be a zone splitter outlet.\n";
    ss << "A5 , \\field Primary Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Air outlet node for the unit must be a zone air inlet node.\n";
    ss << "A6,  \\field Secondary Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Inlet air used for heat rejection or air source\n";
    ss << "A7,  \\field Secondary Air Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Outlet air used for heat rejection or air source\n";
    ss << "N1,  \\field Number of Plant Loop Connections\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 2\n";
    ss << "\\required-field\n";
    ss << "A8 , \\field Plant Connection 1 Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A9 , \\field Plant Connection 1 Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A10, \\field Plant Connection 2 Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A11, \\field Plant Connection 2 Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A12, \\field Supply Inlet Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "\\note Water use storage tank for alternate source of water consumed by device\n";
    ss << "A13, \\field Collection Outlet Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "\\note Water use storage tank for collection of condensate by device\n";
    ss << "A14; \\field Ambient Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note Used for modeling device losses to surrounding zone\n";

    IddObjectType objType(IddObjectType::AirTerminal_SingleDuct_UserDefined);
    OptionalIddObject oObj = IddObject::load("AirTerminal:SingleDuct:UserDefined",
                                             "User Defined HVAC and Plant Component Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AirTerminal_SingleDuct_UserDefined);
  return object;
}

IddObject createCoil_UserDefinedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Coil:UserDefined,\n";
    ss << "\\memo Defines a generic air system component for custom modeling\n";
    ss << "\\memo using Energy Management System or External Interface\n";
    ss << "\\min-fields 9\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference UserDefinedCoil\n";
    ss << "\\note This is the name of the coil\n";
    ss << "A2 , \\field Overall Model Simulation Program Calling Manager Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ProgramNames\n";
    ss << "A3 , \\field Model Setup and Sizing Program Calling Manager Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ProgramNames\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field Number of Air Connections\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 2\n";
    ss << "\\required-field\n";
    ss << "A4 , \\field Air Connection 1 Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Inlet air for primary air stream\n";
    ss << "\\required-field\n";
    ss << "A5 , \\field Air Connection 1 Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Outlet air for primary air stream\n";
    ss << "\\required-field\n";
    ss << "A6 , \\field Air Connection 2 Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Inlet air for secondary air stream\n";
    ss << "A7 , \\field Air Connection 2 Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Outlet air for secondary air stream\n";
    ss << "A8 , \\field Plant Connection is Used\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A9 , \\field Plant Connection Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A10 ,\\field Plant Connection Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A11, \\field Supply Inlet Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "\\note Water use storage tank for alternate source of water consumed by device\n";
    ss << "A12, \\field Collection Outlet Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "\\note Water use storage tank for collection of condensate by device\n";
    ss << "A13; \\field Ambient Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note Used for modeling device losses to surrounding zone\n";

    IddObjectType objType(IddObjectType::Coil_UserDefined);
    OptionalIddObject oObj = IddObject::load("Coil:UserDefined",
                                             "User Defined HVAC and Plant Component Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Coil_UserDefined);
  return object;
}

IddObject createPlantComponent_UserDefinedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PlantComponent:UserDefined,\n";
    ss << "\\memo Defines a generic plant component for custom modeling\n";
    ss << "\\memo using Energy Management System or External Interface\n";
    ss << "\\min-fields 9\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note This is the name of the plant component\n";
    ss << "A2 , \\field Main Model Program Calling Manager Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ProgramNames\n";
    ss << "N1 , \\field Number of Plant Loop Connections\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 4\n";
    ss << "\\required-field\n";
    ss << "A3 , \\field Plant Connection 1 Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A4 , \\field Plant Connection 1 Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A5 , \\field Plant Connection 1 Loading Mode\n";
    ss << "\\type choice\n";
    ss << "\\key DemandsLoad\n";
    ss << "\\key MeetsLoadWithPassiveCapacity\n";
    ss << "\\key MeetsLoadWithNominalCapacity\n";
    ss << "\\key MeetsLoadWithNominalCapacityLowOutLimit\n";
    ss << "\\key MeetsLoadWithNominalCapacityHiOutLimit\n";
    ss << "\\required-field\n";
    ss << "A6 , \\field Plant Connection 1 Loop Flow Request Mode\n";
    ss << "\\type choice\n";
    ss << "\\key NeedsFlowIfLoopOn\n";
    ss << "\\key NeedsFlowAndTurnsLoopOn\n";
    ss << "\\key ReceivesWhateverFlowAvailable\n";
    ss << "\\required-field\n";
    ss << "A7 , \\field Plant Connection 1 Initialization Program Calling Manager Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ProgramNames\n";
    ss << "A8  ,\\field Plant Connection 1 Simulation Program Calling Manager Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ProgramNames\n";
    ss << "A9 , \\field Plant Connection 2 Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A10, \\field Plant Connection 2 Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A11, \\field Plant Connection 2 Loading Mode\n";
    ss << "\\type choice\n";
    ss << "\\key DemandsLoad\n";
    ss << "\\key MeetLoadWithPassiveCapacity\n";
    ss << "\\key MeetLoadWithNominalCapacity\n";
    ss << "\\key MeetLoadWithNominalCapacityLowOutLimit\n";
    ss << "\\key MeetLoadWithNominalCapacityHiOutLimit\n";
    ss << "A12, \\field Plant Connection 2 Loop Flow Request Mode\n";
    ss << "\\type choice\n";
    ss << "\\key NeedsFlowIfLoopOn\n";
    ss << "\\key NeedsFlowAndTurnsLoopOn\n";
    ss << "\\key ReceivesWhateverFlowAvailable\n";
    ss << "A13, \\field Plant Connection 2 Initialization Program Calling Manager Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ProgramNames\n";
    ss << "A14, \\field Plant Connection 2 Simulation Program Calling Manager Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ProgramNames\n";
    ss << "A15, \\field Plant Connection 3 Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A16, \\field Plant Connection 3 Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A17, \\field Plant Connection 3 Loading Mode\n";
    ss << "\\type choice\n";
    ss << "\\key DemandsLoad\n";
    ss << "\\key MeetLoadWithPassiveCapacity\n";
    ss << "\\key MeetLoadWithNominalCapacity\n";
    ss << "\\key MeetLoadWithNominalCapacityLowOutLimit\n";
    ss << "\\key MeetLoadWithNominalCapacityHiOutLimit\n";
    ss << "A18, \\field Plant Connection 3 Loop Flow Request Mode\n";
    ss << "\\type choice\n";
    ss << "\\key NeedsFlowIfLoopOn\n";
    ss << "\\key NeedsFlowAndTurnsLoopOn\n";
    ss << "\\key ReceivesWhateverFlowAvailable\n";
    ss << "A19, \\field Plant Connection 3 Initialization Program Calling Manager Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ProgramNames\n";
    ss << "A20, \\field Plant Connection 3 Simulation Program Calling Manager Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ProgramNames\n";
    ss << "A21, \\field Plant Connection 4 Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A22, \\field Plant Connection 4 Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A23, \\field Plant Connection 4 Loading Mode\n";
    ss << "\\type choice\n";
    ss << "\\key DemandsLoad\n";
    ss << "\\key MeetLoadWithPassiveCapacity\n";
    ss << "\\key MeetLoadWithNominalCapacity\n";
    ss << "\\key MeetLoadWithNominalCapacityLowOutLimit\n";
    ss << "\\key MeetLoadWithNominalCapacityHiOutLimit\n";
    ss << "A24, \\field Plant Connection 4 Loop Flow Request Mode\n";
    ss << "\\type choice\n";
    ss << "\\key NeedsFlowIfLoopOn\n";
    ss << "\\key NeedsFlowAndTurnsLoopOn\n";
    ss << "\\key ReceivesWhateverFlowAvailable\n";
    ss << "A25, \\field Plant Connection 4 Initialization Program Calling Manager Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ProgramNames\n";
    ss << "A26, \\field Plant Connection 4 Simulation Program Calling Manager Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ProgramNames\n";
    ss << "A27, \\field Air Connection Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Inlet air used for heat rejection or air source\n";
    ss << "A28, \\field Air Connection Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Outlet air used for heat rejection or air source\n";
    ss << "A29, \\field Supply Inlet Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "\\note Water use storage tank for alternate source of water consumed by device\n";
    ss << "A30, \\field Collection Outlet Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "\\note Water use storage tank for collection of condensate by device\n";
    ss << "A31; \\field Ambient Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note Used for modeling device losses to surrounding zone\n";

    IddObjectType objType(IddObjectType::PlantComponent_UserDefined);
    OptionalIddObject oObj = IddObject::load("PlantComponent:UserDefined",
                                             "User Defined HVAC and Plant Component Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PlantComponent_UserDefined);
  return object;
}

IddObject createPlantEquipmentOperation_UserDefinedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PlantEquipmentOperation:UserDefined,\n";
    ss << "\\memo Defines a generic plant operation scheme for custom supervisory control\n";
    ss << "\\memo using Energy Management System or External Interface to dispatch loads\n";
    ss << "\\min-fields 5\n";
    ss << "\\extensible:2\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note This is the name of the plant operation scheme\n";
    ss << "A2 , \\field Main Model Program Calling Manager Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ProgramNames\n";
    ss << "\\required-field\n";
    ss << "A3 , \\field Initialization Program Calling Manager Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ProgramNames\n";
    ss << "A4 , \\field Equipment 1 Object Type\n";
    ss << "\\type alpha\n";
    ss << "\\begin-extensible\n";
    ss << "A5 ; \\field Equipment 1 Name\n";
    ss << "\\type alpha\n";

    IddObjectType objType(IddObjectType::PlantEquipmentOperation_UserDefined);
    OptionalIddObject oObj = IddObject::load("PlantEquipmentOperation:UserDefined",
                                             "User Defined HVAC and Plant Component Models",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PlantEquipmentOperation_UserDefined);
  return object;
}

IddObject createAvailabilityManager_ScheduledIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AvailabilityManager:Scheduled,\n";
    ss << "\\min-fields 2\n";
    ss << "\\memo Determines the availability of a loop or system: whether it is on or off.\n";
    ss << "\\memo Schedule overrides fan/pump schedule.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SystemAvailabilityManagers\n";
    ss << "A2 ; \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::AvailabilityManager_Scheduled);
    OptionalIddObject oObj = IddObject::load("AvailabilityManager:Scheduled",
                                             "System Availability Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AvailabilityManager_Scheduled);
  return object;
}

IddObject createAvailabilityManager_ScheduledOnIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AvailabilityManager:ScheduledOn,\n";
    ss << "\\min-fields 2\n";
    ss << "\\memo Determines the availability of a loop or system: only controls the turn on action.\n";
    ss << "\\memo Schedule overrides fan/pump schedule.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SystemAvailabilityManagers\n";
    ss << "A2 ; \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::AvailabilityManager_ScheduledOn);
    OptionalIddObject oObj = IddObject::load("AvailabilityManager:ScheduledOn",
                                             "System Availability Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AvailabilityManager_ScheduledOn);
  return object;
}

IddObject createAvailabilityManager_ScheduledOffIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AvailabilityManager:ScheduledOff,\n";
    ss << "\\min-fields 2\n";
    ss << "\\memo Determines the availability of a loop or system: only controls the turn off action.\n";
    ss << "\\memo Schedule overrides fan/pump schedule.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SystemAvailabilityManagers\n";
    ss << "A2 ; \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::AvailabilityManager_ScheduledOff);
    OptionalIddObject oObj = IddObject::load("AvailabilityManager:ScheduledOff",
                                             "System Availability Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AvailabilityManager_ScheduledOff);
  return object;
}

IddObject createAvailabilityManager_OptimumStartIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AvailabilityManager:OptimumStart,\n";
    ss << "\\memo Determines the optimal start of HVAC systems before occupancy.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SystemAvailabilityManagers\n";
    ss << "A2 , \\field Applicability Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Fan Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key StayOff\n";
    ss << "\\key ControlZone\n";
    ss << "\\key MaximumofZoneList\n";
    ss << "\\default ControlZone\n";
    ss << "A5 , \\field Control Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A6 , \\field Zone List Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneListNames\n";
    ss << "N1 , \\field Maximum Value for Optimum Start Time\n";
    ss << "\\default 6\n";
    ss << "\\units hr\n";
    ss << "\\note this is the maximum number of hours that a system can start before occupancy\n";
    ss << "A7 , \\field Control Algorithm\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantTemperatureGradient\n";
    ss << "\\key AdaptiveTemperatureGradient\n";
    ss << "\\key AdaptiveASHRAE\n";
    ss << "\\key ConstantStartTime\n";
    ss << "\\default AdaptiveASHRAE\n";
    ss << "N2,  \\field Constant Temperature Gradient during Cooling\n";
    ss << "\\units deltaC/hr\n";
    ss << "\\type real\n";
    ss << "N3,  \\field Constant Temperature Gradient during Heating\n";
    ss << "\\units deltaC/hr\n";
    ss << "\\type real\n";
    ss << "N4,  \\field Initial Temperature Gradient during Cooling\n";
    ss << "\\units deltaC/hr\n";
    ss << "\\type real\n";
    ss << "N5,  \\field Initial Temperature Gradient during Heating\n";
    ss << "\\units deltaC/hr\n";
    ss << "\\type real\n";
    ss << "N6,  \\field Constant Start Time\n";
    ss << "\\units hr\n";
    ss << "\\type real\n";
    ss << "\\note this is the number of hours before occupancy for a system\n";
    ss << "N7;  \\field Number of Previous Days\n";
    ss << "\\type integer\n";
    ss << "\\units days\n";
    ss << "\\minimum 2\n";
    ss << "\\default 2\n";
    ss << "\\maximum 5\n";
    ss << "\\note this is the number of days that their actual temperature\n";
    ss << "\\note gradients will be used in the AdaptiveTemperatureGradient method\n";

    IddObjectType objType(IddObjectType::AvailabilityManager_OptimumStart);
    OptionalIddObject oObj = IddObject::load("AvailabilityManager:OptimumStart",
                                             "System Availability Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AvailabilityManager_OptimumStart);
  return object;
}

IddObject createAvailabilityManager_NightCycleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AvailabilityManager:NightCycle,\n";
    ss << "\\min-fields 6\n";
    ss << "\\memo Determines the availability of a loop or system: whether it is on or off.\n";
    ss << "\\memo Depending on zone temperatures, overrides Schedules and forces system Fans on.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SystemAvailabilityManagers\n";
    ss << "A2 , \\field Applicability Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Fan Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key StayOff\n";
    ss << "\\key CycleOnAny\n";
    ss << "\\key CycleOnControlZone\n";
    ss << "\\key CycleOnAnyZoneFansOnly\n";
    ss << "\\default StayOff\n";
    ss << "\\note When AvailabilityManager:NightCycle is used in the zone component availability\n";
    ss << "\\note manager assignment list, the key choices for Control Type would only be\n";
    ss << "\\note StayOff and CycleOnControlZone\n";
    ss << "N1 , \\field Thermostat Tolerance\n";
    ss << "\\default 1.0\n";
    ss << "\\units deltaC\n";
    ss << "N2 , \\field Cycling Run Time\n";
    ss << "\\default 3600.\n";
    ss << "\\units s\n";
    ss << "A5 ; \\field Control Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note When AvailabilityManager:NightCycle is used in the zone component availability\n";
    ss << "\\note manager assignment list, the Control Zone Name should be the name of the zone in which the\n";
    ss << "\\note zone component is.\n";

    IddObjectType objType(IddObjectType::AvailabilityManager_NightCycle);
    OptionalIddObject oObj = IddObject::load("AvailabilityManager:NightCycle",
                                             "System Availability Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AvailabilityManager_NightCycle);
  return object;
}

IddObject createAvailabilityManager_DifferentialThermostatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AvailabilityManager:DifferentialThermostat,\n";
    ss << "\\memo Overrides fan/pump schedules depending on temperature difference between two nodes.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SystemAvailabilityManagers\n";
    ss << "A2 , \\field Hot Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A3 , \\field Cold Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Temperature Difference On Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "N2 ; \\field Temperature Difference Off Limit\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Defaults to Temperature Difference On Limit.\n";

    IddObjectType objType(IddObjectType::AvailabilityManager_DifferentialThermostat);
    OptionalIddObject oObj = IddObject::load("AvailabilityManager:DifferentialThermostat",
                                             "System Availability Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AvailabilityManager_DifferentialThermostat);
  return object;
}

IddObject createAvailabilityManager_HighTemperatureTurnOffIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AvailabilityManager:HighTemperatureTurnOff,\n";
    ss << "\\memo Overrides fan/pump schedules depending on temperature at sensor node.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SystemAvailabilityManagers\n";
    ss << "A2 , \\field Sensor Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 ; \\field Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";

    IddObjectType objType(IddObjectType::AvailabilityManager_HighTemperatureTurnOff);
    OptionalIddObject oObj = IddObject::load("AvailabilityManager:HighTemperatureTurnOff",
                                             "System Availability Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AvailabilityManager_HighTemperatureTurnOff);
  return object;
}

IddObject createAvailabilityManager_HighTemperatureTurnOnIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AvailabilityManager:HighTemperatureTurnOn,\n";
    ss << "\\memo Overrides fan/pump schedules depending on temperature at sensor node.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SystemAvailabilityManagers\n";
    ss << "A2 , \\field Sensor Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 ; \\field Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";

    IddObjectType objType(IddObjectType::AvailabilityManager_HighTemperatureTurnOn);
    OptionalIddObject oObj = IddObject::load("AvailabilityManager:HighTemperatureTurnOn",
                                             "System Availability Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AvailabilityManager_HighTemperatureTurnOn);
  return object;
}

IddObject createAvailabilityManager_LowTemperatureTurnOffIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AvailabilityManager:LowTemperatureTurnOff,\n";
    ss << "\\memo Overrides fan/pump schedules depending on temperature at sensor node.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SystemAvailabilityManagers\n";
    ss << "A2 , \\field Sensor Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 , \\field Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "A3 ; \\field Applicability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note If blank, defaults to always active\n";

    IddObjectType objType(IddObjectType::AvailabilityManager_LowTemperatureTurnOff);
    OptionalIddObject oObj = IddObject::load("AvailabilityManager:LowTemperatureTurnOff",
                                             "System Availability Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AvailabilityManager_LowTemperatureTurnOff);
  return object;
}

IddObject createAvailabilityManager_LowTemperatureTurnOnIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AvailabilityManager:LowTemperatureTurnOn,\n";
    ss << "\\memo Overrides fan/pump schedules depending on temperature at sensor node.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SystemAvailabilityManagers\n";
    ss << "A2 , \\field Sensor Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "N1 ; \\field Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";

    IddObjectType objType(IddObjectType::AvailabilityManager_LowTemperatureTurnOn);
    OptionalIddObject oObj = IddObject::load("AvailabilityManager:LowTemperatureTurnOn",
                                             "System Availability Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AvailabilityManager_LowTemperatureTurnOn);
  return object;
}

IddObject createAvailabilityManager_NightVentilationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AvailabilityManager:NightVentilation,\n";
    ss << "\\min-fields 7\n";
    ss << "\\memo depending on zone and outdoor conditions overrides fan schedule to do\n";
    ss << "\\memo precooling with outdoor air\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SystemAvailabilityManagers\n";
    ss << "A2 , \\field Applicability Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Fan Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Ventilation Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note One zone temperature must be above this scheduled temperature\n";
    ss << "\\note for night ventilation to be enabled\n";
    ss << "N1 , \\field Ventilation Temperature Difference\n";
    ss << "\\units deltaC\n";
    ss << "\\default 2.0\n";
    ss << "\\note The outdoor air temperature minus the control zone temperature\n";
    ss << "\\note must be greater than the ventilation delta T\n";
    ss << "N2 , \\field Ventilation Temperature Low Limit\n";
    ss << "\\units C\n";
    ss << "\\default 15.\n";
    ss << "\\note Night ventilation is disabled if any conditioned zone served by\n";
    ss << "\\note the system falls below this temperature\n";
    ss << "N3 , \\field Night Venting Flow Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.\n";
    ss << "\\note the fraction (could be > 1) of the design system Flow Rate at which\n";
    ss << "\\note night ventilation will be done\n";
    ss << "A5 ; \\field Control Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\required-field\n";
    ss << "\\note When AvailabilityManager:NightVentilation is used in the zone component availability\n";
    ss << "\\note manager assignment list, the Control Zone Name should be the name of the zone in which the\n";
    ss << "\\note zone component is.\n";

    IddObjectType objType(IddObjectType::AvailabilityManager_NightVentilation);
    OptionalIddObject oObj = IddObject::load("AvailabilityManager:NightVentilation",
                                             "System Availability Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AvailabilityManager_NightVentilation);
  return object;
}

IddObject createAvailabilityManager_HybridVentilationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AvailabilityManager:HybridVentilation,\n";
    ss << "\\min-fields 13\n";
    ss << "\\memo Depending on zone and outdoor conditions overrides window/door opening controls\n";
    ss << "\\memo to maximize natural ventilation and turn off an HVAC system when ventilation control\n";
    ss << "\\memo conditions are met.\n";
    ss << "\\memo This object (zone ventilation object name) has not been instrumented to work with\n";
    ss << "\\memo global Zone or Zone List names option for Ventilation:DesignFlowRate.  In order to\n";
    ss << "\\memo use, you must enter the single <Ventilation:DesignFlowRate> name in that\n";
    ss << "\\memo field. If it is a part of a global ventilation assignment the name will be\n";
    ss << "\\memo <Zone Name> <global Ventilation:DesignFlowRate> name.\n";
    ss << "\\memo Currently, hybrid ventilation manager is restricted to one per zone. It can either be applied\n";
    ss << "\\memo through the air loop or directly to the zone. If hybrid ventilation manager is applied to an\n";
    ss << "\\memo air loop and one of the zones served by that air loop also has hybrid ventilation manager,\n";
    ss << "\\memo then zone hybrid ventilation manager is disabled.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SystemAvailabilityManagers\n";
    ss << "A2 , \\field HVAC Air Loop Name\n";
    ss << "\\note Enter the name of an AirLoopHVAC or HVACTemplate:System:* object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirPrimaryLoops\n";
    ss << "\\object-list HVACTemplateSystems\n";
    ss << "\\note If this field is left blank, hybrid ventilation managers will be\n";
    ss << "\\note simulated for zone equipment control\n";
    ss << "A3 , \\field Controlled Zone Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note the controlled zone name should be a zone where a thermostat or humidistat is located\n";
    ss << "\\note served by an air primary loop.\n";
    ss << "A4 , \\field Ventilation Control Mode Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note The Ventilation control mode contains appropriate integer control types.\n";
    ss << "\\note 0 - uncontrolled (Natural ventilation and HVAC system are controlled by themselves)\n";
    ss << "\\note 1 = Temperature control\n";
    ss << "\\note 2 = Enthalpy control\n";
    ss << "\\note 3 = Dewpoint control\n";
    ss << "\\note 4 = Outdoor ventilation air control\n";
    ss << "A5 , \\field Use Weather File Rain Indicators\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "\\note If Yes, ventilation is shutoff when there is rain\n";
    ss << "\\note If No, there is no rain control\n";
    ss << "N1 , \\field Maximum Wind Speed\n";
    ss << "\\type real\n";
    ss << "\\units m/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 40.0\n";
    ss << "\\default 40.0\n";
    ss << "\\note this is the wind speed above which ventilation is shutoff\n";
    ss << "N2 , \\field Minimum Outdoor Temperature\n";
    ss << "\\note this is the outdoor temperature below which ventilation is shutoff\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\default -100\n";
    ss << "N3 , \\field Maximum Outdoor Temperature\n";
    ss << "\\note this is the outdoor temperature above which ventilation is shutoff\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\default 100\n";
    ss << "N4 , \\field Minimum Outdoor Enthalpy\n";
    ss << "\\note this is the outdoor Enthalpy below which ventilation is shutoff\n";
    ss << "\\units J/kg\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 300000.0\n";
    ss << "N5 , \\field Maximum Outdoor Enthalpy\n";
    ss << "\\note this is the outdoor Enthalpy above which ventilation is shutoff\n";
    ss << "\\units J/kg\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum< 300000.0\n";
    ss << "N6 , \\field Minimum Outdoor Dewpoint\n";
    ss << "\\note this is the outdoor temperature below which ventilation is shutoff\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\default -100\n";
    ss << "\\note Applicable only if Ventilation Control Mode = 3\n";
    ss << "N7 , \\field Maximum Outdoor Dewpoint\n";
    ss << "\\note this is the outdoor dewpoint above which ventilation is shutoff\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\default 100\n";
    ss << "\\note Applicable only if Ventilation Control Mode = 3\n";
    ss << "A6 , \\field Minimum Outdoor Ventilation Air Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Used only if Ventilation Control Mode = 4\n";
    ss << "A7 , \\field Opening Factor Function of Wind Speed Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearOrQuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note linear curve = a + b*WS\n";
    ss << "\\note quadratic curve = a + b*WS + c*WS**2\n";
    ss << "\\note WS = wind speed (m/s)\n";
    ss << "A8 , \\field AirflowNetwork Control Type Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note The schedule is used to incorporate operation of AirflowNetwork large opening\n";
    ss << "\\note objects and HVAC system operation.\n";
    ss << "A9 , \\field Simple Airflow Control Type Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note The schedule is used to incorporate operation of simple airflow objects and HVAC\n";
    ss << "\\note system operation.\n";
    ss << "\\note The simple airflow objects are Ventilation and Mixing only\n";
    ss << "A10; \\field ZoneVentilation Object Name\n";
    ss << "\\note This field has not been instrumented to work with\n";
    ss << "\\note global Zone or Zone List names option for Ventilation:DesignFlowRate.  In order to\n";
    ss << "\\note use, you must enter the single <Ventilation:DesignFlowRate> name in this field.\n";
    ss << "\\note If it is a part of a global ventilation assignment the name will be\n";
    ss << "\\note <Zone Name> <global Ventilation:DesignFlowRate> name.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list VentilationNames\n";
    ss << "\\note The other ZoneVentilation:* and ZoneMixing objects controlled in the same AirLoopHVAC\n";
    ss << "\\note will work in the same way as this ventilation object.\n";

    IddObjectType objType(IddObjectType::AvailabilityManager_HybridVentilation);
    OptionalIddObject oObj = IddObject::load("AvailabilityManager:HybridVentilation",
                                             "System Availability Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AvailabilityManager_HybridVentilation);
  return object;
}

IddObject createAvailabilityManagerAssignmentListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "AvailabilityManagerAssignmentList,\n";
    ss << "\\memo Defines the applicable managers used for an AirLoopHVAC or PlantLoop. The priority of\n";
    ss << "\\memo availability managers is based on a set of rules and are specific to the type of loop.\n";
    ss << "\\memo The output from each availability manager is an availability status flag:\n";
    ss << "\\memo NoAction, ForceOff, CycleOn, or CycleOnZoneFansOnly (used only for air loops).\n";
    ss << "\\min-fields 3\n";
    ss << "\\extensible:2 - repeat last two fields, remembering to remove ; from \"inner\" fields.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference SystemAvailabilityManagerLists\n";
    ss << "A2 , \\field Availability Manager 1 Object Type\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key AvailabilityManager:Scheduled\n";
    ss << "\\key AvailabilityManager:ScheduledOn\n";
    ss << "\\key AvailabilityManager:ScheduledOff\n";
    ss << "\\key AvailabilityManager:NightCycle\n";
    ss << "\\key AvailabilityManager:DifferentialThermostat\n";
    ss << "\\key AvailabilityManager:HighTemperatureTurnOff\n";
    ss << "\\key AvailabilityManager:HighTemperatureTurnOn\n";
    ss << "\\key AvailabilityManager:LowTemperatureTurnOff\n";
    ss << "\\key AvailabilityManager:LowTemperatureTurnOn\n";
    ss << "\\key AvailabilityManager:NightVentilation\n";
    ss << "A3 ; \\field Availability Manager 1 Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagers\n";

    IddObjectType objType(IddObjectType::AvailabilityManagerAssignmentList);
    OptionalIddObject oObj = IddObject::load("AvailabilityManagerAssignmentList",
                                             "System Availability Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::AvailabilityManagerAssignmentList);
  return object;
}

IddObject createSetpointManager_ScheduledIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:Scheduled,\n";
    ss << "\\memo The simplest Setpoint Manager simply uses a schedule to determine one\n";
    ss << "\\memo or more setpoints. Values of the nodes are not used as input.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\key MaximumTemperature\n";
    ss << "\\key MinimumTemperature\n";
    ss << "\\key HumidityRatio\n";
    ss << "\\key MaximumHumidityRatio\n";
    ss << "\\key MinimumHumidityRatio\n";
    ss << "\\key MassFlowRate\n";
    ss << "\\key MaximumMassFlowRate\n";
    ss << "\\key MinimumMassFlowRate\n";
    ss << "\\required-field\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\required-field\n";
    ss << "A4 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\note Node(s) at which control variable will be set\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::SetpointManager_Scheduled);
    OptionalIddObject oObj = IddObject::load("SetpointManager:Scheduled",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_Scheduled);
  return object;
}

IddObject createSetpointManager_Scheduled_DualSetpointIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:Scheduled:DualSetpoint,\n";
    ss << "\\memo This setpoint manager places a high and low schedule value\n";
    ss << "\\memo on one or more nodes.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\default Temperature\n";
    ss << "A3 , \\field High Setpoint Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\required-field\n";
    ss << "A4 , \\field Low Setpoint Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\required-field\n";
    ss << "A5 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\note Node(s) at which temperature will be set\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::SetpointManager_Scheduled_DualSetpoint);
    OptionalIddObject oObj = IddObject::load("SetpointManager:Scheduled:DualSetpoint",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_Scheduled_DualSetpoint);
  return object;
}

IddObject createSetpointManager_OutdoorAirResetIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:OutdoorAirReset,\n";
    ss << "\\memo The Outdoor Air Reset Setpoint Manager sets the supply air\n";
    ss << "\\memo temperature according to the outdoor air temperature using a reset rule.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\default Temperature\n";
    ss << "N1 , \\field Setpoint at Outdoor Low Temperature\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "N2 , \\field Outdoor Low Temperature\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field Setpoint at Outdoor High Temperature\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "N4 , \\field Outdoor High Temperature\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "A3 , \\field Setpoint Node or NodeList Name\n";
    ss << "\\note Node(s) at which temperature will be set\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Optional input.\n";
    ss << "\\note Schedule allows scheduling of the outdoor air reset rule - a schedule value\n";
    ss << "\\note of 1 means use the first rule; a value of 2 means use the second rule.\n";
    ss << "N5 , \\field Setpoint at Outdoor Low Temperature 2\n";
    ss << "\\note 2nd outdoor air temperature reset rule\n";
    ss << "\\units C\n";
    ss << "N6 , \\field Outdoor Low Temperature 2\n";
    ss << "\\note 2nd outdoor air temperature reset rule\n";
    ss << "\\units C\n";
    ss << "N7 , \\field Setpoint at Outdoor High Temperature 2\n";
    ss << "\\note 2nd outdoor air temperature reset rule\n";
    ss << "\\units C\n";
    ss << "N8 ; \\field Outdoor High Temperature 2\n";
    ss << "\\note 2nd outdoor air temperature reset rule\n";
    ss << "\\units C\n";

    IddObjectType objType(IddObjectType::SetpointManager_OutdoorAirReset);
    OptionalIddObject oObj = IddObject::load("SetpointManager:OutdoorAirReset",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_OutdoorAirReset);
  return object;
}

IddObject createSetpointManager_SingleZone_ReheatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:SingleZone:Reheat,\n";
    ss << "\\memo This setpoint manager detects the control zone load, zone inlet node flow rate, and\n";
    ss << "\\memo zone node temperature and calculates a setpoint temperature for the supply air that\n";
    ss << "\\memo will satisfy the zone load (heating or cooling) for the control zone. This setpoint\n";
    ss << "\\memo manager is not limited to reheat applications.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\default Temperature\n";
    ss << "N1 , \\field Minimum Supply Air Temperature\n";
    ss << "\\units C\n";
    ss << "\\default -99\n";
    ss << "N2 , \\field Maximum Supply Air Temperature\n";
    ss << "\\units C\n";
    ss << "\\default 99\n";
    ss << "A3 , \\field Control Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\required-field\n";
    ss << "A4 , \\field Zone Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Zone Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\note Node(s) at which the temperature will be set\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::SetpointManager_SingleZone_Reheat);
    OptionalIddObject oObj = IddObject::load("SetpointManager:SingleZone:Reheat",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_SingleZone_Reheat);
  return object;
}

IddObject createSetpointManager_SingleZone_HeatingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:SingleZone:Heating,\n";
    ss << "\\memo This setpoint manager detects the control zone load to meet the current heating\n";
    ss << "\\memo setpoint, zone inlet node flow rate, and zone node temperature, and calculates a\n";
    ss << "\\memo setpoint temperature for the supply air that will satisfy the zone heating load for\n";
    ss << "\\memo the control zone.\n";
    ss << "\\min-fields 8\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\default Temperature\n";
    ss << "N1 , \\field Minimum Supply Air Temperature\n";
    ss << "\\units C\n";
    ss << "\\default -99\n";
    ss << "N2 , \\field Maximum Supply Air Temperature\n";
    ss << "\\units C\n";
    ss << "\\default 99\n";
    ss << "A3 , \\field Control Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\required-field\n";
    ss << "A4 , \\field Zone Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Zone Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\note Node(s) at which the temperature will be set\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::SetpointManager_SingleZone_Heating);
    OptionalIddObject oObj = IddObject::load("SetpointManager:SingleZone:Heating",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_SingleZone_Heating);
  return object;
}

IddObject createSetpointManager_SingleZone_CoolingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:SingleZone:Cooling,\n";
    ss << "\\memo This setpoint manager detects the control zone load to meet the current cooling\n";
    ss << "\\memo setpoint, zone inlet node flow rate, and zone node temperature, and calculates a\n";
    ss << "\\memo setpoint temperature for the supply air that will satisfy the zone cooling load for\n";
    ss << "\\memo the control zone.\n";
    ss << "\\min-fields 8\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\default Temperature\n";
    ss << "N1 , \\field Minimum Supply Air Temperature\n";
    ss << "\\units C\n";
    ss << "\\default -99\n";
    ss << "N2 , \\field Maximum Supply Air Temperature\n";
    ss << "\\units C\n";
    ss << "\\default 99\n";
    ss << "A3 , \\field Control Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\required-field\n";
    ss << "A4 , \\field Zone Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Zone Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\note Node(s) at which the temperature will be set\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::SetpointManager_SingleZone_Cooling);
    OptionalIddObject oObj = IddObject::load("SetpointManager:SingleZone:Cooling",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_SingleZone_Cooling);
  return object;
}

IddObject createSetpointManager_SingleZone_Humidity_MinimumIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:SingleZone:Humidity:Minimum,\n";
    ss << "\\memo The Single Zone Minimum Humidity Setpoint Manager allows the\n";
    ss << "\\memo control of a single zone minimum humidity level.\n";
    ss << "\\memo This setpoint manager can be used in conjunction with\n";
    ss << "\\memo object ZoneControl:Humidistat to detect humidity levels.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\deprecated\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\deprecated\n";
    ss << "A4 , \\field Setpoint Node or NodeList Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Node(s) at which humidity ratio setpoint will be set\n";
    ss << "A5 ; \\field Control Zone Air Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of the zone air node for the humidity control zone\n";

    IddObjectType objType(IddObjectType::SetpointManager_SingleZone_Humidity_Minimum);
    OptionalIddObject oObj = IddObject::load("SetpointManager:SingleZone:Humidity:Minimum",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_SingleZone_Humidity_Minimum);
  return object;
}

IddObject createSetpointManager_SingleZone_Humidity_MaximumIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:SingleZone:Humidity:Maximum,\n";
    ss << "\\memo The Single Zone Maximum Humidity Setpoint Manager allows the\n";
    ss << "\\memo control of a single zone maximum humidity level.\n";
    ss << "\\memo This setpoint manager can be used in conjunction with\n";
    ss << "\\memo object ZoneControl:Humidistat to detect humidity levels.\n";
    ss << "\\min-fields 5\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\deprecated\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\deprecated\n";
    ss << "A4 , \\field Setpoint Node or NodeList Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Node(s) at which humidity ratio setpoint will be set\n";
    ss << "A5 ; \\field Control Zone Air Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Name of the zone air node for the humidity control zone\n";

    IddObjectType objType(IddObjectType::SetpointManager_SingleZone_Humidity_Maximum);
    OptionalIddObject oObj = IddObject::load("SetpointManager:SingleZone:Humidity:Maximum",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_SingleZone_Humidity_Maximum);
  return object;
}

IddObject createSetpointManager_MixedAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:MixedAir,\n";
    ss << "\\memo The Mixed Air Setpoint Manager is meant to be used in conjunction\n";
    ss << "\\memo with a Controller:OutdoorAir object. This setpoint manager is used\n";
    ss << "\\memo to establish a temperature setpoint at the mixed air node.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\default Temperature\n";
    ss << "A3 , \\field Reference Setpoint Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Fan Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A5 , \\field Fan Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "A6 , \\field Setpoint Node or NodeList Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Node(s) at which the temperature will be set\n";
    ss << "A7 , \\field Cooling Coil Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Optional field used to limit economizer operation to prevent freezing of DX cooling coil.\n";
    ss << "A8 , \\field Cooling coil Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Optional field used to limit economizer operation to prevent freezing of DX cooling coil.\n";
    ss << "N1 ; \\field Minimum Temperature at Cooling Coil Outlet Node\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 7.2\n";
    ss << "\\note Optional field used to limit economizer operation to prevent freezing of DX cooling coil.\n";

    IddObjectType objType(IddObjectType::SetpointManager_MixedAir);
    OptionalIddObject oObj = IddObject::load("SetpointManager:MixedAir",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_MixedAir);
  return object;
}

IddObject createSetpointManager_OutdoorAirPretreatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:OutdoorAirPretreat,\n";
    ss << "\\min-fields 11\n";
    ss << "\\memo This setpoint manager determines the required\n";
    ss << "\\memo conditions at the outdoor air stream node which will\n";
    ss << "\\memo produce the reference setpoint condition at the\n";
    ss << "\\memo mixed air node when mixed with the return air stream\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\key HumidityRatio\n";
    ss << "\\key MaximumHumidityRatio\n";
    ss << "\\key MinimumHumidityRatio\n";
    ss << "N1 , \\field Minimum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\default -99\n";
    ss << "\\note Applicable only if Control variable is Temperature\n";
    ss << "N2 , \\field Maximum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\default 99\n";
    ss << "\\note Applicable only if Control variable is Temperature\n";
    ss << "N3 , \\field Minimum Setpoint Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.00001\n";
    ss << "\\note Applicable only if Control variable is\n";
    ss << "\\note MaximumHumidityRatio, MinimumHumidityRatio, or HumidityRatio - then minimum is 0.00001\n";
    ss << "N4 , \\field Maximum Setpoint Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Applicable only if Control variable is\n";
    ss << "\\note MaximumHumidityRatio, MinimumHumidityRatio, or HumidityRatio - then minimum is 0.00001\n";
    ss << "A3 , \\field Reference Setpoint Node Name\n";
    ss << "\\type node\n";
    ss << "\\note The current setpoint at this node is the\n";
    ss << "\\note desired condition for the Mixed Air Node\n";
    ss << "\\note This node must have a valid setpoint\n";
    ss << "\\note which has been set by another setpoint manager\n";
    ss << "A4 , \\field Mixed Air Stream Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Name of Mixed Air Node\n";
    ss << "\\required-field\n";
    ss << "A5 , \\field Outdoor Air Stream Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Name of Outdoor Air Stream Node\n";
    ss << "\\required-field\n";
    ss << "A6 , \\field Return Air Stream Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Name of Return Air Stream Node\n";
    ss << "\\required-field\n";
    ss << "A7 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "\\note Node(s) at which the temperature or humidity\n";
    ss << "\\note ratio will be set\n";

    IddObjectType objType(IddObjectType::SetpointManager_OutdoorAirPretreat);
    OptionalIddObject oObj = IddObject::load("SetpointManager:OutdoorAirPretreat",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_OutdoorAirPretreat);
  return object;
}

IddObject createSetpointManager_WarmestIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:Warmest,\n";
    ss << "\\memo This SetpointManager resets the cooling supply air temperature\n";
    ss << "\\memo of a central forced air HVAC system according to the\n";
    ss << "\\memo cooling demand of the warmest zone.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\default Temperature\n";
    ss << "A3 , \\field HVAC Air Loop Name\n";
    ss << "\\note Enter the name of an AirLoopHVAC object\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirPrimaryLoops\n";
    ss << "N1 , \\field Minimum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 12.\n";
    ss << "N2 , \\field Maximum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 18.\n";
    ss << "A4 , \\field Strategy\n";
    ss << "\\type choice\n";
    ss << "\\key MaximumTemperature\n";
    ss << "\\default MaximumTemperature\n";
    ss << "A5 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Node(s) at which the temperature will be set\n";

    IddObjectType objType(IddObjectType::SetpointManager_Warmest);
    OptionalIddObject oObj = IddObject::load("SetpointManager:Warmest",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_Warmest);
  return object;
}

IddObject createSetpointManager_ColdestIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:Coldest,\n";
    ss << "\\memo This SetpointManager is used in dual duct systems to reset\n";
    ss << "\\memo the setpoint temperature of the air in the heating supply duct.\n";
    ss << "\\memo Usually it is used in conjunction with a SetpointManager:Warmest\n";
    ss << "\\memo resetting the temperature of the air in the cooling supply duct.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\default Temperature\n";
    ss << "A3 , \\field HVAC Air Loop Name\n";
    ss << "\\note Enter the name of an AirLoopHVAC object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirPrimaryLoops\n";
    ss << "N1 , \\field Minimum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 20.\n";
    ss << "N2 , \\field Maximum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 50.\n";
    ss << "A4 , \\field Strategy\n";
    ss << "\\type choice\n";
    ss << "\\key MinimumTemperature\n";
    ss << "\\default MinimumTemperature\n";
    ss << "A5 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Node(s) at which the temperature will be set\n";

    IddObjectType objType(IddObjectType::SetpointManager_Coldest);
    OptionalIddObject oObj = IddObject::load("SetpointManager:Coldest",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_Coldest);
  return object;
}

IddObject createSetpointManager_ReturnAirBypassFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:ReturnAirBypassFlow,\n";
    ss << "\\min-fields 4\n";
    ss << "\\memo This setpoint manager determines the required\n";
    ss << "\\memo mass flow rate through a return air bypass duct\n";
    ss << "\\memo to meet the specified temperature setpoint\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Flow\n";
    ss << "\\default Flow\n";
    ss << "A3 , \\field HVAC Air Loop Name\n";
    ss << "\\note Enter the name of an AirLoopHVAC object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirPrimaryLoops\n";
    ss << "A4 ; \\field Temperature Setpoint Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::SetpointManager_ReturnAirBypassFlow);
    OptionalIddObject oObj = IddObject::load("SetpointManager:ReturnAirBypassFlow",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_ReturnAirBypassFlow);
  return object;
}

IddObject createSetpointManager_WarmestTemperatureFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:WarmestTemperatureFlow,\n";
    ss << "\\min-fields 8\n";
    ss << "\\memo This setpoint manager sets both the supply air temperature\n";
    ss << "\\memo and the supply air flow rate.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "A3 , \\field HVAC Air Loop Name\n";
    ss << "\\note Enter the name of an AirLoopHVAC object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirPrimaryLoops\n";
    ss << "N1 , \\field Minimum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 12.\n";
    ss << "N2 , \\field Maximum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 18.\n";
    ss << "A4 , \\field Strategy\n";
    ss << "\\note For TemperatureFirst the manager tries to find the highest setpoint temperature\n";
    ss << "\\note that will satisfy all the zone cooling loads at minimum supply air flow rate.\n";
    ss << "\\note If this setpoint temperature is less than the minimum, the setpoint temperature is set\n";
    ss << "\\note to the minimum, and the supply air flow rate is increased to meet the loads.\n";
    ss << "\\note For FlowFirst the manager tries to find the lowest supply air flow rate\n";
    ss << "\\note that will satisfy all the zone cooling loads at the maximum setpoint temperature.\n";
    ss << "\\note If this flow is greater than the maximum, the flow is set to the maximum and the\n";
    ss << "\\note setpoint temperature is reduced to satisfy the cooling loads.\n";
    ss << "\\type choice\n";
    ss << "\\key TemperatureFirst\n";
    ss << "\\key FlowFirst\n";
    ss << "\\default TemperatureFirst\n";
    ss << "A5 , \\field Setpoint Node or NodeList Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Node(s) at which the temperature will be set\n";
    ss << "N3 ; \\field Minimum Turndown Ratio\n";
    ss << "\\note Fraction of the maximum supply air flow rate.\n";
    ss << "\\note Used to define the minimum supply flow for the TemperatureFirst strategy.\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.2\n";

    IddObjectType objType(IddObjectType::SetpointManager_WarmestTemperatureFlow);
    OptionalIddObject oObj = IddObject::load("SetpointManager:WarmestTemperatureFlow",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_WarmestTemperatureFlow);
  return object;
}

IddObject createSetpointManager_MultiZone_Heating_AverageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:MultiZone:Heating:Average,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo This setpoint manager sets the average supply air temperature based on the heating load\n";
    ss << "\\memo requirements of all controlled zones in an air loop served by a central air-conditioner.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field HVAC Air Loop Name\n";
    ss << "\\note Enter the name of an AirLoopHVAC object\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirPrimaryLoops\n";
    ss << "N1 , \\field Minimum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 20.\n";
    ss << "N2 , \\field Maximum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 50.\n";
    ss << "A3 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Node(s) at which the temperature will be set\n";

    IddObjectType objType(IddObjectType::SetpointManager_MultiZone_Heating_Average);
    OptionalIddObject oObj = IddObject::load("SetpointManager:MultiZone:Heating:Average",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_MultiZone_Heating_Average);
  return object;
}

IddObject createSetpointManager_MultiZone_Cooling_AverageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:MultiZone:Cooling:Average,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo This setpoint manager sets the average supply air temperature based on the cooling load\n";
    ss << "\\memo requirements of all controlled zones in an air loop served by a central air-conditioner.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field HVAC Air Loop Name\n";
    ss << "\\note Enter the name of an AirLoopHVAC object\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirPrimaryLoops\n";
    ss << "N1 , \\field Minimum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 12.\n";
    ss << "N2 , \\field Maximum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 18.\n";
    ss << "A3 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Node(s) at which the temperature will be set\n";

    IddObjectType objType(IddObjectType::SetpointManager_MultiZone_Cooling_Average);
    OptionalIddObject oObj = IddObject::load("SetpointManager:MultiZone:Cooling:Average",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_MultiZone_Cooling_Average);
  return object;
}

IddObject createSetpointManager_MultiZone_MinimumHumidity_AverageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:MultiZone:MinimumHumidity:Average,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo This setpoint manager sets the average supply air minimum humidity ratio based on moisture\n";
    ss << "\\memo load requirements of all controlled zones in an air loop served by a central air-conditioner.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field HVAC Air Loop Name\n";
    ss << "\\note Enter the name of an AirLoopHVAC object\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirPrimaryLoops\n";
    ss << "N1 , \\field Minimum Setpoint Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.005\n";
    ss << "N2 , \\field Maximum Setpoint Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.012\n";
    ss << "A3 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Node(s) at which the humidity ratio will be set\n";

    IddObjectType objType(IddObjectType::SetpointManager_MultiZone_MinimumHumidity_Average);
    OptionalIddObject oObj = IddObject::load("SetpointManager:MultiZone:MinimumHumidity:Average",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_MultiZone_MinimumHumidity_Average);
  return object;
}

IddObject createSetpointManager_MultiZone_MaximumHumidity_AverageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:MultiZone:MaximumHumidity:Average,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo This setpoint manager sets the average supply air maximum humidity ratio based on moisture\n";
    ss << "\\memo load requirements of all controlled zones in an air loop served by a central air-conditioner.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field HVAC Air Loop Name\n";
    ss << "\\note Enter the name of an AirLoopHVAC object\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirPrimaryLoops\n";
    ss << "N1 , \\field Minimum Setpoint Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.008\n";
    ss << "N2 , \\field Maximum Setpoint Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.015\n";
    ss << "A3 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Node(s) at which the humidity ratio will be set\n";

    IddObjectType objType(IddObjectType::SetpointManager_MultiZone_MaximumHumidity_Average);
    OptionalIddObject oObj = IddObject::load("SetpointManager:MultiZone:MaximumHumidity:Average",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_MultiZone_MaximumHumidity_Average);
  return object;
}

IddObject createSetpointManager_MultiZone_Humidity_MinimumIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:MultiZone:Humidity:Minimum,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo This setpoint manager sets the minimum supply air humidity ratio based on humidification\n";
    ss << "\\memo requirements of a controlled zone with critical humidity ratio setpoint (i.e., a zone with\n";
    ss << "\\memo the highest humidity ratio setpoint) in an air loop served by a central air-conditioner.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field HVAC Air Loop Name\n";
    ss << "\\note Enter the name of an AirLoopHVAC object\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirPrimaryLoops\n";
    ss << "N1 , \\field Minimum Setpoint Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.005\n";
    ss << "N2 , \\field Maximum Setpoint Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.012\n";
    ss << "A3 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Node(s) at which the humidity ratio will be set\n";

    IddObjectType objType(IddObjectType::SetpointManager_MultiZone_Humidity_Minimum);
    OptionalIddObject oObj = IddObject::load("SetpointManager:MultiZone:Humidity:Minimum",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_MultiZone_Humidity_Minimum);
  return object;
}

IddObject createSetpointManager_MultiZone_Humidity_MaximumIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:MultiZone:Humidity:Maximum,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo This setpoint manager sets the maximum supply air humidity ratio based on dehumidification\n";
    ss << "\\memo requirements of a controlled zone with critical humidity ratio setpoint (i.e., a zone with\n";
    ss << "\\memo the lowest humidity ratio setpoint) in an air loop served by a central air-conditioner.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field HVAC Air Loop Name\n";
    ss << "\\note Enter the name of an AirLoopHVAC object\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AirPrimaryLoops\n";
    ss << "N1 , \\field Minimum Setpoint Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.008\n";
    ss << "N2 , \\field Maximum Setpoint Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.015\n";
    ss << "A3 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";
    ss << "\\note Node(s) at which the humidity ratio will be set\n";

    IddObjectType objType(IddObjectType::SetpointManager_MultiZone_Humidity_Maximum);
    OptionalIddObject oObj = IddObject::load("SetpointManager:MultiZone:Humidity:Maximum",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_MultiZone_Humidity_Maximum);
  return object;
}

IddObject createSetpointManager_FollowOutdoorAirTemperatureIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:FollowOutdoorAirTemperature,\n";
    ss << "\\memo This setpoint manager is used to place a temperature setpoint on a system node\n";
    ss << "\\memo that is derived from the current outdoor air environmental conditions.\n";
    ss << "\\memo The outdoor air conditions are obtained from the weather information during the simulation.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\key MinimumTemperature\n";
    ss << "\\key MaximumTemperature\n";
    ss << "\\default Temperature\n";
    ss << "A3 , \\field Reference Temperature Type\n";
    ss << "\\type choice\n";
    ss << "\\key OutdoorAirWetBulb\n";
    ss << "\\key OutdoorAirDryBulb\n";
    ss << "\\default OutdoorAirWetBulb\n";
    ss << "N1 , \\field Offset Temperature Difference\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Maximum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Minimum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "A4 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\note Node(s) at which control variable will be set\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::SetpointManager_FollowOutdoorAirTemperature);
    OptionalIddObject oObj = IddObject::load("SetpointManager:FollowOutdoorAirTemperature",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_FollowOutdoorAirTemperature);
  return object;
}

IddObject createSetpointManager_FollowSystemNodeTemperatureIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:FollowSystemNodeTemperature,\n";
    ss << "\\memo This setpoint manager is used to place a temperature setpoint on a\n";
    ss << "\\memo system node that is derived from the current temperatures at a separate\n";
    ss << "\\memo system node.  The current value of the temperature at a reference node\n";
    ss << "\\memo is obtained and used to generate setpoint on a second system node.\n";
    ss << "\\memo If the reference node is also designated to be an outdoor air (intake) node,\n";
    ss << "\\memo then this setpoint manager can be used to follow outdoor air conditions\n";
    ss << "\\memo that are adjusted for altitude.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\key MinimumTemperature\n";
    ss << "\\key MaximumTemperature\n";
    ss << "\\default Temperature\n";
    ss << "A3,  \\field Reference Node Name\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Reference Temperature Type\n";
    ss << "\\type choice\n";
    ss << "\\key NodeWetBulb\n";
    ss << "\\key NodeDryBulb\n";
    ss << "\\default NodeDryBulb\n";
    ss << "N1 , \\field Offset Temperature Difference\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Maximum Limit Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Minimum Limit Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "A5 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\note Node(s) at which control variable will be set\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::SetpointManager_FollowSystemNodeTemperature);
    OptionalIddObject oObj = IddObject::load("SetpointManager:FollowSystemNodeTemperature",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_FollowSystemNodeTemperature);
  return object;
}

IddObject createSetpointManager_FollowGroundTemperatureIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:FollowGroundTemperature,\n";
    ss << "\\memo This setpoint manager is used to place a temperature setpoint on a\n";
    ss << "\\memo system node that is derived from a current ground temperature.\n";
    ss << "\\memo The ground temperatures are specified in different\n";
    ss << "\\memo Site:GroundTemperature:* objects and used during the simulation.\n";
    ss << "\\memo This setpoint manager is primarily intended for condenser or plant loops\n";
    ss << "\\memo using some type of ground heat exchanger.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\key MinimumTemperature\n";
    ss << "\\key MaximumTemperature\n";
    ss << "\\default Temperature\n";
    ss << "A3 , \\field Reference Ground Temperature Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key Site:GroundTemperature:BuildingSurface\n";
    ss << "\\key Site:GroundTemperature:Shallow\n";
    ss << "\\key Site:GroundTemperature:Deep\n";
    ss << "\\key Site:GroundTemperature:FCfactorMethod\n";
    ss << "N1 , \\field Offset Temperature Difference\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Maximum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Minimum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "A4 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\note Node(s) at which control variable will be set\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::SetpointManager_FollowGroundTemperature);
    OptionalIddObject oObj = IddObject::load("SetpointManager:FollowGroundTemperature",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_FollowGroundTemperature);
  return object;
}

IddObject createSetpointManager_CondenserEnteringResetIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:CondenserEnteringReset,\n";
    ss << "\\min-fields 10\n";
    ss << "\\memo This setpoint manager uses one curve to determine the optimum condenser entering water temperature\n";
    ss << "\\memo for a given timestep and two other curves to place boundary conditions on the setpoint value.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\default Temperature\n";
    ss << "A3 , \\field Default Condenser Entering Water Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\required-field\n";
    ss << "\\note This scheduled setpoint value is only used in a given timestep if the\n";
    ss << "\\note \"Optimized\" Condenser Entering Temperature does not fall within the prescribed\n";
    ss << "\\note boundary conditions.\n";
    ss << "A4 , \\field Minimum Design Wetbulb Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadLinearCurves\n";
    ss << "\\object-list MultiVariateTables\n";
    ss << "A5 , \\field Minimum Outside Air Wetbulb Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadLinearCurves\n";
    ss << "\\object-list MultiVariateTables\n";
    ss << "A6 , \\field Optimized Cond Entering Water Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadLinearCurves\n";
    ss << "\\object-list MultiVariateTables\n";
    ss << "N1 , \\field Minimum Lift\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 11.1\n";
    ss << "N2 , \\field Maximum Condenser Entering Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 32\n";
    ss << "N3 , \\field Cooling Tower Design Inlet Air Wet-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 25.56\n";
    ss << "A7 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\note Node(s) at which control variable will be set\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::SetpointManager_CondenserEnteringReset);
    OptionalIddObject oObj = IddObject::load("SetpointManager:CondenserEnteringReset",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_CondenserEnteringReset);
  return object;
}

IddObject createSetpointManager_CondenserEnteringReset_IdealIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:CondenserEnteringReset:Ideal,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo This setpoint manager determine the ideal optimum condenser entering water temperature\n";
    ss << "\\memo setpoint for a given timestep.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\default Temperature\n";
    ss << "N1 , \\field Minimum Lift\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 11.1\n";
    ss << "N2 , \\field Maximum Condenser Entering Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 32\n";
    ss << "A3 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\note Node(s) at which control variable will be set\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::SetpointManager_CondenserEnteringReset_Ideal);
    OptionalIddObject oObj = IddObject::load("SetpointManager:CondenserEnteringReset:Ideal",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_CondenserEnteringReset_Ideal);
  return object;
}

IddObject createSetpointManager_SingleZone_OneStageCoolingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:SingleZone:OneStageCooling,\n";
    ss << "\\memo This object can be used with CoilSystem:Cooling:DX to model on/off cycling control\n";
    ss << "\\memo of single stage air systems. Setpoints are modulated to run coil full on or full off\n";
    ss << "\\memo depending on zone conditions. Intended for use with ZoneControl:Thermostat:StagedDualSetpoint\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field Cooling Stage On Supply Air Setpoint Temperature\n";
    ss << "\\note This is the setpoint value applied when cooling device is to cycle ON\n";
    ss << "\\units C\n";
    ss << "\\default -99\n";
    ss << "N2 , \\field Cooling Stage Off Supply Air Setpoint Temperature\n";
    ss << "\\note This is the setpoint value applied when cooling device is to cycle OFF\n";
    ss << "\\units C\n";
    ss << "\\default 99\n";
    ss << "A2 , \\field Control Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\required-field\n";
    ss << "A3 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\note Node(s) at which the temperature will be set\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::SetpointManager_SingleZone_OneStageCooling);
    OptionalIddObject oObj = IddObject::load("SetpointManager:SingleZone:OneStageCooling",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_SingleZone_OneStageCooling);
  return object;
}

IddObject createSetpointManager_SingleZone_OneStageHeatingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:SingleZone:OneStageHeating,\n";
    ss << "\\memo This object can be used with CoilSystem:Heating:DX, Coil:Heating:Gas,\n";
    ss << "\\memo Coil:Heating:Electric to model on/off cycling control of single stage air systems.\n";
    ss << "\\memo Setpoints are modulated to run coil full on or full off depending on zone conditions.\n";
    ss << "\\memo Intended for use with ZoneControl:Thermostat:StagedDualSetpoint.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field Heating Stage On Supply Air Setpoint Temperature\n";
    ss << "\\note This is the setpoint value applied when heating device is to cycle ON\n";
    ss << "\\units C\n";
    ss << "\\default 99\n";
    ss << "N2 , \\field Heating Stage Off Supply Air Setpoint Temperature\n";
    ss << "\\note This is the setpoint value applied when heating device is to cycle OFF\n";
    ss << "\\units C\n";
    ss << "\\default -99\n";
    ss << "A2 , \\field Control Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\required-field\n";
    ss << "A3 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\note Node(s) at which the temperature will be set\n";
    ss << "\\required-field\n";
    ss << "\\type node\n";

    IddObjectType objType(IddObjectType::SetpointManager_SingleZone_OneStageHeating);
    OptionalIddObject oObj = IddObject::load("SetpointManager:SingleZone:OneStageHeating",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_SingleZone_OneStageHeating);
  return object;
}

IddObject createSetpointManager_ReturnTemperature_ChilledWaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:ReturnTemperature:ChilledWater,\n";
    ss << "\\memo This setpoint manager is used to place a temperature setpoint on a plant supply\n";
    ss << "\\memo  outlet node based on a target return water setpoint. The setpoint manager attempts\n";
    ss << "\\memo  to achieve the desired return water temperature by adjusting the supply temperature\n";
    ss << "\\memo  setpoint based on the plant conditions at each system time step.\n";
    ss << "\\min-fields 7\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Plant Loop Supply Outlet Node\n";
    ss << "\\note This is the name of the supply outlet node for the plant being controlled by this\n";
    ss << "\\note setpoint manager.  Typically this is where the setpoint will be actuated for\n";
    ss << "\\note supply equipment to control to, but not necessarily.  This setpoint manager will\n";
    ss << "\\note mine that information from the internal plant data structures.\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A3,  \\field Plant Loop Supply Inlet Node\n";
    ss << "\\note This is the name of the supply inlet node for the plant being controlled with this\n";
    ss << "\\note setpoint manager. The temperature on this node is controlled by actuating the\n";
    ss << "\\note supply setpoint.\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "N1,  \\field Minimum Supply Temperature Setpoint\n";
    ss << "\\note This is the minimum chilled water supply temperature setpoint.  This is also used as the default\n";
    ss << "\\note setpoint during no-load or negative-load conditions and during initialization.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 5\n";
    ss << "N2,  \\field Maximum Supply Temperature Setpoint\n";
    ss << "\\note This is the maximum reset temperature for the chilled water supply.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 10\n";
    ss << "A4,  \\field Return Temperature Setpoint Input Type\n";
    ss << "\\note This defines whether the chilled water return temperature target is constant,\n";
    ss << "\\note scheduled, or specified on the supply inlet node by a separate setpoint manager.\n";
    ss << "\\type choice\n";
    ss << "\\key Constant\n";
    ss << "\\key Scheduled\n";
    ss << "\\key ReturnTemperatureSetpoint\n";
    ss << "\\required-field\n";
    ss << "N3,  \\field Return Temperature Setpoint Constant Value\n";
    ss << "\\note This is the desired return temperature target, which is met by adjusting the\n";
    ss << "\\note supply temperature setpoint. This constant value is only used if\n";
    ss << "\\note the Design Chilled Water Return Temperature Input Type is Constant\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 13\n";
    ss << "A5;  \\field Return Temperature Setpoint Schedule Name\n";
    ss << "\\note This is the desired return temperature target, which is met by adjusting the\n";
    ss << "\\note supply temperature setpoint. This is a schedule name to allow the return temperature\n";
    ss << "\\note target value to be scheduled.  This field is only used if\n";
    ss << "\\note the Design Chilled Water Return Temperature Input Type is Scheduled\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::SetpointManager_ReturnTemperature_ChilledWater);
    OptionalIddObject oObj = IddObject::load("SetpointManager:ReturnTemperature:ChilledWater",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_ReturnTemperature_ChilledWater);
  return object;
}

IddObject createSetpointManager_ReturnTemperature_HotWaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "SetpointManager:ReturnTemperature:HotWater,\n";
    ss << "\\memo This setpoint manager is used to place a temperature setpoint on a plant supply\n";
    ss << "\\memo  outlet node based on a target return water setpoint. The setpoint manager attempts\n";
    ss << "\\memo  to achieve the desired return water temperature by adjusting the supply temperature\n";
    ss << "\\memo  setpoint based on the plant conditions at each system time step.\n";
    ss << "\\min-fields 7\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Plant Loop Supply Outlet Node\n";
    ss << "\\note This is the name of the supply outlet node for the plant being controlled by this\n";
    ss << "\\note setpoint manager.  Typically this is where the setpoint will be actuated for\n";
    ss << "\\note supply equipment to control to, but not necessarily.  This setpoint manager will\n";
    ss << "\\note mine that information from the internal plant data structures.\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "A3,  \\field Plant Loop Supply Inlet Node\n";
    ss << "\\note This is the name of the supply inlet node for the plant being controlled with this\n";
    ss << "\\note setpoint manager. The temperature on this node is controlled by actuating the\n";
    ss << "\\note supply setpoint.\n";
    ss << "\\type node\n";
    ss << "\\required-field\n";
    ss << "N1,  \\field Minimum Supply Temperature Setpoint\n";
    ss << "\\note This is the minimum reset temperature for the hot water supply.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 77\n";
    ss << "N2,  \\field Maximum Supply Temperature Setpoint\n";
    ss << "\\note This is the maximum hot water supply temperature setpoint.  This is also used as the default\n";
    ss << "\\note setpoint during no-load or negative-load conditions and during initialization.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 82\n";
    ss << "A4,  \\field Return Temperature Setpoint Input Type\n";
    ss << "\\note This defines whether the hot water return temperature target is constant,\n";
    ss << "\\note scheduled, or specified on the supply inlet node by a separate setpoint manager.\n";
    ss << "\\type choice\n";
    ss << "\\key Constant\n";
    ss << "\\key Scheduled\n";
    ss << "\\key ReturnTemperatureSetpoint\n";
    ss << "\\required-field\n";
    ss << "N3,  \\field Return Temperature Setpoint Constant Value\n";
    ss << "\\note This is the desired return temperature target, which is met by adjusting the\n";
    ss << "\\note supply temperature setpoint. This constant value is only used if\n";
    ss << "\\note the Design Hot Water Return Temperature Input Type is Constant\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 71\n";
    ss << "A5;  \\field Return Temperature Setpoint Schedule Name\n";
    ss << "\\note This is the desired return temperature target, which is met by adjusting the\n";
    ss << "\\note supply temperature setpoint. This is a schedule name to allow the return temperature\n";
    ss << "\\note target value to be scheduled.  This field is only used if\n";
    ss << "\\note the Design Hot Water Return Temperature Input Type is Scheduled\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::SetpointManager_ReturnTemperature_HotWater);
    OptionalIddObject oObj = IddObject::load("SetpointManager:ReturnTemperature:HotWater",
                                             "Setpoint Managers",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::SetpointManager_ReturnTemperature_HotWater);
  return object;
}

IddObject createRefrigeration_CaseIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Refrigeration:Case,\n";
    ss << "\\memo The Refrigeration Case object works in conjunction with a compressor rack, a\n";
    ss << "\\memo refrigeration system, or a secondary loop to simulate the performance of a\n";
    ss << "\\memo refrigerated case system. The object calculates the energy use for lights, fans and\n";
    ss << "\\memo anti-sweat heaters and accounts for the sensible and latent heat exchange with the\n";
    ss << "\\memo surrounding environment (termed \"case credits\") which impacts the temperature\n";
    ss << "\\memo and humidity in the zone where the case is located.\n";
    ss << "\\min-fields 28\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RefrigerationCaseAndWalkInAndListNames\n";
    ss << "\\reference RefrigerationCaseAndWalkInNames\n";
    ss << "A2 ,  \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "A3 ,  \\field Zone Name\n";
    ss << "\\note This must be a controlled zone and appear in a ZoneHVAC:EquipmentConnections object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1 ,  \\field Rated Ambient Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 23.9\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2 ,  \\field Rated Ambient Relative Humidity\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\default 55.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 100.0\n";
    ss << "N3 ,  \\field Rated Total Cooling Capacity per Unit Length\n";
    ss << "\\type real\n";
    ss << "\\units W/m\n";
    ss << "\\default 1900\n";
    ss << "\\minimum> 0.0\n";
    ss << "N4 ,  \\field Rated Latent Heat Ratio\n";
    ss << "\\type real\n";
    ss << "\\default 0.3\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N5 ,  \\field Rated Runtime Fraction\n";
    ss << "\\type real\n";
    ss << "\\default 0.85\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N6 ,  \\field Case Length\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 3.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "N7,   \\field Case Operating Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 1.1\n";
    ss << "\\maximum< 20.0\n";
    ss << "A4 ,  \\field Latent Case Credit Curve Type\n";
    ss << "\\type choice\n";
    ss << "\\key CaseTemperatureMethod\n";
    ss << "\\key RelativeHumidityMethod\n";
    ss << "\\key DewpointMethod\n";
    ss << "\\default CaseTemperatureMethod\n";
    ss << "A5 ,  \\field Latent Case Credit Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "N8 ,  \\field Standard Case Fan Power per Unit Length\n";
    ss << "\\type real\n";
    ss << "\\units W/m\n";
    ss << "\\default 75.0\n";
    ss << "\\minimum 0.0\n";
    ss << "N9 ,  \\field Operating Case Fan Power per Unit Length\n";
    ss << "\\type real\n";
    ss << "\\units W/m\n";
    ss << "\\default 75.0\n";
    ss << "\\minimum 0.0\n";
    ss << "N10,  \\field Standard Case Lighting Power per Unit Length\n";
    ss << "\\type real\n";
    ss << "\\units W/m\n";
    ss << "\\default 90.0\n";
    ss << "N11,  \\field Installed Case Lighting Power per Unit Length\n";
    ss << "\\type real\n";
    ss << "\\units W/m\n";
    ss << "\\note default set equal to Standard Case Lighting Power per Unit Length\n";
    ss << "A6 ,  \\field Case Lighting Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N12,  \\field Fraction of Lighting Energy to Case\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N13,  \\field Case Anti-Sweat Heater Power per Unit Length\n";
    ss << "\\type real\n";
    ss << "\\units W/m\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N14,  \\field Minimum Anti-Sweat Heater Power per Unit Length\n";
    ss << "\\type real\n";
    ss << "\\units W/m\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note This field is only applicable to the Linear, Dewpoint Method, and\n";
    ss << "\\note Heat Balance Method anti-sweat heater control types\n";
    ss << "A7 ,  \\field Anti-Sweat Heater Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Constant\n";
    ss << "\\key Linear\n";
    ss << "\\key DewpointMethod\n";
    ss << "\\key HeatBalanceMethod\n";
    ss << "\\default None\n";
    ss << "N15,  \\field Humidity at Zero Anti-Sweat Heater Energy\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\default -10.0\n";
    ss << "\\note This field is only applicable to Linear AS heater control type\n";
    ss << "\\note Zone relative humidity (%) where anti-sweat heater energy is zero\n";
    ss << "N16,  \\field Case Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0\n";
    ss << "\\default 1.5\n";
    ss << "\\note This field only applicable to Heat Balance Method AS heater control type\n";
    ss << "\\note Height must be greater than zero if Heat Balance Method AS heater control is selected\n";
    ss << "N17,  \\field Fraction of Anti-Sweat Heater Energy to Case\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N18,  \\field Case Defrost Power per Unit Length\n";
    ss << "\\type real\n";
    ss << "\\units W/m\n";
    ss << "\\note Used to evaluate load on case as well as power or heat consumption\n";
    ss << "\\default 0.0\n";
    ss << "\\minimum 0.0\n";
    ss << "A8,   \\field Case Defrost Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key OffCycle\n";
    ss << "\\key HotGas\n";
    ss << "\\key Electric\n";
    ss << "\\key HotFluid\n";
    ss << "\\key HotGasWithTemperatureTermination\n";
    ss << "\\key ElectricWithTemperatureTermination\n";
    ss << "\\key HotFluidWithTemperatureTermination\n";
    ss << "\\default OffCycle\n";
    ss << "A9,   \\field Case Defrost Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note A case defrost schedule name is required unless case defrost type = None\n";
    ss << "A10,  \\field Case Defrost Drip-Down Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note If left blank, the defrost schedule will be used\n";
    ss << "\\note The start time for each defrost period in this drip-down schedule should coincide with\n";
    ss << "\\note the start time for each defrost period in the case defrost schedule (previous input\n";
    ss << "\\note field).The length of each defrost drip-down period must be greater than or equal to the\n";
    ss << "\\note corresponding defrost period specified in the case defrost schedule. This extra time\n";
    ss << "\\note allows the melted frost to drip from the coil before refrigeration is restarted.\n";
    ss << "A11,  \\field Defrost Energy Correction Curve Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key CaseTemperatureMethod\n";
    ss << "\\key RelativeHumidityMethod\n";
    ss << "\\key DewpointMethod\n";
    ss << "\\default None\n";
    ss << "\\note Case Temperature, Relative Humidity, and Dewpoint Method are applicable to case defrost\n";
    ss << "\\note types with temperature termination only.\n";
    ss << "A12,  \\field Defrost Energy Correction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Defrost Energy Correction Curve Name is applicable to case defrost types\n";
    ss << "\\note with temperature termination only.\n";
    ss << "N19,  \\field Under Case HVAC Return Air Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "A13,  \\field Refrigerated Case Restocking Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values should be in units of Watts per unit case length (W/m)\n";
    ss << "\\note Leave this field blank if no restocking is to be modeled\n";
    ss << "A14,  \\field Case Credit Fraction Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values should be from 0 to 1\n";
    ss << "\\note Leave this field blank if no case credit fraction is to be applied\n";
    ss << "N20,  \\field Design Evaporator Temperature or Brine Inlet Temperature\n";
    ss << "\\note Required for detailed refrigeration system, not for compressor rack\n";
    ss << "\\note For a DX system, enter the saturated temperature for refrigerant pressure leaving case\n";
    ss << "\\note For a brine-cooled cooled (secondary system) case, enter the brine inlet temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -70.0\n";
    ss << "\\maximum 40.0\n";
    ss << "\\note Default is 5 C less than case operating temperature\n";
    ss << "N21;  \\field Average Refrigerant Charge Inventory\n";
    ss << "\\units kg/m\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::Refrigeration_Case);
    OptionalIddObject oObj = IddObject::load("Refrigeration:Case",
                                             "Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Refrigeration_Case);
  return object;
}

IddObject createRefrigeration_CompressorRackIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Refrigeration:CompressorRack,\n";
    ss << "\\memo Works in conjunction with the refrigeration case and walk-in objects to simulate the\n";
    ss << "\\memo performance of a refrigerated case system. This object models the electric\n";
    ss << "\\memo consumption of the rack compressors and the condenser fans. Heat can be rejected\n";
    ss << "\\memo either outdoors or to a zone. Compressor rack waste heat can also be reclaimed for\n";
    ss << "\\memo use by an optional air- or water-heating coil (Coil:Heating:Desuperheater and\n";
    ss << "\\memo Coil:WaterHeating:Desuperheater).\n";
    ss << "\\min-fields 25\n";
    ss << "A1 ,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference DesuperHeatingCoilSources\n";
    ss << "A2 ,  \\field Heat Rejection Location\n";
    ss << "\\type choice\n";
    ss << "\\key Outdoors\n";
    ss << "\\key Zone\n";
    ss << "\\default Outdoors\n";
    ss << "N1 ,  \\field Design Compressor Rack COP\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note It is important that this COP correspond to the lowest saturated suction\n";
    ss << "\\note      temperature needed to serve all refrigeration loads\n";
    ss << "A3 ,  \\field Compressor Rack COP Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note It is important that this COP curve correspond to the lowest saturated suction\n";
    ss << "\\note      temperature needed to serve all refrigeration loads\n";
    ss << "N2 ,  \\field Design Condenser Fan Power\n";
    ss << "\\note Design power for condenser fan(s).\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 250.0\n";
    ss << "A4 ,  \\field Condenser Fan Power Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A5 ,  \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "\\key WaterCooled\n";
    ss << "\\default AirCooled\n";
    ss << "\\note Applicable only when Heat Rejection Location is Outdoors.\n";
    ss << "A6 ,  \\field Water-Cooled Condenser Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A7 ,  \\field Water-Cooled Condenser Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A8 ,  \\field Water-Cooled Loop Flow Type\n";
    ss << "\\type choice\n";
    ss << "\\key VariableFlow\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\default VariableFlow\n";
    ss << "\\note Applicable only when Condenser Type is WaterCooled.\n";
    ss << "A9 ,  \\field Water-Cooled Condenser Outlet Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Applicable only when loop Flow type is VariableFlow.\n";
    ss << "N3,   \\field Water-Cooled Condenser Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Applicable only when loop flow type is ConstantFlow.\n";
    ss << "N4,   \\field Water-Cooled Condenser Maximum Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0.0\n";
    ss << "N5,   \\field Water-Cooled Condenser Maximum Water Outlet Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 10.0\n";
    ss << "\\maximum 60.0\n";
    ss << "\\default 55.0\n";
    ss << "N6,   \\field Water-Cooled Condenser Minimum Water Inlet Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 10.0\n";
    ss << "\\maximum 30.0\n";
    ss << "\\default 10.0\n";
    ss << "A10 , \\field Evaporative Condenser Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Schedule values greater than 0 indicate that evaporative cooling of the\n";
    ss << "\\note condenser is available. This schedule allows the user to define seasonal\n";
    ss << "\\note shutdown/draining of the water cooling system in cold climate applications.\n";
    ss << "\\note For periods with schedule values of 0, the condenser operates as AirCooled.\n";
    ss << "N7 ,  \\field Evaporative Condenser Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "\\note Applicable only for Condenser Type = EvaporativlyCooled.\n";
    ss << "N8 ,  \\field Evaporative Condenser Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\default Autocalculate\n";
    ss << "\\note Applicable only for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Used to calculate evaporative condenser water use.\n";
    ss << "N9 ,  \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 200.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled and for periods\n";
    ss << "\\note when the evaporatively cooled condenser is available (field Evaporative Condenser Availability\n";
    ss << "\\note Schedule Name). For this situation, the heater heats the basin water when the\n";
    ss << "\\note outdoor air dry-bulb temperature falls below the setpoint temperature, but\n";
    ss << "\\note only when the condenser fans are off (i.e., no refrigerated case load).\n";
    ss << "N10 ,  \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note Enter the outdoor dry-bulb temperature at which the basin heater turns on.\n";
    ss << "N11 ,  \\field Design Evaporative Condenser Water Pump Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1000.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Design recirc water pump power for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Applicable only for Condenser Type = EvaporativelyCooled.\n";
    ss << "A11 , \\field Evaporative Water Supply Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "\\note If blank, water supply is from Mains.\n";
    ss << "\\note Applicable only for Condenser Type = EvaporativelyCooled.\n";
    ss << "A12 , \\field Condenser Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Applicable only when Heat Rejection Location is Outdoors and Condenser Type is\n";
    ss << "\\note not WaterCooled; otherwise, leave field blank. If field is left blank with\n";
    ss << "\\note Heat Rejection Location = Outdoors, then the model assumes that the Inlet Air\n";
    ss << "\\note conditions are the outdoor air conditions for the current timestep\n";
    ss << "\\note (e.g., no adjustment for height above ground).\n";
    ss << "A13 , \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";
    ss << "A14 , \\field Refrigeration Case Name or WalkIn Name or CaseAndWalkInList Name\n";
    ss << "\\note Enter the name of a Refrigeration:Case or Refrigeration:Walkin or\n";
    ss << "\\note Refrigeration:CaseAndWalkinList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationCaseAndWalkInAndListNames\n";
    ss << "A15  ; \\field Heat Rejection Zone Name\n";
    ss << "\\note This must be a controlled zone and appear in a ZoneHVAC:EquipmentConnections object.\n";
    ss << "\\note Required only if walk-in[s] are connected to this rack\n";
    ss << "\\note AND the heat rejection location is \"Zone\"\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";

    IddObjectType objType(IddObjectType::Refrigeration_CompressorRack);
    OptionalIddObject oObj = IddObject::load("Refrigeration:CompressorRack",
                                             "Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Refrigeration_CompressorRack);
  return object;
}

IddObject createRefrigeration_CaseAndWalkInListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Refrigeration:CaseAndWalkInList,\n";
    ss << "\\memo Provides a list of all the refrigerated cases, walk in coolers, or air chillers\n";
    ss << "\\memo cooled by a single refrigeration system.  Note that the names of all cases,\n";
    ss << "\\memo walk-ins ,air chillers, and CaseAndWalkInLists must be unique.  That is, you cannot\n";
    ss << "\\memo give a list the same name as one of list items. This list may contain a combination\n";
    ss << "\\memo of case and walk-in names OR a list of air chiller names.  Air chillers\n";
    ss << "\\memo may not be included in any list that also includes cases or walk-ins.\n";
    ss << "\\extensible:1  repeat last field, remembering to remove ; from \"inner\" fields.\n";
    ss << "A1 ,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RefrigerationCaseAndWalkInAndListNames\n";
    ss << "A2 ;  \\field Case or WalkIn 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\note Enter the name of a Refrigeration:Case or Refrigeration:WalkIn object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationCaseAndWalkInNames\n";

    IddObjectType objType(IddObjectType::Refrigeration_CaseAndWalkInList);
    OptionalIddObject oObj = IddObject::load("Refrigeration:CaseAndWalkInList",
                                             "Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Refrigeration_CaseAndWalkInList);
  return object;
}

IddObject createRefrigeration_Condenser_AirCooledIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Refrigeration:Condenser:AirCooled,\n";
    ss << "\\memo Air cooled condenser for a refrigeration system (Refrigeration:System).\n";
    ss << "\\min-fields 5\n";
    ss << "A1 ,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RefrigerationAllTypesCondenserNames\n";
    ss << "\\reference DesuperHeatingCoilSources\n";
    ss << "A2 ,  \\field Rated Effective Total Heat Rejection Rate Curve Name\n";
    ss << "\\note Rating as per ARI 460\n";
    ss << "\\note Be sure the rating corresponds to the correct refrigerant\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note HeatRejection(W)=C1 +C2(Condensing Temp - Entering Air Temp, deg C)\n";
    ss << "\\note Will be adjusted for elevation automatically\n";
    ss << "N1 ,  \\field Rated Subcooling Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 0.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note must correspond to rating given for total heat rejection effect\n";
    ss << "A3 ,  \\field Condenser Fan Speed Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Fixed\n";
    ss << "\\key FixedLinear\n";
    ss << "\\key VariableSpeed\n";
    ss << "\\key TwoSpeed\n";
    ss << "\\default Fixed\n";
    ss << "N2 ,  \\field Rated Fan Power\n";
    ss << "\\note Power for condenser fan(s) corresponding to rated total heat rejection effect.\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 250.0\n";
    ss << "N3 ,  \\field Minimum Fan Air Flow Ratio\n";
    ss << "\\note Minimum air flow fraction through condenser fan\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.2\n";
    ss << "A4 ,  \\field Air Inlet Node Name or Zone Name\n";
    ss << "\\type node\n";
    ss << "\\note If field is left blank,\n";
    ss << "\\note then the model assumes that the inlet air\n";
    ss << "\\note conditions are the outdoor air conditions for the current timestep\n";
    ss << "\\note (e.g., no adjustment for height above ground).\n";
    ss << "\\note If the condenser rejects heat to a conditioned zone, enter the zone name here.\n";
    ss << "A5 ,  \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";
    ss << "N4 ,  \\field Condenser Refrigerant Operating Charge Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note optional input\n";
    ss << "N5 ,  \\field Condensate Receiver Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note optional input\n";
    ss << "N6 ;  \\field Condensate Piping Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note optional input\n";

    IddObjectType objType(IddObjectType::Refrigeration_Condenser_AirCooled);
    OptionalIddObject oObj = IddObject::load("Refrigeration:Condenser:AirCooled",
                                             "Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Refrigeration_Condenser_AirCooled);
  return object;
}

IddObject createRefrigeration_Condenser_EvaporativeCooledIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Refrigeration:Condenser:EvaporativeCooled,\n";
    ss << "\\memo Evaporative-cooled condenser for a refrigeration system (Refrigeration:System).\n";
    ss << "\\min-fields 10\n";
    ss << "A1 ,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RefrigerationAllTypesCondenserNames\n";
    ss << "\\reference DesuperHeatingCoilSources\n";
    ss << "N1 ,  \\field Rated Effective Total Heat Rejection Rate\n";
    ss << "\\note Rating as per ARI 490\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Be sure the rating corresponds to the correct refrigerant\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "N2 ,  \\field Rated Subcooling Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 0.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note must correspond to rating given for total heat rejection effect\n";
    ss << "A2 ,  \\field Fan Speed Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Fixed\n";
    ss << "\\key FixedLinear\n";
    ss << "\\key VariableSpeed\n";
    ss << "\\key TwoSpeed\n";
    ss << "\\default Fixed\n";
    ss << "N3 ,  \\field Rated Fan Power\n";
    ss << "\\note Power for condenser fan(s) corresponding to rated total heat rejection effect.\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "N4 ,  \\field Minimum Fan Air Flow Ratio\n";
    ss << "\\note Minimum air flow fraction through condenser fan\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.2\n";
    ss << "N5 ,  \\field Approach Temperature Constant Term\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 20.0\n";
    ss << "\\default 6.63\n";
    ss << "\\note A1 in delta T = A1 + A2(hrcf) + A3/(hrcf) + A4(Twb)\n";
    ss << "N6 ,  \\field Approach Temperature Coefficient 2\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 20.0\n";
    ss << "\\default 0.468\n";
    ss << "\\note A2 in delta T = A1 + A2(hrcf) +A3/(hrcf) +A4(Twb)\n";
    ss << "N7 ,  \\field Approach Temperature Coefficient 3\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 30.0\n";
    ss << "\\default 17.93\n";
    ss << "\\note A3 in delta T = A1 + A2(hrcf) +A3/(hrcf) +A4(Twb)\n";
    ss << "N8 ,  \\field Approach Temperature Coefficient 4\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum -20.0\n";
    ss << "\\maximum 20.0\n";
    ss << "\\default -0.322\n";
    ss << "\\note A4 in deltaT=A1 + A2(hrcf) +A3/(hrcf) +A4(Twb)\n";
    ss << "N9 ,  \\field Minimum Capacity Factor\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 0.50\n";
    ss << "\\note taken from manufacturer's Heat Rejection Capacity Factor Table\n";
    ss << "N10,  \\field Maximum Capacity Factor\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 5.0\n";
    ss << "\\note taken from manufacturer's Heat Rejection Capacity Factor Table\n";
    ss << "A3 ,  \\field Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note If field is left blank,\n";
    ss << "\\note then the model assumes that the inlet air\n";
    ss << "\\note conditions are the outdoor air conditions for the current timestep\n";
    ss << "\\note (e.g., no adjustment for height above ground).\n";
    ss << "N11 , \\field Rated Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "\\note Used to calculate evaporative condenser water use and fan energy use.\n";
    ss << "N12 , \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 200.0\n";
    ss << "\\note This field is only used for periods\n";
    ss << "\\note when the evap condenser is available (field Evaporative Condenser Availability\n";
    ss << "\\note Schedule). For this situation, the heater heats the basin water when the\n";
    ss << "\\note outdoor air dry-bulb temperature falls below the set point temperature, but\n";
    ss << "\\note only when the condenser fans are off (i.e., no refrigerated case load).\n";
    ss << "N13 , \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note Enter the outdoor dry-bulb temperature at which the basin heater turns on.\n";
    ss << "N14 , \\field Rated Water Pump Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\default 1000.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Design recirculating water pump power.\n";
    ss << "A4 ,  \\field Evaporative Water Supply Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "\\note If blank, water supply is from Mains.\n";
    ss << "A5 ,  \\field Evaporative Condenser Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values greater than 0 indicate that evaporative cooling of the\n";
    ss << "\\note condenser is available. This schedule allows the user to define seasonal\n";
    ss << "\\note shutdown/draining of the water cooling system in cold climate applications.\n";
    ss << "\\note For periods with schedule values of 0, the condenser operates as Air Cooled.\n";
    ss << "A6,   \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";
    ss << "N15 , \\field Condenser Refrigerant Operating Charge Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note optional input\n";
    ss << "N16 , \\field Condensate Receiver Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note optional input\n";
    ss << "N17 ; \\field Condensate Piping Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note optional input\n";

    IddObjectType objType(IddObjectType::Refrigeration_Condenser_EvaporativeCooled);
    OptionalIddObject oObj = IddObject::load("Refrigeration:Condenser:EvaporativeCooled",
                                             "Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Refrigeration_Condenser_EvaporativeCooled);
  return object;
}

IddObject createRefrigeration_Condenser_WaterCooledIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Refrigeration:Condenser:WaterCooled,\n";
    ss << "\\memo Water cooled condenser for a refrigeration system (Refrigeration:System).\n";
    ss << "A1 ,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RefrigerationAllTypesCondenserNames\n";
    ss << "\\reference DesuperHeatingCoilSources\n";
    ss << "N1 ,  \\field Rated Effective Total Heat Rejection Rate\n";
    ss << "\\note Rating as per ARI 450\n";
    ss << "\\note Be sure the rating corresponds to the correct refrigerant\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note not used in calculations, only for identification and output\n";
    ss << "N2 ,  \\field Rated Condensing Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units C\n";
    ss << "\\note must correspond to rating given for total heat rejection effect\n";
    ss << "N3 ,  \\field Rated Subcooling Temperature Difference\n";
    ss << "\\default 0.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note must correspond to rating given for total heat rejection effect\n";
    ss << "N4,   \\field Rated Water Inlet Temperature\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note must correspond to rating given for total heat rejection effect\n";
    ss << "A2 ,  \\field Water Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A3 ,  \\field Water Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A4 ,  \\field Water-Cooled Loop Flow Type\n";
    ss << "\\type choice\n";
    ss << "\\key VariableFlow\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\default VariableFlow\n";
    ss << "A5 ,  \\field Water Outlet Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Applicable only when loop flow type is Variable Flow.\n";
    ss << "N5 ,  \\field Water Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\note note required units must be converted from L/s as specified in ARI 450-2007\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Applicable only when loop flow type is Constant Flow.\n";
    ss << "N6 ,  \\field Water Maximum Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0.0\n";
    ss << "N7 ,  \\field Water Maximum Water Outlet Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 10.0\n";
    ss << "\\maximum 60.0\n";
    ss << "\\default 55.0\n";
    ss << "N8 ,  \\field Water Minimum Water Inlet Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 10.0\n";
    ss << "\\maximum 30.0\n";
    ss << "\\default 10.0\n";
    ss << "\\note related to the minimum allowed refrigeration system condensing temperature\n";
    ss << "A6 ,  \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";
    ss << "N9 ,  \\field Condenser Refrigerant Operating Charge Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\note optional input\n";
    ss << "N10 , \\field Condensate Receiver Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\note optional input\n";
    ss << "N11 ; \\field Condensate Piping Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\note optional input\n";

    IddObjectType objType(IddObjectType::Refrigeration_Condenser_WaterCooled);
    OptionalIddObject oObj = IddObject::load("Refrigeration:Condenser:WaterCooled",
                                             "Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Refrigeration_Condenser_WaterCooled);
  return object;
}

IddObject createRefrigeration_Condenser_CascadeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Refrigeration:Condenser:Cascade,\n";
    ss << "\\memo Cascade condenser for a refrigeration system (Refrigeration:System). The cascade\n";
    ss << "\\memo condenser is unlike the other condenser options because it rejects heat to another,\n";
    ss << "\\memo higher-temperature, refrigeration system. That is, the cascade condenser acts as a\n";
    ss << "\\memo heat rejection object for one system, but acts as a refrigeration load for another\n";
    ss << "\\memo system.\n";
    ss << "A1 ,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RefrigerationAllTypesCondenserNames\n";
    ss << "\\reference RefrigerationCascadeCondenserAndSecondarySystemNames\n";
    ss << "\\reference RefrigerationSecondarySystemAndCascadeCondenserAndTransferLoadListNames\n";
    ss << "N1 ,  \\field Rated Condensing Temperature\n";
    ss << "\\note This is the condensing temperature for the lower temperature secondary loop\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N2 ,  \\field Rated Approach Temperature Difference\n";
    ss << "\\note This is the difference between the condensing and evaporating temperatures\n";
    ss << "\\default 3.0\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units deltaC\n";
    ss << "N3 ,  \\field Rated Effective Total Heat Rejection Rate\n";
    ss << "\\required-field\n";
    ss << "\\note used for identification and rough system size error checking\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W\n";
    ss << "A2 ,  \\field Condensing Temperature Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Fixed\n";
    ss << "\\key Float\n";
    ss << "\\default Fixed\n";
    ss << "\\note Fixed keeps condensing temperature constant\n";
    ss << "\\note Float sets the condensing temperature according to\n";
    ss << "\\note      the other loads on the higher temperature system\n";
    ss << "N4 ,  \\field Condenser Refrigerant Operating Charge Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\note optional input\n";
    ss << "N5 , \\field Condensate Receiver Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\note optional input\n";
    ss << "N6 ; \\field Condensate Piping Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\note optional input\n";

    IddObjectType objType(IddObjectType::Refrigeration_Condenser_Cascade);
    OptionalIddObject oObj = IddObject::load("Refrigeration:Condenser:Cascade",
                                             "Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Refrigeration_Condenser_Cascade);
  return object;
}

IddObject createRefrigeration_GasCooler_AirCooledIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Refrigeration:GasCooler:AirCooled,\n";
    ss << "\\memo The transcritical refrigeration system requires a single gas cooler to reject the\n";
    ss << "\\memo system heat.\n";
    ss << "A1 ,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RefrigerationAllTypesGasCoolerNames\n";
    ss << "A2 ,  \\field Rated Total Heat Rejection Rate Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Be sure the rating corresponds to the correct refrigerant (R744)\n";
    ss << "\\note HeatRejection(W)=C1 +C2(Gas Cooler Outlet Temp - Entering Air Temp, deg C)\n";
    ss << "\\note Will be adjusted for elevation automatically\n";
    ss << "A3 ,  \\field Gas Cooler Fan Speed Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Fixed\n";
    ss << "\\key FixedLinear\n";
    ss << "\\key VariableSpeed\n";
    ss << "\\key TwoSpeed\n";
    ss << "\\default Fixed\n";
    ss << "N1 ,  \\field Rated Fan Power\n";
    ss << "\\note Power for gas cooler fan(s) corresponding to rated total heat rejection effect.\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 5000.0\n";
    ss << "N2 ,  \\field Minimum Fan Air Flow Ratio\n";
    ss << "\\note Minimum air flow fraction through gas cooler fan\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.2\n";
    ss << "N3 ,  \\field Transition Temperature\n";
    ss << "\\note Temperature at which system transitions between subcritical and transcritical operation.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 27.0\n";
    ss << "N4 ,  \\field Transcritical Approach Temperature\n";
    ss << "\\note Temperature difference between the CO2 exiting the gas cooler and the air entering the\n";
    ss << "\\note gas cooler during transcritical operation.\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 3.0\n";
    ss << "N5 ,  \\field Subcritical Temperature Difference\n";
    ss << "\\note Temperature difference between the saturated condensing temperature and the air\n";
    ss << "\\note temperature during subcritical operation.\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 10.0\n";
    ss << "N6 ,  \\field Minimum Condensing Temperature\n";
    ss << "\\note Minimum saturated condensing temperature during subcritical operation.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 10.0\n";
    ss << "A4 ,  \\field Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note If field is left blank,\n";
    ss << "\\note then the model assumes that the inlet air\n";
    ss << "\\note conditions are the outdoor air conditions for the current timestep\n";
    ss << "\\note (e.g., no adjustment for height above ground).\n";
    ss << "A5 ,  \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";
    ss << "N7 ,  \\field Gas Cooler Refrigerant Operating Charge Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note optional input\n";
    ss << "N8 ,  \\field Gas Cooler Receiver Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note optional input\n";
    ss << "N9 ;  \\field Gas Cooler Outlet Piping Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note optional input\n";

    IddObjectType objType(IddObjectType::Refrigeration_GasCooler_AirCooled);
    OptionalIddObject oObj = IddObject::load("Refrigeration:GasCooler:AirCooled",
                                             "Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Refrigeration_GasCooler_AirCooled);
  return object;
}

IddObject createRefrigeration_TransferLoadListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Refrigeration:TransferLoadList,\n";
    ss << "\\memo A refrigeration system may provide cooling to other, secondary, systems through\n";
    ss << "\\memo either a secondary loop or a cascade condenser. If multiple transfer loads are served\n";
    ss << "\\memo by a single primary system, use this list to group them together for reference by the\n";
    ss << "\\memo primary system (see the field \"Refrigeration Transfer Load or TransferLoad List Name\"\n";
    ss << "\\memo in the Refrigeration:System object).\n";
    ss << "\\extensible:1  repeat last field, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\min-fields 2\n";
    ss << "A1 ,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RefrigerationSecondarySystemAndCascadeCondenserAndTransferLoadListNames\n";
    ss << "A2 ;  \\field Cascade Condenser Name or Secondary System 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the name of a Refrigeration:Condenser:Cascade object OR\n";
    ss << "\\note   the name of a Refrigeration:SecondarySystem object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationCascadeCondenserAndSecondarySystemNames\n";

    IddObjectType objType(IddObjectType::Refrigeration_TransferLoadList);
    OptionalIddObject oObj = IddObject::load("Refrigeration:TransferLoadList",
                                             "Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Refrigeration_TransferLoadList);
  return object;
}

IddObject createRefrigeration_SubcoolerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Refrigeration:Subcooler,\n";
    ss << "\\memo Two types of subcoolers are modeled by the detailed refrigeration system.  The\n";
    ss << "\\memo liquid suction heat exchanger uses cool suction gas to subcool the hot condensate\n";
    ss << "\\memo after it leaves the condenser and before it reaches the thermal expansion valve.\n";
    ss << "\\memo A mechanical subcooler is used to transfer cooling capacity from one refrigeration\n";
    ss << "\\memo system to another.\n";
    ss << "\\min-fields 5\n";
    ss << "A1 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference RefrigerationSubcoolerNames\n";
    ss << "A2 , \\field Subcooler Type\n";
    ss << "\\type choice\n";
    ss << "\\key Mechanical\n";
    ss << "\\key LiquidSuction\n";
    ss << "\\default LiquidSuction\n";
    ss << "\\note plan to add ambient subcoolers at future time\n";
    ss << "N1 , \\field Liquid Suction Design Subcooling Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Applicable only and required for liquid suction heat exchangers\n";
    ss << "\\note design liquid suction subcooling\n";
    ss << "N2 , \\field Design Liquid Inlet Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note design inlet temperature on liquid side\n";
    ss << "\\note Applicable only and required for liquid suction heat exchangers (LSHX)\n";
    ss << "N3 , \\field Design Vapor Inlet Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note design inlet temperature on vapor side\n";
    ss << "\\note Applicable only and required for liquid suction heat exchangers (LSHX)\n";
    ss << "\\note Design vapor inlet temperature must be less than or equal to\n";
    ss << "\\note      the Liquid inlet design temp\n";
    ss << "A3 , \\field Capacity-Providing System\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationSystemNames\n";
    ss << "\\note Name of the Detailed Refrigeration System providing cooling capacity\n";
    ss << "\\note Applicable only and required for mechanical subcoolers\n";
    ss << "N4 ; \\field Outlet Control Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Control Temperature Out for subcooled liquid\n";
    ss << "\\note Applicable only and required for mechanical subcoolers\n";

    IddObjectType objType(IddObjectType::Refrigeration_Subcooler);
    OptionalIddObject oObj = IddObject::load("Refrigeration:Subcooler",
                                             "Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Refrigeration_Subcooler);
  return object;
}

IddObject createRefrigeration_CompressorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Refrigeration:Compressor,\n";
    ss << "\\memo Refrigeration system compressor. Data is available for many compressors\n";
    ss << "\\memo in the RefrigerationCompressor.idf dataset\n";
    ss << "\\min-fields 6\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RefrigerationCompressorAndListNames\n";
    ss << "\\reference RefrigerationCompressorNames\n";
    ss << "A2 , \\field Refrigeration Compressor Power Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BicubicCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note the input order for the Curve:Bicubic does not\n";
    ss << "\\note match the ARI 540-2004 Eq. 1 coefficient order\n";
    ss << "\\note N1 is ARI_C1, N2 is ARI_C2, N3 is ARI_C4, N4 is ARI_C3,\n";
    ss << "\\note N5 is ARI_C6, N6 is ARI_C5, N7 is ARI_C7, N8 is ARI_C10,\n";
    ss << "\\note N9 is ARI_C8, N10 is ARI_C9,\n";
    ss << "\\note N11 is Minimum Suction dewpoint temperature,\n";
    ss << "\\note N12 is Maximum Suction dewpoint temperature,\n";
    ss << "\\note N13 is Minimum Discharge dewpoint temperature,\n";
    ss << "\\note N14 is Maximum Discharge dewpoint temperature\n";
    ss << "A3 , \\field Refrigeration Compressor Capacity Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BicubicCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note the input order for the Curve:Bicubic does not\n";
    ss << "\\note match the ARI 540-2004 Eq. 1 coefficient order\n";
    ss << "\\note N1 is ARI_C1, N2 is ARI_C2, N3 is ARI_C4, N4 is ARI_C3,\n";
    ss << "\\note N5 is ARI_C6, N6 is ARI_C5, N7 is ARI_C7, N8 is ARI_C10,\n";
    ss << "\\note N9 is ARI_C8, N10 is ARI_C9,\n";
    ss << "\\note N11 is Minimum Suction dewpoint temperature,\n";
    ss << "\\note N12 is Maximum Suction dewpoint temperature,\n";
    ss << "\\note N13 is Minimum Discharge dewpoint temperature,\n";
    ss << "\\note N14 is Maximum Discharge dewpoint temperature\n";
    ss << "N1 , \\field Rated Superheat\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "\\note Use this input field OR the next, not both\n";
    ss << "\\note This is used if the compressor rating is based upon\n";
    ss << "\\note degrees of superheat\n";
    ss << "N2 , \\field Rated Return Gas Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\note Use this input field OR the previous, not both\n";
    ss << "\\note This is used if the compressor rating is based upon\n";
    ss << "\\note rated return gas temperature (Rated Suction Temperature)\n";
    ss << "N3 , \\field Rated Liquid Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\note Use this input field OR the next, not both\n";
    ss << "\\note This is used if the compressor rating is based upon\n";
    ss << "\\note rated liquid temperature at the expansion valve\n";
    ss << "N4 , \\field Rated Subcooling\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "\\note Use this input field OR the previous, not both\n";
    ss << "\\note This is used if the compressor rating is based upon\n";
    ss << "\\note degrees of subcooling\n";
    ss << "A4 , \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";
    ss << "A5 , \\field Mode of Operation\n";
    ss << "\\retaincase\n";
    ss << "\\type choice\n";
    ss << "\\key Subcritical\n";
    ss << "\\key Transcritical\n";
    ss << "\\default Subcritical\n";
    ss << "A6 , \\field Transcritical Compressor Power Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BicubicCurves\n";
    ss << "A7 ; \\field Transcritical Compressor Capacity Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BicubicCurves\n";

    IddObjectType objType(IddObjectType::Refrigeration_Compressor);
    OptionalIddObject oObj = IddObject::load("Refrigeration:Compressor",
                                             "Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Refrigeration_Compressor);
  return object;
}

IddObject createRefrigeration_CompressorListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Refrigeration:CompressorList,\n";
    ss << "\\memo List of all the compressors included within a single refrigeration system\n";
    ss << "\\memo (Refrigeration:System). Each list must contain at least one compressor.\n";
    ss << "\\memo The order in which the individual compressors are listed here will be the\n";
    ss << "\\memo order in which the compressors are dispatched to meet the system load.\n";
    ss << "\\min-fields 2\n";
    ss << "\\extensible:1  repeat last field, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\memo IMPORTANT: List compressor names in the order in which the compressors will be loaded\n";
    ss << "\\memo Data is available for many compressors in the RefrigerationCompressor.idf dataset\n";
    ss << "A1 ,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RefrigerationCompressorAndListNames\n";
    ss << "A2 ;  \\field Refrigeration Compressor 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\note Enter the name of a Refrigeration:Compressor object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationCompressorNames\n";

    IddObjectType objType(IddObjectType::Refrigeration_CompressorList);
    OptionalIddObject oObj = IddObject::load("Refrigeration:CompressorList",
                                             "Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Refrigeration_CompressorList);
  return object;
}

IddObject createRefrigeration_SystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Refrigeration:System,\n";
    ss << "\\memo Simulates the performance of a supermarket refrigeration system when used along with\n";
    ss << "\\memo other objects to define the refrigeration load(s), the compressor(s), and the\n";
    ss << "\\memo condenser.\n";
    ss << "\\min-fields 7\n";
    ss << "A1 ,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RefrigerationSystemNames\n";
    ss << "A2 , \\field Refrigerated Case or Walkin or CaseAndWalkInList Name\n";
    ss << "\\note Enter the name of a Refrigeration:Case or Refrigeration:WalkIn object.\n";
    ss << "\\note If there is more than one refrigerated case or walk-in served by this system,\n";
    ss << "\\note  enter the name of a Refrigeration:CaseAndWalkInList object.\n";
    ss << "\\note Only cases and walkins served directly by the system should be included in this list.\n";
    ss << "\\note Any cases served indirectly via a secondary chiller should NOT be included in this list\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationCaseAndWalkInAndListNames\n";
    ss << "A3  , \\field Refrigeration Transfer Load or TransferLoad List Name\n";
    ss << "\\note Enter the name of a Refrigeration:SecondarySystem object OR\n";
    ss << "\\note   a Refrigeration:Condenser:Cascade object OR,\n";
    ss << "\\note   a Refrigeration:TransferLoadList object.\n";
    ss << "\\note A transfer load is identified as one which moves the load from one system to another.\n";
    ss << "\\note   So if you have more than one such load (including cascade condensers and secondary\n";
    ss << "\\note   loops) served by the same system, use a TransferLoadList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationSecondarySystemAndCascadeCondenserAndTransferLoadListNames\n";
    ss << "A4 ,  \\field Refrigeration Condenser Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationAllTypesCondenserNames\n";
    ss << "A5,  \\field Compressor or CompressorList Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationCompressorAndListNames\n";
    ss << "N1 ,  \\field Minimum Condensing Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "\\note related to the proper operation of the thermal expansion\n";
    ss << "\\note valves and compressors\n";
    ss << "A6 ,  \\field Refrigeration System Working Fluid Type\n";
    ss << "\\note Fluid property data for the refrigerant must be entered.\n";
    ss << "\\note The fluid property data, including the objects:\n";
    ss << "\\note FluidProperties:Name, FluidProperties:Temperatures,\n";
    ss << "\\note FluidProperties:Saturated and FluidProperties:Superheated\n";
    ss << "\\note can be copied from the FluidPropertiesRefData.idf dataset\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FluidNames\n";
    ss << "A7 ,  \\field Suction Temperature Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key FloatSuctionTemperature\n";
    ss << "\\key ConstantSuctionTemperature\n";
    ss << "\\default ConstantSuctionTemperature\n";
    ss << "A8 ,  \\field Mechanical Subcooler Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationSubcoolerNames\n";
    ss << "\\note Optional Field\n";
    ss << "\\note Recipient of refrigeration capacity, that is receives cool liquid\n";
    ss << "\\note    from another refrigeration system to help meet aggregate case loads\n";
    ss << "A9 ,  \\field Liquid Suction Heat Exchanger Subcooler Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationSubcoolerNames\n";
    ss << "\\note Optional Field\n";
    ss << "\\note Liquid Suction Heat Exchanger Name, or leave blank\n";
    ss << "N2 ,  \\field Sum UA Suction Piping\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "\\units W/K\n";
    ss << "\\note Use only if you want to include suction piping heat gain in refrigeration load\n";
    ss << "A10,  \\field Suction Piping Zone Name\n";
    ss << "\\note This will be used to determine the temperature used for distribution piping heat gain\n";
    ss << "\\note  and the pipe heat gains  as cooling credit for the zone.\n";
    ss << "\\note  Required only if Sum UA Distribution Piping >0.0\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A11,  \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";
    ss << "N3 ,  \\field Number of Compressor Stages\n";
    ss << "\\type choice\n";
    ss << "\\key 1\n";
    ss << "\\key 2\n";
    ss << "\\default 1\n";
    ss << "A12,  \\field Intercooler Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Flash Intercooler\n";
    ss << "\\key Shell-and-Coil Intercooler\n";
    ss << "\\default None\n";
    ss << "N4 ,  \\field Shell-and-Coil Intercooler Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\default 0.8\n";
    ss << "A13;  \\field High-Stage Compressor or CompressorList Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationCompressorAndListNames\n";

    IddObjectType objType(IddObjectType::Refrigeration_System);
    OptionalIddObject oObj = IddObject::load("Refrigeration:System",
                                             "Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Refrigeration_System);
  return object;
}

IddObject createRefrigeration_TranscriticalSystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Refrigeration:TranscriticalSystem,\n";
    ss << "\\memo Detailed transcritical carbon dioxide (CO2) booster refrigeration systems used in\n";
    ss << "\\memo supermarkets.  The object allows for modeling either a single stage system with\n";
    ss << "\\memo medium-temperature loads or a two stage system with both medium- and low-temperature\n";
    ss << "\\memo loads.\n";
    ss << "A1 ,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RefrigerationSystemNames\n";
    ss << "A2 ,  \\field System Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key SingleStage\n";
    ss << "\\key TwoStage\n";
    ss << "A3 ,  \\field Medium Temperature Refrigerated Case or Walkin or CaseAndWalkInList Name\n";
    ss << "\\note Enter the name of a Refrigeration:Case or Refrigeration:WalkIn object.\n";
    ss << "\\note If there is more than one refrigerated case or walk-in served by this system,\n";
    ss << "\\note enter the name of a Refrigeration:CaseAndWalkInList object.\n";
    ss << "\\note Only medium temperature cases and walk-ins served directly by the system should\n";
    ss << "\\note be included in this list.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationCaseAndWalkInAndListNames\n";
    ss << "A4 ,  \\field Low Temperature Refrigerated Case or Walkin or CaseAndWalkInList Name\n";
    ss << "\\note Enter the name of a Refrigeration:Case or Refrigeration:WalkIn object.\n";
    ss << "\\note If there is more than one refrigerated case or walk-in served by this system,\n";
    ss << "\\note enter the name of a Refrigeration:CaseAndWalkInList object.\n";
    ss << "\\note Only low temperature cases and walkins served directly by the system should be\n";
    ss << "\\note included in this list.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationCaseAndWalkInAndListNames\n";
    ss << "A5 ,  \\field Refrigeration Gas Cooler Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationAllTypesGasCoolerNames\n";
    ss << "A6 ,  \\field High Pressure Compressor or CompressorList Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationCompressorAndListNames\n";
    ss << "A7 ,  \\field Low Pressure Compressor or CompressorList Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationCompressorAndListNames\n";
    ss << "N1 ,  \\field Receiver Pressure\n";
    ss << "\\type real\n";
    ss << "\\default 4000000\n";
    ss << "\\units Pa\n";
    ss << "N2 ,  \\field Subcooler Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\default 0.4\n";
    ss << "A8 ,  \\field Refrigeration System Working Fluid Type\n";
    ss << "\\note Fluid property data for the refrigerant must be entered.\n";
    ss << "\\note The fluid property data, including the objects:\n";
    ss << "\\note FluidProperties:Name, FluidProperties:Temperatures,\n";
    ss << "\\note FluidProperties:Saturated and FluidProperties:Superheated\n";
    ss << "\\note can be copied from the FluidPropertiesRefData.idf dataset\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FluidNames\n";
    ss << "N3 ,  \\field Sum UA Suction Piping for Medium Temperature Loads\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "\\units W/K\n";
    ss << "\\note Use only if you want to include suction piping heat gain in refrigeration load\n";
    ss << "A9 ,  \\field Medium Temperature Suction Piping Zone Name\n";
    ss << "\\note This will be used to determine the temperature used for distribution piping heat\n";
    ss << "\\note gain and the pipe heat gains as cooling credit for the zone.\n";
    ss << "\\note Required only if Sum UA Distribution Piping for Medium Temperature Loads > 0.0\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N4 ,  \\field Sum UA Suction Piping for Low Temperature Loads\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "\\units W/K\n";
    ss << "\\note Use only if you want to include suction piping heat gain in refrigeration load\n";
    ss << "A10,  \\field Low Temperature Suction Piping Zone Name\n";
    ss << "\\note This will be used to determine the temperature used for distribution piping heat\n";
    ss << "\\note gain and the pipe heat gains as cooling credit for the zone.\n";
    ss << "\\note Required only if Sum UA Distribution Piping for Low Temperature Loads > 0.0\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A11;  \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::Refrigeration_TranscriticalSystem);
    OptionalIddObject oObj = IddObject::load("Refrigeration:TranscriticalSystem",
                                             "Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Refrigeration_TranscriticalSystem);
  return object;
}

IddObject createRefrigeration_SecondarySystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Refrigeration:SecondarySystem,\n";
    ss << "\\memo Works in conjunction with refrigerated cases and walkins to simulate the performance\n";
    ss << "\\memo of a secondary loop supermarket refrigeration system. Heat from the refrigeration\n";
    ss << "\\memo loads served by the secondary loop is absorbed by a primary refrigeration system\n";
    ss << "\\memo (Refrigeration:System). The SecondarySystem object simulates a heat exchanger that\n";
    ss << "\\memo is an evaporator, or refrigeration load, on the primary refrigeration system.\n";
    ss << "\\min-fields 14\n";
    ss << "\\min-fields 12\n";
    ss << "A1 ,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RefrigerationCascadeCondenserAndSecondarySystemNames\n";
    ss << "\\reference RefrigerationSecondarySystemAndCascadeCondenserAndTransferLoadListNames\n";
    ss << "A2 ,  \\field Refrigerated Case or Walkin or CaseAndWalkInList Name\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the name of a Refrigeration:Case or Refrigeration:WalkIn object.\n";
    ss << "\\note If there is more than one refrigerated case or walk-in served by this secondary system,\n";
    ss << "\\note  enter the name of a Refrigeration:CaseAndWalkInList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationCaseAndWalkInAndListNames\n";
    ss << "A3 ,  \\field Circulating Fluid Type\n";
    ss << "\\type choice\n";
    ss << "\\key FluidAlwaysLiquid\n";
    ss << "\\key FluidPhaseChange\n";
    ss << "\\required-field\n";
    ss << "\\note If \"FluidAlwaysLiquid\" is selected, the fluid properties\n";
    ss << "\\note    must be input using the objects: FluidProperties:Name,\n";
    ss << "\\note    FluidProperties:GlycolConcentration, and, if user defined fluid type,\n";
    ss << "\\note    FluidProperties:Temperatures and FluidProperties:Concentration.\n";
    ss << "\\note    Many sets of fluid properties can be found in GlycolPropertiesRefData.idf.\n";
    ss << "\\note If \"FluidPhaseChange\" is selected, the refrigerant properties\n";
    ss << "\\note    must be input using the objects: (if user defined fluid type): FluidProperties:Name,\n";
    ss << "\\note    FluidProperties:Temperatures, FluidProperties:Saturated, and\n";
    ss << "\\note    FluidProperties:Superheated.\n";
    ss << "\\note    Many sets of refrigerant data can be found in FluidPropertiesRefData.idf.\n";
    ss << "A4 ,  \\field Circulating Fluid Name\n";
    ss << "\\note This must correspond to a name in the FluidProperties:Name object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FluidAndGlycolNames\n";
    ss << "N1 ,  \\field Evaporator Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units W\n";
    ss << "\\note For \"FluidAlwaysLiquid\", at least one of the two, Evaporator Capacity OR\n";
    ss << "\\note    Evaporator Flow Rate for Secondary Fluid, is required.\n";
    ss << "\\note For \"FluidPhaseChange\", the default capacity is the sum of the rated capacities of the\n";
    ss << "\\note    Cases and Walk-ins served by the secondary loop.\n";
    ss << "N2 ,  \\field Evaporator Flow Rate for Secondary Fluid\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\note For \"FluidAlwaysLiquid\", at least one of the two, Evaporator Capacity OR\n";
    ss << "\\note    Evaporator Flow Rate for Secondary Fluid, is required.\n";
    ss << "\\note For \"FluidPhaseChange\" loops, this input is not used. (see PhaseChange Circulating\n";
    ss << "\\note Rate)\n";
    ss << "N3 ,  \\field Evaporator Evaporating Temperature\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\note  This is the evaporating temperature in the heat exchanger\n";
    ss << "\\note      used to chill or condense the secondary loop circulating fluid.\n";
    ss << "\\note      It is NOT the temperature in any cases or walk-ins served by the\n";
    ss << "\\note      secondary loop.\n";
    ss << "N4 ,  \\field Evaporator Approach Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units deltaC\n";
    ss << "\\note  For \"FluidAlwaysLiquid\", this is the rated difference between the temperature of the\n";
    ss << "\\note      circulating fluid leaving the heat exchanger\n";
    ss << "\\note      and the heat exchanger's rated evaporating temperature.\n";
    ss << "\\note  For \"FluidPhaseChange\", this is the difference between the temperature of the\n";
    ss << "\\note      evaporating and condensing temperatures in the heat exchanger.\n";
    ss << "N5 ,  \\field Evaporator Range Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note  For \"FluidAlwaysLiquid\", this is the rated difference between the temperature of the\n";
    ss << "\\note      circulating fluid entering the heat exchanger and the temperature of the\n";
    ss << "\\note      circulating fluid leaving the heat exchanger, and is Required.\n";
    ss << "\\note  For \"FluidPhaseChange\", this input is not used.\n";
    ss << "N6 ,  \\field Number of Pumps in Loop\n";
    ss << "\\type integer\n";
    ss << "\\default 1\n";
    ss << "N7 ,  \\field Total Pump Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\note For \"FluidAlwaysLiquid\",if not input, Evaporator Flow Rate for Secondary Fluid\n";
    ss << "\\note       will be used.\n";
    ss << "\\note For \"FluidPhaseChange\", if not input, this will be calculated using the\n";
    ss << "\\note       PhaseChange Circulating Rate.\n";
    ss << "N8 ,  \\field Total Pump Power\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units W\n";
    ss << "\\note Either the Total Pump Power or the Total Pump Head is required.\n";
    ss << "N9 ,  \\field Total Pump Head\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units Pa\n";
    ss << "\\note Either the Total Pump Power or the Total Pump Head is required.\n";
    ss << "N10,  \\field PhaseChange Circulating Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 2.5\n";
    ss << "\\note This is the total mass flow at the pump divided by the gaseous mass flow\n";
    ss << "\\note      leaving the refrigeration load.\n";
    ss << "A5 ,  \\field Pump Drive Type\n";
    ss << "\\type choice\n";
    ss << "\\key Constant\n";
    ss << "\\key Variable\n";
    ss << "\\default Constant\n";
    ss << "A6 ,  \\field Variable Speed Pump Cubic Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\note Variable Speed Pump Curve Name is applicable to variable speed pumps\n";
    ss << "\\note only.\n";
    ss << "N11 , \\field Pump Motor Heat to Fluid\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.85\n";
    ss << "\\note This is the portion of the pump motor heat added to secondary circulating fluid\n";
    ss << "\\note    and is equal to the motor efficiency for non-hermetic motor.\n";
    ss << "\\note Enter 1.0 for a semi-hermetic motor.\n";
    ss << "N12,  \\field Sum UA Distribution Piping\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "\\units W/K\n";
    ss << "\\note Use only if you want to include distribution piping heat gain in refrigeration load.\n";
    ss << "A7 ,  \\field Distribution Piping Zone Name\n";
    ss << "\\note This will be used to determine the temperature used for distribution piping heat gain.\n";
    ss << "\\note  The pipe heat gains are also counted as cooling credit for the zone.\n";
    ss << "\\note  Required only if Sum UA Distribution Piping >0.0\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N13,  \\field Sum UA Receiver/Separator Shell\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "\\units W/K\n";
    ss << "\\note Use only if you want to include Receiver/Separator Shell heat gain in refrigeration load.\n";
    ss << "A8 ,  \\field Receiver/Separator Zone Name\n";
    ss << "\\note This will be used to determine the temperature used for Receiver/Separator Shell heat gain.\n";
    ss << "\\note  The shell heat gains are also counted as cooling credit for the zone.\n";
    ss << "\\note  Required only if Sum UA Receiver/Separator Shell >0.0\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N14,  \\field Evaporator Refrigerant Inventory\n";
    ss << "\\units kg\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "\\note This value refers to the refrigerant circulating within the primary system providing\n";
    ss << "\\note    cooling to the chiller for the secondary loop, not to the fluid circulating\n";
    ss << "\\note    within the secondary loop itself.\n";
    ss << "A9;  \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::Refrigeration_SecondarySystem);
    OptionalIddObject oObj = IddObject::load("Refrigeration:SecondarySystem",
                                             "Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Refrigeration_SecondarySystem);
  return object;
}

IddObject createRefrigeration_WalkInIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Refrigeration:WalkIn,\n";
    ss << "\\memo Works in conjunction with a compressor rack, a refrigeration system, or a\n";
    ss << "\\memo refrigeration secondary system to simulate the performance of a walk-in cooler.\n";
    ss << "\\memo The walk-in cooler model uses information at rated conditions along with input\n";
    ss << "\\memo descriptions for heat transfer surfaces facing multiple zones to determine\n";
    ss << "\\memo performance.\n";
    ss << "\\extensible:12 -- duplicate last 12 fields, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\min-fields 28\n";
    ss << "A1 ,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RefrigerationCaseAndWalkInNames\n";
    ss << "\\reference RefrigerationCaseAndWalkInAndListNames\n";
    ss << "A2 ,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 ,  \\field Rated Coil Cooling Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\required-field\n";
    ss << "N2 ,  \\field Operating Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "\\maximum< 20.0\n";
    ss << "N3 ,  \\field Rated Cooling Source Temperature\n";
    ss << "\\note If DXEvaporator, use evaporating temperature (saturated suction temperature)\n";
    ss << "\\note If BrineCoil, use Brine entering temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -70.0\n";
    ss << "\\maximum 40.\n";
    ss << "\\note used to set minimum suction pressure for DX systems and\n";
    ss << "\\note    minimum brine temp for secondary systems\n";
    ss << "N4 ,  \\field Rated Total Heating Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\required-field\n";
    ss << "\\note Include total for all anti-sweat, door, drip-pan, and floor heater power\n";
    ss << "\\note Do not include defrost heater power\n";
    ss << "A3 ,  \\field Heating Power Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Values will be used to multiply the total heating power\n";
    ss << "\\note Values in the schedule should be between 0.0 and 1.0\n";
    ss << "\\note For example, this could be used if display door antisweat heaters\n";
    ss << "\\note are turned off at night\n";
    ss << "\\note Defaults to always on if schedule name left blank.\n";
    ss << "N5 ,  \\field Rated Cooling Coil Fan Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\default 375.0\n";
    ss << "\\minimum 0.\n";
    ss << "N6 ,  \\field Rated Circulation Fan Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\default 0.0\n";
    ss << "\\minimum 0.0\n";
    ss << "N7 ,  \\field Rated Total Lighting Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the total (display + task) installed lighting power.\n";
    ss << "A4 ,  \\field Lighting Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note The schedule should contain values between 0 and 1\n";
    ss << "\\note Defaults to always on if schedule name left blank.\n";
    ss << "A5 ,  \\field Defrost Type\n";
    ss << "\\type choice\n";
    ss << "\\key HotFluid\n";
    ss << "\\key Electric\n";
    ss << "\\key None\n";
    ss << "\\key OffCycle\n";
    ss << "\\default Electric\n";
    ss << "\\note HotFluid includes either hot gas defrost for a DX system or\n";
    ss << "\\note   Hot Brine defrost if this walk in is cooled by brine from a secondary chiller\n";
    ss << "A6 ,  \\field Defrost Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key TimeSchedule\n";
    ss << "\\key TemperatureTermination\n";
    ss << "\\default TimeSchedule\n";
    ss << "A7 ,  \\field Defrost Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\required-field\n";
    ss << "\\note The schedule values should be 0 (off) or 1 (on)\n";
    ss << "A8 ,  \\field Defrost Drip-Down Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note The schedule values should be 0 (off) or 1 (on)\n";
    ss << "\\note The start time for each defrost period in this drip-down schedule should coincide with\n";
    ss << "\\note the start time for each defrost period in the defrost schedule (previous input\n";
    ss << "\\note field).The length of each defrost drip-down period must be greater than or equal to the\n";
    ss << "\\note corresponding defrost period specified in the defrost schedule. This extra time\n";
    ss << "\\note allows the melted frost to drip from the coil before refrigeration is restarted.\n";
    ss << "N8 ,  \\field Defrost Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note needed for all defrost types except none and offcycle\n";
    ss << "N9 ,  \\field Temperature Termination Defrost Fraction to Ice\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note This is the portion of the defrost energy that is available to melt frost\n";
    ss << "\\note     Needed only for defrost control type TemperatureTermination\n";
    ss << "\\note     defaults to 0.7 for electric defrost and to 0.3 for hot fluid defrost\n";
    ss << "A9 ,  \\field Restocking Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values should be in units of Watts\n";
    ss << "\\note Leave this field blank if no restocking is to be modeled\n";
    ss << "N10,  \\field Average Refrigerant Charge Inventory\n";
    ss << "\\units kg\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "\\note This value is only used if the Cooling Source Type is DXEvaporator\n";
    ss << "N11 , \\field Insulated Floor Surface Area\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m2\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note floor area of walk-in cooler\n";
    ss << "N12 , \\field Insulated Floor U-Value\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\default 0.3154\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note The default value corresponds to R18 [ft2-F-hr/Btu]\n";
    ss << "\\note To convert other IP R-values to U, divide 5.678 by the R-value\n";
    ss << "\\note Some examples:\n";
    ss << "\\note R15 is U 0.3785 W/m2-K\n";
    ss << "\\note R5 is U 1.136 W/m2-K\n";
    ss << "A10 , \\field Zone 1 Name\n";
    ss << "\\note This must be a controlled zone and appear in a ZoneHVAC:EquipmentConnections object.\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note The walk-in cooler can face multiple zones.  The heat exchange with each zone\n";
    ss << "\\note    must be input separately\n";
    ss << "N13 , \\field Total Insulated Surface Area Facing Zone 1\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m2\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Area should include walls and ceilings, but not doors\n";
    ss << "N14 , \\field Insulated Surface U-Value Facing Zone 1\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\default 0.3154\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note The default value corresponds to R18 [ft2-F-hr/Btu]\n";
    ss << "\\note To convert other IP R-values to U, divide 5.678 by the R-value\n";
    ss << "\\note Some examples:\n";
    ss << "\\note R15 is U 0.3785 W/m2-K\n";
    ss << "\\note R5 is U 1.136 W/m2-K\n";
    ss << "N15 , \\field Area of Glass Reach In Doors Facing Zone 1\n";
    ss << "\\type real\n";
    ss << "\\units m2\n";
    ss << "\\default 0.0\n";
    ss << "N16 , \\field Height of Glass Reach In Doors Facing Zone 1\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 1.5\n";
    ss << "N17 , \\field Glass Reach In Door U Value Facing Zone 1\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\default 1.136\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note The default value corresponds to R5 [ft2-F-hr/Btu]\n";
    ss << "\\note To convert other IP R-values to U, divide 5.678 by the R-value\n";
    ss << "A11 , \\field Glass Reach In Door Opening Schedule Name Facing Zone 1\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values should all be between 0.0 and 1.0.\n";
    ss << "\\note For example, if the door is open 30% of the time during working hours,\n";
    ss << "\\note  then the schedule would hold the value 0.3 during working hours\n";
    ss << "\\note  and 0 during other hours\n";
    ss << "\\note  If no schedule name is entered, default is 5% open time during all hours\n";
    ss << "N18 , \\field Area of Stocking Doors Facing Zone 1\n";
    ss << "\\type real\n";
    ss << "\\units m2\n";
    ss << "\\default 0.0\n";
    ss << "N19 , \\field Height of Stocking Doors Facing Zone 1\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 3.0\n";
    ss << "N20 , \\field Stocking Door U Value Facing Zone 1\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\default 0.3785\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note The default value corresponds to R15 [ft2-F-hr/Btu]\n";
    ss << "\\note To convert other IP R-values to U, divide 5.678 by the R-value\n";
    ss << "\\note Some examples:\n";
    ss << "\\note R5 is U 1.136 W/m2-K\n";
    ss << "\\note R18 is U 0.3154 W/m2-K\n";
    ss << "A12 , \\field Stocking Door Opening Schedule Name Facing Zone 1\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values should all be between 0.0 and 1.0.\n";
    ss << "\\note For example, if the door is open 30% of the time during working hours,\n";
    ss << "\\note  then the schedule would hold the value 0.3 during working hours\n";
    ss << "\\note  and 0 during other hours\n";
    ss << "\\note  If no schedule name is entered, default is 5% open time during all hours\n";
    ss << "A13 ; \\field Stocking Door Opening Protection Type Facing Zone 1\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key AirCurtain\n";
    ss << "\\key StripCurtain\n";
    ss << "\\note Use StripCurtain for hanging strips or airlock vestibules\n";
    ss << "\\default AirCurtain\n";

    IddObjectType objType(IddObjectType::Refrigeration_WalkIn);
    OptionalIddObject oObj = IddObject::load("Refrigeration:WalkIn",
                                             "Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Refrigeration_WalkIn);
  return object;
}

IddObject createRefrigeration_AirChillerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Refrigeration:AirChiller,\n";
    ss << "\\memo Works in conjunction with a refrigeration chiller set, compressor rack, a\n";
    ss << "\\memo refrigeration system, or a refrigeration secondary system to simulate the performance\n";
    ss << "\\memo of an air chiller, similar to one found in a refrigerated warehouse. Energy use for\n";
    ss << "\\memo fans and heaters is modeled based on inputs for nominal power, schedules, and control\n";
    ss << "\\memo type. The air chiller model accounts for the sensible and latent heat exchange\n";
    ss << "\\memo with the surrounding environment.\n";
    ss << "\\min-fields 23\n";
    ss << "A1 ,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RefrigerationCaseAndWalkInNames\n";
    ss << "\\reference RefrigerationCaseAndWalkInAndListNames\n";
    ss << "\\reference RefrigerationAirChillerNames\n";
    ss << "A2 ,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 ,  \\field Capacity Rating Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\note In each case, select the rating option that corresponds to the expected service conditions.\n";
    ss << "\\note For example, U.S. manufacturers quote a separate Unit Load Factor for wet or frosted coils.\n";
    ss << "\\note If the evaporating temperature is less than 0C, input the frosted coil value.\n";
    ss << "\\note Within the European convention, select SC1, 2, 3, 4, or 5 depending upon the expected evaporating temperature.\n";
    ss << "\\key UnitLoadFactorSensibleOnly\n";
    ss << "\\key CapacityTotalSpecificConditions\n";
    ss << "\\key EuropeanSC1Standard\n";
    ss << "\\key EuropeanSC1NominalWet\n";
    ss << "\\key EuropeanSC2Standard\n";
    ss << "\\key EuropeanSC2NominalWet\n";
    ss << "\\key EuropeanSC3Standard\n";
    ss << "\\key FixedLinear\n";
    ss << "\\key EuropeanSC3NominalWet\n";
    ss << "\\key EuropeanSC4Standard\n";
    ss << "\\key EuropeanSC4NominalWet\n";
    ss << "\\key EuropeanSC5Standard\n";
    ss << "\\key EuropeanSC5NominalWet\n";
    ss << "N1 ,  \\field Rated Unit Load Factor\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\note The sensible cooling capacity in watts (W/C) at rated conditions.\n";
    ss << "\\note  The value entered for this field must be greater than zero, with no default value.\n";
    ss << "\\note This value is only used if the Capacity Rating Type is UnitLoadFactorSensibleOnly.\n";
    ss << "\\note The value given must be based upon the difference between the chiller inlet and\n";
    ss << "\\note outlet air temperatures, not on the difference between the zone mean temperature\n";
    ss << "\\note and the outlet air temperature\n";
    ss << "N2 ,  \\field Rated Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\note This value is only used if the Capacity Rating Type is NOT UnitLoadFactorSensibleOnly.\n";
    ss << "\\note For CapacityTotalSpecificConditions, this capacity includes both sensible and latent\n";
    ss << "\\note at the conditions given in the next two fields.\n";
    ss << "\\note Note that the European Standard ratings are sensible only and\n";
    ss << "\\note the European Nominal ratings include latent capacity as well.\n";
    ss << "\\note The value given here must correspond to the capacity rating type given previously\n";
    ss << "N3 ,  \\field Rated Relative Humidity\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\maximum 100\n";
    ss << "\\default 85\n";
    ss << "\\note This field is ONLY used if the Capacity Rating Type is CapacityTotalSpecificConditions and\n";
    ss << "\\note represents the relative humidity at rated conditions. The default is 85.\n";
    ss << "N4 ,  \\field Rated Cooling Source Temperature\n";
    ss << "\\note If DXEvaporator, use evaporating temperature (saturated suction temperature)\n";
    ss << "\\note If BrineCoil, use Brine entering temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -70.0\n";
    ss << "\\maximum 40.\n";
    ss << "\\note used to set minimum suction pressure for DX systems and\n";
    ss << "\\note    minimum brine temp for secondary systems\n";
    ss << "N5 ,  \\field Rated Temperature Difference DT1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 20.\n";
    ss << "\\note The rated difference between the air entering the refrigeration chiller and the\n";
    ss << "\\note cooling source temperature in degC.\n";
    ss << "N6 ,  \\field Maximum Temperature Difference Between Inlet Air and Evaporating Temperature\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 25.\n";
    ss << "\\note The maximum difference between the air entering the refrigeration chiller and the\n";
    ss << "\\note cooling source temperature in degC used to limit capacity during pull-down.\n";
    ss << "\\note defaults to 1.3 times the Rated Temperature Difference DT1\n";
    ss << "N7 ,  \\field Coil Material Correction Factor\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 1.0\n";
    ss << "\\note This is the manufacturer's correction factor for coil material corresponding to rating\n";
    ss << "N8 ,  \\field Refrigerant Correction Factor\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 1.0\n";
    ss << "\\note This is the manufacturer's correction factor for refrigerant corresponding to rating\n";
    ss << "A4 ,  \\field Capacity Correction Curve Type\n";
    ss << "\\note In each case, select the correction curve type that corresponds to the rating type.\n";
    ss << "\\type choice\n";
    ss << "\\key LinearSHR60\n";
    ss << "\\key QuadraticSHR\n";
    ss << "\\key European\n";
    ss << "\\key TabularRHxDT1xTRoom\n";
    ss << "\\note default LinearSHR60 unless Capacity Rating Type = CapacityTotalSpecificConditions\n";
    ss << "A5 ,  \\field Capacity Correction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Can also be the name of a \"Table:OneIndependentVariable\" or a \"Table:MultiVariableLookup\"\n";
    ss << "\\note Should be blank for LinearSHR60 correction curve type\n";
    ss << "N9 ,  \\field SHR60 Correction Factor\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 1.48\n";
    ss << "\\maximum 1.67\n";
    ss << "\\note only used when the capacity correction curve type is LinearSHR60\n";
    ss << "N10,  \\field Rated Total Heating Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\required-field\n";
    ss << "\\note Include total for all heater power\n";
    ss << "\\note Do not include defrost heater power\n";
    ss << "A6 ,  \\field Heating Power Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Values will be used to multiply the total heating power\n";
    ss << "\\note Values in the schedule should be between 0.0 and 1.0\n";
    ss << "\\note Defaults to always on if schedule name left blank.\n";
    ss << "A7 ,  \\field Fan Speed Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Fixed\n";
    ss << "\\key FixedLinear\n";
    ss << "\\key VariableSpeed\n";
    ss << "\\key TwoSpeed\n";
    ss << "\\default Fixed\n";
    ss << "N11,  \\field Rated Fan Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\default 375.0\n";
    ss << "\\minimum 0.\n";
    ss << "N12,  \\field Rated Air Flow\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "N13,  \\field Minimum Fan Air Flow Ratio\n";
    ss << "\\note Minimum air flow fraction through fan\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.2\n";
    ss << "A8 ,  \\field Defrost Type\n";
    ss << "\\type choice\n";
    ss << "\\key HotFluid\n";
    ss << "\\key Electric\n";
    ss << "\\key None\n";
    ss << "\\key OffCycle\n";
    ss << "\\default Electric\n";
    ss << "\\note HotFluid includes either hot gas defrost for a DX system or\n";
    ss << "\\note   Hot Brine defrost if this walk in is cooled by brine from a secondary chiller\n";
    ss << "A9 ,  \\field Defrost Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key TimeSchedule\n";
    ss << "\\key TemperatureTermination\n";
    ss << "\\default TimeSchedule\n";
    ss << "A10,  \\field Defrost Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\required-field\n";
    ss << "\\note The schedule values should be 0 (off) or 1 (on)\n";
    ss << "A11,  \\field Defrost Drip-Down Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note The schedule values should be 0 (off) or 1 (on)\n";
    ss << "\\note The start time for each defrost period in this drip-down schedule should coincide with\n";
    ss << "\\note the start time for each defrost period in the defrost schedule (previous input\n";
    ss << "\\note field).The length of each defrost drip-down period must be greater than or equal to the\n";
    ss << "\\note corresponding defrost period specified in the defrost schedule. This extra time\n";
    ss << "\\note allows the melted frost to drip from the coil before refrigeration is restarted.\n";
    ss << "N14,  \\field Defrost Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note needed for all defrost types except none and offcycle\n";
    ss << "N15,  \\field Temperature Termination Defrost Fraction to Ice\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note This is the portion of the defrost energy that is available to melt frost\n";
    ss << "\\note     Needed only for defrost control type TemperatureTermination\n";
    ss << "\\note     defaults to 0.7 for electric defrost and to 0.3 for hot fluid defrost\n";
    ss << "A12,  \\field Vertical Location\n";
    ss << "\\type choice\n";
    ss << "\\key Ceiling\n";
    ss << "\\key Middle\n";
    ss << "\\key Floor\n";
    ss << "\\default Middle\n";
    ss << "N16;  \\field Average Refrigerant Charge Inventory\n";
    ss << "\\units kg\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "\\note This value is only used if the Cooling Source Type is DXEvaporator\n";

    IddObjectType objType(IddObjectType::Refrigeration_AirChiller);
    OptionalIddObject oObj = IddObject::load("Refrigeration:AirChiller",
                                             "Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Refrigeration_AirChiller);
  return object;
}

IddObject createZoneHVAC_RefrigerationChillerSetIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ZoneHVAC:RefrigerationChillerSet,\n";
    ss << "\\memo Works in conjunction with one or multiple air chillers, compressor racks,\n";
    ss << "\\memo refrigeration systems, or refrigeration secondary system objects to simulate the\n";
    ss << "\\memo performance of a group of air chillers cooling a single zone. The chiller set\n";
    ss << "\\memo model passes information about the zone conditions to determine the performance of\n";
    ss << "\\memo individual chiller coils within the set, thus providing the sensible and latent heat\n";
    ss << "\\memo exchange with the zone environment.\n";
    ss << "\\extensible:1 -- duplicate last field, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\min-fields 6\n";
    ss << "A1 ,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 ,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3  , \\field Zone Name\n";
    ss << "\\note This must be a controlled zone and appear in a ZoneHVAC:EquipmentConnections object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A4 ,  \\field Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Not used - reserved for future use\n";
    ss << "\\note Name of the zone exhaust node (see Node) from which the refrigeration chiller\n";
    ss << "\\note draws its indoor air.\n";
    ss << "\\note This should be one of the zone exhaust nodes for the zone cooled by the chiller set.\n";
    ss << "A5 ,  \\field Air Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Not used - reserved for future use\n";
    ss << "\\note The name of the node where the chiller coil sends its outlet air,\n";
    ss << "\\note which must be one of the inlet air nodes for the zone which is being cooled.\n";
    ss << "A6 ;  \\field Air Chiller 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\type object-list\n";
    ss << "\\note This is the first chiller turned on to meet the zone load\n";
    ss << "\\object-list RefrigerationAirChillerNames\n";

    IddObjectType objType(IddObjectType::ZoneHVAC_RefrigerationChillerSet);
    OptionalIddObject oObj = IddObject::load("ZoneHVAC:RefrigerationChillerSet",
                                             "Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ZoneHVAC_RefrigerationChillerSet);
  return object;
}

IddObject createDemandManagerAssignmentListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "DemandManagerAssignmentList,\n";
    ss << "\\extensible:2 Duplicate the last two fields DemandManager Object Type and DemandManager Name\n";
    ss << "\\memo a list of meters that can be reported are available after a run on\n";
    ss << "\\memo the meter dictionary file (.mdd) if the Output:VariableDictionary has been requested.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Meter Name\n";
    ss << "\\required-field\n";
    ss << "\\type external-list\n";
    ss << "\\external-list autoRDDmeter\n";
    ss << "A3 , \\field Demand Limit Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Demand Limit Safety Fraction\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "A4 , \\field Billing Period Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field should reference the same schedule as the month schedule name field of the\n";
    ss << "\\note UtilityCost:Tariff object, if used.\n";
    ss << "\\note If blank, defaults to regular divisions between months.\n";
    ss << "A5 , \\field Peak Period Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field should reference the same schedule as the period schedule name field of the\n";
    ss << "\\note UtilityCost:Tariff object, if used.\n";
    ss << "\\note If blank, defaults to always on peak.\n";
    ss << "N2 , \\field Demand Window Length\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0\n";
    ss << "\\units minutes\n";
    ss << "A6 , \\field Demand Manager Priority\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Sequential\n";
    ss << "\\key All\n";
    ss << "A7 , \\field DemandManager 1 Object Type\n";
    ss << "\\begin-extensible\n";
    ss << "\\type choice\n";
    ss << "\\key DemandManager:ExteriorLights\n";
    ss << "\\key DemandManager:Lights\n";
    ss << "\\key DemandManager:ElectricEquipment\n";
    ss << "\\key DemandManager:Thermostats\n";
    ss << "\\key DemandManager:Ventilation\n";
    ss << "A8 ; \\field DemandManager 1 Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DemandManagerNames\n";

    IddObjectType objType(IddObjectType::DemandManagerAssignmentList);
    OptionalIddObject oObj = IddObject::load("DemandManagerAssignmentList",
                                             "Demand Limiting Controls",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::DemandManagerAssignmentList);
  return object;
}

IddObject createDemandManager_ExteriorLightsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "DemandManager:ExteriorLights,\n";
    ss << "\\memo used for demand limiting Exterior:Lights objects.\n";
    ss << "\\extensible:1 Duplicate the last field Exterior:Lights Name\n";
    ss << "\\min-fields 9\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference DemandManagerNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Limit Control\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Off\n";
    ss << "\\key Fixed\n";
    ss << "N1 , \\field Minimum Limit Duration\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0\n";
    ss << "\\units minutes\n";
    ss << "\\note If blank, duration defaults to the timestep\n";
    ss << "N2 , \\field Maximum Limit Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N3 , \\field Limit Step Change\n";
    ss << "\\note Not yet implemented\n";
    ss << "\\type real\n";
    ss << "A4 , \\field Selection Control\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key All\n";
    ss << "\\key RotateMany\n";
    ss << "\\key RotateOne\n";
    ss << "N4 , \\field Rotation Duration\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\units minutes\n";
    ss << "\\note If blank, duration defaults to the timestep\n";
    ss << "A5 ; \\field Exterior Lights 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\note Enter the name of an Exterior:Lights object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ExteriorLightsNames\n";

    IddObjectType objType(IddObjectType::DemandManager_ExteriorLights);
    OptionalIddObject oObj = IddObject::load("DemandManager:ExteriorLights",
                                             "Demand Limiting Controls",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::DemandManager_ExteriorLights);
  return object;
}

IddObject createDemandManager_LightsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "DemandManager:Lights,\n";
    ss << "\\memo used for demand limiting Lights objects.\n";
    ss << "\\extensible:1 Duplicate the last field Lights Name\n";
    ss << "\\min-fields 9\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference DemandManagerNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Limit Control\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Off\n";
    ss << "\\key Fixed\n";
    ss << "N1 , \\field Minimum Limit Duration\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0\n";
    ss << "\\units minutes\n";
    ss << "\\note If blank, duration defaults to the timestep\n";
    ss << "N2 , \\field Maximum Limit Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N3 , \\field Limit Step Change\n";
    ss << "\\note Not yet implemented\n";
    ss << "\\type real\n";
    ss << "A4 , \\field Selection Control\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key All\n";
    ss << "\\key RotateMany\n";
    ss << "\\key RotateOne\n";
    ss << "N4 , \\field Rotation Duration\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\units minutes\n";
    ss << "\\note If blank, duration defaults to the timestep\n";
    ss << "A5 ; \\field Lights 1 Name\n";
    ss << "\\note Enter the name of an Lights object.\n";
    ss << "\\note if ZoneList option is used on the Lights object,\n";
    ss << "\\note a single lights object from that assignment\n";
    ss << "\\note can be selected by entering <Zone Name><space><Global Lights Object Name>.\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LightsNames\n";

    IddObjectType objType(IddObjectType::DemandManager_Lights);
    OptionalIddObject oObj = IddObject::load("DemandManager:Lights",
                                             "Demand Limiting Controls",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::DemandManager_Lights);
  return object;
}

IddObject createDemandManager_ElectricEquipmentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "DemandManager:ElectricEquipment,\n";
    ss << "\\memo used for demand limiting ElectricEquipment objects.\n";
    ss << "\\extensible:1 Duplicate the last field ElectricEquipment Name\n";
    ss << "\\min-fields 9\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference DemandManagerNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Limit Control\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Off\n";
    ss << "\\key Fixed\n";
    ss << "N1 , \\field Minimum Limit Duration\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0\n";
    ss << "\\units minutes\n";
    ss << "\\note If blank, duration defaults to the timestep\n";
    ss << "N2 , \\field Maximum Limit Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N3 , \\field Limit Step Change\n";
    ss << "\\note Not yet implemented\n";
    ss << "\\type real\n";
    ss << "A4 , \\field Selection Control\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key All\n";
    ss << "\\key RotateMany\n";
    ss << "\\key RotateOne\n";
    ss << "N4 , \\field Rotation Duration\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\units minutes\n";
    ss << "\\note If blank, duration defaults to the timestep\n";
    ss << "A5 ; \\field Electric Equipment 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\note Enter the name of an ElectricEquipment object.\n";
    ss << "\\note if ZoneList option is used on the ElectricEquipment object,\n";
    ss << "\\note a single equipment object from that assignment\n";
    ss << "\\note can be selected by entering <Zone Name><space><Global ElectricEquipment Object Name>.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ElectricEquipmentNames\n";

    IddObjectType objType(IddObjectType::DemandManager_ElectricEquipment);
    OptionalIddObject oObj = IddObject::load("DemandManager:ElectricEquipment",
                                             "Demand Limiting Controls",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::DemandManager_ElectricEquipment);
  return object;
}

IddObject createDemandManager_ThermostatsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "DemandManager:Thermostats,\n";
    ss << "\\memo used for demand limiting ZoneControl:Thermostat objects.\n";
    ss << "\\extensible:1 Duplicate the last field ZoneControl:Thermostat Name\n";
    ss << "\\min-fields 10\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference DemandManagerNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Reset Control\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Off\n";
    ss << "\\key Fixed\n";
    ss << "N1 , \\field Minimum Reset Duration\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0\n";
    ss << "\\units minutes\n";
    ss << "\\note If blank, duration defaults to the timestep\n";
    ss << "N2 , \\field Maximum Heating Setpoint Reset\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N3 , \\field Maximum Cooling Setpoint Reset\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N4 , \\field Reset Step Change\n";
    ss << "\\note Not yet implemented\n";
    ss << "\\type real\n";
    ss << "A4 , \\field Selection Control\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key All\n";
    ss << "\\key RotateMany\n";
    ss << "\\key RotateOne\n";
    ss << "N5 , \\field Rotation Duration\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\units minutes\n";
    ss << "\\note If blank, duration defaults to the timestep\n";
    ss << "A5 ; \\field Thermostat 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\note Enter the name of a ZoneControl:Thermostat object.\n";
    ss << "\\note if ZoneList option is used on the ZoneControl:Thermostat object,\n";
    ss << "\\note a single thermostat object from that assignment\n";
    ss << "\\note can be selected by entering <Zone Name><space><Global Thermostat Object Name>.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneControlThermostaticNames\n";

    IddObjectType objType(IddObjectType::DemandManager_Thermostats);
    OptionalIddObject oObj = IddObject::load("DemandManager:Thermostats",
                                             "Demand Limiting Controls",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::DemandManager_Thermostats);
  return object;
}

IddObject createDemandManager_VentilationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "DemandManager:Ventilation,\n";
    ss << "\\memo used for demand limiting Controller:OutdoorAir objects.\n";
    ss << "\\extensible:1 Duplicate the last field Controller:OutdoorAir Name\n";
    ss << "\\min-fields 10\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference DemandManagerNames\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this demand manager. Schedule value > 0 means the demand manager is available.\n";
    ss << "\\note If this field is blank, the DR is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Limit Control\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Off\n";
    ss << "\\key FixedRate\n";
    ss << "\\key ReductionRatio\n";
    ss << "N1 , \\field Minimum Limit Duration\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0\n";
    ss << "\\units minutes\n";
    ss << "\\note If blank, duration defaults to the timestep\n";
    ss << "N2 , \\field Fixed Rate\n";
    ss << "\\memo Used in case when Limit strategy is set to FixedRate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units m3/s\n";
    ss << "N3 , \\field Reduction Ratio\n";
    ss << "\\memo Used in case when Limit Control is set to ReductionRatio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N4 , \\field Limit Step Change\n";
    ss << "\\note Not yet implemented\n";
    ss << "\\type real\n";
    ss << "A4 , \\field Selection Control\n";
    ss << "\\type choice\n";
    ss << "\\key All\n";
    ss << "\\key RotateMany\n";
    ss << "\\key RotateOne\n";
    ss << "\\default All\n";
    ss << "N5 , \\field Rotation Duration\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\units minutes\n";
    ss << "\\note If blank, duration defaults to the timestep\n";
    ss << "A5 ; \\field Controller Outdoor Air 1 Name\n";
    ss << "\\note Enter the name of a Controller:OutdoorAir object.\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OAControllerNames\n";

    IddObjectType objType(IddObjectType::DemandManager_Ventilation);
    OptionalIddObject oObj = IddObject::load("DemandManager:Ventilation",
                                             "Demand Limiting Controls",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::DemandManager_Ventilation);
  return object;
}

IddObject createGenerator_InternalCombustionEngineIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Generator:InternalCombustionEngine,\n";
    ss << "\\memo This generator model is the empirical model from the Building Loads\n";
    ss << "\\memo and System Thermodynamics (BLAST) program.  Engine performance\n";
    ss << "\\memo curves are generated by fitting catalog data to second order\n";
    ss << "\\memo polynomial equations.  Three sets of coefficients are required.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference GeneratorNames\n";
    ss << "N1, \\field Rated Power Output\n";
    ss << "\\units W\n";
    ss << "A2, \\field Electric Circuit Node Name\n";
    ss << "N2, \\field Minimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N3, \\field Maximum Part Load Ratio\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N4, \\field Optimum Part Load Ratio\n";
    ss << "A3, \\field Shaft Power Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note PLR = Ratio of Generator Load to Rated Power Output\n";
    ss << "A4, \\field Jacket Heat Recovery Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note PLR = Ratio of Generator Load to Rated Power Output\n";
    ss << "A5, \\field Lube Heat Recovery Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note PLR = Ratio of Generator Load to Rated Power Output\n";
    ss << "A6, \\field Total Exhaust Energy Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note PLR = Ratio of Generator Load to Rated Power Output\n";
    ss << "A7, \\field Exhaust Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note PLR = Ratio of Generator Load to Rated Power Output\n";
    ss << "N5, \\field Coefficient 1 of U-Factor Times Area Curve\n";
    ss << "\\note curve = C1 * Generator Rated Power Output**C2\n";
    ss << "N6, \\field Coefficient 2 of U-Factor Times Area Curve\n";
    ss << "\\note curve = C1 * Generator Rated Power Output**C2\n";
    ss << "\\note typical value .9\n";
    ss << "\\maximum 2\n";
    ss << "N7, \\field Maximum Exhaust Flow per Unit of Power Output\n";
    ss << "\\units (kg/s)/W\n";
    ss << "N8, \\field Design Minimum Exhaust Temperature\n";
    ss << "\\units C\n";
    ss << "N9, \\field Fuel Higher Heating Value\n";
    ss << "\\units kJ/kg\n";
    ss << "N10, \\field Design Heat Recovery Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note if non-zero, then inlet, outlet nodes must be entered.\n";
    ss << "\\ip-units gal/min\n";
    ss << "A8, \\field Heat Recovery Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A9, \\field Heat Recovery Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A10,\\field Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\default Diesel\n";
    ss << "N11; \\field Heat Recovery Maximum Temperature\n";
    ss << "\\units C\n";
    ss << "\\maximum 100.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 80.0\n";

    IddObjectType objType(IddObjectType::Generator_InternalCombustionEngine);
    OptionalIddObject oObj = IddObject::load("Generator:InternalCombustionEngine",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Generator_InternalCombustionEngine);
  return object;
}

IddObject createGenerator_CombustionTurbineIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Generator:CombustionTurbine,\n";
    ss << "\\memo This generator model is the empirical model from the Building Loads\n";
    ss << "\\memo and System Thermodynamics (BLAST) program.  Generator performance\n";
    ss << "\\memo curves are generated by fitting catalog data to second order\n";
    ss << "\\memo polynomial equations.  Three sets of coefficients are required.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference GeneratorNames\n";
    ss << "N1, \\field Rated Power Output\n";
    ss << "\\units W\n";
    ss << "A2, \\field Electric Circuit Node Name\n";
    ss << "N2, \\field Minimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N3, \\field Maximum Part Load Ratio\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N4, \\field Optimum Part Load Ratio\n";
    ss << "A3, \\field Part Load Based Fuel Input Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note PLR = Ratio of Generator Load to Rated Power Output\n";
    ss << "\\note this curve is multiplied to the Temperature Based Fuel Input Curve\n";
    ss << "\\note to determine Fuel Energy In\n";
    ss << "A4, \\field Temperature Based Fuel Input Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = a + b*AT + c*AT**2\n";
    ss << "\\note AT = Ambient Delta T\n";
    ss << "\\note this curve is multiplied to the Part Load Based Fuel Input Curve\n";
    ss << "\\note to determine Fuel Energy In\n";
    ss << "A5, \\field Exhaust Flow Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = a + b*AT + c*AT**2\n";
    ss << "\\note AT = Ambient Delta T\n";
    ss << "A6, \\field Part Load Based Exhaust Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note PLR = Ratio of Generator Load to Rated Power Output\n";
    ss << "\\note this curve is multiplied to the Temperature Based Exhaust Temperature Curve\n";
    ss << "\\note to determine Exhaust Temperature\n";
    ss << "A7, \\field Temperature Based Exhaust Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = a + b*AT + c*AT**2\n";
    ss << "\\note AT = Ambient Delta T\n";
    ss << "\\note this curve is multiplied to the Part Load Based Exhaust Temperature Curve\n";
    ss << "\\note to determine Exhaust Temperature\n";
    ss << "A8, \\field Heat Recovery Lube Energy Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note PLR = Ratio of Generator Load to Rated Power Output\n";
    ss << "N5, \\field Coefficient 1 of U-Factor Times Area Curve\n";
    ss << "\\note curve = C1 * Rated Power Output**C2\n";
    ss << "N6, \\field Coefficient 2 of U-Factor Times Area Curve\n";
    ss << "\\note curve = C1 * Rated Power Output**C2\n";
    ss << "\\note typical value .9\n";
    ss << "\\maximum 2\n";
    ss << "N7, \\field Maximum Exhaust Flow per Unit of Power Output\n";
    ss << "\\units (kg/s)/W\n";
    ss << "N8, \\field Design Minimum Exhaust Temperature\n";
    ss << "\\units C\n";
    ss << "N9, \\field Design Air Inlet Temperature\n";
    ss << "\\units C\n";
    ss << "N10, \\field Fuel Higher Heating Value\n";
    ss << "\\units kJ/kg\n";
    ss << "N11, \\field Design Heat Recovery Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note if non-zero, then inlet, outlet nodes must be entered.\n";
    ss << "\\ip-units gal/min\n";
    ss << "A9 , \\field Heat Recovery Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A10, \\field Heat Recovery Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A11, \\field Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\default NaturalGas\n";
    ss << "N12, \\field Heat Recovery Maximum Temperature\n";
    ss << "\\units C\n";
    ss << "\\maximum 100.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 80.0\n";
    ss << "A12; \\field Outdoor Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Enter the name of an outdoor air node\n";

    IddObjectType objType(IddObjectType::Generator_CombustionTurbine);
    OptionalIddObject oObj = IddObject::load("Generator:CombustionTurbine",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Generator_CombustionTurbine);
  return object;
}

IddObject createGenerator_MicroTurbineIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Generator:MicroTurbine,\n";
    ss << "\\memo MicroTurbine generators are small combustion turbines (e.g., 25kW to 500kW). The model\n";
    ss << "\\memo calculates electrical power output, fuel use, standby and ancillary power.\n";
    ss << "\\memo Energy recovery from exhaust air can be used to heat water.\n";
    ss << "\\min-fields 11\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference GeneratorNames\n";
    ss << "\\reference MicroTurbineGeneratorNames\n";
    ss << "N1, \\field Reference Electrical Power Output\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2, \\field Minimum Full Load Electrical Power Output\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N3, \\field Maximum Full Load Electrical Power Output\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note If left blank, Maximum Full Load Electrical Power Output will be set\n";
    ss << "\\note equal to the Reference Electrical Power Output.\n";
    ss << "N4, \\field Reference Electrical Efficiency Using Lower Heating Value\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note Electric power output divided by fuel energy input (LHV basis)\n";
    ss << "\\note at reference conditions.\n";
    ss << "N5, \\field Reference Combustion Air Inlet Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 15.0\n";
    ss << "N6, \\field Reference Combustion Air Inlet Humidity Ratio\n";
    ss << "\\type real\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.00638\n";
    ss << "N7, \\field Reference Elevation\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum -300.0\n";
    ss << "\\default 0.0\n";
    ss << "A2, \\field Electrical Power Function of Temperature and Elevation Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*T + c*T**2 + d*Elev + e*Elev**2 + f*T*Elev\n";
    ss << "\\note T = combustion air inlet temperature (C)\n";
    ss << "\\note Elev = elevation (m)\n";
    ss << "A3, \\field Electrical Efficiency Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Quadratic curve = a + b*T + c*T**2\n";
    ss << "\\note Cubic curve = a + b*T + c*T**2 + d*T**3\n";
    ss << "\\note T = combustion air inlet temperature (C)\n";
    ss << "A4, \\field Electrical Efficiency Function of Part Load Ratio Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note Quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note Cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLR = ratio of Generator Load to steady state Electrical Power Output at\n";
    ss << "\\note current operating conditions\n";
    ss << "A5, \\field Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\default NaturalGas\n";
    ss << "N8, \\field Fuel Higher Heating Value\n";
    ss << "\\type real\n";
    ss << "\\units kJ/kg\n";
    ss << "\\default 50000\n";
    ss << "\\minimum> 0.0\n";
    ss << "N9, \\field Fuel Lower Heating Value\n";
    ss << "\\type real\n";
    ss << "\\units kJ/kg\n";
    ss << "\\default 45450\n";
    ss << "\\minimum> 0.0\n";
    ss << "N10, \\field Standby Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\default 0.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Electric power consumed when the generator is available but not being called\n";
    ss << "\\note by the Electric Load Center.\n";
    ss << "N11, \\field Ancillary Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\default 0.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Electric power consumed by ancillary equipment (e.g., external fuel pressurization pump).\n";
    ss << "\\note Set to zero if Reference Electrical Power Output is the 'net' value (ancillary power\n";
    ss << "\\note already deducted). Input value is positive, but indicates negative electric generation.\n";
    ss << "A6, \\field Ancillary Power Function of Fuel Input Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Quadratic curve = a + b*mdot + c*mdot**2\n";
    ss << "\\note mdot = fuel mass flow rate (kg/s)\n";
    ss << "\\note If left blank, model assumes ancillary power defined in previous field is constant\n";
    ss << "\\note whenever the generator is operating.\n";
    ss << "A7, \\field Heat Recovery Water Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A8, \\field Heat Recovery Water Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N12, \\field Reference Thermal Efficiency Using Lower Heat Value\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Reference thermal efficiency (heat recovery to water) based on the\n";
    ss << "\\note Lower Heating Value (LHV) of the fuel.\n";
    ss << "N13, \\field Reference Inlet Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "A9, \\field Heat Recovery Water Flow Operating Mode\n";
    ss << "\\type choice\n";
    ss << "\\key PlantControl\n";
    ss << "\\key InternalControl\n";
    ss << "\\default PlantControl\n";
    ss << "\\note PlantControl means the heat recovery water flow rate is determined by the plant,\n";
    ss << "\\note but the user needs to supply a heat recovery water flow rate.\n";
    ss << "\\note InternalControl means the heat recovery water flow rate is controlled by this generator.\n";
    ss << "\\note If 'InternalControl' is selected, then the user needs to supply a reference heat\n";
    ss << "\\note recovery water flow rate and optionally the name of a heat recovery flow rate modifier curve.\n";
    ss << "N14, \\field Reference Heat Recovery Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0.0\n";
    ss << "A10, \\field Heat Recovery Water Flow Rate Function of Temperature and Power Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*T + c*T**2 + d*Pnet + e*Pnet + f*T*Pnet\n";
    ss << "\\note T = heat recovery inlet water temperature\n";
    ss << "\\note Pnet = net power output = electric power output - ancillary power\n";
    ss << "\\note If left blank, model assumes the heat recovery water flow rate is constant whenever the\n";
    ss << "\\note generator is operating, at the Reference HR Water Flow Rate defined in the previous field.\n";
    ss << "A11, \\field Thermal Efficiency Function of Temperature and Elevation Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BicubicBiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note Bicubic curve = a + b*T + c*T**2 + d*Elev + e*Elev**2 + f*T*Elev + g*T**3 + h*Elev**3 + i*T**2*Elev + j*T*Elev**2\n";
    ss << "\\note Biquadratic curve = a + b*T + c*T**2 + d*Elev + e*Elev**2 + f*T*Elev\n";
    ss << "\\note T = combustion air inlet temperature (C)\n";
    ss << "\\note Elev = elevation (m)\n";
    ss << "\\note If field is left blank, model assumes this modifier equals 1 for entire simulation.\n";
    ss << "A12, \\field Heat Recovery Rate Function of Part Load Ratio Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note Cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLR = ratio of Generator Load to steady state Electrical Power Output at\n";
    ss << "\\note current operating conditions\n";
    ss << "\\note If field is left blank, model assumes this modifier equals 1 for entire simulation.\n";
    ss << "A13, \\field Heat Recovery Rate Function of Inlet Water Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Quadratic curve = a + b*T + c*T**2\n";
    ss << "\\note T = inlet water temperature (C)\n";
    ss << "\\note If field is left blank, model assumes this modifier equals 1 for entire simulation.\n";
    ss << "A14, \\field Heat Recovery Rate Function of Water Flow Rate Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Quadratic curve = a + b*Flow + c*Flow**2\n";
    ss << "\\note Flow = flow rate of water through the heat exchanger (m3/s)\n";
    ss << "\\note If field is left blank, model assumes this modifier equals 1 for entire simulation.\n";
    ss << "N15, \\field Minimum Heat Recovery Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N16, \\field Maximum Heat Recovery Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N17, \\field Maximum Heat Recovery Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "A15, \\field Combustion Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "\\note Must be an outdoor air node.\n";
    ss << "A16, \\field Combustion Air Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N18, \\field Reference Exhaust Air Mass Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units kg/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "A17, \\field Exhaust Air Flow Rate Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Quadratic curve = a + b*T + c*T**2\n";
    ss << "\\note Cubic curve = a + b*T + c*T**2 + d*T**3\n";
    ss << "\\note T = combustion air inlet temperature (C)\n";
    ss << "\\note If field is left blank, model assumes this modifier equals 1 for entire simulation.\n";
    ss << "A18, \\field Exhaust Air Flow Rate Function of Part Load Ratio Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note Cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLR = ratio of Generator Load to steady state Electrical Power Output at\n";
    ss << "\\note current operating conditions.\n";
    ss << "\\note If field is left blank, model assumes this modifier equals 1 for entire simulation.\n";
    ss << "N19, \\field Nominal Exhaust Air Outlet Temperature\n";
    ss << "\\type real\n";
    ss << "\\note Exhaust air outlet temperature at reference conditions.\n";
    ss << "A19, \\field Exhaust Air Temperature Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Quadratic curve = a + b*T + c*T**2\n";
    ss << "\\note Cubic curve = a + b*T + c*T**2 + d*T**3\n";
    ss << "\\note T = combustion air inlet temperature (C)\n";
    ss << "\\note If field is left blank, model assumes this modifier equals 1 for entire simulation.\n";
    ss << "A20; \\field Exhaust Air Temperature Function of Part Load Ratio Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note Cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLR = ratio of Generator Load to steady state Electrical Power Output at\n";
    ss << "\\note current operating conditions.\n";
    ss << "\\note If field is left blank, model assumes this modifier equals 1 for entire simulation.\n";

    IddObjectType objType(IddObjectType::Generator_MicroTurbine);
    OptionalIddObject oObj = IddObject::load("Generator:MicroTurbine",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Generator_MicroTurbine);
  return object;
}

IddObject createGenerator_PhotovoltaicIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Generator:Photovoltaic,\n";
    ss << "\\memo Describes an array of photovoltaic (PV) modules.  A series of different PV arrays\n";
    ss << "\\memo can be connected to a single electric load center (and inverter) by listing them all\n";
    ss << "\\memo in an ElectricLoadCenter:Generator object. PV performance is taken from the\n";
    ss << "\\memo referenced PhotovoltaicPerformance:* object. Array tilt, azimuth, and gross area\n";
    ss << "\\memo are taken from the referenced building surface or shading surface. The array\n";
    ss << "\\memo surface participates normally in all shading calculations.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference GeneratorNames\n";
    ss << "\\reference PVGeneratorNames\n";
    ss << "A2 , \\field Surface Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllShadingAndHTSurfNames\n";
    ss << "A3 , \\field Photovoltaic Performance Object Type\n";
    ss << "\\type choice\n";
    ss << "\\key PhotovoltaicPerformance:Simple\n";
    ss << "\\key PhotovoltaicPerformance:EquivalentOne-Diode\n";
    ss << "\\key PhotovoltaicPerformance:Sandia\n";
    ss << "A4 , \\field Module Performance Name\n";
    ss << "\\note PV array modeling details\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PVModules\n";
    ss << "A5 , \\field Heat Transfer Integration Mode\n";
    ss << "\\type choice\n";
    ss << "\\key Decoupled\n";
    ss << "\\key DecoupledUllebergDynamic\n";
    ss << "\\key IntegratedSurfaceOutsideFace\n";
    ss << "\\key IntegratedTranspiredCollector\n";
    ss << "\\key IntegratedExteriorVentedCavity\n";
    ss << "\\key PhotovoltaicThermalSolarCollector\n";
    ss << "\\default Decoupled\n";
    ss << "N1 , \\field Number of Modules in Parallel\n";
    ss << "\\default 1\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 1\n";
    ss << "N2 ; \\field Number of Modules in Series\n";
    ss << "\\default 1\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 1\n";

    IddObjectType objType(IddObjectType::Generator_Photovoltaic);
    OptionalIddObject oObj = IddObject::load("Generator:Photovoltaic",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Generator_Photovoltaic);
  return object;
}

IddObject createPhotovoltaicPerformance_SimpleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PhotovoltaicPerformance:Simple,\n";
    ss << "\\memo Describes a simple model of photovoltaics that may be useful for early phase\n";
    ss << "\\memo design analysis. In this model the user has direct access to the efficiency with\n";
    ss << "\\memo which surfaces convert incident solar radiation to electricity and need not specify\n";
    ss << "\\memo arrays of specific modules.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\reference PVModules\n";
    ss << "N1 , \\field Fraction of Surface Area with Active Solar Cells\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A2 , \\field Conversion Efficiency Input Mode\n";
    ss << "\\type choice\n";
    ss << "\\key Fixed\n";
    ss << "\\key Scheduled\n";
    ss << "N2 , \\field Value for Cell Efficiency if Fixed\n";
    ss << "\\note Efficiency = (power generated [W])/(incident solar[W])\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A3 ; \\field Efficiency Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::PhotovoltaicPerformance_Simple);
    OptionalIddObject oObj = IddObject::load("PhotovoltaicPerformance:Simple",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PhotovoltaicPerformance_Simple);
  return object;
}

IddObject createPhotovoltaicPerformance_EquivalentOneDiodeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PhotovoltaicPerformance:EquivalentOne-Diode,\n";
    ss << "\\memo Describes the performance characteristics of Photovoltaic (PV) modules to be modeled\n";
    ss << "\\memo using an equivalent one-diode circuit.  This model is also known as\n";
    ss << "\\memo the 4- or 5-parameter TRNSYS model for photovoltaics.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\reference PVModules\n";
    ss << "A2 , \\field Cell type\n";
    ss << "\\type choice\n";
    ss << "\\key CrystallineSilicon\n";
    ss << "\\key AmorphousSilicon\n";
    ss << "N1 , \\field Number of Cells in Series\n";
    ss << "\\default 36\n";
    ss << "\\type integer\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "N2 , \\field Active Area\n";
    ss << "\\note The total power output of the array is determined by the\n";
    ss << "\\note number of modules (see above).  The Active Area is only\n";
    ss << "\\note used to calculate the PV Array Efficiency output variable.\n";
    ss << "\\default 0.89\n";
    ss << "\\type real\n";
    ss << "\\units m2\n";
    ss << "\\minimum 0.1\n";
    ss << "N3 , \\field Transmittance Absorptance Product\n";
    ss << "\\default 0.95\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N4 , \\field Semiconductor Bandgap\n";
    ss << "\\default 1.12\n";
    ss << "\\type real\n";
    ss << "\\units eV\n";
    ss << "\\minimum 0.0\n";
    ss << "N5 , \\field Shunt Resistance\n";
    ss << "\\default 1000000.0\n";
    ss << "\\type real\n";
    ss << "\\units ohms\n";
    ss << "\\minimum 0.0\n";
    ss << "N6 , \\field Short Circuit Current\n";
    ss << "\\default 6.5\n";
    ss << "\\type real\n";
    ss << "\\units A\n";
    ss << "\\minimum 0.0\n";
    ss << "N7, \\field Open Circuit Voltage\n";
    ss << "\\default 21.6\n";
    ss << "\\type real\n";
    ss << "\\units V\n";
    ss << "\\minimum 0.0\n";
    ss << "N8, \\field Reference Temperature\n";
    ss << "\\default 25\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "N9, \\field Reference Insolation\n";
    ss << "\\default 1000\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "N10, \\field Module Current at Maximum Power\n";
    ss << "\\note Single module current at the maximum power point\n";
    ss << "\\note and reference conditions.  Module Current, Module Voltage,\n";
    ss << "\\note Number of Modules in Parallel and Number of Modules in Series\n";
    ss << "\\note determine the maximum power output of the array.\n";
    ss << "\\default 5.9\n";
    ss << "\\type real\n";
    ss << "\\units A\n";
    ss << "\\minimum 0.0\n";
    ss << "N11, \\field Module Voltage at Maximum Power\n";
    ss << "\\note Single module voltage at the maximum power point\n";
    ss << "\\note and reference conditions.  Module Current, Module Voltage,\n";
    ss << "\\note Number of Modules in Parallel and Number of Modules in Series\n";
    ss << "\\note determine the maximum power output of the array.\n";
    ss << "\\default 17\n";
    ss << "\\type real\n";
    ss << "\\units V\n";
    ss << "\\minimum 0.0\n";
    ss << "N12, \\field Temperature Coefficient of Short Circuit Current\n";
    ss << "\\default 0.02\n";
    ss << "\\type real\n";
    ss << "\\units A/K\n";
    ss << "N13, \\field Temperature Coefficient of Open Circuit Voltage\n";
    ss << "\\default -0.079\n";
    ss << "\\type real\n";
    ss << "\\units V/K\n";
    ss << "N14, \\field Nominal Operating Cell Temperature Test Ambient Temperature\n";
    ss << "\\default 20\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "N15, \\field Nominal Operating Cell Temperature Test Cell Temperature\n";
    ss << "\\default 40\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "N16, \\field Nominal Operating Cell Temperature Test Insolation\n";
    ss << "\\default 800\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "N17, \\field Module Heat Loss Coefficient\n";
    ss << "\\default 30\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum 0.0\n";
    ss << "N18; \\field Total Heat Capacity\n";
    ss << "\\default 50000\n";
    ss << "\\type real\n";
    ss << "\\units J/m2-K\n";
    ss << "\\minimum 0.0\n";

    IddObjectType objType(IddObjectType::PhotovoltaicPerformance_EquivalentOneDiode);
    OptionalIddObject oObj = IddObject::load("PhotovoltaicPerformance:EquivalentOne-Diode",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PhotovoltaicPerformance_EquivalentOneDiode);
  return object;
}

IddObject createPhotovoltaicPerformance_SandiaIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "PhotovoltaicPerformance:Sandia,\n";
    ss << "\\memo Describes performance input data needed for specific makes and models of production\n";
    ss << "\\memo PV panels using the empirical coefficients assembled by Sandia National Laboratory.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\reference PVModules\n";
    ss << "N1 , \\field Active Area\n";
    ss << "\\note (m2, single module)\n";
    ss << "\\default 1.0\n";
    ss << "\\type real\n";
    ss << "\\units m2\n";
    ss << "\\minimum 0.0\n";
    ss << "N2 , \\field Number of Cells in Series\n";
    ss << "\\default 1\n";
    ss << "\\type integer\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 1\n";
    ss << "N3 , \\field Number of Cells in Parallel\n";
    ss << "\\default 1\n";
    ss << "\\type integer\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 1\n";
    ss << "N4 , \\field Short Circuit Current\n";
    ss << "\\note (Amps)\n";
    ss << "\\type real\n";
    ss << "\\units A\n";
    ss << "N5 , \\field Open Circuit Voltage\n";
    ss << "\\note (Volts)\n";
    ss << "\\type real\n";
    ss << "\\units V\n";
    ss << "N6 , \\field Current at Maximum Power Point\n";
    ss << "\\note (Amps)\n";
    ss << "\\type real\n";
    ss << "\\units A\n";
    ss << "N7 , \\field Voltage at Maximum Power Point\n";
    ss << "\\note (Volts)\n";
    ss << "\\type real\n";
    ss << "\\units V\n";
    ss << "N8 , \\field Sandia Database Parameter aIsc\n";
    ss << "\\note (1/degC)\n";
    ss << "\\type real\n";
    ss << "\\units 1/K\n";
    ss << "N9 , \\field Sandia Database Parameter aImp\n";
    ss << "\\note (1/degC)\n";
    ss << "\\type real\n";
    ss << "\\units 1/K\n";
    ss << "N10 , \\field Sandia Database Parameter c0\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N11 , \\field Sandia Database Parameter c1\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N12 , \\field Sandia Database Parameter BVoc0\n";
    ss << "\\note (Volts/degC)\n";
    ss << "\\type real\n";
    ss << "\\units V/K\n";
    ss << "N13 , \\field Sandia Database Parameter mBVoc\n";
    ss << "\\note (Volts/degC)\n";
    ss << "\\type real\n";
    ss << "\\units V/K\n";
    ss << "N14 , \\field Sandia Database Parameter BVmp0\n";
    ss << "\\note (Volts/degC)\n";
    ss << "\\type real\n";
    ss << "\\units V/K\n";
    ss << "N15 , \\field Sandia Database Parameter mBVmp\n";
    ss << "\\note (Volts/degC)\n";
    ss << "\\type real\n";
    ss << "\\units V/K\n";
    ss << "N16 , \\field Diode Factor\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N17 , \\field Sandia Database Parameter c2\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N18 , \\field Sandia Database Parameter c3\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N19 , \\field Sandia Database Parameter a0\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N20 , \\field Sandia Database Parameter a1\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N21 , \\field Sandia Database Parameter a2\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N22 , \\field Sandia Database Parameter a3\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N23 , \\field Sandia Database Parameter a4\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N24 , \\field Sandia Database Parameter b0\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N25 , \\field Sandia Database Parameter b1\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N26 , \\field Sandia Database Parameter b2\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N27 , \\field Sandia Database Parameter b3\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N28 , \\field Sandia Database Parameter b4\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N29 , \\field Sandia Database Parameter b5\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N30 , \\field Sandia Database Parameter Delta(Tc)\n";
    ss << "\\note (deg C)\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "N31 , \\field Sandia Database Parameter fd\n";
    ss << "\\note (nondimensional)\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N32 , \\field Sandia Database Parameter a\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N33 , \\field Sandia Database Parameter b\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N34 , \\field Sandia Database Parameter c4\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N35 , \\field Sandia Database Parameter c5\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N36 , \\field Sandia Database Parameter Ix0\n";
    ss << "\\note (Amps)\n";
    ss << "\\type real\n";
    ss << "N37 , \\field Sandia Database Parameter Ixx0\n";
    ss << "\\note (Amps)\n";
    ss << "\\type real\n";
    ss << "N38 , \\field Sandia Database Parameter c6\n";
    ss << "\\type real\n";
    ss << "N39 ; \\field Sandia Database Parameter c7\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::PhotovoltaicPerformance_Sandia);
    OptionalIddObject oObj = IddObject::load("PhotovoltaicPerformance:Sandia",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::PhotovoltaicPerformance_Sandia);
  return object;
}

IddObject createGenerator_FuelCellIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Generator:FuelCell,\n";
    ss << "\\memo This generator model is the FC model from IEA Annex 42\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference GeneratorNames\n";
    ss << "A2, \\field Power Module Name\n";
    ss << "\\note Enter the name of a Generator:FuelCell:PowerModule object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FCPMNames\n";
    ss << "A3, \\field Air Supply Name\n";
    ss << "\\note Enter then name of a Generator:FuelCell:AirSupply object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FCAirSupNames\n";
    ss << "A4, \\field Fuel Supply Name\n";
    ss << "\\note Enter the name of a Generator:FuelSupply object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list GenFuelSupNames\n";
    ss << "A5, \\field Water Supply Name\n";
    ss << "\\note Enter the name of a Generator:FuelCell:WaterSupply object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FCWaterSupNames\n";
    ss << "A6, \\field Auxiliary Heater Name\n";
    ss << "\\note Enter the name of a Generator:FuelCell:AuxiliaryHeater object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FCAuxHeatNames\n";
    ss << "A7, \\field Heat Exchanger Name\n";
    ss << "\\note Enter the name of a Generator:FuelCell:ExhaustGasToWaterHeatExchanger object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FCExhaustHXNames\n";
    ss << "A8, \\field Electrical Storage Name\n";
    ss << "\\note Enter the name of a Generator:FuelCell:ElectricalStorage object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FCStorageNames\n";
    ss << "A9, \\field Inverter Name\n";
    ss << "\\note Enter the name of a Generator:FuelCell:Inverter object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FCInverterNames\n";
    ss << "A10; \\field Stack Cooler Name\n";
    ss << "\\note Enter the name of a Generator:FuelCell:StackCooler object.\n";
    ss << "\\note optional, used for PEMFC\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FCStackCoolerNames\n";

    IddObjectType objType(IddObjectType::Generator_FuelCell);
    OptionalIddObject oObj = IddObject::load("Generator:FuelCell",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Generator_FuelCell);
  return object;
}

IddObject createGenerator_FuelCell_PowerModuleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Generator:FuelCell:PowerModule,\n";
    ss << "\\memo Describe the core power module subsystem of a fuel cell power generator. This includes\n";
    ss << "\\memo the fuel cell stack, fuel reformer, and whatever ancillary devices are included inside.\n";
    ss << "\\memo If the model has multiple FC generators that are of the exact same type, then only one\n";
    ss << "\\memo of these objects is needed and all the Generator:FuelCell objects can reference it.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference FCPMNames\n";
    ss << "A2, \\field Efficiency Curve Mode\n";
    ss << "\\type choice\n";
    ss << "\\key Annex42\n";
    ss << "\\key Normalized\n";
    ss << "A3, \\field Efficiency Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\required-field\n";
    ss << "N1, \\field Nominal Efficiency\n";
    ss << "\\note This field is not used.\n";
    ss << "N2, \\field Nominal Electrical Power\n";
    ss << "\\note This field is not used\n";
    ss << "\\units W\n";
    ss << "N3, \\field Number of Stops at Start of Simulation\n";
    ss << "\\note this is Nstops in SOFC model specification\n";
    ss << "N4, \\field Cycling Performance Degradation Coefficient\n";
    ss << "\\note this is D in SOFC model specification\n";
    ss << "N5, \\field Number of Run Hours at Beginning of Simulation\n";
    ss << "\\units hr\n";
    ss << "N6, \\field Accumulated Run Time Degradation Coefficient\n";
    ss << "\\note this is L in SOFC model specification\n";
    ss << "N7, \\field Run Time Degradation Initiation Time Threshold\n";
    ss << "\\units hr\n";
    ss << "N8, \\field Power Up Transient Limit\n";
    ss << "\\units W/s\n";
    ss << "\\note Maximum rate of change in electrical output [power increasing]\n";
    ss << "N9, \\field Power Down Transient Limit\n";
    ss << "\\units W/s\n";
    ss << "\\note Maximum rate of change in electrical output [power decreasing]\n";
    ss << "\\note Enter positive value for rate of change\n";
    ss << "N10,\\field Start Up Time\n";
    ss << "\\units s\n";
    ss << "\\note Time from start up to normal operation\n";
    ss << "N11,\\field Start Up Fuel\n";
    ss << "\\units kmol\n";
    ss << "N12,\\field Start Up Electricity Consumption\n";
    ss << "\\units J\n";
    ss << "N13,\\field Start Up Electricity Produced\n";
    ss << "\\units J\n";
    ss << "N14,\\field Shut Down Time\n";
    ss << "\\units s\n";
    ss << "N15,\\field Shut Down Fuel\n";
    ss << "\\units kmol\n";
    ss << "N16,\\field Shut Down Electricity Consumption\n";
    ss << "\\units J\n";
    ss << "N17,\\field Ancillary Electricity Constant Term\n";
    ss << "N18,\\field Ancillary Electricity Linear Term\n";
    ss << "A4, \\field Skin Loss Calculation Mode\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantRate\n";
    ss << "\\key UAForProcessGasTemperature\n";
    ss << "\\key QuadraticFunctionOfFuelRate\n";
    ss << "A5, \\field Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N19,\\field Skin Loss Radiative Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N20,\\field Constant Skin Loss Rate\n";
    ss << "\\units W\n";
    ss << "N21,\\field Skin Loss U-Factor Times Area Term\n";
    ss << "\\units W/K\n";
    ss << "A6, \\field Skin Loss Quadratic Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note curve is function of fuel use rate\n";
    ss << "N22,\\field Dilution Air Flow Rate\n";
    ss << "\\units kmol/s\n";
    ss << "N23,\\field Stack Heat loss to Dilution Air\n";
    ss << "\\units W\n";
    ss << "A7, \\field Dilution Inlet Air Node Name\n";
    ss << "\\type node\n";
    ss << "A8 ,\\field Dilution Outlet Air Node Name\n";
    ss << "\\type node\n";
    ss << "N24, \\field Minimum Operating Point\n";
    ss << "\\units W\n";
    ss << "N25; \\field Maximum Operating Point\n";
    ss << "\\units W\n";

    IddObjectType objType(IddObjectType::Generator_FuelCell_PowerModule);
    OptionalIddObject oObj = IddObject::load("Generator:FuelCell:PowerModule",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Generator_FuelCell_PowerModule);
  return object;
}

IddObject createGenerator_FuelCell_AirSupplyIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Generator:FuelCell:AirSupply,\n";
    ss << "\\memo Used to define details of the air supply subsystem for a fuel cell power generator.\n";
    ss << "\\extensible:2 - repeat last two fields, remembering to remove ; from \"inner\" fields.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference FCAirSupNames\n";
    ss << "A2, \\field Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A3, \\field Blower Power Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "N1, \\field Blower Heat Loss Factor\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A4, \\field Air Supply Rate Calculation Mode\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key AirRatiobyStoics\n";
    ss << "\\key QuadraticFunctionofElectricPower\n";
    ss << "\\key QuadraticFunctionofFuelRate\n";
    ss << "N2, \\field Stoichiometric Ratio\n";
    ss << "\\note This is the excess air \"stoics\"\n";
    ss << "\\note the value entered is incremented by 1 in the model.\n";
    ss << "A5, \\field Air Rate Function of Electric Power Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "N3, \\field Air Rate Air Temperature Coefficient\n";
    ss << "A6, \\field Air Rate Function of Fuel Rate Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A7, \\field Air Intake Heat Recovery Mode\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key NoRecovery\n";
    ss << "\\key RecoverBurnerInverterStorage\n";
    ss << "\\key RecoverAuxiliaryBurner\n";
    ss << "\\key RecoverInverterandStorage\n";
    ss << "\\key RecoverInverter\n";
    ss << "\\key RecoverElectricalStorage\n";
    ss << "A8, \\field Air Supply Constituent Mode\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key AmbientAir\n";
    ss << "\\key UserDefinedConstituents\n";
    ss << "N4, \\field Number of UserDefined Constituents\n";
    ss << "\\maximum 5\n";
    ss << "A9, \\field Constituent 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\type choice\n";
    ss << "\\key CarbonDioxide\n";
    ss << "\\key Nitrogen\n";
    ss << "\\key Oxygen\n";
    ss << "\\key Water\n";
    ss << "\\key Argon\n";
    ss << "N5; \\field Molar Fraction 1\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";

    IddObjectType objType(IddObjectType::Generator_FuelCell_AirSupply);
    OptionalIddObject oObj = IddObject::load("Generator:FuelCell:AirSupply",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Generator_FuelCell_AirSupply);
  return object;
}

IddObject createGenerator_FuelCell_WaterSupplyIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Generator:FuelCell:WaterSupply,\n";
    ss << "\\memo Used to provide details of the water supply subsystem for a fuel cell power generator.\n";
    ss << "\\memo This water is used for steam reforming of the fuel and is not the same\n";
    ss << "\\memo as the water used for thermal heat recovery.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference FCWaterSupNames\n";
    ss << "A2, \\field Reformer Water Flow Rate Function of Fuel Rate Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A3, \\field Reformer Water Pump Power Function of Fuel Rate Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "N1, \\field Pump Heat Loss Factor\n";
    ss << "A4, \\field Water Temperature Modeling Mode\n";
    ss << "\\type choice\n";
    ss << "\\key TemperatureFromAirNode\n";
    ss << "\\key TemperatureFromWaterNode\n";
    ss << "\\key TemperatureFromSchedule\n";
    ss << "\\key MainsWaterTemperature\n";
    ss << "A5, \\field Water Temperature Reference Node Name\n";
    ss << "\\type node\n";
    ss << "A6; \\field Water Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::Generator_FuelCell_WaterSupply);
    OptionalIddObject oObj = IddObject::load("Generator:FuelCell:WaterSupply",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Generator_FuelCell_WaterSupply);
  return object;
}

IddObject createGenerator_FuelCell_AuxiliaryHeaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Generator:FuelCell:AuxiliaryHeater,\n";
    ss << "\\memo Intended for modeling an auxiliary heater for a fuel cell power generator, however this\n";
    ss << "\\memo portion of the model is not yet available. The program still requires one of these\n";
    ss << "\\memo objects be included even though the data are not yet used (so that internal data\n";
    ss << "\\memo structures can be allocated).\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference FCAuxHeatNames\n";
    ss << "N1, \\field Excess Air Ratio\n";
    ss << "N2, \\field Ancillary Power Constant Term\n";
    ss << "N3, \\field Ancillary Power Linear Term\n";
    ss << "N4, \\field Skin Loss U-Factor Times Area Value\n";
    ss << "\\units W/K\n";
    ss << "A2, \\field Skin Loss Destination\n";
    ss << "\\type choice\n";
    ss << "\\key SurroundingZone\n";
    ss << "\\key AirInletForFuelCell\n";
    ss << "A3, \\field Zone Name to Receive Skin Losses\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A4, \\field Heating Capacity Units\n";
    ss << "\\type choice\n";
    ss << "\\key Watts\n";
    ss << "\\key kmol/s\n";
    ss << "N5, \\field Maximum Heating Capacity in Watts\n";
    ss << "\\units W\n";
    ss << "N6, \\field Minimum Heating Capacity in Watts\n";
    ss << "\\units W\n";
    ss << "N7, \\field Maximum Heating Capacity in Kmol per Second\n";
    ss << "\\units kmol/s\n";
    ss << "N8; \\field Minimum Heating Capacity in Kmol per Second\n";
    ss << "\\units kmol/s\n";

    IddObjectType objType(IddObjectType::Generator_FuelCell_AuxiliaryHeater);
    OptionalIddObject oObj = IddObject::load("Generator:FuelCell:AuxiliaryHeater",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Generator_FuelCell_AuxiliaryHeater);
  return object;
}

IddObject createGenerator_FuelCell_ExhaustGasToWaterHeatExchangerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Generator:FuelCell:ExhaustGasToWaterHeatExchanger,\n";
    ss << "\\memo Describes the exhaust gas heat exchanger subsystem of a fuel cell power generator\n";
    ss << "\\memo used to recovery thermal energy\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference FCExhaustHXNames\n";
    ss << "A2, \\field Heat Recovery Water Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A3, \\field Heat Recovery Water Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N1, \\field Heat Recovery Water Maximum Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "A4, \\field Exhaust Outlet Air Node Name\n";
    ss << "\\type node\n";
    ss << "A5, \\field Heat Exchanger Calculation Method\n";
    ss << "\\type choice\n";
    ss << "\\key FixedEffectiveness\n";
    ss << "\\key EmpiricalUAeff\n";
    ss << "\\key FundementalUAeff\n";
    ss << "\\key Condensing\n";
    ss << "N2, \\field Method 1 Heat Exchanger Effectiveness\n";
    ss << "N3, \\field Method 2 Parameter hxs0\n";
    ss << "N4, \\field Method 2 Parameter hxs1\n";
    ss << "N5, \\field Method 2 Parameter hxs2\n";
    ss << "N6, \\field Method 2 Parameter hxs3\n";
    ss << "N7, \\field Method 2 Parameter hxs4\n";
    ss << "N8, \\field Method 3 h0Gas Coefficient\n";
    ss << "N9, \\field Method 3 NdotGasRef Coefficient\n";
    ss << "N10, \\field Method 3 n Coefficient\n";
    ss << "N11, \\field Method 3 Gas Area\n";
    ss << "\\units m2\n";
    ss << "N12, \\field Method 3 h0 Water Coefficient\n";
    ss << "N13, \\field Method 3 N dot Water ref Coefficient\n";
    ss << "N14, \\field Method 3 m Coefficient\n";
    ss << "N15, \\field Method 3 Water Area\n";
    ss << "\\units m2\n";
    ss << "N16, \\field Method 3 F Adjustment Factor\n";
    ss << "N17, \\field Method 4 hxl1 Coefficient\n";
    ss << "N18, \\field Method 4 hxl2 Coefficient\n";
    ss << "N19; \\field Method 4 Condensation Threshold\n";
    ss << "\\units C\n";

    IddObjectType objType(IddObjectType::Generator_FuelCell_ExhaustGasToWaterHeatExchanger);
    OptionalIddObject oObj = IddObject::load("Generator:FuelCell:ExhaustGasToWaterHeatExchanger",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Generator_FuelCell_ExhaustGasToWaterHeatExchanger);
  return object;
}

IddObject createGenerator_FuelCell_ElectricalStorageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Generator:FuelCell:ElectricalStorage,\n";
    ss << "\\memo Used to describe the electrical storage subsystem for a fuel cell power generator.\n";
    ss << "\\memo The electrical storage model is a very simple \"constrained bucket\" model.\n";
    ss << "\\memo Note that this electrical storage is embedded within the FC device.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference FCStorageNames\n";
    ss << "A2, \\field Choice of Model\n";
    ss << "\\type choice\n";
    ss << "\\key SimpleEfficiencyWithConstraints\n";
    ss << "N1, \\field Nominal Charging Energetic Efficiency\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "N2, \\field Nominal Discharging Energetic Efficiency\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "N3, \\field Simple Maximum Capacity\n";
    ss << "\\units J\n";
    ss << "N4, \\field Simple Maximum Power Draw\n";
    ss << "\\units W\n";
    ss << "N5, \\field Simple Maximum Power Store\n";
    ss << "\\units W\n";
    ss << "N6; \\field Initial Charge State\n";
    ss << "\\units J\n";

    IddObjectType objType(IddObjectType::Generator_FuelCell_ElectricalStorage);
    OptionalIddObject oObj = IddObject::load("Generator:FuelCell:ElectricalStorage",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Generator_FuelCell_ElectricalStorage);
  return object;
}

IddObject createGenerator_FuelCell_InverterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Generator:FuelCell:Inverter,\n";
    ss << "\\memo Used to describe the power condition unit subsystem of a fuel cell power generator.\n";
    ss << "\\memo This object models an inverter system contained within a fuel cell system that\n";
    ss << "\\memo converts from direct current (DC) to alternating current (AC).\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference FCInverterNames\n";
    ss << "A2, \\field Inverter Efficiency Calculation Mode\n";
    ss << "\\type choice\n";
    ss << "\\key Quadratic\n";
    ss << "\\key Constant\n";
    ss << "N1, \\field Inverter Efficiency\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A3; \\field Efficiency Function of DC Power Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";

    IddObjectType objType(IddObjectType::Generator_FuelCell_Inverter);
    OptionalIddObject oObj = IddObject::load("Generator:FuelCell:Inverter",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Generator_FuelCell_Inverter);
  return object;
}

IddObject createGenerator_FuelCell_StackCoolerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Generator:FuelCell:StackCooler,\n";
    ss << "\\memo This object is optional and is used to define details needed to model the stack cooler\n";
    ss << "\\memo on PEMFC.\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference FCStackCoolerNames\n";
    ss << "A2, \\field Heat Recovery Water Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A3, \\field Heat Recovery Water Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "N1,  \\field Nominal Stack Temperature\n";
    ss << "\\units C\n";
    ss << "N2,  \\field Actual Stack Temperature\n";
    ss << "\\units C\n";
    ss << "N3,  \\field Coefficient r0\n";
    ss << "N4,  \\field Coefficient r1\n";
    ss << "N5,  \\field Coefficient r2\n";
    ss << "N6,  \\field Coefficient r3\n";
    ss << "N7,  \\field Stack Coolant Flow Rate\n";
    ss << "\\units kg/s\n";
    ss << "N8,  \\field Stack Cooler U-Factor Times Area Value\n";
    ss << "\\units W/K\n";
    ss << "N9,  \\field Fs-cogen Adjustment Factor\n";
    ss << "N10, \\field Stack Cogeneration Exchanger Area\n";
    ss << "\\units m2\n";
    ss << "N11, \\field Stack Cogeneration Exchanger Nominal Flow Rate\n";
    ss << "\\units kg/s\n";
    ss << "N12, \\field Stack Cogeneration Exchanger Nominal Heat Transfer Coefficient\n";
    ss << "\\units W/m2-K\n";
    ss << "N13, \\field Stack Cogeneration Exchanger Nominal Heat Transfer Coefficient Exponent\n";
    ss << "N14, \\field Stack Cooler Pump Power\n";
    ss << "\\units W\n";
    ss << "N15, \\field Stack Cooler Pump Heat Loss Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N16, \\field Stack Air Cooler Fan Coefficient f0\n";
    ss << "N17, \\field Stack Air Cooler Fan Coefficient f1\n";
    ss << "N18; \\field Stack Air Cooler Fan Coefficient f2\n";

    IddObjectType objType(IddObjectType::Generator_FuelCell_StackCooler);
    OptionalIddObject oObj = IddObject::load("Generator:FuelCell:StackCooler",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Generator_FuelCell_StackCooler);
  return object;
}

IddObject createGenerator_MicroCHPIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Generator:MicroCHP,\n";
    ss << "\\memo Small-scale combined heat and power (micro CHP) electric generator using the model\n";
    ss << "\\memo developed by IEA/ECBCS Annex 42 see www.cogen-sim.net. The model was developed\n";
    ss << "\\memo for both internal combustion and Stirling cycle\n";
    ss << "\\memo engines, but might be used for other types of residential CHP devices.\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Name\n";
    ss << "\\reference GeneratorNames\n";
    ss << "A2, \\field Performance Parameters Name\n";
    ss << "\\note Enter the name of a Generator:MicroCHP:NonNormalizedParameters object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MicroCHPParametersNames\n";
    ss << "A3, \\field Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A4, \\field Cooling Water Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A5, \\field Cooling Water Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A6, \\field Air Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A7, \\field Air Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A8, \\field Generator Fuel Supply Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list GenFuelSupNames\n";
    ss << "\\note Enter the name of a Generator:FuelSupply object.\n";
    ss << "A9; \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::Generator_MicroCHP);
    OptionalIddObject oObj = IddObject::load("Generator:MicroCHP",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Generator_MicroCHP);
  return object;
}

IddObject createGenerator_MicroCHP_NonNormalizedParametersIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Generator:MicroCHP:NonNormalizedParameters,\n";
    ss << "\\memo This object is referenced by a Generator:MicroCHP object and provides the\n";
    ss << "\\memo non-normalized parameters for the MicroCHP generator model.\n";
    ss << "A1, \\field Name\n";
    ss << "\\reference MicroCHPParametersNames\n";
    ss << "N1, \\field Maximum Electric Power\n";
    ss << "\\units W\n";
    ss << "N2, \\field Minimum Electric Power\n";
    ss << "\\units W\n";
    ss << "N3, \\field Minimum Cooling Water Flow Rate\n";
    ss << "\\units kg/s\n";
    ss << "N4, \\field Maximum Cooling Water Temperature\n";
    ss << "\\units C\n";
    ss << "A2, \\field Electrical Efficiency Curve Name\n";
    ss << "\\note TriQuadratic\n";
    ss << "\\type object-list\n";
    ss << "\\object-list TriQuadraticCurves\n";
    ss << "\\object-list MultiVariateTables\n";
    ss << "A3, \\field Thermal Efficiency Curve Name\n";
    ss << "\\note TriQuadratic\n";
    ss << "\\type object-list\n";
    ss << "\\object-list TriQuadraticCurves\n";
    ss << "\\object-list MultiVariateTables\n";
    ss << "A4, \\field Cooling Water Flow Rate Mode\n";
    ss << "\\type choice\n";
    ss << "\\key PlantControl\n";
    ss << "\\key InternalControl\n";
    ss << "A5, \\field Cooling Water Flow Rate Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A6, \\field Air Flow Rate Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "N5,  \\field Maximum Net Electrical Power Rate of Change\n";
    ss << "\\units W/s\n";
    ss << "N6,  \\field Maximum Fuel Flow Rate of Change\n";
    ss << "\\units kg/s2\n";
    ss << "N7,  \\field Heat Exchanger U-Factor Times Area Value\n";
    ss << "\\units W/K\n";
    ss << "N8,  \\field Skin Loss U-Factor Times Area Value\n";
    ss << "\\units W/K\n";
    ss << "N9,  \\field Skin Loss Radiative Fraction\n";
    ss << "\\type real\n";
    ss << "N10,  \\field Aggregated Thermal Mass of Energy Conversion Portion of Generator\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "N11,  \\field Aggregated Thermal Mass of Heat Recovery Portion of Generator\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "N12, \\field Standby Power\n";
    ss << "\\units W\n";
    ss << "A7, \\field Warm Up Mode\n";
    ss << "\\type choice\n";
    ss << "\\key NominalEngineTemperature\n";
    ss << "\\key TimeDelay\n";
    ss << "\\note Stirling engines use Nominal Engine Temperature\n";
    ss << "\\note Internal combustion engines use Time Delay\n";
    ss << "N13, \\field Warm Up Fuel Flow Rate Coefficient\n";
    ss << "N14, \\field Nominal Engine Operating Temperature\n";
    ss << "\\units C\n";
    ss << "N15, \\field Warm Up Power Coefficient\n";
    ss << "N16, \\field Warm Up Fuel Flow Rate Limit Ratio\n";
    ss << "N17, \\field Warm Up Delay Time\n";
    ss << "\\units s\n";
    ss << "N18, \\field Cool Down Power\n";
    ss << "\\units W\n";
    ss << "N19, \\field Cool Down Delay Time\n";
    ss << "\\units s\n";
    ss << "A8; \\field Restart Mode\n";
    ss << "\\type choice\n";
    ss << "\\key MandatoryCoolDown\n";
    ss << "\\key OptionalCoolDown\n";

    IddObjectType objType(IddObjectType::Generator_MicroCHP_NonNormalizedParameters);
    OptionalIddObject oObj = IddObject::load("Generator:MicroCHP:NonNormalizedParameters",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Generator_MicroCHP_NonNormalizedParameters);
  return object;
}

IddObject createGenerator_FuelSupplyIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Generator:FuelSupply,\n";
    ss << "\\extensible:2\n";
    ss << "\\max-fields 36\n";
    ss << "\\memo Used only with Generator:FuelCell and Generator:MicroCHP\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference GenFuelSupNames\n";
    ss << "A2, \\field Fuel Temperature Modeling Mode\n";
    ss << "\\type choice\n";
    ss << "\\key TemperatureFromAirNode\n";
    ss << "\\key Scheduled\n";
    ss << "A3, \\field Fuel Temperature Reference Node Name\n";
    ss << "\\type node\n";
    ss << "A4, \\field Fuel Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5, \\field Compressor Power Multiplier Function of Fuel Rate Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "N1, \\field Compressor Heat Loss Factor\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A6, \\field Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key GaseousConstituents\n";
    ss << "\\key LiquidGeneric\n";
    ss << "N2, \\field Liquid Generic Fuel Lower Heating Value\n";
    ss << "\\units kJ/kg\n";
    ss << "N3, \\field Liquid Generic Fuel Higher Heating Value\n";
    ss << "\\units kJ/kg\n";
    ss << "N4, \\field Liquid Generic Fuel Molecular Weight\n";
    ss << "\\units g/mol\n";
    ss << "N5, \\field Liquid Generic Fuel CO2 Emission Factor\n";
    ss << "N6, \\field Number of Constituents in Gaseous Constituent Fuel Supply\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 12.0\n";
    ss << "! sets of input data on each constituent\n";
    ss << "A7, \\field Constituent 1 Name\n";
    ss << "\\type choice\n";
    ss << "\\key CarbonDioxide\n";
    ss << "\\key Nitrogen\n";
    ss << "\\key Oxygen\n";
    ss << "\\key Water\n";
    ss << "\\key Argon\n";
    ss << "\\key Hydrogen\n";
    ss << "\\key Methane\n";
    ss << "\\key Ethane\n";
    ss << "\\key Propane\n";
    ss << "\\key Butane\n";
    ss << "\\key Pentane\n";
    ss << "\\key Hexane\n";
    ss << "\\key Methanol\n";
    ss << "\\key Ethanol\n";
    ss << "\\begin-extensible\n";
    ss << "N7; \\field Constituent 1 Molar Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";

    IddObjectType objType(IddObjectType::Generator_FuelSupply);
    OptionalIddObject oObj = IddObject::load("Generator:FuelSupply",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Generator_FuelSupply);
  return object;
}

IddObject createGenerator_WindTurbineIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Generator:WindTurbine,\n";
    ss << "\\memo Wind turbine generator.\n";
    ss << "\\min-fields 26\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference GeneratorNames\n";
    ss << "A2, \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Rotor Type\n";
    ss << "\\note allowed values are: Horizontal Axis Wind Turbine or Vertical Axis Wind Turbine\n";
    ss << "\\type choice\n";
    ss << "\\key HorizontalAxisWindTurbine\n";
    ss << "\\key VerticalAxisWindTurbine\n";
    ss << "\\default HorizontalAxisWindTurbine\n";
    ss << "A4, \\field Power Control\n";
    ss << "\\note Constant power output is obtained in the last three control types\n";
    ss << "\\note when the wind speed exceeds the rated wind speed.\n";
    ss << "\\note allowed values are: Fixed Speed Fixed Pitch, Fixed Speed Variable Pitch,\n";
    ss << "\\note Variable Speed Fixed Pitch or Variable Speed Variable Pitch\n";
    ss << "\\type choice\n";
    ss << "\\key FixedSpeedFixedPitch\n";
    ss << "\\key FixedSpeedVariablePitch\n";
    ss << "\\key VariableSpeedFixedPitch\n";
    ss << "\\key VariableSpeedVariablePitch\n";
    ss << "\\default VariableSpeedVariablePitch\n";
    ss << "N1, \\field Rated Rotor Speed\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units rev/min\n";
    ss << "N2, \\field Rotor Diameter\n";
    ss << "\\note This field is the diameter of the perpendicular circle of the Vertical Axis Wind Turbine system\n";
    ss << "\\note from the upright pole on the ground.\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m\n";
    ss << "N3, \\field Overall Height\n";
    ss << "\\note This field is the height of the hub for the Horizontal Axis Wind Turbines and\n";
    ss << "\\note of the pole for the Vertical Axis Wind Turbines.\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m\n";
    ss << "N4, \\field Number of Blades\n";
    ss << "\\minimum 2\n";
    ss << "\\default 3\n";
    ss << "N5, \\field Rated Power\n";
    ss << "\\required-field\n";
    ss << "\\note This field is the nominal power at the rated wind speed.\n";
    ss << "\\note Users should input maximum power in case of Fixed Speed Fixed Pitch control type.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W\n";
    ss << "N6, \\field Rated Wind Speed\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m/s\n";
    ss << "N7, \\field Cut In Wind Speed\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m/s\n";
    ss << "N8, \\field Cut Out Wind Speed\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m/s\n";
    ss << "N9, \\field Fraction system Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.835\n";
    ss << "N10,\\field Maximum Tip Speed Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 12.0\n";
    ss << "\\default 5.0\n";
    ss << "N11,\\field Maximum Power Coefficient\n";
    ss << "\\note This field should be input if the rotor type is Horizontal Axis Wind Turbine\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 0.59\n";
    ss << "\\default 0.25\n";
    ss << "N12,\\field Annual Local Average Wind Speed\n";
    ss << "\\type real\n";
    ss << "\\units m/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "N13,\\field Height for Local Average Wind Speed\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 50.0\n";
    ss << "N14,\\field Blade Chord Area\n";
    ss << "\\type real\n";
    ss << "\\units m2\n";
    ss << "N15,\\field Blade Drag Coefficient\n";
    ss << "\\note This field is only for Vertical Axis Wind Turbine..\n";
    ss << "\\note The user must input this field if the rotor type is Vertical Axis Wind Turbine.\n";
    ss << "\\type real\n";
    ss << "\\default 0.9\n";
    ss << "N16,\\field Blade Lift Coefficient\n";
    ss << "\\note This field is only for Vertical Axis Wind Turbine..\n";
    ss << "\\note The user must input this field if the rotor type is Vertical Axis Wind Turbine.\n";
    ss << "\\type real\n";
    ss << "\\default 0.05\n";
    ss << "N17,\\field Power Coefficient C1\n";
    ss << "\\note This field is only available for Horizontal Axis Wind Turbine.\n";
    ss << "\\note The user should input all six parameters\n";
    ss << "\\note so that the analytic approximation is assumed.\n";
    ss << "\\note The simple approximation will be assumed,\n";
    ss << "\\note if any field C1 through C6 is not input.\n";
    ss << "\\note Leave this field blank, if the manufacturer's data is unavailable\n";
    ss << "\\note so that the simple approximation will be assumed.\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "\\default 0.5176\n";
    ss << "N18,\\field Power Coefficient C2\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "\\default 116.0\n";
    ss << "N19,\\field Power Coefficient C3\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "\\default 0.4\n";
    ss << "N20,\\field Power Coefficient C4\n";
    ss << "\\minimum 0.0\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "N21,\\field Power Coefficient C5\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "\\default 5.0\n";
    ss << "N22;\\field Power Coefficient C6\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\type real\n";
    ss << "\\default 21.0\n";

    IddObjectType objType(IddObjectType::Generator_WindTurbine);
    OptionalIddObject oObj = IddObject::load("Generator:WindTurbine",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Generator_WindTurbine);
  return object;
}

IddObject createElectricLoadCenter_GeneratorsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ElectricLoadCenter:Generators,\n";
    ss << "\\memo List of electric power generators to include in the simulation including the name and\n";
    ss << "\\memo type of each generators along with availability schedule, rated power output,\n";
    ss << "\\memo and thermal-to-electrical power ratio.\n";
    ss << "\\extensible:5 - repeat set of five fields, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\min-fields 6\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference GeneratorLists\n";
    ss << "A2 , \\field Generator 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list GeneratorNames\n";
    ss << "A3 , \\field Generator 1 Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Generator:InternalCombustionEngine\n";
    ss << "\\key Generator:CombustionTurbine\n";
    ss << "\\key Generator:Photovoltaic\n";
    ss << "\\key Generator:FuelCell\n";
    ss << "\\key Generator:MicroCHP\n";
    ss << "\\key Generator:MicroTurbine\n";
    ss << "\\key Generator:WindTurbine\n";
    ss << "N1 , \\field Generator 1 Rated Electric Power Output\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "A4 , \\field Generator 1 Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this generator. Schedule value > 0 means the generator is available.\n";
    ss << "\\note If this field is blank, the generator is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N2 ; \\field Generator 1 Rated Thermal to Electrical Power Ratio\n";
    ss << "\\note Required field when generator is used by an ElectricLoadCenter:Distribution object with Generator Operation Scheme set to FollowThermal or FollowThermalLimitElectrical\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::ElectricLoadCenter_Generators);
    OptionalIddObject oObj = IddObject::load("ElectricLoadCenter:Generators",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ElectricLoadCenter_Generators);
  return object;
}

IddObject createElectricLoadCenter_Inverter_SimpleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ElectricLoadCenter:Inverter:Simple,\n";
    ss << "\\memo Electric power inverter to convert from direct current (DC) to alternating current\n";
    ss << "\\memo (AC) in an electric load center that contains photovoltaic modules. This input\n";
    ss << "\\memo object is for the simplest inverter model and uses a fixed efficiency.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\reference InverterList\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\note enter name of zone to receive inverter losses as heat\n";
    ss << "\\note if blank then inverter is assumed to be outdoors\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1 , \\field Radiative Fraction\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "N2 ; \\field Inverter Efficiency\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";

    IddObjectType objType(IddObjectType::ElectricLoadCenter_Inverter_Simple);
    OptionalIddObject oObj = IddObject::load("ElectricLoadCenter:Inverter:Simple",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ElectricLoadCenter_Inverter_Simple);
  return object;
}

IddObject createElectricLoadCenter_Inverter_FunctionOfPowerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ElectricLoadCenter:Inverter:FunctionOfPower,\n";
    ss << "\\memo Electric power inverter to convert from direct current (DC) to alternating current\n";
    ss << "\\memo (AC) in an electric load center that contains photovoltaic modules. This input\n";
    ss << "\\memo object is for an inverter model where efficiency is a function of normalized\n";
    ss << "\\memo power.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\reference InverterList\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\note Enter name of zone to receive inverter losses as heat\n";
    ss << "\\note if blank then inverter is assumed to be outdoors\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1 , \\field Radiative Fraction\n";
    ss << "A4 , \\field Efficiency Function of Power Curve Name\n";
    ss << "\\note curve describes efficiency as a function of power\n";
    ss << "\\note curve is normalized relative to rated power in next field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "N2,  \\field Rated Maximum Continuous Input Power\n";
    ss << "\\units W\n";
    ss << "N3 , \\field Minimum Efficiency\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "N4 , \\field Maximum Efficiency\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "N5 , \\field Minimum Power Output\n";
    ss << "\\units W\n";
    ss << "N6 , \\field Maximum Power Output\n";
    ss << "\\units W\n";
    ss << "N7 ; \\field Ancillary Power Consumed In Standby\n";
    ss << "\\units W\n";

    IddObjectType objType(IddObjectType::ElectricLoadCenter_Inverter_FunctionOfPower);
    OptionalIddObject oObj = IddObject::load("ElectricLoadCenter:Inverter:FunctionOfPower",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ElectricLoadCenter_Inverter_FunctionOfPower);
  return object;
}

IddObject createElectricLoadCenter_Inverter_LookUpTableIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ElectricLoadCenter:Inverter:LookUpTable,\n";
    ss << "\\memo   California Energy Commission tests and publishes data on inverters\n";
    ss << "\\memo   This inverter model interpolates using CEC test data\n";
    ss << "\\memo   Input data are at http://www.gosolarcalifornia.org/equipment/inverter_tests/summaries\n";
    ss << "A1 , \\field Name\n";
    ss << "\\reference InverterList\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\note Enter name of zone to receive inverter losses as heat\n";
    ss << "\\note if blank then inverter is assumed to be outdoors\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1 , \\field Radiative Fraction\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "N2 , \\field Rated Maximum Continuous Output Power\n";
    ss << "\\units W\n";
    ss << "N3 , \\field Night Tare Loss Power\n";
    ss << "\\units W\n";
    ss << "N4 , \\field Nominal Voltage Input\n";
    ss << "\\units V\n";
    ss << "N5 , \\field Efficiency at 10% Power and Nominal Voltage\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "N6 , \\field Efficiency at 20% Power and Nominal Voltage\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "N7 , \\field Efficiency at 30% Power and Nominal Voltage\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "N8 , \\field Efficiency at 50% Power and Nominal Voltage\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "N9 , \\field Efficiency at 75% Power and Nominal Voltage\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "N10; \\field Efficiency at 100% Power and Nominal Voltage\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";

    IddObjectType objType(IddObjectType::ElectricLoadCenter_Inverter_LookUpTable);
    OptionalIddObject oObj = IddObject::load("ElectricLoadCenter:Inverter:LookUpTable",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ElectricLoadCenter_Inverter_LookUpTable);
  return object;
}

IddObject createElectricLoadCenter_Storage_SimpleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ElectricLoadCenter:Storage:Simple,\n";
    ss << "\\memo Used to model storage of electricity in an electric load center.  This is a simple\n";
    ss << "\\memo model that does not attempt to represent any of the characteristics of a real\n";
    ss << "\\memo storage device such as a battery.  The type of power, AC or DC, depends on\n";
    ss << "\\memo the configuration chosen as the Electrical Buss Type in the\n";
    ss << "\\memo ElectricLoadCenter:Distribution object.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\reference ElecStorageList\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3,  \\field Zone Name\n";
    ss << "\\note Enter name of zone to receive storage losses as heat\n";
    ss << "\\note if blank then storage is assumed to be outdoors\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N1 , \\field Radiative Fraction for Zone Heat Gains\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "N2,  \\field Nominal Energetic Efficiency for Charging\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "N3,  \\field Nominal Discharging Energetic Efficiency\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "N4,  \\field Maximum Storage Capacity\n";
    ss << "\\units J\n";
    ss << "N5,  \\field Maximum Power for Discharging\n";
    ss << "\\units W\n";
    ss << "N6,  \\field Maximum Power for Charging\n";
    ss << "\\units W\n";
    ss << "N7;  \\field Initial State of Charge\n";
    ss << "\\units J\n";

    IddObjectType objType(IddObjectType::ElectricLoadCenter_Storage_Simple);
    OptionalIddObject oObj = IddObject::load("ElectricLoadCenter:Storage:Simple",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ElectricLoadCenter_Storage_Simple);
  return object;
}

IddObject createElectricLoadCenter_Storage_BatteryIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ElectricLoadCenter:Storage:Battery,\n";
    ss << "\\memo Uses the kinetic battery model (KiBaM) to simulate rechargeable battery banks in an\n";
    ss << "\\memo electrical load center. The battery bank is a collection of one or more individual\n";
    ss << "\\memo battery modules. Given the surplus or deficit power from the electrical system and\n";
    ss << "\\memo the state of charge from the previous time step, this object can model the voltage,\n";
    ss << "\\memo current, and energy losses with charging and discharging during each time step.\n";
    ss << "\\memo The cumulative battery damage can be also modeled and reported at the end of\n";
    ss << "\\memo each simulation run.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ElecStorageList\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3,  \\field Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note Enter name of zone to receive electrical storage losses as heat\n";
    ss << "\\note if blank then electrical storage losses are dissipated to outdoors\n";
    ss << "N1,  \\field Radiative Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "N2,  \\field Number of Battery Modules in Parallel\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";
    ss << "\\note A module usually consists of several cells.\n";
    ss << "\\note The total number of modules in the battery bank\n";
    ss << "\\note is equal to number of modules in parallel times\n";
    ss << "\\note number of modules in series.\n";
    ss << "N3,  \\field Number of Battery Modules in Series\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";
    ss << "\\note A module usually consists of several cells.\n";
    ss << "\\note The total number of modules in the battery bank\n";
    ss << "\\note is equal to number of modules in parallel times\n";
    ss << "\\note number of modules in series.\n";
    ss << "N4,  \\field Maximum Module Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units Ah\n";
    ss << "\\note The capacity is for each module.\n";
    ss << "\\note A model parameter from manufacturer's data or test data.\n";
    ss << "N5,  \\field Initial Fractional State of Charge\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note The state of charge is evaluated based on the\n";
    ss << "\\note maximum capacity defined in the next field.\n";
    ss << "N6,  \\field Fraction of Available Charge Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note A model parameter usually derived from test data by curve fitting.\n";
    ss << "N7,  \\field Change Rate from Bound Charge to Available Charge\n";
    ss << "\\minimum 0\n";
    ss << "\\units 1/hr\n";
    ss << "\\note A model parameter usually derived from test data by curve fitting.\n";
    ss << "N8,  \\field Fully Charged Module Open Circuit Voltage\n";
    ss << "\\type real\n";
    ss << "\\units V\n";
    ss << "\\minimum 0\n";
    ss << "\\note The voltage is for each battery module.\n";
    ss << "N9, \\field Fully Discharged Module Open Circuit Voltage\n";
    ss << "\\type real\n";
    ss << "\\units V\n";
    ss << "\\minimum 0\n";
    ss << "\\note The voltage is for each battery module.\n";
    ss << "A4, \\field Voltage Change Curve Name for Charging\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RectangularHyperbola2Curves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Determines how the open circuit voltage change with state of charge relative to the fully discharged state.\n";
    ss << "A5, \\field Voltage Change Curve Name for Discharging\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RectangularHyperbola2Curves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Determines how the open circuit voltage change with state of charge relative to the fully charged state.\n";
    ss << "N10, \\field Module Internal Electrical Resistance\n";
    ss << "\\type real\n";
    ss << "\\units ohms\n";
    ss << "\\minimum 0\n";
    ss << "\\note A model parameter from manufacture or derived from test data.\n";
    ss << "\\note Internal resistance is assumed to be constant.\n";
    ss << "\\note The internal resistance is for each battery module.\n";
    ss << "N11, \\field Maximum Module Discharging Current\n";
    ss << "\\type real\n";
    ss << "\\units A\n";
    ss << "\\minimum 0\n";
    ss << "\\note The constraint on discharging current is for each battery module.\n";
    ss << "N12, \\field Module Cut-off Voltage\n";
    ss << "\\type real\n";
    ss << "\\units V\n";
    ss << "\\minimum 0\n";
    ss << "\\note The voltage constraint is for each battery module.\n";
    ss << "N13, \\field Module Charge Rate Limit\n";
    ss << "\\type real\n";
    ss << "\\note units 1/hr\n";
    ss << "\\minimum 0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Charge rate limit is the division between charging current the remaining capacity.\n";
    ss << "\\note The constraint on charging current is for each module.\n";
    ss << "A6,  \\field Battery Life Calculation\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N14, \\field Number of Cycle Bins\n";
    ss << "\\type integer\n";
    ss << "\\minimum 5\n";
    ss << "\\default 10\n";
    ss << "\\note Only required when battery life calculation is activated\n";
    ss << "A7; \\field Battery Life Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DoubleExponentialDecayCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Determines the number of cycles to failure in relation to cycle range.\n";
    ss << "\\note Only required when battery life calculation is activated.\n";

    IddObjectType objType(IddObjectType::ElectricLoadCenter_Storage_Battery);
    OptionalIddObject oObj = IddObject::load("ElectricLoadCenter:Storage:Battery",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ElectricLoadCenter_Storage_Battery);
  return object;
}

IddObject createElectricLoadCenter_TransformerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ElectricLoadCenter:Transformer,\n";
    ss << "\\memo a list of meters that can be reported are available after a run on\n";
    ss << "\\memo the meter dictionary file (.mdd) if the Output:VariableDictionary has been requested.\n";
    ss << "\\extensible:1\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference TransformerNames\n";
    ss << "A2,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3,  \\field Transformer Usage\n";
    ss << "\\type choice\n";
    ss << "\\key PowerInFromGrid\n";
    ss << "\\key PowerOutToGrid\n";
    ss << "\\key LoadCenterPowerConditioning\n";
    ss << "\\default PowerInFromGrid\n";
    ss << "\\note A transformer can be used to transfer electric energy from utility grid to\n";
    ss << "\\note building (PowerInFromGrid)or from building on-site generation to\n";
    ss << "\\note the grid (PowerOutToGrid) or within a load center to match generation\n";
    ss << "\\note to the facility service main panel (LoadCenterPowerConditioning)\n";
    ss << "A4,  \\field Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "\\note Enter name of zone to receive transformer losses as heat\n";
    ss << "\\note if blank then transformer losses are dissipated to outdoors\n";
    ss << "N1,  \\field Radiative Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0\n";
    ss << "N2,  \\field Rated Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units VA\n";
    ss << "\\note the unit is VA, instead of kVA as usually shown on transformer nameplates.\n";
    ss << "N3,  \\field Phase\n";
    ss << "\\type choice\n";
    ss << "\\key 1\n";
    ss << "\\key 3\n";
    ss << "\\default 3\n";
    ss << "\\note Must be single or three phase transformer.\n";
    ss << "\\note NOT used in the current model.\n";
    ss << "A5,  \\field Conductor Material\n";
    ss << "\\type choice\n";
    ss << "\\key Copper\n";
    ss << "\\key Aluminum\n";
    ss << "\\default Aluminum\n";
    ss << "\\note Winding material used by the transformer.\n";
    ss << "N4,  \\field Full Load Temperature Rise\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 50\n";
    ss << "\\maximum 180\n";
    ss << "\\default 150\n";
    ss << "N5,  \\field Fraction of Eddy Current Losses\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.1\n";
    ss << "A6,  \\field Performance Input Method\n";
    ss << "\\type choice\n";
    ss << "\\key RatedLosses\n";
    ss << "\\key NominalEfficiency\n";
    ss << "\\default RatedLosses\n";
    ss << "\\note User can define transformer performance by specifying\n";
    ss << "\\note load and no load losses at rated conditions or\n";
    ss << "\\note nameplate efficiency and maximum efficiency\n";
    ss << "N6,  \\field Rated No Load Loss\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Only required when RatedLosses is the performance input method\n";
    ss << "N7,  \\field Rated Load Loss\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\note Only required when RatedLosses is the performance input method\n";
    ss << "N8,  \\field Nameplate Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.98\n";
    ss << "\\note Only required when NominalEfficiency is the performance input method\n";
    ss << "N9,  \\field Per Unit Load for Nameplate Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.35\n";
    ss << "\\note Percentage of the rated capacity at which the nameplate efficiency is defined\n";
    ss << "\\note Only required when NominalEfficiency is the performance input method\n";
    ss << "N10, \\field Reference Temperature for Nameplate Efficiency\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 20\n";
    ss << "\\maximum 150\n";
    ss << "\\default 75\n";
    ss << "\\note Conductor operating temperature at which the nameplate efficiency is defined\n";
    ss << "\\note Only required when NominalEfficiency is the performance input method\n";
    ss << "N11, \\field Per Unit Load for Maximum Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note Percentage of the rate capacity at which the maximum efficiency is obtained\n";
    ss << "\\note Only required when NominalEfficiency is the performance input method\n";
    ss << "A7,  \\field Consider Transformer Loss for Utility Cost\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "\\note Only required when the transformer is used for power in from the utility grid\n";
    ss << "A8;  \\field Meter 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\type external-list\n";
    ss << "\\external-list autoRDDmeter\n";
    ss << "\\note Must be an electric meter (with electricity as the resource type)\n";
    ss << "\\note Only required when transformer is used for power in from the utility grid\n";

    IddObjectType objType(IddObjectType::ElectricLoadCenter_Transformer);
    OptionalIddObject oObj = IddObject::load("ElectricLoadCenter:Transformer",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ElectricLoadCenter_Transformer);
  return object;
}

IddObject createElectricLoadCenter_DistributionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ElectricLoadCenter:Distribution,\n";
    ss << "\\memo Describes a subpanel\n";
    ss << "\\memo a list of meters that can be reported are available after a run on\n";
    ss << "\\memo the meter dictionary file (.mdd) if the Output:VariableDictionary has been requested.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Generator List Name\n";
    ss << "\\note Name of an ElectricLoadCenter:Generators object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list GeneratorLists\n";
    ss << "A3,  \\field Generator Operation Scheme Type\n";
    ss << "\\note Determines how generators are to be controlled\n";
    ss << "\\note Required if Generator List is entered.\n";
    ss << "\\type choice\n";
    ss << "\\key Baseload\n";
    ss << "\\key DemandLimit\n";
    ss << "\\key TrackElectrical\n";
    ss << "\\key TrackSchedule\n";
    ss << "\\key TrackMeter\n";
    ss << "\\key FollowThermal\n";
    ss << "\\key FollowThermalLimitElectrical\n";
    ss << "N1,  \\field Generator Demand Limit Scheme Purchased Electric Demand Limit\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "A4,  \\field Generator Track Schedule Name Scheme Schedule Name\n";
    ss << "\\note required when Generator Operation Scheme Type=TrackSchedule\n";
    ss << "\\note schedule values in Watts\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5,  \\field Generator Track Meter Scheme Meter Name\n";
    ss << "\\note required when Generator Operation Scheme Type=TrackMeter\n";
    ss << "\\type external-list\n";
    ss << "\\external-list autoRDDmeter\n";
    ss << "A6,  \\field Electrical Buss Type\n";
    ss << "\\type choice\n";
    ss << "\\key AlternatingCurrent\n";
    ss << "\\key AlternatingCurrentWithStorage\n";
    ss << "\\key DirectCurrentWithInverter\n";
    ss << "\\key DirectCurrentWithInverterDCStorage\n";
    ss << "\\key DirectCurrentWithInverterACStorage\n";
    ss << "\\default AlternatingCurrent\n";
    ss << "A7,  \\field Inverter Name\n";
    ss << "\\note required when Electrical Buss Type=DirectCurrentWithInverter, DirectCurrentWithInverterDCStorage,\n";
    ss << "\\note or DirectCurrentWithInverterACStorage\n";
    ss << "\\type object-list\n";
    ss << "\\object-list InverterList\n";
    ss << "A8,  \\field Electrical Storage Object Name\n";
    ss << "\\note required when Electrical Buss Type=AlternatingCurrentWithStorage, DirectCurrentWithInverterDCStorage,\n";
    ss << "\\note or DirectCurrentWithInverterACStorage\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ElecStorageList\n";
    ss << "A9,  \\field Transformer Object Name\n";
    ss << "\\note required when power needs to be output from on-site generation or storage to the grid via transformer\n";
    ss << "\\type object-list\n";
    ss << "\\object-list TransformerNames\n";
    ss << "A10, \\field Storage Operation Scheme\n";
    ss << "\\note Select method to govern how storage charge and discharge is controlled\n";
    ss << "\\type choice\n";
    ss << "\\key TrackFacilityElectricDemandStoreExcessOnSite\n";
    ss << "\\note TrackFacilityElectricDemandStoreExcessOnSite indicates that storage control will follow the facility power demand\n";
    ss << "\\note while accounting for any on-site generation.  Only excess on site generation  gets stored (legacy behavior).\n";
    ss << "\\default TrackFacilityElectricDemandStoreExcessOnSite\n";
    ss << "\\key TrackMeterDemandStoreExcessOnSite\n";
    ss << "\\note TrackMeterDemandStoreExcessOnSite indicates that storage discharge control will follow an electric meter named in the field called Storage Control Track Meter Name.  This scheme is similiar\n";
    ss << "\\note to TrackFacilityElectricDemandStoreExcessOnSite except that instead of the main facility electric meter, the control is based off of a user-selected meter.\n";
    ss << "\\key TrackChargeDischargeSchedules\n";
    ss << "\\note TrackChargeDischargeSchedules indicates that control will follow the charging and discharging power and schedules defined in the fields called Maximum Storage Charge Grid Supply Power,\n";
    ss << "\\note Storage Charge Grid Supply Power Fraction Schedule Name, Design Storage Discharge Grid Export Power, and Storage Discharge Grid Export Fraction Schedule Name.\n";
    ss << "\\key FacilityDemandLeveling\n";
    ss << "\\note FacilityDemandLeveling indicates that storage control will attempt to control the facility's power demand drawn from the utility service to a prescribed level.\n";
    ss << "\\note The target utility demand is entered in the fields called Storage Control Utility Demand Limit and Storage Control Utility Demand Limit Fraction Schedule Name\n";
    ss << "\\note This scheme first accounts for any on-site generation and during times of high use will discharge storage to reduce facility grid demand to meet the target level\n";
    ss << "\\note and during times of low use will charge storage from the grid to increase facility grid demand to meet the target level.\n";
    ss << "A11, \\field Storage Control Track Meter Name\n";
    ss << "\\note required when Storage Operation Scheme is set to TrackMeterDemandStoreExcessOnSite.\n";
    ss << "\\type external-list\n";
    ss << "\\external-list autoRDDmeter\n";
    ss << "A12, \\field Storage Converter Object Name\n";
    ss << "\\note Name of an ElectricLoadCenter:Storage:Converter used to convert AC to DC when charging DC storage from grid supply.\n";
    ss << "\\note A converter is expected when using Storage Operation Schemes FacilityDemandLeveling or TrackChargeDischargeSchedules\n";
    ss << "\\note A single bidirectional device will reference both an inverter object (DC to AC) and a converter object (AC to DC).\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConverterList\n";
    ss << "N2 , \\field Maximum Storage State of Charge Fraction\n";
    ss << "\\note Fraction of storage capacity used as upper limit for controlling charging, for all storage operation schemes.\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "N3,  \\field Minimum Storage State of Charge Fraction\n";
    ss << "\\note Fraction of storage capacity used as lower limit for controlling discharging, for all storage operation schemes.\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "N4 , \\field Design Storage Control Charge Power\n";
    ss << "\\note Maximum rate that electric power can be charged into storage.\n";
    ss << "\\note Storage charging adjusted downward for conversion losses.\n";
    ss << "\\note Rate is modified by fractional values in the schedule named in the next field.\n";
    ss << "\\note Required field when using Storage Operation Schemes FacilityDemandLeveling or TrackChargeDischargeSchedules.\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "A13, \\field Storage Charge Power Fraction Schedule Name\n";
    ss << "\\note Controls timing and magnitude of charging storage.\n";
    ss << "\\note Required field if Storage Operation Scheme is set to TrackChargeDischargeSchedules.\n";
    ss << "\\note Schedule values should be fractions from 0.0 to 1.0, inclusive.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N5 , \\field Design Storage Control Discharge Power\n";
    ss << "\\note Maximum rate that electric power can be discharged from storage.\n";
    ss << "\\note Rate is modified by fractional values in the schedule named in the next field.\n";
    ss << "\\note Required field when using Storage Operation Schemes FacilityDemandLeveling or TrackChargeDischargeSchedules.\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "A14, \\field Storage Discharge Power Fraction Schedule Name\n";
    ss << "\\note Controls timing and magnitude of discharging storage\n";
    ss << "\\note Required field if Storage Operation Scheme is set to TrackChargeDischargeSchedules.\n";
    ss << "\\note Schedule values should be fractions from 0.0 to 1.0, inclusive.\n";
    ss << "N6,  \\field Storage Control Utility Demand Target\n";
    ss << "\\note Target utility service demand power for discharge control.  Storage draws are adjusted upwards for conversion losses.\n";
    ss << "\\note Required field for FacilityDemandLeveling storage operation scheme\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "A15; \\field Storage Control Utility Demand Target Fraction Schedule Name\n";
    ss << "\\note Modifies the target utility service demand power over time.\n";
    ss << "\\note Schedule values should be fractions from -1.0 to 1.0, inclusive.\n";
    ss << "\\note if omitted a schedule value of 1.0 is used. Negative values indicate export to grid\n";
    ss << "\\note Schedule is used if Storage Operation Scheme is set to FacilityDemandLeveling.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::ElectricLoadCenter_Distribution);
    OptionalIddObject oObj = IddObject::load("ElectricLoadCenter:Distribution",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ElectricLoadCenter_Distribution);
  return object;
}

IddObject createElectricLoadCenter_Storage_ConverterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ElectricLoadCenter:Storage:Converter,\n";
    ss << "\\memo This model is for converting AC to DC for grid-supplied charging of DC storage\n";
    ss << "\\min-fields 4\n";
    ss << "A1 , \\field Name\n";
    ss << "\\reference ConverterList\n";
    ss << "A2 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the converter is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3 , \\field Power Conversion Efficiency Method\n";
    ss << "\\type choice\n";
    ss << "\\key SimpleFixed\n";
    ss << "\\default SimpleFixed\n";
    ss << "\\note SimpleFixed indicates power conversion losses are based on Simple Fixed Efficiency\n";
    ss << "\\key FunctionOfPower\n";
    ss << "\\note FunctionOfPower indicates power conversion losses are a function of normalized power using a curve or table.\n";
    ss << "N1 , \\field Simple Fixed Efficiency\n";
    ss << "\\note Constant efficiency for conversion of AC to DC at all power levels.\n";
    ss << "\\note Field is only used when Power Conversion Efficiency Method is set to SimpleFixed.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.95\n";
    ss << "N2,  \\field Design Maximum Continuous Input Power\n";
    ss << "\\note Required field when Power Conversion Efficiency Method is set to FunctionOfPower.\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "A4 , \\field Efficiency Function of Power Curve Name\n";
    ss << "\\note Curve or table with a single independent variable that describes efficiency as a function of normalized power.\n";
    ss << "\\note The \"x\" input for curve or table is the ratio of current input power divided by design power in the previous field\n";
    ss << "\\note Required field when Power Conversion Efficiency Method is set to FunctionOfPower.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UniVariateCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "N3 , \\field Ancillary Power Consumed In Standby\n";
    ss << "\\note Optional standby power consumed when converter is available but no power is being conditioned.\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "A5 , \\field Zone Name\n";
    ss << "\\note enter name of zone to receive converter losses as heat\n";
    ss << "\\note if blank then converter is assumed to be outdoors\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N4 ; \\field Radiative Fraction\n";
    ss << "\\note fraction of zone heat gains treated as thermal radiation\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";

    IddObjectType objType(IddObjectType::ElectricLoadCenter_Storage_Converter);
    OptionalIddObject oObj = IddObject::load("ElectricLoadCenter:Storage:Converter",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ElectricLoadCenter_Storage_Converter);
  return object;
}

IddObject createWaterUse_EquipmentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WaterUse:Equipment,\n";
    ss << "\\memo A generalized object for simulating all water end uses. Hot and cold water uses are\n";
    ss << "\\memo included, as well as controlled mixing of hot and cold water at the tap. The\n";
    ss << "\\memo WaterUse:Equipment object can be used stand-alone, or coupled into a plant loop using\n";
    ss << "\\memo the WaterUse:Connections object (see below). The WaterUse:Connections object allows\n";
    ss << "\\memo water uses to be linked to WaterUse:Storage objects to store and draw reclaimed water.\n";
    ss << "\\memo The object can also simulate drainwater heat recovery.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WaterUseEquipmentNames\n";
    ss << "A2 , \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";
    ss << "N1 , \\field Peak Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "A3 , \\field Flow Rate Fraction Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defaults to 1.0 at all times\n";
    ss << "A4 , \\field Target Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defaults to hot water supply temperature\n";
    ss << "A5 , \\field Hot Water Supply Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defaults to cold water supply temperature\n";
    ss << "A6 , \\field Cold Water Supply Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defaults to water temperatures calculated by Site:WaterMainsTemperature object\n";
    ss << "A7 , \\field Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "A8 , \\field Sensible Fraction Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defaults to 0.0 at all times\n";
    ss << "A9 ; \\field Latent Fraction Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defaults to 0.0 at all times\n";

    IddObjectType objType(IddObjectType::WaterUse_Equipment);
    OptionalIddObject oObj = IddObject::load("WaterUse:Equipment",
                                             "Water Systems",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WaterUse_Equipment);
  return object;
}

IddObject createWaterUse_ConnectionsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WaterUse:Connections,\n";
    ss << "\\memo A subsystem that groups together multiple WaterUse:Equipment components.\n";
    ss << "\\memo As its name suggests, the object provides connections that are shared by these\n";
    ss << "\\memo components, including: 1. Inlet node and outlet node connections to a plant loop\n";
    ss << "\\memo 2. Connections to WaterUse:Storage objects to store and draw reclaimed water\n";
    ss << "\\memo 3. Internal connections to simulate drainwater heat recovery.\n";
    ss << "\\extensible:1 - repeat last field\n";
    ss << "\\min-fields 11\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Inlet Node Name\n";
    ss << "\\type node\n";
    ss << "A3 , \\field Outlet Node Name\n";
    ss << "\\type node\n";
    ss << "A4 , \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "\\note If blank, or tank is empty, defaults to fresh water from the mains\n";
    ss << "A5 , \\field Reclamation Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A6 , \\field Hot Water Supply Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defaults to cold water supply temperature\n";
    ss << "A7 , \\field Cold Water Supply Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defaults to water temperatures calculated by Site:WaterMainsTemperature object\n";
    ss << "A8 , \\field Drain Water Heat Exchanger Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Ideal\n";
    ss << "\\key CounterFlow\n";
    ss << "\\key CrossFlow\n";
    ss << "\\default None\n";
    ss << "A9 , \\field Drain Water Heat Exchanger Destination\n";
    ss << "\\type choice\n";
    ss << "\\key Plant\n";
    ss << "\\key Equipment\n";
    ss << "\\key PlantAndEquipment\n";
    ss << "\\default Plant\n";
    ss << "N1 , \\field Drain Water Heat Exchanger U-Factor Times Area\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "A10; \\field Water Use Equipment 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\note Enter the name of a WaterUse:Equipment object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterUseEquipmentNames\n";

    IddObjectType objType(IddObjectType::WaterUse_Connections);
    OptionalIddObject oObj = IddObject::load("WaterUse:Connections",
                                             "Water Systems",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WaterUse_Connections);
  return object;
}

IddObject createWaterUse_StorageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WaterUse:Storage,\n";
    ss << "\\memo A water storage tank. If the building model is to include any on-site\n";
    ss << "\\memo water collection, wells, or storing and reuse of graywater, then a WaterUse:Storage\n";
    ss << "\\memo object is needed. Each WaterUse:Storage can serve as a central node and make\n";
    ss << "\\memo connections to numerous sources of supply or numerous components with demand. If a\n";
    ss << "\\memo maximum capacity is not specified, the tank is assumed to have unlimited capacity.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WaterStorageTankNames\n";
    ss << "A2 , \\field Water Quality Subcategory\n";
    ss << "\\type alpha\n";
    ss << "N1 , \\field Maximum Capacity\n";
    ss << "\\type real\n";
    ss << "\\units m3\n";
    ss << "\\ip-units gal\n";
    ss << "\\note Defaults to unlimited capacity.\n";
    ss << "N2 , \\field Initial Volume\n";
    ss << "\\type real\n";
    ss << "\\units m3\n";
    ss << "\\ip-units gal\n";
    ss << "N3 , \\field Design In Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\note Defaults to unlimited flow.\n";
    ss << "N4 , \\field Design Out Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\note Defaults to unlimited flow.\n";
    ss << "A3 , \\field Overflow Destination\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "\\note If blank, overflow is discarded\n";
    ss << "A4 , \\field Type of Supply Controlled by Float Valve\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Mains\n";
    ss << "\\key GroundwaterWell\n";
    ss << "\\key OtherTank\n";
    ss << "N5 , \\field Float Valve On Capacity\n";
    ss << "\\type real\n";
    ss << "\\units m3\n";
    ss << "\\ip-units gal\n";
    ss << "\\note Lower range of target storage level e.g. float valve kicks on\n";
    ss << "N6 , \\field Float Valve Off Capacity\n";
    ss << "\\type real\n";
    ss << "\\units m3\n";
    ss << "\\ip-units gal\n";
    ss << "\\note Upper range of target storage level e.g. float valve kicks off\n";
    ss << "N7 , \\field Backup Mains Capacity\n";
    ss << "\\type real\n";
    ss << "\\units m3\n";
    ss << "\\ip-units gal\n";
    ss << "\\note Lower range of secondary target storage level\n";
    ss << "\\note used to keep tanks at a minimum level using\n";
    ss << "\\note mains water if well can't keep up\n";
    ss << "A5,  \\field Other Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A6 , \\field Water Thermal Mode\n";
    ss << "\\type choice\n";
    ss << "\\key ScheduledTemperature\n";
    ss << "\\key ThermalModel\n";
    ss << "A7 , \\field Water Temperature Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A8 , \\field Ambient Temperature Indicator\n";
    ss << "\\type choice\n";
    ss << "\\key Schedule\n";
    ss << "\\key Zone\n";
    ss << "\\key Outdoors\n";
    ss << "A9 , \\field Ambient Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A10, \\field Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneNames\n";
    ss << "N8 , \\field Tank Surface Area\n";
    ss << "\\type real\n";
    ss << "\\units m2\n";
    ss << "N9 , \\field Tank U Value\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "A11; \\field Tank Outside Surface Material Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list MaterialName\n";

    IddObjectType objType(IddObjectType::WaterUse_Storage);
    OptionalIddObject oObj = IddObject::load("WaterUse:Storage",
                                             "Water Systems",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WaterUse_Storage);
  return object;
}

IddObject createWaterUse_WellIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WaterUse:Well,\n";
    ss << "\\memo Simulates on-site water supply from a well. Well water is pumped out of the ground\n";
    ss << "\\memo into a WaterUse:Storage. The operation of the ground water well is controlled by the\n";
    ss << "\\memo associated WaterUse:Storage which is assumed to be operated as a vented cistern with\n";
    ss << "\\memo no pressure tank.\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Storage Tank Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "N1 , \\field Pump Depth\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "N2 , \\field Pump Rated Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N3 , \\field Pump Rated Head\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "N4 , \\field Pump Rated Power Consumption\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "N5 , \\field Pump Efficiency\n";
    ss << "\\type real\n";
    ss << "N6 , \\field Well Recovery Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N7 , \\field Nominal Well Storage Volume\n";
    ss << "\\type real\n";
    ss << "\\units m3\n";
    ss << "\\ip-units gal\n";
    ss << "A3 , \\field Water Table Depth Mode\n";
    ss << "\\type choice\n";
    ss << "\\key Constant\n";
    ss << "\\key Scheduled\n";
    ss << "N8 , \\field Water Table Depth\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "A4 ; \\field Water Table Depth Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::WaterUse_Well);
    OptionalIddObject oObj = IddObject::load("WaterUse:Well",
                                             "Water Systems",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WaterUse_Well);
  return object;
}

IddObject createWaterUse_RainCollectorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "WaterUse:RainCollector,\n";
    ss << "\\memo Used for harvesting rainwater falling on building surfaces. The rainwater is sent to a\n";
    ss << "\\memo WaterUse:Storage object. In order to use this object it is necessary to also include\n";
    ss << "\\memo a Site:Precipitation object to describe the rates of rainfall.\n";
    ss << "\\extensible:1 - repeat last field\n";
    ss << "\\min-fields 7\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Storage Tank Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A3,  \\field Loss Factor Mode\n";
    ss << "\\type choice\n";
    ss << "\\key Constant\n";
    ss << "\\key Scheduled\n";
    ss << "N1 , \\field Collection Loss Factor\n";
    ss << "\\type real\n";
    ss << "\\note this is the portion of rain\n";
    ss << "\\note that is lost in the process of collecting it\n";
    ss << "\\note the rain collected is one minus this factor\n";
    ss << "A4 , \\field Collection Loss Factor Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N2 , \\field Maximum Collection Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\note Defaults to unlimited flow.\n";
    ss << "A5 ; \\field Collection Surface 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllShadingAndHTSurfNames\n";

    IddObjectType objType(IddObjectType::WaterUse_RainCollector);
    OptionalIddObject oObj = IddObject::load("WaterUse:RainCollector",
                                             "Water Systems",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::WaterUse_RainCollector);
  return object;
}

IddObject createFaultModel_TemperatureSensorOffset_OutdoorAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FaultModel:TemperatureSensorOffset:OutdoorAir,\n";
    ss << "\\memo This object describes outdoor air temperature sensor offset\n";
    ss << "\\min-fields 3\n";
    ss << "A1, \\field Name\n";
    ss << "\\note Enter the name of the fault\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Severity Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4, \\field Controller Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Controller:OutdoorAir\n";
    ss << "A5, \\field Controller Object Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OAControllerNames\n";
    ss << "N1; \\field Temperature Sensor Offset\n";
    ss << "\\type real\n";
    ss << "\\minimum> -10\n";
    ss << "\\maximum< 10\n";
    ss << "\\default 0.0\n";
    ss << "\\units deltaC\n";

    IddObjectType objType(IddObjectType::FaultModel_TemperatureSensorOffset_OutdoorAir);
    OptionalIddObject oObj = IddObject::load("FaultModel:TemperatureSensorOffset:OutdoorAir",
                                             "Operational Faults",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FaultModel_TemperatureSensorOffset_OutdoorAir);
  return object;
}

IddObject createFaultModel_HumiditySensorOffset_OutdoorAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FaultModel:HumiditySensorOffset:OutdoorAir,\n";
    ss << "\\memo This object describes outdoor air humidity sensor offset\n";
    ss << "\\min-fields 3\n";
    ss << "A1, \\field Name\n";
    ss << "\\note Enter the name of the fault\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Severity Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4, \\field Controller Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Controller:OutdoorAir\n";
    ss << "A5, \\field Controller Object Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OAControllerNames\n";
    ss << "N1; \\field Humidity Sensor Offset\n";
    ss << "\\type real\n";
    ss << "\\minimum> -0.02\n";
    ss << "\\maximum< 0.02\n";
    ss << "\\default 0.0\n";
    ss << "\\units kgWater/kgDryAir\n";

    IddObjectType objType(IddObjectType::FaultModel_HumiditySensorOffset_OutdoorAir);
    OptionalIddObject oObj = IddObject::load("FaultModel:HumiditySensorOffset:OutdoorAir",
                                             "Operational Faults",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FaultModel_HumiditySensorOffset_OutdoorAir);
  return object;
}

IddObject createFaultModel_EnthalpySensorOffset_OutdoorAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FaultModel:EnthalpySensorOffset:OutdoorAir,\n";
    ss << "\\memo This object describes outdoor air enthalpy sensor offset\n";
    ss << "\\min-fields 3\n";
    ss << "A1, \\field Name\n";
    ss << "\\note Enter the name of the fault\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Severity Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4, \\field Controller Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Controller:OutdoorAir\n";
    ss << "A5, \\field Controller Object Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OAControllerNames\n";
    ss << "N1; \\field Enthalpy Sensor Offset\n";
    ss << "\\type real\n";
    ss << "\\minimum> -20000\n";
    ss << "\\maximum< 20000\n";
    ss << "\\default 0.0\n";
    ss << "\\units J/kg\n";

    IddObjectType objType(IddObjectType::FaultModel_EnthalpySensorOffset_OutdoorAir);
    OptionalIddObject oObj = IddObject::load("FaultModel:EnthalpySensorOffset:OutdoorAir",
                                             "Operational Faults",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FaultModel_EnthalpySensorOffset_OutdoorAir);
  return object;
}

IddObject createFaultModel_PressureSensorOffset_OutdoorAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FaultModel:PressureSensorOffset:OutdoorAir,\n";
    ss << "\\memo This object describes outdoor air pressure sensor offset\n";
    ss << "\\min-fields 3\n";
    ss << "A1, \\field Name\n";
    ss << "\\note Enter the name of the fault\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Severity Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4, \\field Controller Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Controller:OutdoorAir\n";
    ss << "A5, \\field Controller Object Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OAControllerNames\n";
    ss << "N1; \\field Pressure Sensor Offset\n";
    ss << "\\type real\n";
    ss << "\\minimum> -10000\n";
    ss << "\\maximum< 10000\n";
    ss << "\\default 0.0\n";
    ss << "\\units Pa\n";

    IddObjectType objType(IddObjectType::FaultModel_PressureSensorOffset_OutdoorAir);
    OptionalIddObject oObj = IddObject::load("FaultModel:PressureSensorOffset:OutdoorAir",
                                             "Operational Faults",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FaultModel_PressureSensorOffset_OutdoorAir);
  return object;
}

IddObject createFaultModel_TemperatureSensorOffset_ReturnAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FaultModel:TemperatureSensorOffset:ReturnAir,\n";
    ss << "\\memo This object describes return air temperature sensor offset\n";
    ss << "\\min-fields 3\n";
    ss << "A1, \\field Name\n";
    ss << "\\note Enter the name of the fault\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Severity Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4, \\field Controller Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Controller:OutdoorAir\n";
    ss << "A5, \\field Controller Object Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OAControllerNames\n";
    ss << "N1; \\field Temperature Sensor Offset\n";
    ss << "\\type real\n";
    ss << "\\minimum> -10\n";
    ss << "\\maximum< 10\n";
    ss << "\\default 0.0\n";
    ss << "\\units deltaC\n";

    IddObjectType objType(IddObjectType::FaultModel_TemperatureSensorOffset_ReturnAir);
    OptionalIddObject oObj = IddObject::load("FaultModel:TemperatureSensorOffset:ReturnAir",
                                             "Operational Faults",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FaultModel_TemperatureSensorOffset_ReturnAir);
  return object;
}

IddObject createFaultModel_EnthalpySensorOffset_ReturnAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FaultModel:EnthalpySensorOffset:ReturnAir,\n";
    ss << "\\memo This object describes return air enthalpy sensor offset\n";
    ss << "\\min-fields 3\n";
    ss << "A1, \\field Name\n";
    ss << "\\note Enter the name of the fault\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A3, \\field Severity Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4, \\field Controller Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Controller:OutdoorAir\n";
    ss << "A5, \\field Controller Object Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OAControllerNames\n";
    ss << "N1; \\field Enthalpy Sensor Offset\n";
    ss << "\\type real\n";
    ss << "\\minimum> -20000\n";
    ss << "\\maximum< 20000\n";
    ss << "\\default 0.0\n";
    ss << "\\units J/kg\n";

    IddObjectType objType(IddObjectType::FaultModel_EnthalpySensorOffset_ReturnAir);
    OptionalIddObject oObj = IddObject::load("FaultModel:EnthalpySensorOffset:ReturnAir",
                                             "Operational Faults",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FaultModel_EnthalpySensorOffset_ReturnAir);
  return object;
}

IddObject createFaultModel_ThermostatOffsetIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FaultModel:ThermostatOffset,\n";
    ss << "\\memo This object describes fault of thermostat offset\n";
    ss << "\\min-fields 3\n";
    ss << "A1, \\field Name\n";
    ss << "\\note Enter the name of the fault\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ThermostatOffsetFaults\n";
    ss << "A2, \\field Thermostat Name\n";
    ss << "\\note Enter the name of a ZoneControl:Thermostat object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneControlThermostaticNames\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4, \\field Severity Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1; \\field Reference Thermostat Offset\n";
    ss << "\\type real\n";
    ss << "\\minimum> -10\n";
    ss << "\\maximum< 10\n";
    ss << "\\default 2\n";
    ss << "\\units deltaC\n";

    IddObjectType objType(IddObjectType::FaultModel_ThermostatOffset);
    OptionalIddObject oObj = IddObject::load("FaultModel:ThermostatOffset",
                                             "Operational Faults",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FaultModel_ThermostatOffset);
  return object;
}

IddObject createFaultModel_HumidistatOffsetIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FaultModel:HumidistatOffset,\n";
    ss << "\\memo This object describes fault of humidistat offset\n";
    ss << "\\min-fields 4\n";
    ss << "A1, \\field Name\n";
    ss << "\\note Enter the name of the fault\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2, \\field Humidistat Name\n";
    ss << "\\note Enter the name of a ZoneControl:Humidistat object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneControlHumidistatNames\n";
    ss << "A3, \\field Humidistat Offset Type\n";
    ss << "\\note Two types are available:\n";
    ss << "\\note Type ThermostatOffsetIndependent\n";
    ss << "\\note Type ThermostatOffsetDependent\n";
    ss << "\\type choice\n";
    ss << "\\key ThermostatOffsetIndependent\n";
    ss << "\\key ThermostatOffsetDependent\n";
    ss << "\\default ThermostatOffsetIndependent\n";
    ss << "A4, \\field Availability Schedule Name\n";
    ss << "\\note This field is applicable for Type ThermostatOffsetIndependent\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5, \\field Severity Schedule Name\n";
    ss << "\\note This field is applicable for Type ThermostatOffsetIndependent\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Reference Humidistat Offset\n";
    ss << "\\note Required field for Type ThermostatOffsetIndependent\n";
    ss << "\\type real\n";
    ss << "\\minimum> -20\n";
    ss << "\\maximum< 20\n";
    ss << "\\default 5\n";
    ss << "\\units percent\n";
    ss << "A6; \\field Related Thermostat Offset Fault Name\n";
    ss << "\\note Enter the name of a FaultModel:ThermostatOffset object\n";
    ss << "\\note Required field for Type ThermostatOffsetDependent\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermostatOffsetFaults\n";

    IddObjectType objType(IddObjectType::FaultModel_HumidistatOffset);
    OptionalIddObject oObj = IddObject::load("FaultModel:HumidistatOffset",
                                             "Operational Faults",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FaultModel_HumidistatOffset);
  return object;
}

IddObject createFaultModel_Fouling_AirFilterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FaultModel:Fouling:AirFilter,\n";
    ss << "\\memo This object describes fault of dirty air filters\n";
    ss << "\\min-fields 4\n";
    ss << "A1, \\field Name\n";
    ss << "\\note Enter the name of the fault\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2, \\field Fan Object Type\n";
    ss << "\\note Choose the type of the fan\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fan:OnOff\n";
    ss << "\\key Fan:ConstantVolume\n";
    ss << "\\key Fan:VariableVolume\n";
    ss << "A3, \\field Fan Name\n";
    ss << "\\note Enter the name of a fan object\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOffandVAV\n";
    ss << "A4, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5, \\field Pressure Fraction Schedule Name\n";
    ss << "\\note Enter the name of a schedule\n";
    ss << "\\note describing the variations of the fan pressure rise\n";
    ss << "\\note in terms of multipliers to the fan design pressure rise\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6; \\field Fan Curve Name\n";
    ss << "\\note The curve describes the relationship between\n";
    ss << "\\note the fan pressure rise and air flow rate\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\object-list UniVariateTables\n";

    IddObjectType objType(IddObjectType::FaultModel_Fouling_AirFilter);
    OptionalIddObject oObj = IddObject::load("FaultModel:Fouling:AirFilter",
                                             "Operational Faults",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FaultModel_Fouling_AirFilter);
  return object;
}

IddObject createFaultModel_Fouling_CoilIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FaultModel:Fouling:Coil,\n";
    ss << "\\memo This object describes fouling water heating or cooling coils\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2, \\field Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SimpleCoils\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4, \\field Severity Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5, \\field Fouling Input Method\n";
    ss << "\\type choice\n";
    ss << "\\key FouledUARated\n";
    ss << "\\key FoulingFactor\n";
    ss << "\\default FouledUARated\n";
    ss << "N1, \\field UAFouled\n";
    ss << "\\note Fouling coil UA value under rating conditions\n";
    ss << "\\note For Fouling Input Method: FouledUARated\n";
    ss << "\\units W/K\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2, \\field Water Side Fouling Factor\n";
    ss << "\\note For Fouling Input Method: FoulingFactor\n";
    ss << "\\units m2-K/W\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N3, \\field Air Side Fouling Factor\n";
    ss << "\\note For Fouling Input Method: FoulingFactor\n";
    ss << "\\units m2-K/W\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N4, \\field Outside Coil Surface Area\n";
    ss << "\\note For Fouling Input Method: FoulingFactor\n";
    ss << "\\units m2\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N5; \\field Inside to Outside Coil Surface Area Ratio\n";
    ss << "\\note For Fouling Input Method: FoulingFactor\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.07\n";

    IddObjectType objType(IddObjectType::FaultModel_Fouling_Coil);
    OptionalIddObject oObj = IddObject::load("FaultModel:Fouling:Coil",
                                             "Operational Faults",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FaultModel_Fouling_Coil);
  return object;
}

IddObject createMatrix_TwoDimensionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Matrix:TwoDimension,\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 4\n";
    ss << "\\max-fields 21041\n";
    ss << "\\memo matrix data in row-major order\n";
    ss << "\\memo list each row keeping the columns in order\n";
    ss << "\\memo number of values must equal N1 x N2\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference DataMatrices\n";
    ss << "N1 , \\field Number of Rows\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "N2 , \\field Number of Columns\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "N3 ; \\field Value 1\n";
    ss << "\\begin-extensible\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::Matrix_TwoDimension);
    OptionalIddObject oObj = IddObject::load("Matrix:TwoDimension",
                                             "General Data Entry",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Matrix_TwoDimension);
  return object;
}

IddObject createCurve_LinearIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:Linear,\n";
    ss << "\\memo Linear curve with one independent variable.\n";
    ss << "\\memo Input for the linear curve consists of a curve name, the two coefficients, and the\n";
    ss << "\\memo maximum and minimum valid independent variable values. Optional inputs for\n";
    ss << "\\memo curve minimum and maximum may be used to limit the output of the performance curve.\n";
    ss << "\\memo curve = C1 + C2*x\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference LinearCurves\n";
    ss << "\\reference LinearOrQuadraticCurves\n";
    ss << "\\reference UniVariateCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1 , \\field Coefficient1 Constant\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Coefficient2 x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Minimum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N4 , \\field Maximum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N5 , \\field Minimum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "N6 , \\field Maximum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "A2,  \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key Pressure\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A3;  \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";
    ss << "\\default Dimensionless\n";

    IddObjectType objType(IddObjectType::Curve_Linear);
    OptionalIddObject oObj = IddObject::load("Curve:Linear",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_Linear);
  return object;
}

IddObject createCurve_QuadLinearIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:QuadLinear,\n";
    ss << "\\memo Linear curve with four independent variables.\n";
    ss << "\\memo Input for the linear curve consists of a curve name, the two coefficients, and the\n";
    ss << "\\memo maximum and minimum valid independent variable values. Optional inputs for curve\n";
    ss << "\\memo minimum and maximum may be used to limit the output of the performance curve.\n";
    ss << "\\memo curve = C1 + C2*w + C3*x + C4*y + C5*z\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference QuadLinearCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1 , \\field Coefficient1 Constant\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Coefficient2 w\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Coefficient3 x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Coefficient4 y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N5 , \\field Coefficient5 z\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N7 , \\field Minimum Value of w\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N8 , \\field Maximum Value of w\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N9 , \\field Minimum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "N10 ,\\field Maximum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "N11 , \\field Minimum Value of y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "N12, \\field Maximum Value of y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "N13, \\field Minimum Value of z\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A5\n";
    ss << "N14, \\field Maximum Value of z\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A5\n";
    ss << "N15, \\field Minimum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "N16, \\field Maximum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "A2 , \\field Input Unit Type for w\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\key VolumetricFlowPerPower\n";
    ss << "\\default Dimensionless\n";
    ss << "A3 , \\field Input Unit Type for x\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\key VolumetricFlowPerPower\n";
    ss << "\\default Dimensionless\n";
    ss << "A4 , \\field Input Unit Type for y\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\key VolumetricFlowPerPower\n";
    ss << "\\default Dimensionless\n";
    ss << "A5;  \\field Input Unit Type for z\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\key VolumetricFlowPerPower\n";
    ss << "\\default Dimensionless\n";

    IddObjectType objType(IddObjectType::Curve_QuadLinear);
    OptionalIddObject oObj = IddObject::load("Curve:QuadLinear",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_QuadLinear);
  return object;
}

IddObject createCurve_QuadraticIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:Quadratic,\n";
    ss << "\\memo Quadratic curve with one independent variable.\n";
    ss << "\\memo Input for a quadratic curve consists of the curve name, the three coefficients, and\n";
    ss << "\\memo the maximum and minimum valid independent variable values. Optional inputs for curve\n";
    ss << "\\memo minimum and maximum may be used to limit the output of the performance curve.\n";
    ss << "\\memo curve = C1 + C2*x + C3*x**2\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference QuadraticCurves\n";
    ss << "\\reference LinearOrQuadraticCurves\n";
    ss << "\\reference UniVariateCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "\\reference QuadraticCubicCurves\n";
    ss << "\\reference BiquadraticQuadraticCubicCurves\n";
    ss << "N1 , \\field Coefficient1 Constant\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Coefficient2 x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Coefficient3 x**2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Minimum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N5 , \\field Maximum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N6 , \\field Minimum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "N7 , \\field Maximum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "A2,  \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A3;  \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";
    ss << "\\default Dimensionless\n";

    IddObjectType objType(IddObjectType::Curve_Quadratic);
    OptionalIddObject oObj = IddObject::load("Curve:Quadratic",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_Quadratic);
  return object;
}

IddObject createCurve_CubicIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:Cubic,\n";
    ss << "\\memo Cubic curve with one independent variable.\n";
    ss << "\\memo Input for a cubic curve consists of the curve name, the 4 coefficients, and the\n";
    ss << "\\memo maximum and minimum valid independent variable values. Optional inputs for curve\n";
    ss << "\\memo minimum and maximum may be used to limit the output of the performance curve.\n";
    ss << "\\memo curve = C1 + C2*x + C3*x**2 + C4*x**3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CubicCurves\n";
    ss << "\\reference UniVariateCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "\\reference QuadraticCubicCurves\n";
    ss << "\\reference BiquadraticCubicCurves\n";
    ss << "\\reference BiquadraticQuadraticCubicCurves\n";
    ss << "N1 , \\field Coefficient1 Constant\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Coefficient2 x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Coefficient3 x**2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Coefficient4 x**3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N5 , \\field Minimum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N6 , \\field Maximum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N7 , \\field Minimum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "N8 , \\field Maximum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "A2,  \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A3;  \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";
    ss << "\\default Dimensionless\n";

    IddObjectType objType(IddObjectType::Curve_Cubic);
    OptionalIddObject oObj = IddObject::load("Curve:Cubic",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_Cubic);
  return object;
}

IddObject createCurve_QuarticIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:Quartic,\n";
    ss << "\\memo Quartic (fourth order polynomial) curve with one independent variable.\n";
    ss << "\\memo Input for a Quartic curve consists of the curve name, the\n";
    ss << "\\memo five coefficients, and the maximum and minimum valid independent variable values.\n";
    ss << "\\memo Optional inputs for curve minimum and maximum may be used to limit the\n";
    ss << "\\memo output of the performance curve.\n";
    ss << "\\memo curve = C1 + C2*x + C3*x**2 + C4*x**3 + C5*x**4\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference QuarticCurves\n";
    ss << "\\reference UniVariateCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1 , \\field Coefficient1 Constant\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Coefficient2 x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Coefficient3 x**2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Coefficient4 x**3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N5 , \\field Coefficient5 x**4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N6 , \\field Minimum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N7 , \\field Maximum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N8 , \\field Minimum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "N9 , \\field Maximum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "A2 , \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A3 ; \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";
    ss << "\\default Dimensionless\n";

    IddObjectType objType(IddObjectType::Curve_Quartic);
    OptionalIddObject oObj = IddObject::load("Curve:Quartic",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_Quartic);
  return object;
}

IddObject createCurve_ExponentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:Exponent,\n";
    ss << "\\memo Exponent curve with one independent variable.\n";
    ss << "\\memo Input for a exponent curve consists of the curve name, the 3 coefficients, and the\n";
    ss << "\\memo maximum and minimum valid independent variable values. Optional inputs for curve\n";
    ss << "\\memo minimum and maximum may be used to limit the output of the performance curve.\n";
    ss << "\\memo curve = C1 + C2*x**C3\n";
    ss << "\\memo The independent variable x is raised to the C3 power, multiplied by C2, and C1 is added to the result.\n";
    ss << "\\min-fields 6\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ExponentCurves\n";
    ss << "\\reference UniVariateCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1 , \\field Coefficient1 Constant\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Coefficient2 Constant\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Coefficient3 Constant\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Minimum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note Specify the minimum value of the independent variable x allowed\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N5 , \\field Maximum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note Specify the maximum value of the independent variable x allowed\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N6 , \\field Minimum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "N7 , \\field Maximum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "A2,  \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A3;  \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";
    ss << "\\default Dimensionless\n";

    IddObjectType objType(IddObjectType::Curve_Exponent);
    OptionalIddObject oObj = IddObject::load("Curve:Exponent",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_Exponent);
  return object;
}

IddObject createCurve_BicubicIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:Bicubic,\n";
    ss << "\\memo Cubic curve with two independent variables. Input consists of the\n";
    ss << "\\memo curve name, the ten coefficients, and the minimum and maximum values for each of\n";
    ss << "\\memo the independent variables. Optional inputs for curve minimum and maximum may\n";
    ss << "\\memo be used to limit the output of the performance curve.\n";
    ss << "\\memo curve = C1 + C2*x + C3*x**2 + C4*y + C5*y**2 + C6*x*y + C7*x**3 + C8*y**3 + C9*x**2*y\n";
    ss << "\\memo + C10*x*y**2\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference BiVariateCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "\\reference BicubicCurves\n";
    ss << "\\reference BicubicBiquadraticCurves\n";
    ss << "N1 , \\field Coefficient1 Constant\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Coefficient2 x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Coefficient3 x**2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Coefficient4 y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N5 , \\field Coefficient5 y**2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N6 , \\field Coefficient6 x*y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N7 , \\field Coefficient7 x**3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N8 , \\field Coefficient8 y**3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N9 , \\field Coefficient9 x**2*y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N10, \\field Coefficient10 x*y**2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N11, \\field Minimum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N12, \\field Maximum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N13, \\field Minimum Value of y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "N14, \\field Maximum Value of y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "N15, \\field Minimum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "N16, \\field Maximum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "A2,  \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A3,  \\field Input Unit Type for Y\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A4;  \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";
    ss << "\\default Dimensionless\n";

    IddObjectType objType(IddObjectType::Curve_Bicubic);
    OptionalIddObject oObj = IddObject::load("Curve:Bicubic",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_Bicubic);
  return object;
}

IddObject createCurve_BiquadraticIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:Biquadratic,\n";
    ss << "\\memo Quadratic curve with two independent variables. Input consists of the curve name, the\n";
    ss << "\\memo six coefficients, and min and max values for each of the independent variables.\n";
    ss << "\\memo Optional inputs for curve minimum and maximum may be used to limit the\n";
    ss << "\\memo output of the performance curve.\n";
    ss << "\\memo curve = C1 + C2*x + C3*x**2 + C4*y + C5*y**2 + C6*x*y\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference BiquadraticCurves\n";
    ss << "\\reference BiVariateCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "\\reference BiquadraticCubicCurves\n";
    ss << "\\reference BiquadraticQuadraticCubicCurves\n";
    ss << "\\reference BicubicBiquadraticCurves\n";
    ss << "N1 , \\field Coefficient1 Constant\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Coefficient2 x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Coefficient3 x**2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Coefficient4 y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N5 , \\field Coefficient5 y**2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N6 , \\field Coefficient6 x*y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N7 , \\field Minimum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N8 , \\field Maximum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N9 , \\field Minimum Value of y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "N10, \\field Maximum Value of y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "N11, \\field Minimum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "N12, \\field Maximum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "A2,  \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A3,  \\field Input Unit Type for Y\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A4;  \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";
    ss << "\\default Dimensionless\n";

    IddObjectType objType(IddObjectType::Curve_Biquadratic);
    OptionalIddObject oObj = IddObject::load("Curve:Biquadratic",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_Biquadratic);
  return object;
}

IddObject createCurve_QuadraticLinearIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:QuadraticLinear,\n";
    ss << "\\memo Quadratic-linear curve with two independent variables. Input consists of the curve\n";
    ss << "\\memo name, the six coefficients, and min and max values for each of the independent\n";
    ss << "\\memo variables. Optional inputs for curve minimum and maximum may be used to limit the\n";
    ss << "\\memo output of the performance curve.\n";
    ss << "\\memo curve = (C1 + C2*x + C3*x**2) + (C4 + C5*x + C6*x**2)*y\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference QuadraticLinearCurves\n";
    ss << "\\reference BiVariateCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1 , \\field Coefficient1 Constant\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Coefficient2 x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Coefficient3 x**2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Coefficient4 y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N5 , \\field Coefficient5 x*y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N6 , \\field Coefficient6 x**2*y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N7 , \\field Minimum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N8 , \\field Maximum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N9 , \\field Minimum Value of y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "N10, \\field Maximum Value of y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "N11, \\field Minimum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "N12, \\field Maximum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "A2,  \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A3,  \\field Input Unit Type for Y\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A4;  \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";
    ss << "\\default Dimensionless\n";

    IddObjectType objType(IddObjectType::Curve_QuadraticLinear);
    OptionalIddObject oObj = IddObject::load("Curve:QuadraticLinear",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_QuadraticLinear);
  return object;
}

IddObject createCurve_CubicLinearIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:CubicLinear,\n";
    ss << "\\memo Cubic-linear curve with two independent variables. Input consists of the curve\n";
    ss << "\\memo name, the six coefficients, and min and max values for each of the independent\n";
    ss << "\\memo variables. Optional inputs for curve minimum and maximum may be used to limit the\n";
    ss << "\\memo output of the performance curve.\n";
    ss << "\\memo curve = (C1 + C2*x + C3*x**2 + C4*x**3) + (C5 + C6*x)*y\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CubicLinearCurves\n";
    ss << "\\reference BiVariateCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1 , \\field Coefficient1 Constant\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Coefficient2 x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Coefficient3 x**2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Coefficient4 x**3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N5 , \\field Coefficient5 y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N6 , \\field Coefficient6 x*y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N7 , \\field Minimum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N8 , \\field Maximum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N9 , \\field Minimum Value of y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "N10, \\field Maximum Value of y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "N11, \\field Minimum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "N12, \\field Maximum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "A2,  \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\default Dimensionless\n";
    ss << "A3,  \\field Input Unit Type for Y\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\default Dimensionless\n";
    ss << "A4;  \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\default Dimensionless\n";

    IddObjectType objType(IddObjectType::Curve_CubicLinear);
    OptionalIddObject oObj = IddObject::load("Curve:CubicLinear",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_CubicLinear);
  return object;
}

IddObject createCurve_TriquadraticIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:Triquadratic,\n";
    ss << "\\memo Quadratic curve with three independent variables. Input consists of the curve name,\n";
    ss << "\\memo the twenty seven coefficients, and min and max values for each of the independent\n";
    ss << "\\memo variables. Optional inputs for curve minimum and maximum may be used to\n";
    ss << "\\memo limit the output of the performance curve.\n";
    ss << "\\memo curve = a0 + a1*x**2 + a2*x + a3*y**2 + a4*y\n";
    ss << "\\memo         + a5*z**2 + a6*z + a7*x**2*y**2 + a8*x*y\n";
    ss << "\\memo         + a9*x*y**2 + a10*x**2*y + a11*x**2*z**2\n";
    ss << "\\memo         + a12*x*z + a13*x*z**2 + a14*x**2*z + a15*y**2*z**2\n";
    ss << "\\memo         + a16*y*z + a17*y*z**2 + a18*y**2*z + a19*x**2*y**2*z**2\n";
    ss << "\\memo         + a20*x**2*y**2*z + a21*x**2*y*z**2 + a22*x*y**2*z**2\n";
    ss << "\\memo         + a23*x**2*y*z + a24*x*y**2*z + a25*x*y*z**2 +a26*x*y*z\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference TriQuadraticCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1 , \\field Coefficient1 Constant\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Coefficient2 x**2\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Coefficient3 x\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Coefficient4 y**2\n";
    ss << "\\type real\n";
    ss << "N5 , \\field Coefficient5 y\n";
    ss << "\\type real\n";
    ss << "N6 , \\field Coefficient6 z**2\n";
    ss << "\\type real\n";
    ss << "N7 , \\field Coefficient7 z\n";
    ss << "\\type real\n";
    ss << "N8 , \\field Coefficient8 x**2*y**2\n";
    ss << "\\type real\n";
    ss << "N9 , \\field Coefficient9 x*y\n";
    ss << "\\type real\n";
    ss << "N10, \\field Coefficient10 x*y**2\n";
    ss << "\\type real\n";
    ss << "N11, \\field Coefficient11 x**2*y\n";
    ss << "\\type real\n";
    ss << "N12, \\field Coefficient12 x**2*z**2\n";
    ss << "\\type real\n";
    ss << "N13, \\field Coefficient13 x*z\n";
    ss << "\\type real\n";
    ss << "N14, \\field Coefficient14 x*z**2\n";
    ss << "\\type real\n";
    ss << "N15, \\field Coefficient15 x**2*z\n";
    ss << "\\type real\n";
    ss << "N16, \\field Coefficient16 y**2*z**2\n";
    ss << "\\type real\n";
    ss << "N17, \\field Coefficient17 y*z\n";
    ss << "\\type real\n";
    ss << "N18, \\field Coefficient18 y*z**2\n";
    ss << "\\type real\n";
    ss << "N19, \\field Coefficient19 y**2*z\n";
    ss << "\\type real\n";
    ss << "N20, \\field Coefficient20 x**2*y**2*z**2\n";
    ss << "\\type real\n";
    ss << "N21, \\field Coefficient21 x**2*y**2*z\n";
    ss << "\\type real\n";
    ss << "N22, \\field Coefficient22 x**2*y*z**2\n";
    ss << "\\type real\n";
    ss << "N23, \\field Coefficient23 x*y**2*z**2\n";
    ss << "\\type real\n";
    ss << "N24, \\field Coefficient24 x**2*y*z\n";
    ss << "\\type real\n";
    ss << "N25, \\field Coefficient25 x*y**2*z\n";
    ss << "\\type real\n";
    ss << "N26, \\field Coefficient26 x*y*z**2\n";
    ss << "\\type real\n";
    ss << "N27, \\field Coefficient27 x*y*z\n";
    ss << "\\type real\n";
    ss << "N28, \\field Minimum Value of x\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N29, \\field Maximum Value of x\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N30, \\field Minimum Value of y\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "N31, \\field Maximum Value of y\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "N32, \\field Minimum Value of z\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "N33, \\field Maximum Value of z\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "N34, \\field Minimum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A5\n";
    ss << "N35, \\field Maximum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A5\n";
    ss << "A2,  \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A3,  \\field Input Unit Type for Y\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A4,  \\field Input Unit Type for Z\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A5;  \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";
    ss << "\\default Dimensionless\n";

    IddObjectType objType(IddObjectType::Curve_Triquadratic);
    OptionalIddObject oObj = IddObject::load("Curve:Triquadratic",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_Triquadratic);
  return object;
}

IddObject createCurve_Functional_PressureDropIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:Functional:PressureDrop,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo Sets up curve information for minor loss and/or friction\n";
    ss << "\\memo calculations in plant pressure simulations\n";
    ss << "\\memo Expression: DeltaP = {K + f*(L/D)} * (rho * V^2) / 2\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference UniVariateCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "\\reference PressureDropCurves\n";
    ss << "N1 , \\field Diameter\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\note \"D\" in above expression, used to also calculate local velocity\n";
    ss << "\\minimum> 0\n";
    ss << "N2 , \\field Minor Loss Coefficient\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\note \"K\" in above expression\n";
    ss << "\\minimum> 0\n";
    ss << "N3 , \\field Length\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\note \"L\" in above expression\n";
    ss << "\\minimum> 0\n";
    ss << "N4 , \\field Roughness\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\note This will be used to calculate \"f\" from Moody-chart approximations\n";
    ss << "\\minimum> 0\n";
    ss << "N5 ; \\field Fixed Friction Factor\n";
    ss << "\\note Optional way to set a constant value for \"f\", instead of using\n";
    ss << "\\note  internal Moody-chart approximations\n";
    ss << "\\minimum> 0\n";

    IddObjectType objType(IddObjectType::Curve_Functional_PressureDrop);
    OptionalIddObject oObj = IddObject::load("Curve:Functional:PressureDrop",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_Functional_PressureDrop);
  return object;
}

IddObject createCurve_FanPressureRiseIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:FanPressureRise,\n";
    ss << "\\memo Special curve type with two independent variables.\n";
    ss << "\\memo Input for the fan total pressure rise curve consists of the curve name, the four\n";
    ss << "\\memo coefficients, and the maximum and minimum valid independent variable values. Optional\n";
    ss << "\\memo inputs for the curve minimum and maximum may be used to limit the output of the\n";
    ss << "\\memo performance curve.\n";
    ss << "\\memo curve = C1*Qfan**2+C2*Qfan+C3*Qfan*(Psm-Po)**0.5+C4*(Psm-Po)\n";
    ss << "\\memo Po assumed to be zero\n";
    ss << "\\memo See InputOut Reference for curve details\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference FanPressureRiseCurves\n";
    ss << "\\reference BiVariateCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1 , \\field Coefficient1 C1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Coefficient2 C2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Coefficient3 C3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Coefficient4 C4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N5 , \\field Minimum Value of Qfan\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "N6 , \\field Maximum Value of Qfan\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "N7 , \\field Minimum Value of Psm\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units Pa\n";
    ss << "N8 , \\field Maximum Value of Psm\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units Pa\n";
    ss << "N9 , \\field Minimum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units Pa\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "N10 ; \\field Maximum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units Pa\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";

    IddObjectType objType(IddObjectType::Curve_FanPressureRise);
    OptionalIddObject oObj = IddObject::load("Curve:FanPressureRise",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_FanPressureRise);
  return object;
}

IddObject createCurve_ExponentialSkewNormalIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:ExponentialSkewNormal,\n";
    ss << "\\memo Exponential-modified skew normal curve with one independent variable.\n";
    ss << "\\memo Input consists of the curve name, the four coefficients, and the maximum\n";
    ss << "\\memo and minimum valid independent variable values. Optional inputs for the curve minimum\n";
    ss << "\\memo and maximum may be used to limit the output of the performance curve.\n";
    ss << "\\memo curve = see Input Output Reference\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ExponentialSkewNormalCurves\n";
    ss << "\\reference UniVariateCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "\\note See InputOut Reference for curve description\n";
    ss << "N1 , \\field Coefficient1 C1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Coefficient2 C2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Coefficient3 C3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Coefficient4 C4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N5 , \\field Minimum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N6 , \\field Maximum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N7 , \\field Minimum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "N8 , \\field Maximum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "A2,  \\field Input Unit Type for x\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\default Dimensionless\n";
    ss << "A3;  \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\default Dimensionless\n";

    IddObjectType objType(IddObjectType::Curve_ExponentialSkewNormal);
    OptionalIddObject oObj = IddObject::load("Curve:ExponentialSkewNormal",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_ExponentialSkewNormal);
  return object;
}

IddObject createCurve_SigmoidIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:Sigmoid,\n";
    ss << "\\memo Sigmoid curve with one independent variable.\n";
    ss << "\\memo Input consists of the curve name, the five coefficients, and the maximum and minimum\n";
    ss << "\\memo valid independent variable values. Optional inputs for the curve minimum and maximum\n";
    ss << "\\memo may be used to limit the output of the performance curve.\n";
    ss << "\\memo curve = C1+C2/[1+exp((C3-x)/C4)]**C5\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SigmoidCurves\n";
    ss << "\\reference UniVariateCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "\\note See InputOut Reference for curve description\n";
    ss << "N1 , \\field Coefficient1 C1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Coefficient2 C2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Coefficient3 C3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Coefficient4 C4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N5 , \\field Coefficient5 C5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N6 , \\field Minimum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N7 , \\field Maximum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N8 , \\field Minimum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "N9 , \\field Maximum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "A2,  \\field Input Unit Type for x\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\default Dimensionless\n";
    ss << "A3;  \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\default Dimensionless\n";

    IddObjectType objType(IddObjectType::Curve_Sigmoid);
    OptionalIddObject oObj = IddObject::load("Curve:Sigmoid",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_Sigmoid);
  return object;
}

IddObject createCurve_RectangularHyperbola1IddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:RectangularHyperbola1,\n";
    ss << "\\memo Rectangular hyperbola type 1 curve with one independent variable.\n";
    ss << "\\memo Input consists of the curve name, the three coefficients, and the maximum and\n";
    ss << "\\memo minimum valid independent variable values. Optional inputs for the curve minimum and\n";
    ss << "\\memo maximum may be used to limit the output of the performance curve.\n";
    ss << "\\memo curve = ((C1*x)/(C2+x))+C3\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RectangularHyperbola1Curves\n";
    ss << "\\reference UniVariateCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1 , \\field Coefficient1 C1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Coefficient2 C2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Coefficient3 C3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Minimum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N5 , \\field Maximum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N6 , \\field Minimum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "N7 , \\field Maximum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "A2,  \\field Input Unit Type for x\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\default Dimensionless\n";
    ss << "A3;  \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\default Dimensionless\n";

    IddObjectType objType(IddObjectType::Curve_RectangularHyperbola1);
    OptionalIddObject oObj = IddObject::load("Curve:RectangularHyperbola1",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_RectangularHyperbola1);
  return object;
}

IddObject createCurve_RectangularHyperbola2IddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:RectangularHyperbola2,\n";
    ss << "\\memo Rectangular hyperbola type 2 curve with one independent variable.\n";
    ss << "\\memo Input consists of the curve name, the three coefficients, and the maximum and\n";
    ss << "\\memo minimum valid independent variable values. Optional inputs for the curve minimum and\n";
    ss << "\\memo maximum may be used to limit the output of the performance curve.\n";
    ss << "\\memo curve = ((C1*x)/(C2+x))+(C3*x)\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RectangularHyperbola2Curves\n";
    ss << "\\reference UniVariateCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1 , \\field Coefficient1 C1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Coefficient2 C2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Coefficient3 C3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Minimum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N5 , \\field Maximum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N6 , \\field Minimum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "N7 , \\field Maximum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "A2,  \\field Input Unit Type for x\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\default Dimensionless\n";
    ss << "A3;  \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\default Dimensionless\n";

    IddObjectType objType(IddObjectType::Curve_RectangularHyperbola2);
    OptionalIddObject oObj = IddObject::load("Curve:RectangularHyperbola2",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_RectangularHyperbola2);
  return object;
}

IddObject createCurve_ExponentialDecayIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:ExponentialDecay,\n";
    ss << "\\memo Exponential decay curve with one independent variable.\n";
    ss << "\\memo Input consists of the curve name, the three coefficients, and the maximum and minimum\n";
    ss << "\\memo valid independent variable values. Optional inputs for the curve minimum and\n";
    ss << "\\memo maximum may be used to limit the output of the performance curve.\n";
    ss << "\\memo curve = C1+C2*exp(C3*x)\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ExponentialDecayCurves\n";
    ss << "\\reference UniVariateCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1 , \\field Coefficient1 C1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Coefficient2 C2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Coefficient3 C3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Minimum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N5 , \\field Maximum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N6 , \\field Minimum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "N7 , \\field Maximum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "A2,  \\field Input Unit Type for x\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\default Dimensionless\n";
    ss << "A3;  \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\default Dimensionless\n";

    IddObjectType objType(IddObjectType::Curve_ExponentialDecay);
    OptionalIddObject oObj = IddObject::load("Curve:ExponentialDecay",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_ExponentialDecay);
  return object;
}

IddObject createCurve_DoubleExponentialDecayIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:DoubleExponentialDecay,\n";
    ss << "\\memo Double exponential decay curve with one independent variable.\n";
    ss << "\\memo Input consists of the curve name, the five coefficients, and the maximum and minimum\n";
    ss << "\\memo valid independent variable values. Optional inputs for the curve minimum and\n";
    ss << "\\memo maximum may be used to limit the output of the performance curve.\n";
    ss << "\\memo curve = C1+C2*exp(C3*x)+C4*exp(C5*x)\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference DoubleExponentialDecayCurves\n";
    ss << "\\reference UniVariateCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1 , \\field Coefficient1 C1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Coefficient2 C2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Coefficient3 C3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Coefficient3 C4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N5 , \\field Coefficient3 C5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N6 , \\field Minimum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N7 , \\field Maximum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N8 , \\field Minimum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "N9 , \\field Maximum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "A2,  \\field Input Unit Type for x\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\default Dimensionless\n";
    ss << "A3;  \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\default Dimensionless\n";

    IddObjectType objType(IddObjectType::Curve_DoubleExponentialDecay);
    OptionalIddObject oObj = IddObject::load("Curve:DoubleExponentialDecay",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_DoubleExponentialDecay);
  return object;
}

IddObject createCurve_ChillerPartLoadWithLiftIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Curve:ChillerPartLoadWithLift,\n";
    ss << "\\memo This chiller part-load performance curve has three independent variables.\n";
    ss << "\\memo Input consists of the curve name, the twelve coefficients, and the maximum\n";
    ss << "\\memo and minimum valid independent variable values. Optional inputs for the curve minimum\n";
    ss << "\\memo and maximum may be used to limit the output of the performance curve.\n";
    ss << "\\memo curve = C1 + C2*x + C3*x**2 + C4*y + C5*y**2 + C6*x*y + C7*x**3\n";
    ss << "\\memo + C8*y**3 + C9*x**2*y + C10*x*y**2 + C11*x**2*y**2 + C12*z*y**3\n";
    ss << "\\memo x = dT* = normalized fractional Lift = dT / dTref\n";
    ss << "\\memo y = PLR = part load ratio (cooling load/steady state capacity)\n";
    ss << "\\memo z = Tdev* = normalized Tdev = Tdev / dTref\n";
    ss << "\\memo Where:\n";
    ss << "\\memo dT = Lift = Leaving Condenser Water Temperature - Leaving Chilled Water Temperature\n";
    ss << "\\memo dTref = dT at the reference condition\n";
    ss << "\\memo Tdev = Leaving Chilled Water Temperature - Reference Chilled Water Temperature\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ChillerPartLoadWithLiftCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1 , \\field Coefficient1 C1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Coefficient2 C2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Coefficient3 C3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Coefficient4 C4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N5 , \\field Coefficient5 C5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N6 , \\field Coefficient6 C6\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N7 , \\field Coefficient7 C7\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N8 , \\field Coefficient8 C8\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N9 , \\field Coefficient9 C9\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N10, \\field Coefficient10 C10\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N11, \\field Coefficient11 C11\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N12, \\field Coefficient12 C12\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N13, \\field Minimum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N14, \\field Maximum Value of x\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "N15, \\field Minimum Value of y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "N16, \\field Maximum Value of y\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A3\n";
    ss << "N17, \\field Minimum Value of z\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "N18, \\field Maximum Value of z\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "N19, \\field Minimum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A5\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "N20, \\field Maximum Curve Output\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A5\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "A2 , \\field Input Unit Type for x\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\default Dimensionless\n";
    ss << "A3 , \\field Input Unit Type for y\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\default Dimensionless\n";
    ss << "A4 , \\field Input Unit Type for z\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\default Dimensionless\n";
    ss << "A5;  \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\default Dimensionless\n";

    IddObjectType objType(IddObjectType::Curve_ChillerPartLoadWithLift);
    OptionalIddObject oObj = IddObject::load("Curve:ChillerPartLoadWithLift",
                                             "Performance Curves",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Curve_ChillerPartLoadWithLift);
  return object;
}

IddObject createTable_OneIndependentVariableIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Table:OneIndependentVariable,\n";
    ss << "\\extensible:2 repeat last two fields\n";
    ss << "\\min-fields 14\n";
    ss << "\\memo Allows entry of tabular data pairs as alternate input\n";
    ss << "\\memo for performance curve objects.\n";
    ss << "\\memo Performance curve objects can be created using these inputs.\n";
    ss << "\\memo Linear Table Equation: Output = a + bX\n";
    ss << "\\memo Linear solution requires a minimum of 2 data pairs\n";
    ss << "\\memo Quadratic Table Equation: Output = a + b*X + c*X**2\n";
    ss << "\\memo Quadratic solution requires a minimum of 3 data pairs\n";
    ss << "\\memo Cubic Table Equation: Output = a + b*X + c* X**2 + d*X**3\n";
    ss << "\\memo Cubic solution requires a minimum of 4 data pairs\n";
    ss << "\\memo Quartic Table Equation: Output = a + b*X + c* X**2 + d*X**3 + e*X**4\n";
    ss << "\\memo Quartic solution requires a minimum of 5 data pairs\n";
    ss << "\\memo Exponent Table Equation: Output = a + b*X**c\n";
    ss << "\\memo Exponent solution requires a minimum of 4 data pairs\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AllCurves\n";
    ss << "\\reference UniVariateTables\n";
    ss << "A2 , \\field Curve Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Linear\n";
    ss << "\\key Quadratic\n";
    ss << "\\key Cubic\n";
    ss << "\\key Quartic\n";
    ss << "\\key Exponent\n";
    ss << "A3 , \\field Interpolation Method\n";
    ss << "\\type choice\n";
    ss << "\\key LinearInterpolationOfTable\n";
    ss << "\\key EvaluateCurveToLimits\n";
    ss << "\\key LagrangeInterpolationLinearExtrapolation\n";
    ss << "N1 , \\field Minimum Value of X\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "\\note used only when Interpolation Type is Evaluate Curve\n";
    ss << "\\note to Limits\n";
    ss << "N2 , \\field Maximum Value of X\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "\\note used only when Interpolation Type is Evaluate Curve\n";
    ss << "\\note to Limits\n";
    ss << "N3 , \\field Minimum Table Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the minimum value calculated by this table\n";
    ss << "\\note lookup object\n";
    ss << "\\unitsBasedOnField A5\n";
    ss << "\\note used only when Interpolation Type is Evaluate Curve\n";
    ss << "\\note to Limits\n";
    ss << "N4 , \\field Maximum Table Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the maximum value calculated by this table\n";
    ss << "\\note lookup object\n";
    ss << "\\unitsBasedOnField A5\n";
    ss << "\\note used only when Interpolation Type is Evaluate Curve\n";
    ss << "\\note to Limits\n";
    ss << "A4,  \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A5,  \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";
    ss << "\\default Dimensionless\n";
    ss << "N5 , \\field Normalization Reference\n";
    ss << "\\type real\n";
    ss << "\\note This field is used to normalize the following ouput data.\n";
    ss << "\\note The minimum and maximum table output fields are also normalized.\n";
    ss << "\\note If this field is blank or 1, the table data presented\n";
    ss << "\\note in the following fields will be used with normalization\n";
    ss << "\\note reference set to 1.\n";
    ss << "N6 , \\field X Value 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\begin-extensible\n";
    ss << "N7 ; \\field Output Value 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::Table_OneIndependentVariable);
    OptionalIddObject oObj = IddObject::load("Table:OneIndependentVariable",
                                             "Performance Tables",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Table_OneIndependentVariable);
  return object;
}

IddObject createTable_TwoIndependentVariablesIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Table:TwoIndependentVariables,\n";
    ss << "\\extensible:3 repeat last three fields\n";
    ss << "\\min-fields 22\n";
    ss << "\\memo Allows entry of tabular data pairs as alternate input\n";
    ss << "\\memo for performance curve objects.\n";
    ss << "\\memo Performance curve objects can be created using these inputs.\n";
    ss << "\\memo BiQuadratic Table Equation: Output = a + bX + cX**2 + dY + eY**2 + fXY\n";
    ss << "\\memo BiQuadratic solution requires a minimum of 6 data pairs\n";
    ss << "\\memo QuadraticLinear Table Equation: Output = a + bX + cX**2 + dY + eXY + fX**2Y\n";
    ss << "\\memo QuadraticLinear solution requires a minimum of 6 data pairs\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AllCurves\n";
    ss << "\\reference BiVariateTables\n";
    ss << "A2 , \\field Curve Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key BiQuadratic\n";
    ss << "\\key QuadraticLinear\n";
    ss << "A3 , \\field Interpolation Method\n";
    ss << "\\type choice\n";
    ss << "\\key LinearInterpolationOfTable\n";
    ss << "\\key EvaluateCurveToLimits\n";
    ss << "\\key LagrangeInterpolationLinearExtrapolation\n";
    ss << "\\default LagrangeInterpolationLinearExtrapolation\n";
    ss << "N1 , \\field Minimum Value of X\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "N2 , \\field Maximum Value of X\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "N3 , \\field Minimum Value of Y\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A5\n";
    ss << "N4 , \\field Maximum Value of Y\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A5\n";
    ss << "N5 , \\field Minimum Table Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the minimum value calculated by this table lookup object\n";
    ss << "\\unitsBasedOnField A6\n";
    ss << "N6 , \\field Maximum Table Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the maximum value calculated by this table lookup object\n";
    ss << "\\unitsBasedOnField A6\n";
    ss << "A4,  \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A5,  \\field Input Unit Type for Y\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A6,  \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";
    ss << "\\default Dimensionless\n";
    ss << "N7 , \\field Normalization Reference\n";
    ss << "\\type real\n";
    ss << "\\note This field is used to normalize the following output data.\n";
    ss << "\\note The minimum and maximum table output fields are also normalized.\n";
    ss << "\\note If this field is blank or 1, the table data presented below will be used.\n";
    ss << "N8 , \\field X Value 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\begin-extensible\n";
    ss << "N9 , \\field Y Value 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N10; \\field Output Value 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::Table_TwoIndependentVariables);
    OptionalIddObject oObj = IddObject::load("Table:TwoIndependentVariables",
                                             "Performance Tables",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Table_TwoIndependentVariables);
  return object;
}

IddObject createTable_MultiVariableLookupIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Table:MultiVariableLookup,\n";
    ss << "\\memo The multi-variable lookup table can represent from 1 to 5 independent variables and\n";
    ss << "\\memo can interpolate these independent variables up to a 4th order polynomial. The\n";
    ss << "\\memo polynomial order is assumed to be the number of interpolation points (n) minus 1.\n";
    ss << "\\memo When any independent variable value is outside the table limits, linear extrapolation\n";
    ss << "\\memo is used to predict the table result and is based on the two nearest data points in the\n";
    ss << "\\memo table for that particular independent variable.\n";
    ss << "\\extensible:1 repeat last twenty fields remembering to move the semi-colon to the last value\n";
    ss << "\\min-fields 27\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference AllCurves\n";
    ss << "\\reference UniVariateTables\n";
    ss << "\\reference BiVariateTables\n";
    ss << "\\reference MultiVariateTables\n";
    ss << "\\type alpha\n";
    ss << "A2 , \\field Interpolation Method\n";
    ss << "\\type choice\n";
    ss << "\\key LinearInterpolationOfTable\n";
    ss << "\\key EvaluateCurveToLimits\n";
    ss << "\\key LagrangeInterpolationLinearExtrapolation\n";
    ss << "\\default LagrangeInterpolationLinearExtrapolation\n";
    ss << "N1 , \\field Number of Interpolation Points\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 1\n";
    ss << "\\maximum 4\n";
    ss << "\\default 3\n";
    ss << "A3 , \\field Curve Type\n";
    ss << "\\type choice\n";
    ss << "\\key Linear\n";
    ss << "\\key Quadratic\n";
    ss << "\\key Cubic\n";
    ss << "\\key Quartic\n";
    ss << "\\key Exponent\n";
    ss << "\\key BiQuadratic\n";
    ss << "\\key QuadraticLinear\n";
    ss << "\\key BiCubic\n";
    ss << "\\key TriQuadratic\n";
    ss << "\\key Other\n";
    ss << "\\note The curve types BiCubic and TriQuadratic may not\n";
    ss << "\\note be used with Interpolation Method = EvaluateCurveToLimits\n";
    ss << "A4 , \\field Table Data Format\n";
    ss << "\\type choice\n";
    ss << "\\key SingleLineIndependentVariableWithMatrix\n";
    ss << "\\default SingleLineIndependentVariableWithMatrix\n";
    ss << "A5 , \\field External File Name\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "A6 , \\field X1 Sort Order\n";
    ss << "\\type choice\n";
    ss << "\\key Ascending\n";
    ss << "\\key Descending\n";
    ss << "\\default Ascending\n";
    ss << "A7 , \\field X2 Sort Order\n";
    ss << "\\type choice\n";
    ss << "\\key Ascending\n";
    ss << "\\key Descending\n";
    ss << "\\default Ascending\n";
    ss << "N2 , \\field Normalization Reference\n";
    ss << "\\type real\n";
    ss << "\\note This field is used to normalize the table output data.\n";
    ss << "\\note The minimum and maximum table output fields are also normalized.\n";
    ss << "\\note If this field is blank or 1, the table data will be directly used.\n";
    ss << "\\note This field is not allowed to be set equal to 0.\n";
    ss << "N3 , \\field Minimum Value of X1\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A8\n";
    ss << "N4 , \\field Maximum Value of X1\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A8\n";
    ss << "N5 , \\field Minimum Value of X2\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A9\n";
    ss << "N6 , \\field Maximum Value of X2\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A9\n";
    ss << "N7 , \\field Minimum Value of X3\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A10\n";
    ss << "N8 , \\field Maximum Value of X3\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A10\n";
    ss << "N9 , \\field Minimum Value of X4\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A11\n";
    ss << "N10, \\field Maximum Value of X4\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A11\n";
    ss << "N11, \\field Minimum Value of X5\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A12\n";
    ss << "N12, \\field Maximum Value of X5\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A12\n";
    ss << "N13, \\field Minimum Table Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A13\n";
    ss << "N14, \\field Maximum Table Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\unitsBasedOnField A13\n";
    ss << "A8 , \\field Input Unit Type for X1\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A9 , \\field Input Unit Type for X2\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A10, \\field Input Unit Type for X3\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A11, \\field Input Unit Type for X4\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A12, \\field Input Unit Type for X5\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A13, \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";
    ss << "\\default Dimensionless\n";
    ss << "N15, \\field Number of Independent Variables\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 5\n";
    ss << "\\required-field\n";
    ss << "N16; \\field Data\n";
    ss << "\\type real\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::Table_MultiVariableLookup);
    OptionalIddObject oObj = IddObject::load("Table:MultiVariableLookup",
                                             "Performance Tables",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Table_MultiVariableLookup);
  return object;
}

IddObject createFluidProperties_NameIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FluidProperties:Name,\n";
    ss << "\\memo potential fluid name/type in the input file\n";
    ss << "\\memo repeat this object for each fluid\n";
    ss << "A1,  \\field Fluid Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference FluidNames\n";
    ss << "\\reference FluidAndGlycolNames\n";
    ss << "A2;  \\field Fluid Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Refrigerant\n";
    ss << "\\key Glycol\n";

    IddObjectType objType(IddObjectType::FluidProperties_Name);
    OptionalIddObject oObj = IddObject::load("FluidProperties:Name",
                                             "Fluid Properties",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FluidProperties_Name);
  return object;
}

IddObject createFluidProperties_GlycolConcentrationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FluidProperties:GlycolConcentration,\n";
    ss << "\\memo glycol and what concentration it is\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Glycol Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key EthyleneGlycol\n";
    ss << "\\key PropyleneGlycol\n";
    ss << "\\key UserDefinedGlycolType\n";
    ss << "\\note or UserDefined Fluid (must show up as a glycol in FluidProperties:Name object)\n";
    ss << "A3,  \\field User Defined Glycol Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FluidAndGlycolNames\n";
    ss << "N1;  \\field Glycol Concentration\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";

    IddObjectType objType(IddObjectType::FluidProperties_GlycolConcentration);
    OptionalIddObject oObj = IddObject::load("FluidProperties:GlycolConcentration",
                                             "Fluid Properties",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FluidProperties_GlycolConcentration);
  return object;
}

IddObject createFluidProperties_TemperaturesIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FluidProperties:Temperatures,\n";
    ss << "\\memo property values for fluid properties\n";
    ss << "\\memo list of up to 250 temperatures, note that number of property values must match the number of properties\n";
    ss << "\\memo in other words, there must be a one-to-one correspondence between the property values in this list and\n";
    ss << "\\memo the actual properties list in other syntax\n";
    ss << "\\memo degrees C (for all temperature inputs)\n";
    ss << "\\format FluidProperty\n";
    ss << "\\extensible:1\n";
    ss << "\\max-fields 251\n";
    ss << "A1, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\reference FluidPropertyTemperatures\n";
    ss << "N1; \\field Temperature 1\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::FluidProperties_Temperatures);
    OptionalIddObject oObj = IddObject::load("FluidProperties:Temperatures",
                                             "Fluid Properties",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FluidProperties_Temperatures);
  return object;
}

IddObject createFluidProperties_SaturatedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FluidProperties:Saturated,\n";
    ss << "\\memo fluid properties for the saturated region\n";
    ss << "\\format FluidProperty\n";
    ss << "\\extensible:1\n";
    ss << "\\max-fields 254\n";
    ss << "A1, \\field Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FluidNames\n";
    ss << "A2, \\field Fluid Property Type\n";
    ss << "\\note Enthalpy Units are J/kg\n";
    ss << "\\note Density Units are kg/m3\n";
    ss << "\\note SpecificHeat Units are J/kg-K\n";
    ss << "\\note Pressure Units are Pa\n";
    ss << "\\type choice\n";
    ss << "\\key Enthalpy     ! Units are J/kg\n";
    ss << "\\key Density      ! Units are kg/m3\n";
    ss << "\\key SpecificHeat ! Units are J/kg-K\n";
    ss << "\\key Pressure     ! Units are Pa\n";
    ss << "A3, \\field Fluid Phase\n";
    ss << "\\note Fluid=saturated fluid\n";
    ss << "\\note FluidGas=saturated vapor\n";
    ss << "\\type choice\n";
    ss << "\\key Fluid        ! saturated fluid\n";
    ss << "\\key FluidGas     ! saturated vapor\n";
    ss << "A4, \\field Temperature Values Name\n";
    ss << "\\note Enter the name of a FluidProperties:Temperatures object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FluidPropertyTemperatures\n";
    ss << "N1; \\field Property Value 1\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::FluidProperties_Saturated);
    OptionalIddObject oObj = IddObject::load("FluidProperties:Saturated",
                                             "Fluid Properties",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FluidProperties_Saturated);
  return object;
}

IddObject createFluidProperties_SuperheatedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FluidProperties:Superheated,\n";
    ss << "\\memo fluid properties for the superheated region\n";
    ss << "\\format FluidProperty\n";
    ss << "\\extensible:1\n";
    ss << "\\max-fields 254\n";
    ss << "A1, \\field Fluid Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FluidNames\n";
    ss << "A2, \\field Fluid Property Type\n";
    ss << "\\note Enthalpy Units are J/kg\n";
    ss << "\\note Density Units are kg/m3\n";
    ss << "\\type choice\n";
    ss << "\\key Enthalpy     ! Units are J/kg\n";
    ss << "\\key Density      ! Units are kg/m3\n";
    ss << "A3, \\field Temperature Values Name\n";
    ss << "\\note Enter the name of a FluidProperties:Temperatures object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FluidPropertyTemperatures\n";
    ss << "N1, \\field Pressure\n";
    ss << "\\note pressure for this list of properties\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2; \\field Property Value 1\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::FluidProperties_Superheated);
    OptionalIddObject oObj = IddObject::load("FluidProperties:Superheated",
                                             "Fluid Properties",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FluidProperties_Superheated);
  return object;
}

IddObject createFluidProperties_ConcentrationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FluidProperties:Concentration,\n";
    ss << "\\memo fluid properties for water/other fluid mixtures\n";
    ss << "\\format FluidProperty\n";
    ss << "\\extensible:1\n";
    ss << "\\max-fields 254\n";
    ss << "A1, \\field Fluid Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FluidNames\n";
    ss << "\\note should not be any of the defaults (Water, EthyleneGlycol, or PropyleneGlycol)\n";
    ss << "A2, \\field Fluid Property Type\n";
    ss << "\\note Density Units are kg/m3\n";
    ss << "\\note SpecificHeat Units are J/kg-K\n";
    ss << "\\note Conductivity Units are W/m-K\n";
    ss << "\\note Viscosity Units are N-s/m2\n";
    ss << "\\type choice\n";
    ss << "\\key Density      ! Units are kg/m3\n";
    ss << "\\key SpecificHeat ! Units are J/kg-K\n";
    ss << "\\key Conductivity ! Units are W/m-K\n";
    ss << "\\key Viscosity    ! Units are N-s/m2\n";
    ss << "A3, \\field Temperature Values Name\n";
    ss << "\\note Enter the name of a FluidProperties:Temperatures object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FluidPropertyTemperatures\n";
    ss << "N1, \\field Concentration\n";
    ss << "\\note Glycol concentration for this list of properties entered as a fraction\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N2; \\field Property Value 1\n";
    ss << "\\type real\n";
    ss << "\\unitsBasedOnField A2\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::FluidProperties_Concentration);
    OptionalIddObject oObj = IddObject::load("FluidProperties:Concentration",
                                             "Fluid Properties",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FluidProperties_Concentration);
  return object;
}

IddObject createCurrencyTypeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "CurrencyType,\n";
    ss << "\\memo If CurrencyType is not specified, it will default to USD and produce $ in the reports.\n";
    ss << "\\unique-object\n";
    ss << "A1;   \\field Monetary Unit\n";
    ss << "\\required-field\n";
    ss << "\\note The commonly used three letter currency code for the units of money for the country or region.\n";
    ss << "\\note Based on ISO 4217 currency codes.  Common currency codes are USD for $ and EUR for Euros.\n";
    ss << "\\type choice\n";
    ss << "\\key USD\n";
    ss << "\\key AFN\n";
    ss << "\\key ALL\n";
    ss << "\\key ANG\n";
    ss << "\\key ARS\n";
    ss << "\\key AUD\n";
    ss << "\\key AWG\n";
    ss << "\\key AZN\n";
    ss << "\\key BAM\n";
    ss << "\\key BBD\n";
    ss << "\\key BGN\n";
    ss << "\\key BMD\n";
    ss << "\\key BND\n";
    ss << "\\key BOB\n";
    ss << "\\key BRL\n";
    ss << "\\key BSD\n";
    ss << "\\key BWP\n";
    ss << "\\key BYR\n";
    ss << "\\key BZD\n";
    ss << "\\key CAD\n";
    ss << "\\key CHF\n";
    ss << "\\key CLP\n";
    ss << "\\key CNY\n";
    ss << "\\key COP\n";
    ss << "\\key CRC\n";
    ss << "\\key CUP\n";
    ss << "\\key CZK\n";
    ss << "\\key DKK\n";
    ss << "\\key DOP\n";
    ss << "\\key EEK\n";
    ss << "\\key EGP\n";
    ss << "\\key EUR\n";
    ss << "\\key FJD\n";
    ss << "\\key GBP\n";
    ss << "\\key GHC\n";
    ss << "\\key GIP\n";
    ss << "\\key GTQ\n";
    ss << "\\key GYD\n";
    ss << "\\key HKD\n";
    ss << "\\key HNL\n";
    ss << "\\key HRK\n";
    ss << "\\key HUF\n";
    ss << "\\key IDR\n";
    ss << "\\key ILS\n";
    ss << "\\key IMP\n";
    ss << "\\key INR\n";
    ss << "\\key IRR\n";
    ss << "\\key ISK\n";
    ss << "\\key JEP\n";
    ss << "\\key JMD\n";
    ss << "\\key JPY\n";
    ss << "\\key KGS\n";
    ss << "\\key KHR\n";
    ss << "\\key KPW\n";
    ss << "\\key KRW\n";
    ss << "\\key KYD\n";
    ss << "\\key KZT\n";
    ss << "\\key LAK\n";
    ss << "\\key LBP\n";
    ss << "\\key LKR\n";
    ss << "\\key LRD\n";
    ss << "\\key LTL\n";
    ss << "\\key LVL\n";
    ss << "\\key MKD\n";
    ss << "\\key MNT\n";
    ss << "\\key MUR\n";
    ss << "\\key MXN\n";
    ss << "\\key MYR\n";
    ss << "\\key MZN\n";
    ss << "\\key NAD\n";
    ss << "\\key NGN\n";
    ss << "\\key NIO\n";
    ss << "\\key NOK\n";
    ss << "\\key NPR\n";
    ss << "\\key NZD\n";
    ss << "\\key OMR\n";
    ss << "\\key PAB\n";
    ss << "\\key PEN\n";
    ss << "\\key PHP\n";
    ss << "\\key PKR\n";
    ss << "\\key PLN\n";
    ss << "\\key PYG\n";
    ss << "\\key QAR\n";
    ss << "\\key RON\n";
    ss << "\\key RSD\n";
    ss << "\\key RUB\n";
    ss << "\\key SAR\n";
    ss << "\\key SBD\n";
    ss << "\\key SCR\n";
    ss << "\\key SEK\n";
    ss << "\\key SGD\n";
    ss << "\\key SHP\n";
    ss << "\\key SOS\n";
    ss << "\\key SRD\n";
    ss << "\\key SVC\n";
    ss << "\\key SYP\n";
    ss << "\\key THB\n";
    ss << "\\key TRL\n";
    ss << "\\key TRY\n";
    ss << "\\key TTD\n";
    ss << "\\key TVD\n";
    ss << "\\key TWD\n";
    ss << "\\key UAH\n";
    ss << "\\key UYU\n";
    ss << "\\key UZS\n";
    ss << "\\key VEF\n";
    ss << "\\key VND\n";
    ss << "\\key XCD\n";
    ss << "\\key YER\n";
    ss << "\\key ZAR\n";
    ss << "\\key ZWD\n";

    IddObjectType objType(IddObjectType::CurrencyType);
    OptionalIddObject oObj = IddObject::load("CurrencyType",
                                             "Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::CurrencyType);
  return object;
}

IddObject createComponentCost_AdjustmentsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ComponentCost:Adjustments,\n";
    ss << "\\memo Used to perform various modifications to the construction costs to arrive at an\n";
    ss << "\\memo estimate for total project costs. This object allows extending the line item model\n";
    ss << "\\memo so that the overall costs of the project will reflect various profit and fees.\n";
    ss << "N1 ,\\field Miscellaneous Cost per Conditioned Area\n";
    ss << "\\type real\n";
    ss << "\\note based on conditioned floor area\n";
    ss << "\\note for cost not accounted for in current line item cost model\n";
    ss << "\\units $/m2\n";
    ss << "N2 ,\\field Design and Engineering Fees\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N3 ,\\field Contractor Fee\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N4 ,\\field Contingency\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N5 ,\\field Permits, Bonding and Insurance\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N6 ,\\field Commissioning Fee\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N7 ;\\field Regional Adjustment Factor\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\note for use with average data in line item and Misc cost models\n";

    IddObjectType objType(IddObjectType::ComponentCost_Adjustments);
    OptionalIddObject oObj = IddObject::load("ComponentCost:Adjustments",
                                             "Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ComponentCost_Adjustments);
  return object;
}

IddObject createComponentCost_ReferenceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ComponentCost:Reference,\n";
    ss << "\\memo Used to allow comparing the current cost estimate to the results of a previous\n";
    ss << "\\memo estimate for a reference building. This object parallels the ComponentCost:Adjustments\n";
    ss << "\\memo object but adds a field for entering the cost line item model result for the reference\n";
    ss << "\\memo building. The factors entered in this object are applied to the reference building\n";
    ss << "\\memo while the factors listed in the ComponentCost:Adjustments object are applied to the\n";
    ss << "\\memo current building model cost estimate.\n";
    ss << "N1 ,\\field Reference Building Line Item Costs\n";
    ss << "\\type real\n";
    ss << "\\units $\n";
    ss << "\\note should be comparable to the components in current line item cost model\n";
    ss << "N2 ,\\field Reference Building Miscellaneous Cost per Conditioned Area\n";
    ss << "\\type real\n";
    ss << "\\units $/m2\n";
    ss << "\\note based on conditioned floor area\n";
    ss << "\\note for cost not accounted for in reference line item costs\n";
    ss << "N3 ,\\field Reference Building Design and Engineering Fees\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N4 ,\\field Reference Building Contractor Fee\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N5 ,\\field Reference Building Contingency\n";
    ss << "\\type real\n";
    ss << "N6 ,\\field Reference Building Permits, Bonding and Insurance\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N7 ,\\field Reference Building Commissioning Fee\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N8 ;\\field Reference Building Regional Adjustment Factor\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\note for use with average data in line item and Misc cost models\n";

    IddObjectType objType(IddObjectType::ComponentCost_Reference);
    OptionalIddObject oObj = IddObject::load("ComponentCost:Reference",
                                             "Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ComponentCost_Reference);
  return object;
}

IddObject createComponentCost_LineItemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "ComponentCost:LineItem,\n";
    ss << "\\memo Each instance of this object creates a cost line item and will contribute to the total\n";
    ss << "\\memo for a cost estimate.\n";
    ss << "A1 ,\\field Name\n";
    ss << "\\type alpha\n";
    ss << "A2 ,\\field Type\n";
    ss << "\\type alpha\n";
    ss << "A3 ,\\field Line Item Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key General\n";
    ss << "\\key Construction\n";
    ss << "\\key Coil:DX\n";
    ss << "\\key Coil:Cooling:DX:SingleSpeed\n";
    ss << "\\key Coil:Heating:Gas\n";
    ss << "\\key Chiller:Electric\n";
    ss << "\\key Daylighting:Controls\n";
    ss << "\\key Shading:Zone:Detailed\n";
    ss << "\\key Lights\n";
    ss << "\\key Generator:Photovoltaic\n";
    ss << "\\note  extend choice-keys as Cases are added to code\n";
    ss << "A4 ,\\field Item Name\n";
    ss << "\\required-field\n";
    ss << "\\note wildcard \"*\" is acceptable for some components\n";
    ss << "A5 ,\\field Object End-Use Key\n";
    ss << "\\type alpha\n";
    ss << "\\note not yet used\n";
    ss << "N1 ,\\field Cost per Each\n";
    ss << "\\type real\n";
    ss << "\\units $\n";
    ss << "N2 ,\\field Cost per Area\n";
    ss << "\\type real\n";
    ss << "\\units $/m2\n";
    ss << "N3 ,\\field Cost per Unit of Output Capacity\n";
    ss << "\\type real\n";
    ss << "\\units $/kW\n";
    ss << "N4 ,\\field Cost per Unit of Output Capacity per COP\n";
    ss << "\\type real\n";
    ss << "\\units $/kW\n";
    ss << "\\note The value is per change in COP.\n";
    ss << "N5 ,\\field Cost per Volume\n";
    ss << "\\type real\n";
    ss << "\\units $/m3\n";
    ss << "N6 ,\\field Cost per Volume Rate\n";
    ss << "\\type real\n";
    ss << "\\units $/(m3/s)\n";
    ss << "N7 ,\\field Cost per Energy per Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units $/(W/K)\n";
    ss << "\\note as in for use with UA sizing of Coils\n";
    ss << "N8 ;\\field Quantity\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\note optional for use with Cost per Each and \"General\" object Type\n";

    IddObjectType objType(IddObjectType::ComponentCost_LineItem);
    OptionalIddObject oObj = IddObject::load("ComponentCost:LineItem",
                                             "Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::ComponentCost_LineItem);
  return object;
}

IddObject createUtilityCost_TariffIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "UtilityCost:Tariff,\n";
    ss << "\\memo Defines the name of a utility cost tariff, the type of tariff, and other details\n";
    ss << "\\memo about the overall tariff. Each other object that is part of the tariff model\n";
    ss << "\\memo references the tariff name.  See UtilityCost:Charge:Simple, UtilityCost:Charge:Block,\n";
    ss << "\\memo UtilityCost:Ratchet, UtilityCost:Qualify, UtilityCost:Variable and\n";
    ss << "\\memo UtilityCost:Computation objects.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference UtilityCostTariffs\n";
    ss << "\\note The name of the tariff. Tariffs are sometimes called rates. The name is used in identifying\n";
    ss << "\\note the output results and in associating all of the charges and other objects that make up a tariff.\n";
    ss << "A2,  \\field Output Meter Name\n";
    ss << "\\note The name of any standard meter or custom meter or but usually set to either Electricity:Facility or Gas:Facility\n";
    ss << "\\required-field\n";
    ss << "\\type external-list\n";
    ss << "\\external-list autoRDDmeter\n";
    ss << "A3,  \\field Conversion Factor Choice\n";
    ss << "\\type choice\n";
    ss << "\\key UserDefined\n";
    ss << "\\key kWh\n";
    ss << "\\key Therm\n";
    ss << "\\key MMBtu\n";
    ss << "\\key MJ\n";
    ss << "\\key kBtu\n";
    ss << "\\key MCF\n";
    ss << "\\key CCF\n";
    ss << "\\note A choice that allows several different predefined conversion factors to be used; otherwise user\n";
    ss << "\\note defined conversion factors are used as defined in the next two fields.\n";
    ss << "N1,  \\field Energy Conversion Factor\n";
    ss << "\\type real\n";
    ss << "\\note Is a multiplier used to convert energy into the units specified by the utility in their tariff. If\n";
    ss << "\\note left blank it defaults to 1 (no conversion). This field should will be used only if Conversion Factor\n";
    ss << "\\note Choice is set to UserDefined.  Within EnergyPlus energy always has units of J (joules).  For\n";
    ss << "\\note conversion from J to kWh use the value of 0.0000002778. This is also used for all objects that\n";
    ss << "\\note reference the UtilityCost:Tariff.\n";
    ss << "N2,  \\field Demand Conversion Factor\n";
    ss << "\\type real\n";
    ss << "\\note Is a multiplier used to convert demand into the units specified by the utility in their tariff. If\n";
    ss << "\\note left blank it defaults to 1 (no conversion).  This field should will be used only if Conversion\n";
    ss << "\\note Factor Choice is set to UserDefined.  Within EnergyPlus demand always has units of J/s (joules/sec)\n";
    ss << "\\note which equivalent to W (watts).  For conversion from W to kW use the value of 0.001. This is also used\n";
    ss << "\\note for all objects that reference the UtilityCost:Tariff.\n";
    ss << "A4,  \\field Time of Use Period Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note The name of the schedule that defines the time-of-use periods that occur each day. The values for the\n";
    ss << "\\note different variables are: 1 for Peak. 2 for Shoulder. 3 for OffPeak. 4 for MidPeak.\n";
    ss << "A5,  \\field Season Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note The name of a schedule that defines the seasons.  The schedule values are: 1 for Winter. 2 for Spring.\n";
    ss << "\\note 3 for Summer. 4 for Autumn.\n";
    ss << "A6,  \\field Month Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note The name of the schedule that defines the billing periods of the year. Normally this entry is allowed\n";
    ss << "\\note to default and a schedule will be internally used that has the breaks between billing periods occurring\n";
    ss << "\\note at the same time as the breaks between months i.e. at midnight prior to the first day of the month.\n";
    ss << "\\note If other billing periods are used such as two month cycles or a single bill for an entire season such\n";
    ss << "\\note as some natural gas companies do in the summer then the month schedule may be used to redefine it.\n";
    ss << "\\note Make sure that the month schedule and season schedule are consistent otherwise an error will be issued.\n";
    ss << "A7,  \\field Demand Window Length\n";
    ss << "\\type choice\n";
    ss << "\\key QuarterHour\n";
    ss << "\\key HalfHour\n";
    ss << "\\key FullHour\n";
    ss << "\\key Day\n";
    ss << "\\key Week\n";
    ss << "\\note The determination of demand can vary by utility. Some utilities use the peak instantaneous demand\n";
    ss << "\\note measured but most use a fifteen minute average demand or a one hour average demand. Some gas utilities\n";
    ss << "\\note measure demand as the use during the peak day or peak week.\n";
    ss << "A8,  \\field Monthly Charge or Variable Name\n";
    ss << "\\note The fixed monthly service charge that many utilities have.  The entry may be numeric and gets added to\n";
    ss << "\\note the ServiceCharges variable or if a variable name is entered here its values for each month are used.\n";
    ss << "A9,  \\field Minimum Monthly Charge or Variable Name\n";
    ss << "\\note The minimum total charge for the tariff or if a variable name is entered here its\n";
    ss << "\\note values for each month are used.\n";
    ss << "A10, \\field Real Time Pricing Charge Schedule Name\n";
    ss << "\\note Used with real time pricing rates. The name of a schedule that contains the cost of\n";
    ss << "\\note energy for that particular time period of the year. Real time rates can be modeled using a charge\n";
    ss << "\\note schedule with the actual real time prices entered in the schedule.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A11, \\field Customer Baseline Load Schedule Name\n";
    ss << "\\note Used with real time pricing rates. The name of a schedule that contains the baseline\n";
    ss << "\\note energy use for the customer. Many real time rates apply the charges as a credit or debit only to the\n";
    ss << "\\note difference between the baseline use and the actual use.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A12, \\field Group Name\n";
    ss << "\\note The group name of the tariff such as distribution transmission supplier etc. If more than one tariff\n";
    ss << "\\note with the same group name is present and qualifies only the lowest cost tariff is used. Usually the group\n";
    ss << "\\note name field is left blank which results in all tariffs using the same meter variable being compared and\n";
    ss << "\\note the lowest cost one being selected.\n";
    ss << "A13; \\field Buy Or Sell\n";
    ss << "\\type  choice\n";
    ss << "\\key   BuyFromUtility\n";
    ss << "\\key   SellToUtility\n";
    ss << "\\key   NetMetering\n";
    ss << "\\default BuyFromUtility\n";
    ss << "\\note Sets whether the tariff is used for buying selling or both to the utility.  This\n";
    ss << "\\note should be allowed to default to buyFromUtility unless a power generation system is included in the\n";
    ss << "\\note building that may generate more power than the building needs during the year\n";

    IddObjectType objType(IddObjectType::UtilityCost_Tariff);
    OptionalIddObject oObj = IddObject::load("UtilityCost:Tariff",
                                             "Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::UtilityCost_Tariff);
  return object;
}

IddObject createUtilityCost_QualifyIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "UtilityCost:Qualify,\n";
    ss << "\\memo The qualify object allows only tariffs to be selected based on limits which may apply\n";
    ss << "\\memo such as maximum or minimum demand requirements. If the results of the simulation fall\n";
    ss << "\\memo outside of the range of qualifications, that tariff is still calculated but the\n";
    ss << "\\memo \"Qualified\" entry will say \"No\" and the UtilityCost:Qualify that caused its exclusion\n";
    ss << "\\memo is shown. Multiple UtilityCost:Qualify objects can appear for the same tariff and\n";
    ss << "\\memo they can be based on any variable.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\note Displayed in the report if the tariff does not qualify\n";
    ss << "A2,  \\field Tariff Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UtilityCostTariffs\n";
    ss << "\\note The name of the UtilityCost:Tariff that is associated with this UtilityCost:Qualify.\n";
    ss << "A3,  \\field Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\note The name of the variable used. For energy and demand the automatically created variables totalEnergy\n";
    ss << "\\note and totalDemand should be used respectively.\n";
    ss << "A4,  \\field Qualify Type\n";
    ss << "\\type choice\n";
    ss << "\\key Minimum\n";
    ss << "\\key Maximum\n";
    ss << "\\default Maximum\n";
    ss << "A5,  \\field Threshold Value or Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\note The minimum or maximum value for the qualify. If the variable has values that are less than this value\n";
    ss << "\\note when the qualify type is minimum then the tariff may be disqualified.  If the variable has values that\n";
    ss << "\\note are greater than this value when the qualify type is maximum then the tariff may be disqualified.\n";
    ss << "A6,  \\field Season\n";
    ss << "\\type choice\n";
    ss << "\\key Annual\n";
    ss << "\\key Summer\n";
    ss << "\\key Winter\n";
    ss << "\\key Spring\n";
    ss << "\\key Fall\n";
    ss << "\\note If the UtilityCost:Qualify only applies to a season enter the season name. If this field is left blank\n";
    ss << "\\note it defaults to Annual.\n";
    ss << "A7,  \\field Threshold Test\n";
    ss << "\\type choice\n";
    ss << "\\key Count\n";
    ss << "\\key Consecutive\n";
    ss << "\\default Consecutive\n";
    ss << "\\note Uses the number in Number of Months in one of two different ways depending on the Threshold  Test. If\n";
    ss << "\\note the Threshold Test is set to Count then the qualification is based on the count of the total number\n";
    ss << "\\note of months per year.  If the Threshold Test is set to consecutive then the qualification is based on\n";
    ss << "\\note a consecutive number of months.\n";
    ss << "N1;  \\field Number of Months\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "\\note A number from 1 to 12.  If no value entered 12 is assumed when the qualify type is minimum and 1 when\n";
    ss << "\\note the qualify type is maximum.  This is the number of months that the threshold test applies to determine\n";
    ss << "\\note if the rate qualifies or not.  If the season is less than 12 months (if it is not annual) then the\n";
    ss << "\\note value is automatically reduced to the number of months of the season.\n";

    IddObjectType objType(IddObjectType::UtilityCost_Qualify);
    OptionalIddObject oObj = IddObject::load("UtilityCost:Qualify",
                                             "Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::UtilityCost_Qualify);
  return object;
}

IddObject createUtilityCost_Charge_SimpleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "UtilityCost:Charge:Simple,\n";
    ss << "\\memo UtilityCost:Charge:Simple is one of the most often used objects for tariff\n";
    ss << "\\memo calculation. It is used to compute energy and demand charges that are very simple.\n";
    ss << "\\memo It may also be used for taxes, surcharges and any other charges that occur on a\n";
    ss << "\\memo utility bill. Multiple UtilityCost:Charge:Simple objects may be defined for a single\n";
    ss << "\\memo tariff and they will be added together.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\note Charge Variable Name\n";
    ss << "\\note This is the name associated with the UtilityCost:Charge:Simple object and will appear in the report.\n";
    ss << "\\note In addition the results of the UtilityCost:Charge:Simple calculation are stored in a variable with the\n";
    ss << "\\note same name.  That way the results may be used for further calculation.  Spaces are not significant in\n";
    ss << "\\note Charge variable names. They are removed during the utility bill calculation process.\n";
    ss << "A2,  \\field Tariff Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UtilityCostTariffs\n";
    ss << "\\note The name of the UtilityCost:Tariff that is associated with this UtilityCost:Charge:Simple.\n";
    ss << "A3,  \\field Source Variable\n";
    ss << "\\required-field\n";
    ss << "\\note The name of the source used by the UtilityCost:Charge:Simple.  This is usually the name of the variable\n";
    ss << "\\note holding the energy or demand but may also be the name of any variable including the subtotal or basis\n";
    ss << "\\note if other charges are based on those. Typical values include totalEnergy totalDemand EnergyCharges DemandCharges\n";
    ss << "\\note ServiceCharges Basis Adjustments Surcharges Subtotal Taxes and Total. If it is a time-of-use rate then\n";
    ss << "\\note peakEnergy peakDemand shoulderEnergy shoulderDemand offPeakEnergy offPeakDemand midPeakEnergy and midPeakDemand.\n";
    ss << "\\note In addition see the Tariff Report to see other native variables that may be available. Also you can\n";
    ss << "\\note create additional user defined variables to model complex tariffs.\n";
    ss << "A4,  \\field Season\n";
    ss << "\\type choice\n";
    ss << "\\key Annual\n";
    ss << "\\key Summer\n";
    ss << "\\key Winter\n";
    ss << "\\key Spring\n";
    ss << "\\key Fall\n";
    ss << "\\note If this is set to annual the calculations are performed for the UtilityCost:Charge:Simple for the entire\n";
    ss << "\\note year (all months) otherwise it is calculated only for those months in the season defined.\n";
    ss << "A5,  \\field Category Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key EnergyCharges\n";
    ss << "\\key DemandCharges\n";
    ss << "\\key ServiceCharges\n";
    ss << "\\key Basis\n";
    ss << "\\key Adjustment\n";
    ss << "\\key Surcharge\n";
    ss << "\\key Subtotal\n";
    ss << "\\key Taxes\n";
    ss << "\\key Total\n";
    ss << "\\key NotIncluded\n";
    ss << "\\note This field shows where the charge should be added. The reason to enter this field appropriately is so\n";
    ss << "\\note that the charge gets reported in a reasonable category.  The charge automatically gets added to the\n";
    ss << "\\note variable that is the category.\n";
    ss << "A6;  \\field Cost per Unit Value or Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\note This field contains either a single number or the name of a variable.  The number is multiplied with\n";
    ss << "\\note all of the energy or demand or other source that is specified in the source field.  If a variable is\n";
    ss << "\\note used then the monthly values of the variable are multiplied against the variable specified in the\n";
    ss << "\\note source field.  This field makes it easy to include a simple charge without specifying block sizes.\n";
    ss << "\\note This is a good way to include a tax or cost adjustment.\n";

    IddObjectType objType(IddObjectType::UtilityCost_Charge_Simple);
    OptionalIddObject oObj = IddObject::load("UtilityCost:Charge:Simple",
                                             "Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::UtilityCost_Charge_Simple);
  return object;
}

IddObject createUtilityCost_Charge_BlockIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "UtilityCost:Charge:Block,\n";
    ss << "\\memo Used to compute energy and demand charges (or any other charges) that are structured\n";
    ss << "\\memo in blocks of charges. Multiple UtilityCost:Charge:Block objects may be defined for a\n";
    ss << "\\memo single tariff and they will be added together.\n";
    ss << "\\extensible:2\n";
    ss << "\\max-fields 37\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\note Charge Variable Name\n";
    ss << "\\note This is the name associated with the UtilityCost:Charge:Block object and will appear in the report.\n";
    ss << "\\note In addition the results of the UtilityCost:Charge:Block are stored in a variable with the same name.\n";
    ss << "\\note That way the results may be used for further calculation.\n";
    ss << "A2,  \\field Tariff Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UtilityCostTariffs\n";
    ss << "\\note The name of the UtilityCost:Tariff that is associated with this UtilityCost:Charge:Block.\n";
    ss << "A3,  \\field Source Variable\n";
    ss << "\\required-field\n";
    ss << "\\note The name of the source used by the UtilityCost:Charge:Block.  This is usually the name of the variable\n";
    ss << "\\note holding the energy or demand but may also be the name of any variable including the subtotal or basis if\n";
    ss << "\\note other charges are based on those. Typical values include totalEnergy totalDemand EnergyCharges DemandCharges\n";
    ss << "\\note ServiceCharges Basis Adjustments Surcharges Subtotal Taxes and Total. If it is a time-of-use rate then\n";
    ss << "\\note peakEnergy peakDemand shoulderEnergy shoulderDemand offPeakEnergy offPeakDemand midPeakEnergy and midPeakDemand.\n";
    ss << "\\note In addition see the Tariff Report to see other native variables that may be available. Also you can\n";
    ss << "\\note create additional user defined variables to model complex tariffs.\n";
    ss << "A4,  \\field Season\n";
    ss << "\\type choice\n";
    ss << "\\key Annual\n";
    ss << "\\key Summer\n";
    ss << "\\key Winter\n";
    ss << "\\key Spring\n";
    ss << "\\key Fall\n";
    ss << "\\default Annual\n";
    ss << "\\note If this is set to annual the calculations are performed for the UtilityCost:Charge:Block for the entire\n";
    ss << "\\note year (all months) otherwise it is calculated only for those months in the season defined.\n";
    ss << "A5,  \\field Category Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key EnergyCharges\n";
    ss << "\\key DemandCharges\n";
    ss << "\\key ServiceCharges\n";
    ss << "\\key Basis\n";
    ss << "\\key Adjustment\n";
    ss << "\\key Surcharge\n";
    ss << "\\key Subtotal\n";
    ss << "\\key Taxes\n";
    ss << "\\key Total\n";
    ss << "\\key NotIncluded\n";
    ss << "\\note This field shows where the charge should be added. The reason to enter this field appropriately is so\n";
    ss << "\\note that the charge gets reported in a reasonable category.  The charge automatically gets added to the\n";
    ss << "\\note variable that is the category.\n";
    ss << "A6,  \\field Remaining Into Variable\n";
    ss << "\\note If the blocks do not use all of the energy or demand from the source some energy and demand remains\n";
    ss << "\\note then the remaining amount should be assigned to a variable. If no variable is assigned and some amount\n";
    ss << "\\note of energy or demand is not used in the block structure a warning will be issued.\n";
    ss << "A7,  \\field Block Size Multiplier Value or Variable Name\n";
    ss << "\\note The sizes of the blocks are usually used directly but if a value or a variable is entered here the block\n";
    ss << "\\note sizes entered in the rest of the charge are first multiplied by the entered value prior to being used.\n";
    ss << "\\note This is common for rates that are kWh/kW rates and in that case the variable that holds the monthly\n";
    ss << "\\note total electric demand would be entered.  If no value is entered a default value of one is assumed so\n";
    ss << "\\note that the block sizes remain exactly as entered.  This field is unusual for the EnergyPlus syntax because\n";
    ss << "\\note it can be either a number or a name of a variable.\n";
    ss << "A8,  \\field Block Size 1 Value or Variable Name\n";
    ss << "\\note The size of the block of the charges is entered here. For most rates that use multiple blocks this will\n";
    ss << "\\note be the value for the block size. Using remaining may be used when the remaining amount should be included\n";
    ss << "\\note in that block.  This field is unusual because it can be either a number or a name of a variable.\n";
    ss << "\\begin-extensible\n";
    ss << "A9;  \\field Block 1 Cost per Unit Value or Variable Name\n";
    ss << "\\note The cost of the block. This field is unusual for the EnergyPlus syntax because it can be either a number\n";
    ss << "\\note or a name of a variable.\n";

    IddObjectType objType(IddObjectType::UtilityCost_Charge_Block);
    OptionalIddObject oObj = IddObject::load("UtilityCost:Charge:Block",
                                             "Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::UtilityCost_Charge_Block);
  return object;
}

IddObject createUtilityCost_RatchetIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "UtilityCost:Ratchet,\n";
    ss << "\\memo Allows the modeling of tariffs that include some type of seasonal ratcheting.\n";
    ss << "\\memo Ratchets are most common when used with electric demand charges. A ratchet is when a\n";
    ss << "\\memo utility requires that the demand charge for a month with a low demand may be\n";
    ss << "\\memo increased to be more consistent with a month that set a higher demand charge.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\note Ratchet Variable Name\n";
    ss << "\\note The name of the ratchet and the name of the result of this single ratchet.\n";
    ss << "A2,  \\field Tariff Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UtilityCostTariffs\n";
    ss << "\\note The name of the UtilityCost:Tariff that is associated with this UtilityCost:Ratchet.\n";
    ss << "A3,  \\field Baseline Source Variable\n";
    ss << "\\required-field\n";
    ss << "\\note When the ratcheted value exceeds the baseline value for a month the ratcheted value is used but when the\n";
    ss << "\\note baseline value is greater then the ratcheted value the baseline value is used. Usually the electric\n";
    ss << "\\note demand charge is used.  The baseline source variable can be the results of another ratchet object. This\n";
    ss << "\\note allows utility tariffs that have multiple ratchets to be modeled.\n";
    ss << "A4,  \\field Adjustment Source Variable\n";
    ss << "\\required-field\n";
    ss << "\\note The variable that the ratchet is calculated from. It is often but not always the same as the baseline\n";
    ss << "\\note source variable.  The ratcheting calculations using offset and multiplier are using the values from the\n";
    ss << "\\note adjustment source variable. If left blank the adjustment source variable is the same as the baseline\n";
    ss << "\\note source variable.\n";
    ss << "A5,  \\field Season From\n";
    ss << "\\type choice\n";
    ss << "\\key Annual\n";
    ss << "\\key Summer\n";
    ss << "\\key Winter\n";
    ss << "\\key Spring\n";
    ss << "\\key Fall\n";
    ss << "\\key Monthly\n";
    ss << "\\note The name of the season that is being examined.  The maximum value for all of the months in the named\n";
    ss << "\\note season is what is used with the multiplier and offset.  This is most commonly Summer or Annual.  When\n";
    ss << "\\note Monthly is used the adjustment source variable is used directly for all months.\n";
    ss << "A6,  \\field Season To\n";
    ss << "\\type choice\n";
    ss << "\\key Annual\n";
    ss << "\\key Summer\n";
    ss << "\\key Winter\n";
    ss << "\\key Spring\n";
    ss << "\\key Fall\n";
    ss << "\\note The name of the season when the ratchet would be calculated.  This is most commonly Winter.  The ratchet\n";
    ss << "\\note only is applied to the months in the named season. The resulting variable for months not in the Season To\n";
    ss << "\\note selection will contain the values as appear in the baseline source variable.\n";
    ss << "A7,  \\field Multiplier Value or Variable Name\n";
    ss << "\\note Often the ratchet has a clause such as \"the current month demand or 90% of the summer month demand\".  For\n";
    ss << "\\note this case a value of 0.9 would be entered here as the multiplier.  This value may be left blank if no\n";
    ss << "\\note multiplier is needed and a value of one will be used as a default.\n";
    ss << "A8;  \\field Offset Value or Variable Name\n";
    ss << "\\note A less common strategy is to say that the ratchet must be all demand greater than a value in this case\n";
    ss << "\\note an offset that is added to the demand may be entered here. If entered it is common for the offset value\n";
    ss << "\\note to be negative representing that the demand be reduced.   If no value is entered it is assumed to be\n";
    ss << "\\note zero and not affect the ratchet.\n";

    IddObjectType objType(IddObjectType::UtilityCost_Ratchet);
    OptionalIddObject oObj = IddObject::load("UtilityCost:Ratchet",
                                             "Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::UtilityCost_Ratchet);
  return object;
}

IddObject createUtilityCost_VariableIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "UtilityCost:Variable,\n";
    ss << "\\memo Allows for the direct entry of monthly values into a utility tariff variable.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,   \\field Tariff Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UtilityCostTariffs\n";
    ss << "\\note The name of the UtilityCost:Tariff that is associated with this UtilityCost:Variable.\n";
    ss << "A3,   \\field Variable Type\n";
    ss << "\\type choice\n";
    ss << "\\key Energy\n";
    ss << "\\key Power\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Currency\n";
    ss << "\\default Dimensionless\n";
    ss << "N1,   \\field January Value\n";
    ss << "N2,   \\field February Value\n";
    ss << "N3,   \\field March Value\n";
    ss << "N4,   \\field April Value\n";
    ss << "N5,   \\field May Value\n";
    ss << "N6,   \\field June Value\n";
    ss << "N7,   \\field July Value\n";
    ss << "N8,   \\field August Value\n";
    ss << "N9,   \\field September Value\n";
    ss << "N10,  \\field October Value\n";
    ss << "N11,  \\field November Value\n";
    ss << "N12;  \\field December Value\n";

    IddObjectType objType(IddObjectType::UtilityCost_Variable);
    OptionalIddObject oObj = IddObject::load("UtilityCost:Variable",
                                             "Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::UtilityCost_Variable);
  return object;
}

IddObject createUtilityCost_ComputationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "UtilityCost:Computation,\n";
    ss << "\\memo The object lists a series of computations that are used to perform the utility bill\n";
    ss << "\\memo calculation. The object is only used for complex tariffs that cannot be modeled any\n";
    ss << "\\memo other way. For most utility tariffs, UtilityCost:Computation is unnecessary and\n";
    ss << "\\memo should be avoided. If UtilityCost:Computation is used, it must contain references\n";
    ss << "\\memo to all objects involved in the rate in the order that they should be computed.\n";
    ss << "\\extensible:1\n";
    ss << "\\max-fields 32\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,   \\field Tariff Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UtilityCostTariffs\n";
    ss << "\\note The name of the UtilityCost:Tariff that is associated with this UtilityCost:Variable.\n";
    ss << "A3;   \\field Compute Step 1\n";
    ss << "\\note Contain a simple language that describes the steps used in the computation process similar to a\n";
    ss << "\\note programming language.\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::UtilityCost_Computation);
    OptionalIddObject oObj = IddObject::load("UtilityCost:Computation",
                                             "Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::UtilityCost_Computation);
  return object;
}

IddObject createLifeCycleCost_ParametersIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "LifeCycleCost:Parameters,\n";
    ss << "\\memo Provides inputs related to the overall life-cycle analysis. It establishes many of\n";
    ss << "\\memo the assumptions used in computing the present value. It is important that when\n";
    ss << "\\memo comparing the results of multiple simulations that the fields in the\n";
    ss << "\\memo LifeCycleCost:Parameters objects are the same for all the simulations. When this\n";
    ss << "\\memo object is present the tabular report file will contain the Life-Cycle Cost Report.\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 11\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2,  \\field Discounting Convention\n";
    ss << "\\type choice\n";
    ss << "\\key EndOfYear\n";
    ss << "\\key MidYear\n";
    ss << "\\key BeginningOfYear\n";
    ss << "\\default EndOfYear\n";
    ss << "\\note The field specifies if the discounting of future costs should be computed as occurring at the end\n";
    ss << "\\note of each year or the middle of each year or the beginning of each year. The most common discounting\n";
    ss << "\\note convention uses the end of each year.\n";
    ss << "A3,  \\field Inflation Approach\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantDollar\n";
    ss << "\\key CurrentDollar\n";
    ss << "\\default ConstantDollar\n";
    ss << "\\note This field is used to determine if the analysis should use constant dollars or current dollars\n";
    ss << "\\note which is related to how inflation is treated. If ConstantDollar is selected then the Real Discount\n";
    ss << "\\note Rate input is used and it excludes the rate of inflation. If CurrentDollar is selected then the\n";
    ss << "\\note Nominal Discount Rate input is used and it includes the rate of inflation.\n";
    ss << "N1,  \\field Real Discount Rate\n";
    ss << "\\type real\n";
    ss << "\\note Enter the real discount rate as a decimal. For a 3% rate enter the value 0.03. This input is\n";
    ss << "\\note used when the Inflation Approach is ConstantDollar. The real discount rate reflects the interest\n";
    ss << "\\note rates needed to make current and future expenditures have comparable equivalent values when\n";
    ss << "\\note general inflation is ignored. When Inflation Approach is set to CurrentDollar this input is ignored.\n";
    ss << "N2,  \\field Nominal Discount Rate\n";
    ss << "\\type real\n";
    ss << "\\note Enter the nominal discount rate as a decimal. For a 5% rate enter the value 0.05. This input\n";
    ss << "\\note is used when the Inflation Approach is CurrentDollar. The real discount rate reflects the interest\n";
    ss << "\\note rates needed to make current and future expenditures have comparable equivalent values when general\n";
    ss << "\\note inflation is included. When Inflation Approach is set to ConstantDollar this input is ignored.\n";
    ss << "N3,  \\field Inflation\n";
    ss << "\\type real\n";
    ss << "\\note Enter the rate of inflation for general goods and services as a decimal. For a 2% rate enter\n";
    ss << "\\note the value 0.02.\n";
    ss << "A4,  \\field Base Date Month\n";
    ss << "\\type choice\n";
    ss << "\\key January\n";
    ss << "\\key February\n";
    ss << "\\key March\n";
    ss << "\\key April\n";
    ss << "\\key May\n";
    ss << "\\key June\n";
    ss << "\\key July\n";
    ss << "\\key August\n";
    ss << "\\key September\n";
    ss << "\\key October\n";
    ss << "\\key November\n";
    ss << "\\key December\n";
    ss << "\\default January\n";
    ss << "\\note Enter the month that is the beginning of study period also known as the beginning of the base period.\n";
    ss << "N4,  \\field Base Date Year\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1900\n";
    ss << "\\maximum 2100\n";
    ss << "\\note Enter the four digit year that is the beginning of study period such as 2010. The study period is\n";
    ss << "\\note also known as the base period.\n";
    ss << "A5,  \\field Service Date Month\n";
    ss << "\\type choice\n";
    ss << "\\key January\n";
    ss << "\\key February\n";
    ss << "\\key March\n";
    ss << "\\key April\n";
    ss << "\\key May\n";
    ss << "\\key June\n";
    ss << "\\key July\n";
    ss << "\\key August\n";
    ss << "\\key September\n";
    ss << "\\key October\n";
    ss << "\\key November\n";
    ss << "\\key December\n";
    ss << "\\default January\n";
    ss << "\\note Enter the month that is the beginning of building occupancy. Energy costs computed by EnergyPlus\n";
    ss << "\\note are assumed to occur during the year following the service date. The service date must be the\n";
    ss << "\\note same or later than the Base Date. This field could also be referred to as part of beneficial\n";
    ss << "\\note occupancy date.\n";
    ss << "N5,  \\field Service Date Year\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1900\n";
    ss << "\\maximum 2100\n";
    ss << "\\note Enter the four digit year that is the beginning of occupancy such as 2010.\n";
    ss << "N6,  \\field Length of Study Period in Years\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 100\n";
    ss << "\\note Enter the number of years of the study period. It is the number of years that the study continues\n";
    ss << "\\note based on the start at the base date. The default value is 25 years. Only integers may be used\n";
    ss << "\\note indicating whole years.\n";
    ss << "N7,  \\field Tax rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the overall marginal tax rate for the project costs. This does not include energy or water\n";
    ss << "\\note taxes. The tax rate entered should be based on the marginal tax rate for the entity and not the\n";
    ss << "\\note average tax rate. Enter the tax rate results in present value calculations after taxes. Most\n";
    ss << "\\note analyses do not factor in the impact of taxes and assume that all options under consideration\n";
    ss << "\\note have roughly the same tax impact. Due to this many times the tax rate can be left to default\n";
    ss << "\\note to zero and the present value results before taxes are used to make decisions. The value\n";
    ss << "\\note should be entered as a decimal value. For 15% enter 0.15. For an analysis that does not include\n";
    ss << "\\note tax impacts enter 0.0.\n";
    ss << "A6;  \\field Depreciation Method\n";
    ss << "\\type choice\n";
    ss << "\\key ModifiedAcceleratedCostRecoverySystem-3year\n";
    ss << "\\key ModifiedAcceleratedCostRecoverySystem-5year\n";
    ss << "\\key ModifiedAcceleratedCostRecoverySystem-7year\n";
    ss << "\\key ModifiedAcceleratedCostRecoverySystem-10year\n";
    ss << "\\key ModifiedAcceleratedCostRecoverySystem-15year\n";
    ss << "\\key ModifiedAcceleratedCostRecoverySystem-20year\n";
    ss << "\\key StraightLine-27year\n";
    ss << "\\key StraightLine-31year\n";
    ss << "\\key StraightLine-39year\n";
    ss << "\\key StraightLine-40year\n";
    ss << "\\key None\n";
    ss << "\\default None\n";
    ss << "\\note For an analysis that includes income tax impacts this entry describes how capital costs are\n";
    ss << "\\note depreciated. Only one depreciation method may be used for an analysis and is applied to all\n";
    ss << "\\note capital expenditures.\n";

    IddObjectType objType(IddObjectType::LifeCycleCost_Parameters);
    OptionalIddObject oObj = IddObject::load("LifeCycleCost:Parameters",
                                             "Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::LifeCycleCost_Parameters);
  return object;
}

IddObject createLifeCycleCost_RecurringCostsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "LifeCycleCost:RecurringCosts,\n";
    ss << "\\memo Recurring costs are costs that repeat over time on a regular schedule during the\n";
    ss << "\\memo study period. If costs associated with equipment do repeat but not on a regular\n";
    ss << "\\memo schedule, use LifeCycleCost:NonrecurringCost objects instead.\n";
    ss << "\\min-fields 7\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2,  \\field Category\n";
    ss << "\\type choice\n";
    ss << "\\key Maintenance\n";
    ss << "\\key Repair\n";
    ss << "\\key Operation\n";
    ss << "\\key Replacement\n";
    ss << "\\key MinorOverhaul\n";
    ss << "\\key MajorOverhaul\n";
    ss << "\\key OtherOperational\n";
    ss << "\\default Maintenance\n";
    ss << "N1,  \\field Cost\n";
    ss << "\\type real\n";
    ss << "\\note Enter the cost in dollars (or the appropriate monetary unit) for the recurring costs. Enter\n";
    ss << "\\note the cost for each time it occurs. For example if the annual maintenance cost is 500 dollars\n";
    ss << "\\note enter 500 here.\n";
    ss << "A3,  \\field Start of Costs\n";
    ss << "\\type choice\n";
    ss << "\\key ServicePeriod\n";
    ss << "\\key BasePeriod\n";
    ss << "\\default ServicePeriod\n";
    ss << "\\note Enter when the costs start. The First Year of Cost is based on the number of years past the\n";
    ss << "\\note Start of Costs. For most maintenance costs the Start of Costs should be Service Period.\n";
    ss << "N2,  \\field Years from Start\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 100\n";
    ss << "\\note This field and the Months From Start field together represent the time from either the start\n";
    ss << "\\note of the Service Period on the service month and year or start of the Base Period on the base\n";
    ss << "\\note month and year (depending on the Start of Costs field) that the costs start to occur. Only\n";
    ss << "\\note integers should be entered representing whole years.\n";
    ss << "N3,  \\field Months from Start\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1200\n";
    ss << "\\note This field and the Years From Start field together represent the time from either the start\n";
    ss << "\\note of the Service Period on the service month and year or start of the Base Period on the base\n";
    ss << "\\note month and year (depending on the Start of Costs field) that the costs start to occur. Only\n";
    ss << "\\note integers should be entered representing whole months. The Years From Start (times 12) and\n";
    ss << "\\note Months From Start are added together.\n";
    ss << "N4,  \\field Repeat Period Years\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 100\n";
    ss << "\\default 1\n";
    ss << "\\note This field and the Repeat Period Months field indicate how much time elapses between\n";
    ss << "\\note re-occurrences of the cost. For costs that occur every year such the Repeat Period Years\n";
    ss << "\\note should be 1 and Repeat Period Months should be 0. Only integers should be entered\n";
    ss << "\\note representing whole years.\n";
    ss << "N5,  \\field Repeat Period Months\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1200\n";
    ss << "\\default 0\n";
    ss << "\\note This field and the Repeat Period Years field indicate how much time elapses between\n";
    ss << "\\note re-occurrences of the cost. Only integers should be entered representing whole years.\n";
    ss << "\\note The Repeat Period Years (times 12) and Repeat Period Months are added together.\n";
    ss << "N6;  \\field Annual escalation rate\n";
    ss << "\\type real\n";
    ss << "\\minimum -0.3\n";
    ss << "\\maximum 0.3\n";
    ss << "\\note Enter the annual escalation rate as a decimal. For a 1% rate enter the value 0.01.\n";
    ss << "\\note This input is used when the Inflation Approach is CurrentDollar. When Inflation\n";
    ss << "\\note Approach is set to ConstantDollar this input is ignored.\n";

    IddObjectType objType(IddObjectType::LifeCycleCost_RecurringCosts);
    OptionalIddObject oObj = IddObject::load("LifeCycleCost:RecurringCosts",
                                             "Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::LifeCycleCost_RecurringCosts);
  return object;
}

IddObject createLifeCycleCost_NonrecurringCostIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "LifeCycleCost:NonrecurringCost,\n";
    ss << "\\memo A non-recurring cost happens only once during the study period. For costs that occur\n";
    ss << "\\memo more than once during the study period on a regular schedule, use the\n";
    ss << "\\memo LifeCycleCost:RecurringCost object.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2,  \\field Category\n";
    ss << "\\type choice\n";
    ss << "\\key Construction\n";
    ss << "\\key Salvage\n";
    ss << "\\key OtherCapital\n";
    ss << "\\default Construction\n";
    ss << "N1,  \\field Cost\n";
    ss << "\\type real\n";
    ss << "\\note Enter the non-recurring cost value. For construction and other capital costs the value\n";
    ss << "\\note entered is typically a positive value. For salvage costs the value entered is typically a\n";
    ss << "\\note negative value which represents the money paid to the investor for the equipment at the\n";
    ss << "\\note end of the study period.\n";
    ss << "A3,  \\field Start of Costs\n";
    ss << "\\type choice\n";
    ss << "\\key ServicePeriod\n";
    ss << "\\key BasePeriod\n";
    ss << "\\default ServicePeriod\n";
    ss << "\\note Enter when the costs start. The First Year of Cost is based on the number of years past the\n";
    ss << "\\note Start of Costs. For most non-recurring costs the Start of Costs should be Base Period which\n";
    ss << "\\note begins at the base month and year.\n";
    ss << "N2,  \\field Years from Start\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 100\n";
    ss << "\\note This field and the Months From Start field together represent the time from either the start\n";
    ss << "\\note of the Service Period on the service month and year or start of the Base Period on the base\n";
    ss << "\\note month and year (depending on the Start of Cost field) that the costs start to occur. Only\n";
    ss << "\\note integers should be entered representing whole years.\n";
    ss << "N3;  \\field Months from Start\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1200\n";
    ss << "\\note This field and the Years From Start field together represent the time from either the start\n";
    ss << "\\note of the Service Period on the service month and year or start of the Base Period on the base\n";
    ss << "\\note month and year (depending on the Start of Cost field) that the costs start to occur. Only\n";
    ss << "\\note integers should be entered representing whole months. The Years From Start (times 12) and\n";
    ss << "\\note Months From Start are added together.\n";

    IddObjectType objType(IddObjectType::LifeCycleCost_NonrecurringCost);
    OptionalIddObject oObj = IddObject::load("LifeCycleCost:NonrecurringCost",
                                             "Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::LifeCycleCost_NonrecurringCost);
  return object;
}

IddObject createLifeCycleCost_UsePriceEscalationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "LifeCycleCost:UsePriceEscalation,\n";
    ss << "\\memo Life cycle cost escalation factors. The values for this object may be found in the\n";
    ss << "\\memo annual supplement to NIST Handbook 135 in Tables Ca-1 to Ca-5 and are included in an\n";
    ss << "\\memo EnergyPlus dataset file.\n";
    ss << "\\extensible:1\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note The identifier used for the object. The name usually identifies the location (such as the\n";
    ss << "\\note state or region or country or census area) that the escalations apply to. In addition the\n";
    ss << "\\note name should identify the building class such as residential or commercial or industrial\n";
    ss << "\\note and the use type such as electricity or natural gas or water.\n";
    ss << "A2,  \\field Resource\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key ElectricityPurchased\n";
    ss << "\\key ElectricityProduced\n";
    ss << "\\key ElectricitySurplusSold\n";
    ss << "\\key ElectricityNet\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key Steam\n";
    ss << "\\key Gasoline\n";
    ss << "\\key Diesel\n";
    ss << "\\key Coal\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Propane\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\key Water\n";
    ss << "N1,  \\field Escalation Start Year\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1900\n";
    ss << "\\maximum 2100\n";
    ss << "\\note This field and the Escalation Start Month define the time that corresponds to Year 1 Escalation\n";
    ss << "\\note such as 2010 when the escalation rates are applied. This field and the Escalation Start Month\n";
    ss << "\\note define the time that escalation begins.\n";
    ss << "A3,  \\field Escalation Start Month\n";
    ss << "\\type choice\n";
    ss << "\\key January\n";
    ss << "\\key February\n";
    ss << "\\key March\n";
    ss << "\\key April\n";
    ss << "\\key May\n";
    ss << "\\key June\n";
    ss << "\\key July\n";
    ss << "\\key August\n";
    ss << "\\key September\n";
    ss << "\\key October\n";
    ss << "\\key November\n";
    ss << "\\key December\n";
    ss << "\\default January\n";
    ss << "\\note This field and the Escalation Start Year define the time that corresponds to Year 1 Escalation\n";
    ss << "\\note such as 2010 when the escalation rates are applied. This field and the Escalation Start Year\n";
    ss << "\\note define the time that escalation begins.\n";
    ss << "N2;  \\field Year 1 Escalation\n";
    ss << "\\type real\n";
    ss << "\\begin-extensible\n";
    ss << "\\note The escalation in price of the energy or water use for the first year expressed as a decimal.\n";

    IddObjectType objType(IddObjectType::LifeCycleCost_UsePriceEscalation);
    OptionalIddObject oObj = IddObject::load("LifeCycleCost:UsePriceEscalation",
                                             "Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::LifeCycleCost_UsePriceEscalation);
  return object;
}

IddObject createLifeCycleCost_UseAdjustmentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "LifeCycleCost:UseAdjustment,\n";
    ss << "\\memo Used by advanced users to adjust the energy or water use costs for future years. This\n";
    ss << "\\memo should not be used for compensating for inflation but should only be used to increase\n";
    ss << "\\memo the costs of energy or water based on assumed changes to the actual usage, such as\n";
    ss << "\\memo anticipated changes in the future function of the building. The adjustments begin at\n";
    ss << "\\memo the start of the service period.\n";
    ss << "\\extensible:1\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2,  \\field Resource\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key ElectricityPurchased\n";
    ss << "\\key ElectricityProduced\n";
    ss << "\\key ElectricitySurplusSold\n";
    ss << "\\key ElectricityNet\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key Steam\n";
    ss << "\\key Gasoline\n";
    ss << "\\key Diesel\n";
    ss << "\\key Coal\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Propane\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\key Water\n";
    ss << "N1;  \\field Year 1 Multiplier\n";
    ss << "\\type real\n";
    ss << "\\begin-extensible\n";
    ss << "\\note The multiplier to be applied to the end-use cost for the first year in the service period.\n";
    ss << "\\note The total utility costs for the selected end-use is multiplied by this value. For no change\n";
    ss << "\\note enter 1.0.\n";

    IddObjectType objType(IddObjectType::LifeCycleCost_UseAdjustment);
    OptionalIddObject oObj = IddObject::load("LifeCycleCost:UseAdjustment",
                                             "Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::LifeCycleCost_UseAdjustment);
  return object;
}

IddObject createParametric_SetValueForRunIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Parametric:SetValueForRun,\n";
    ss << "\\memo Parametric objects allow a set of multiple simulations to be defined in a single idf\n";
    ss << "\\memo file. The parametric preprocessor scans the idf for Parametric:* objects then creates\n";
    ss << "\\memo and runs multiple idf files, one for each defined simulation.\n";
    ss << "\\memo The core parametric object is Parametric:SetValueForRun which defines the name\n";
    ss << "\\memo of a parameters and sets the parameter to different values depending on which\n";
    ss << "\\memo run is being simulated.\n";
    ss << "\\min-fields 2\n";
    ss << "\\extensible:1\n";
    ss << "A1,  \\field Name\n";
    ss << "\\note Parameter Name\n";
    ss << "\\note Must begin with the dollar sign character. The second character must be a letter.\n";
    ss << "\\note Remaining characters may only be letters or numbers. No spaces allowed.\n";
    ss << "\\required-field\n";
    ss << "\\type  alpha\n";
    ss << "A2;  \\field Value for Run 1\n";
    ss << "\\begin-extensible\n";
    ss << "\\type  alpha\n";

    IddObjectType objType(IddObjectType::Parametric_SetValueForRun);
    OptionalIddObject oObj = IddObject::load("Parametric:SetValueForRun",
                                             "Parametrics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Parametric_SetValueForRun);
  return object;
}

IddObject createParametric_LogicIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Parametric:Logic,\n";
    ss << "\\memo This object allows some types of objects to be included for some parametric cases and\n";
    ss << "\\memo not for others. For example, you might want an overhang on a window in some\n";
    ss << "\\memo parametric runs and not others. A single Parametric:Logic object is allowed per file.\n";
    ss << "\\memo Consult the Input Output Reference for available commands and syntax.\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 2\n";
    ss << "\\extensible:1\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type  alpha\n";
    ss << "A2;  \\field Parametric Logic Line 1\n";
    ss << "\\begin-extensible\n";
    ss << "\\type  alpha\n";

    IddObjectType objType(IddObjectType::Parametric_Logic);
    OptionalIddObject oObj = IddObject::load("Parametric:Logic",
                                             "Parametrics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Parametric_Logic);
  return object;
}

IddObject createParametric_RunControlIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Parametric:RunControl,\n";
    ss << "\\memo Controls which parametric runs are simulated. This object is optional. If it is not\n";
    ss << "\\memo included, then all parametric runs are performed.\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 2\n";
    ss << "\\extensible:1\n";
    ss << "A1,  \\field Name\n";
    ss << "\\type  alpha\n";
    ss << "A2;  \\field Perform Run 1\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default Yes\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::Parametric_RunControl);
    OptionalIddObject oObj = IddObject::load("Parametric:RunControl",
                                             "Parametrics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Parametric_RunControl);
  return object;
}

IddObject createParametric_FileNameSuffixIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Parametric:FileNameSuffix,\n";
    ss << "\\memo Defines the suffixes to be appended to the idf and output file names for each\n";
    ss << "\\memo parametric run. If this object is omitted, the suffix will default to the run number.\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 2\n";
    ss << "\\extensible:1\n";
    ss << "A1,  \\field Name\n";
    ss << "\\type  alpha\n";
    ss << "A2;  \\field Suffix for File Name in Run 1\n";
    ss << "\\type  alpha\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::Parametric_FileNameSuffix);
    OptionalIddObject oObj = IddObject::load("Parametric:FileNameSuffix",
                                             "Parametrics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Parametric_FileNameSuffix);
  return object;
}

IddObject createOutput_VariableDictionaryIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:VariableDictionary,\n";
    ss << "\\memo Produces a list summarizing the output variables and meters that are available for\n";
    ss << "\\memo reporting for the model being simulated (rdd output file). The list varies depending\n";
    ss << "\\memo on the types of objects present in the idf file.  For example, variables related to\n";
    ss << "\\memo lights will only appear if a Lights object is present. The IDF option generates\n";
    ss << "\\memo complete Output:Variable objects to simplify adding the desired output to the idf file.\n";
    ss << "\\format singleLine\n";
    ss << "A1, \\field Key Field\n";
    ss << "\\type choice\n";
    ss << "\\key IDF\n";
    ss << "\\key regular\n";
    ss << "\\default regular\n";
    ss << "A2;  \\field Sort Option\n";
    ss << "\\type choice\n";
    ss << "\\key Name\n";
    ss << "\\key Unsorted\n";

    IddObjectType objType(IddObjectType::Output_VariableDictionary);
    OptionalIddObject oObj = IddObject::load("Output:VariableDictionary",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_VariableDictionary);
  return object;
}

IddObject createOutput_Surfaces_ListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:Surfaces:List,\n";
    ss << "\\memo Produces a report summarizing the details of surfaces in the eio output file.\n";
    ss << "\\format singleLine\n";
    ss << "A1, \\field Report Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Details\n";
    ss << "\\key Vertices\n";
    ss << "\\key DetailsWithVertices\n";
    ss << "\\key ViewFactorInfo\n";
    ss << "\\key Lines\n";
    ss << "\\key CostInfo\n";
    ss << "\\key DecayCurvesfromZoneComponentLoads\n";
    ss << "A2; \\field Report Specifications\n";
    ss << "\\note (IDF, only for Surfaces, Lines report -- will print transformed coordinates in IDF style)\n";
    ss << "\\type choice\n";
    ss << "\\key IDF\n";

    IddObjectType objType(IddObjectType::Output_Surfaces_List);
    OptionalIddObject oObj = IddObject::load("Output:Surfaces:List",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_Surfaces_List);
  return object;
}

IddObject createOutput_Surfaces_DrawingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:Surfaces:Drawing,\n";
    ss << "\\format singleLine\n";
    ss << "A1,  \\field Report Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key DXF\n";
    ss << "\\key DXF:WireFrame\n";
    ss << "\\key VRML\n";
    ss << "A2,  \\field Report Specifications 1\n";
    ss << "\\type choice\n";
    ss << "\\key Triangulate3DFace\n";
    ss << "\\key ThickPolyline\n";
    ss << "\\key RegularPolyline\n";
    ss << "\\default Triangulate3DFace\n";
    ss << "\\note Triangulate3DFace (default), ThickPolyline, RegularPolyline apply to DXF\n";
    ss << "\\note This field is ignored for DXF:WireFrame and VRML\n";
    ss << "A3 ; \\field Report Specifications 2\n";
    ss << "\\note Use ColorScheme Name for DXF reports\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ColorSchemes\n";

    IddObjectType objType(IddObjectType::Output_Surfaces_Drawing);
    OptionalIddObject oObj = IddObject::load("Output:Surfaces:Drawing",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_Surfaces_Drawing);
  return object;
}

IddObject createOutput_SchedulesIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:Schedules,\n";
    ss << "\\memo Produces a condensed reporting that illustrates the full range of schedule values in\n";
    ss << "\\memo the eio output file. In the style of input: DaySchedule,  WeekSchedule, and\n";
    ss << "\\memo Annual Schedule.\n";
    ss << "\\format singleLine\n";
    ss << "A1;  \\field Key Field\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Hourly\n";
    ss << "\\key Timestep\n";

    IddObjectType objType(IddObjectType::Output_Schedules);
    OptionalIddObject oObj = IddObject::load("Output:Schedules",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_Schedules);
  return object;
}

IddObject createOutput_ConstructionsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:Constructions,\n";
    ss << "\\memo Adds a report to the eio output file which shows details for each construction,\n";
    ss << "\\memo including overall properties, a list of material layers, and calculated results\n";
    ss << "\\memo related to conduction transfer functions.\n";
    ss << "\\format singleLine\n";
    ss << "A1,  \\field Details Type 1\n";
    ss << "\\type choice\n";
    ss << "\\key Constructions\n";
    ss << "\\key Materials\n";
    ss << "A2;  \\field Details Type 2\n";
    ss << "\\type choice\n";
    ss << "\\key Constructions\n";
    ss << "\\key Materials\n";

    IddObjectType objType(IddObjectType::Output_Constructions);
    OptionalIddObject oObj = IddObject::load("Output:Constructions",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_Constructions);
  return object;
}

IddObject createOutput_EnergyManagementSystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:EnergyManagementSystem,\n";
    ss << "\\memo This object is used to control the output produced by the Energy Management System\n";
    ss << "\\unique-object\n";
    ss << "A1, \\field Actuator Availability Dictionary Reporting\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key NotByUniqueKeyNames\n";
    ss << "\\key Verbose\n";
    ss << "\\default None\n";
    ss << "A2, \\field Internal Variable Availability Dictionary Reporting\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key NotByUniqueKeyNames\n";
    ss << "\\key Verbose\n";
    ss << "\\default None\n";
    ss << "A3; \\field EMS Runtime Language Debug Output Level\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key ErrorsOnly\n";
    ss << "\\key Verbose\n";
    ss << "\\default None\n";

    IddObjectType objType(IddObjectType::Output_EnergyManagementSystem);
    OptionalIddObject oObj = IddObject::load("Output:EnergyManagementSystem",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_EnergyManagementSystem);
  return object;
}

IddObject createOutputControl_SurfaceColorSchemeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OutputControl:SurfaceColorScheme,\n";
    ss << "\\memo This object is used to set colors for reporting on various building elements particularly for the\n";
    ss << "\\memo DXF reports.  We know the user can enter 0 to 255 and the color map is available in DXF output.\n";
    ss << "\\memo Therefore, we are limiting the colors in that range.  You can\n";
    ss << "\\memo extend by editing the IDD but you do so on your own.  Colors not changed in any scheme will\n";
    ss << "\\memo remain as the default scheme uses.\n";
    ss << "\\extensible:2\n";
    ss << "\\max-fields 31\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\note choose a name or use one of the DataSets\n";
    ss << "\\reference ColorSchemes\n";
    ss << "A2,  \\field Drawing Element 1 Type\n";
    ss << "\\type choice\n";
    ss << "\\key Text\n";
    ss << "\\key Walls\n";
    ss << "\\key Windows\n";
    ss << "\\key GlassDoors\n";
    ss << "\\key Doors\n";
    ss << "\\key Roofs\n";
    ss << "\\key Floors\n";
    ss << "\\key DetachedBuildingShades\n";
    ss << "\\key DetachedFixedShades\n";
    ss << "\\key AttachedBuildingShades\n";
    ss << "\\key Photovoltaics\n";
    ss << "\\key TubularDaylightDomes\n";
    ss << "\\key TubularDaylightDiffusers\n";
    ss << "\\key DaylightReferencePoint1\n";
    ss << "\\key DaylightReferencePoint2\n";
    ss << "\\begin-extensible\n";
    ss << "N1;  \\field Color for Drawing Element 1\n";
    ss << "\\note use color number for output assignment (e.g. DXF)\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 255\n";

    IddObjectType objType(IddObjectType::OutputControl_SurfaceColorScheme);
    OptionalIddObject oObj = IddObject::load("OutputControl:SurfaceColorScheme",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OutputControl_SurfaceColorScheme);
  return object;
}

IddObject createOutput_Table_SummaryReportsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:Table:SummaryReports,\n";
    ss << "\\extensible:1\n";
    ss << "\\memo This object allows the user to call report types that are predefined and will appear with the\n";
    ss << "\\memo other tabular reports.  These predefined reports are sensitive to the OutputControl:Table:Style object\n";
    ss << "\\memo and appear in the same files as the tabular reports.  The entries for this object is a list\n";
    ss << "\\memo of the predefined reports that should appear in the tabular report output file.\n";
    ss << "\\memo There should be as many fields (A) in this object as there are keys in the following (minus\n";
    ss << "\\memo AllSummary+AllMonthly+AllSummaryAndMonthly)\n";
    ss << "\\unique-object\n";
    ss << "A1; \\field Report 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\type choice\n";
    ss << "\\key AllSummary\n";
    ss << "\\key AllSummaryAndSizingPeriod\n";
    ss << "\\key AllMonthly\n";
    ss << "\\key AllSummaryAndMonthly\n";
    ss << "\\key AllSummaryMonthlyAndSizingPeriod\n";
    ss << "\\key AnnualBuildingUtilityPerformanceSummary\n";
    ss << "\\key InputVerificationandResultsSummary\n";
    ss << "\\key DemandEndUseComponentsSummary\n";
    ss << "\\key SourceEnergyEndUseComponentsSummary\n";
    ss << "\\key ClimaticDataSummary\n";
    ss << "\\key EquipmentSummary\n";
    ss << "\\key EnvelopeSummary\n";
    ss << "\\key SurfaceShadowingSummary\n";
    ss << "\\key ShadingSummary\n";
    ss << "\\key LightingSummary\n";
    ss << "\\key HVACSizingSummary\n";
    ss << "\\key SystemSummary\n";
    ss << "\\key ComponentSizingSummary\n";
    ss << "\\key OutdoorAirSummary\n";
    ss << "\\key ObjectCountSummary\n";
    ss << "\\key ComponentCostEconomicsSummary\n";
    ss << "\\key AdaptiveComfortSummary\n";
    ss << "\\key SensibleHeatGainSummary\n";
    ss << "\\key ZoneComponentLoadSummary\n";
    ss << "\\key Standard62.1Summary\n";
    ss << "\\key EnergyMeters\n";
    ss << "\\key LEEDSummary\n";
    ss << "\\key ZoneCoolingSummaryMonthly\n";
    ss << "\\key ZoneHeatingSummaryMonthly\n";
    ss << "\\key ZoneElectricSummaryMonthly\n";
    ss << "\\key SpaceGainsMonthly\n";
    ss << "\\key PeakSpaceGainsMonthly\n";
    ss << "\\key SpaceGainComponentsAtCoolingPeakMonthly\n";
    ss << "\\key EnergyConsumptionElectricityNaturalGasMonthly\n";
    ss << "\\key EnergyConsumptionElectricityGeneratedPropaneMonthly\n";
    ss << "\\key EnergyConsumptionDieselFuelOilMonthly\n";
    ss << "\\key EnergyConsumptionDistrictHeatingCoolingMonthly\n";
    ss << "\\key EnergyConsumptionCoalGasolineMonthly\n";
    ss << "\\key EnergyConsumptionOtherFuelsMonthly\n";
    ss << "\\key EndUseEnergyConsumptionElectricityMonthly\n";
    ss << "\\key EndUseEnergyConsumptionNaturalGasMonthly\n";
    ss << "\\key EndUseEnergyConsumptionDieselMonthly\n";
    ss << "\\key EndUseEnergyConsumptionFuelOilMonthly\n";
    ss << "\\key EndUseEnergyConsumptionCoalMonthly\n";
    ss << "\\key EndUseEnergyConsumptionPropaneMonthly\n";
    ss << "\\key EndUseEnergyConsumptionGasolineMonthly\n";
    ss << "\\key EndUseEnergyConsumptionOtherFuelsMonthly\n";
    ss << "\\key PeakEnergyEndUseElectricityPart1Monthly\n";
    ss << "\\key PeakEnergyEndUseElectricityPart2Monthly\n";
    ss << "\\key ElectricComponentsOfPeakDemandMonthly\n";
    ss << "\\key PeakEnergyEndUseNaturalGasMonthly\n";
    ss << "\\key PeakEnergyEndUseDieselMonthly\n";
    ss << "\\key PeakEnergyEndUseFuelOilMonthly\n";
    ss << "\\key PeakEnergyEndUseCoalMonthly\n";
    ss << "\\key PeakEnergyEndUsePropaneMonthly\n";
    ss << "\\key PeakEnergyEndUseGasolineMonthly\n";
    ss << "\\key PeakEnergyEndUseOtherFuelsMonthly\n";
    ss << "\\key SetpointsNotMetWithTemperaturesMonthly\n";
    ss << "\\key ComfortReportSimple55Monthly\n";
    ss << "\\key UnglazedTranspiredSolarCollectorSummaryMonthly\n";
    ss << "\\key OccupantComfortDataSummaryMonthly\n";
    ss << "\\key ChillerReportMonthly\n";
    ss << "\\key TowerReportMonthly\n";
    ss << "\\key BoilerReportMonthly\n";
    ss << "\\key DXReportMonthly\n";
    ss << "\\key WindowReportMonthly\n";
    ss << "\\key WindowEnergyReportMonthly\n";
    ss << "\\key WindowZoneSummaryMonthly\n";
    ss << "\\key WindowEnergyZoneSummaryMonthly\n";
    ss << "\\key AverageOutdoorConditionsMonthly\n";
    ss << "\\key OutdoorConditionsMaximumDryBulbMonthly\n";
    ss << "\\key OutdoorConditionsMinimumDryBulbMonthly\n";
    ss << "\\key OutdoorConditionsMaximumWetBulbMonthly\n";
    ss << "\\key OutdoorConditionsMaximumDewPointMonthly\n";
    ss << "\\key OutdoorGroundConditionsMonthly\n";
    ss << "\\key WindowACReportMonthly\n";
    ss << "\\key WaterHeaterReportMonthly\n";
    ss << "\\key GeneratorReportMonthly\n";
    ss << "\\key DaylightingReportMonthly\n";
    ss << "\\key CoilReportMonthly\n";
    ss << "\\key PlantLoopDemandReportMonthly\n";
    ss << "\\key FanReportMonthly\n";
    ss << "\\key PumpReportMonthly\n";
    ss << "\\key CondLoopDemandReportMonthly\n";
    ss << "\\key ZoneTemperatureOscillationReportMonthly\n";
    ss << "\\key AirLoopSystemEnergyAndWaterUseMonthly\n";
    ss << "\\key AirLoopSystemComponentLoadsMonthly\n";
    ss << "\\key AirLoopSystemComponentEnergyUseMonthly\n";
    ss << "\\key MechanicalVentilationLoadsMonthly\n";

    IddObjectType objType(IddObjectType::Output_Table_SummaryReports);
    OptionalIddObject oObj = IddObject::load("Output:Table:SummaryReports",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_Table_SummaryReports);
  return object;
}

IddObject createOutput_Table_TimeBinsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:Table:TimeBins,\n";
    ss << "\\memo Produces a bin report in the table output file which shows the amount of time in hours\n";
    ss << "\\memo that occurs in different bins for a single specific output variable or meter.\n";
    ss << "\\memo Two different types of binning are reported: by month and by hour of the day.\n";
    ss << "\\min-fields 5\n";
    ss << "A1, \\field Key Value\n";
    ss << "\\default *\n";
    ss << "\\note use '*' (without quotes) to apply this variable to all keys\n";
    ss << "A2, \\field Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\type external-list\n";
    ss << "\\external-list autoRDDvariableMeter\n";
    ss << "N1, \\field Interval Start\n";
    ss << "\\type real\n";
    ss << "\\note The lowest value for the intervals being binned into.\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "N2, \\field Interval Size\n";
    ss << "\\type real\n";
    ss << "\\note The size of the bins starting with Interval start.\n";
    ss << "\\unitsBasedOnField A4\n";
    ss << "N3, \\field Interval Count\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 20\n";
    ss << "\\note The number of bins used. The number of hours below the start of the\n";
    ss << "\\note Lowest bin and above the value of the last bin are also shown.\n";
    ss << "A3, \\field Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Optional schedule name. Binning is performed for non-zero hours.\n";
    ss << "\\note Binning always performed if left blank.\n";
    ss << "A4; \\field Variable Type\n";
    ss << "\\type choice\n";
    ss << "\\key Energy\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key Power\n";
    ss << "\\note Optional input on the type of units for the variable used by other fields in the object.\n";

    IddObjectType objType(IddObjectType::Output_Table_TimeBins);
    OptionalIddObject oObj = IddObject::load("Output:Table:TimeBins",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_Table_TimeBins);
  return object;
}

IddObject createOutput_Table_MonthlyIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:Table:Monthly,\n";
    ss << "\\memo Provides a generic method of setting up tables of monthly results. The report\n";
    ss << "\\memo has multiple columns that are each defined using a repeated group of fields for any\n";
    ss << "\\memo number of columns. A single Output:Table:Monthly object often produces multiple\n";
    ss << "\\memo tables in the output. A table is produced for every instance of a particular output\n";
    ss << "\\memo variable. For example, a table defined with zone variables will be produced once for\n";
    ss << "\\memo every zone.\n";
    ss << "\\extensible:2\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "N1, \\field Digits After Decimal\n";
    ss << "\\type integer\n";
    ss << "\\default 2\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 10\n";
    ss << "! The next two fields are repeated for each column\n";
    ss << "A2, \\field Variable or Meter 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\type external-list\n";
    ss << "\\external-list autoRDDvariableMeter\n";
    ss << "\\note The name of an output variable or  meter that is available in the RDD file.\n";
    ss << "A3; \\field Aggregation Type for Variable or Meter 1\n";
    ss << "\\type choice\n";
    ss << "\\key SumOrAverage\n";
    ss << "\\key Maximum\n";
    ss << "\\key Minimum\n";
    ss << "\\key ValueWhenMaximumOrMinimum\n";
    ss << "\\key HoursNonZero\n";
    ss << "\\key HoursZero\n";
    ss << "\\key HoursPositive\n";
    ss << "\\key HoursNonPositive\n";
    ss << "\\key HoursNegative\n";
    ss << "\\key HoursNonNegative\n";
    ss << "\\key SumOrAverageDuringHoursShown\n";
    ss << "\\key MaximumDuringHoursShown\n";
    ss << "\\key MinimumDuringHoursShown\n";
    ss << "\\note The method of aggregation for the selected variable or meter.\n";
    ss << "\\note SumOrAverage adds up the values for every timestep in the month if the variable\n";
    ss << "\\note   is a sum variable. If the variable is an average variable it reports the average value.\n";
    ss << "\\note   This is probably the most common Aggregation Type option to choose.\n";
    ss << "\\note Maximum and Minimum find the maximum and minimum value for the month and report it\n";
    ss << "\\note   along with the time that it first occurred.  When Maximum or Minimum are selected a\n";
    ss << "\\note   column is automatically shown in the output report for the time that it occurred.\n";
    ss << "\\note   When Maximum or Minimum are used with an average variable the value is divided\n";
    ss << "\\note   by the length of the timestep.\n";
    ss << "\\note ValueWhenMaxMin looks at the previous variable in the report that sets a maximum or minimum\n";
    ss << "\\note   and displays the value of the current variable at that same timestep.\n";
    ss << "\\note   Order of the variables in the report is important when using ValueWhenMaxMin.\n";
    ss << "\\note   This can be used when an outdoor temperature should be reported for the time of the\n";
    ss << "\\note   maximum cooling load.\n";
    ss << "\\note HoursNonZero adds up the elapsed time during the month that this variable is non-zero\n";
    ss << "\\note   and would be appropriate to determine the number of hour that a fan operates.\n";
    ss << "\\note HoursZero - The HoursZero option adds up the elapsed time during the month that this\n";
    ss << "\\note   variable has a zero value and would be appropriate to determine the number of hour\n";
    ss << "\\note   that a fan does not operate.\n";
    ss << "\\note HoursPositive - The HoursPositive option adds up the elapsed time during the month that\n";
    ss << "\\note   this variable has a positive value.  Hours with a zero value are not included.\n";
    ss << "\\note HoursNonPositive - The HoursNonPositive option adds up the elapsed time during the month\n";
    ss << "\\note   that this variable has non-positive value. Hours with a negative value and hours with a\n";
    ss << "\\note   zero value are all included.\n";
    ss << "\\note HoursNegative - The HoursNegative option adds up the elapsed time during the month that\n";
    ss << "\\note   this variable has a negative value.  Hours with a zero value are not included.\n";
    ss << "\\note HoursNonNegative - The HoursNonNegative option adds up the elapsed time during the month\n";
    ss << "\\note   that this variable has non-negative value. Hours with a positive value and\n";
    ss << "\\note   hours with a zero value are all included.\n";
    ss << "\\note SumOrAverageDuringHoursShown - Provides the sum or average of the named variable when\n";
    ss << "\\note   during the hours that the previous variable displayed with any of the Aggregation Types\n";
    ss << "\\note   starting with \"Hours\". For \"sum\" type variables adds up the values for each timestep\n";
    ss << "\\note   and reports the sum of the value monthly during the hours reported on the previous\n";
    ss << "\\note   variable. For \"average\" type variables, the value shown will be the average for the month\n";
    ss << "\\note   during the hours reported on the previous variable.  Order of the variables in\n";
    ss << "\\note   the report is important when using this Aggregation Type.\n";
    ss << "\\note MaximumDuringHoursShown - Reports the maximum value and the time that the maximum value\n";
    ss << "\\note   occurred but only during the hours reported with the previous \"hours-\" Aggregation Type.\n";
    ss << "\\note   When the Maximum option is used with an average variable the value is divided\n";
    ss << "\\note   by the length of the timestep.  Order of the variables in the report is important\n";
    ss << "\\note   when using this Aggregation Type.\n";
    ss << "\\note MinimumDuringHoursShown - Reports the minimum value and the time that the minimum value\n";
    ss << "\\note   occurred but only during the hours reported with the previous \"hours-\" Aggregation Type.\n";
    ss << "\\note   When the Minimum option is used with an average variable the value is divided\n";
    ss << "\\note   by the length of the timestep.  Order of the variables in the report is important\n";
    ss << "\\note   when using this Aggregation Type.\n";

    IddObjectType objType(IddObjectType::Output_Table_Monthly);
    OptionalIddObject oObj = IddObject::load("Output:Table:Monthly",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_Table_Monthly);
  return object;
}

IddObject createOutput_Table_AnnualIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:Table:Annual,\n";
    ss << "\\memo Provides a generic method of setting up tables of annual results with one row per object.\n";
    ss << "\\memo The report has multiple columns that are each defined using a repeated group of fields\n";
    ss << "\\memo for any number of columns. A single Output:Table:Annual produces a single table in the\n";
    ss << "\\memo output.\n";
    ss << "\\extensible:3\n";
    ss << "A1, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A2, \\field Filter\n";
    ss << "\\type alpha\n";
    ss << "\\note An optional text string that is compared to the names of the objects referenced by the\n";
    ss << "\\note variables and if they match are included in the table. A footnote will appear that indicates\n";
    ss << "\\note that the objects shown may not be all the objects that of that type that occur in the file.\n";
    ss << "A3, \\field Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Optional schedule name. If left blank, aggregation is performed for all hours simulated. If\n";
    ss << "\\note a schedule is specified, aggregation is performed for non-zero hours in the schedule.\n";
    ss << "! The next two fields are repeated for each column\n";
    ss << "A4, \\field Variable or Meter or EMS Variable or Field 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\type external-list\n";
    ss << "\\external-list autoRDDvariableMeter\n";
    ss << "\\note contain the name of a variable (see Output:Variable and eplusout.rdd), meter (see Output:Meter\n";
    ss << "\\note and eplusout.mdd), or EMS Internal Variable Name or IDF Object Field name. This value is shown\n";
    ss << "\\note using the aggregation method specified.\n";
    ss << "A5, \\field Aggregation Type for Variable or Meter 1\n";
    ss << "\\type choice\n";
    ss << "\\key SumOrAverage\n";
    ss << "\\key Maximum\n";
    ss << "\\key Minimum\n";
    ss << "\\key ValueWhenMaximumOrMinimum\n";
    ss << "\\key HoursNonZero\n";
    ss << "\\key HoursZero\n";
    ss << "\\key HoursPositive\n";
    ss << "\\key HoursNonPositive\n";
    ss << "\\key HoursNegative\n";
    ss << "\\key HoursNonNegative\n";
    ss << "\\key HourInTenBinsMinToMax\n";
    ss << "\\key HourInTenBinsZeroToMax\n";
    ss << "\\key HourInTenBinsMinToZero\n";
    ss << "\\key SumOrAverageDuringHoursShown\n";
    ss << "\\key MaximumDuringHoursShown\n";
    ss << "\\key MinimumDuringHoursShown\n";
    ss << "\\note The method of aggregation for the selected variable or meter.\n";
    ss << "\\note SumOrAverage adds up the values for every timestep in the month if the variable\n";
    ss << "\\note   is a sum variable. If the variable is an average variable it reports the average value.\n";
    ss << "\\note   This is probably the most common Aggregation Type option to choose.\n";
    ss << "\\note Maximum and Minimum find the maximum and minimum value for the month and report it\n";
    ss << "\\note   along with the time that it first occurred.  When Maximum or Minimum are selected a\n";
    ss << "\\note   column is automatically shown in the output report for the time that it occurred.\n";
    ss << "\\note   When Maximum or Minimum are used with an average variable the value is divided\n";
    ss << "\\note   by the length of the timestep.\n";
    ss << "\\note ValueWhenMaxMin looks at the previous variable in the report that sets a maximum or minimum\n";
    ss << "\\note   and displays the value of the current variable at that same timestep.\n";
    ss << "\\note   Order of the variables in the report is important when using ValueWhenMaxMin.\n";
    ss << "\\note   This can be used when an outdoor temperature should be reported for the time of the\n";
    ss << "\\note   maximum cooling load.\n";
    ss << "\\note HoursNonZero adds up the elapsed time during the month that this variable is non-zero\n";
    ss << "\\note   and would be appropriate to determine the number of hour that a fan operates.\n";
    ss << "\\note HoursZero - The HoursZero option adds up the elapsed time during the month that this\n";
    ss << "\\note   variable has a zero value and would be appropriate to determine the number of hour\n";
    ss << "\\note   that a fan does not operate.\n";
    ss << "\\note HoursPositive - The HoursPositive option adds up the elapsed time during the month that\n";
    ss << "\\note   this variable has a positive value.  Hours with a zero value are not included.\n";
    ss << "\\note HoursNonPositive - The HoursNonPositive option adds up the elapsed time during the month\n";
    ss << "\\note   that this variable has non-positive value. Hours with a negative value and hours with a\n";
    ss << "\\note   zero value are all included.\n";
    ss << "\\note HoursNegative - The HoursNegative option adds up the elapsed time during the month that\n";
    ss << "\\note   this variable has a negative value.  Hours with a zero value are not included.\n";
    ss << "\\note HoursNonNegative - The HoursNonNegative option adds up the elapsed time during the month\n";
    ss << "\\note   that this variable has non-negative value. Hours with a positive value and\n";
    ss << "\\note   hours with a zero value are all included.\n";
    ss << "\\note HourInTenBinsMinToMax - Creates 10 columns for the specified variable and shows the number\n";
    ss << "\\note   of hours in each of 10 bins based on the minimum and maximum value. The bin sizes will\n";
    ss << "\\note   be rounded up to the next most signficant digit value.\n";
    ss << "\\note HourInTenBinsZeroToMax - Creates 11 columns for the specified variable and shows the number\n";
    ss << "\\note   of hours in each of 10 bins from zero to the maximum value and a bin for hours below zero.\n";
    ss << "\\note   The bin sizes will be rounded up to the next most significant digit value.\n";
    ss << "\\note HourInTenBinsMinToZero - Creates 11 columns for the specified variable and shows the number\n";
    ss << "\\note   of hours in each of 10 bins from zero to the minimum value and a bin for hours above zero.\n";
    ss << "\\note   The bin sizes will be rounded up to the next most significant digit value.\n";
    ss << "\\note SumOrAverageDuringHoursShown - Provides the sum or average of the named variable when\n";
    ss << "\\note   during the hours that the previous variable displayed with any of the Aggregation Types\n";
    ss << "\\note   starting with \"Hours\". For \"sum\" type variables adds up the values for each timestep\n";
    ss << "\\note   and reports the sum of the value monthly during the hours reported on the previous\n";
    ss << "\\note   variable. For \"average\" type variables, the value shown will be the average for the month\n";
    ss << "\\note   during the hours reported on the previous variable.  Order of the variables in\n";
    ss << "\\note   the report is important when using this Aggregation Type.\n";
    ss << "\\note MaximumDuringHoursShown - Reports the maximum value and the time that the maximum value\n";
    ss << "\\note   occurred but only during the hours reported with the previous \"hours-\" Aggregation Type.\n";
    ss << "\\note   When the Maximum option is used with an average variable the value is divided\n";
    ss << "\\note   by the length of the timestep.  Order of the variables in the report is important\n";
    ss << "\\note   when using this Aggregation Type.\n";
    ss << "\\note MinimumDuringHoursShown - Reports the minimum value and the time that the minimum value\n";
    ss << "\\note   occurred but only during the hours reported with the previous \"hours-\" Aggregation Type.\n";
    ss << "\\note   When the Minimum option is used with an average variable the value is divided\n";
    ss << "\\note   by the length of the timestep.  Order of the variables in the report is important\n";
    ss << "\\note   when using this Aggregation Type.\n";
    ss << "N1; \\field Digits After Decimal 1\n";
    ss << "\\type integer\n";
    ss << "\\default 2\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 10\n";

    IddObjectType objType(IddObjectType::Output_Table_Annual);
    OptionalIddObject oObj = IddObject::load("Output:Table:Annual",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_Table_Annual);
  return object;
}

IddObject createOutputControl_Table_StyleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OutputControl:Table:Style,\n";
    ss << "\\memo default style for the OutputControl:Table:Style is comma -- this works well for\n";
    ss << "\\memo importing into spreadsheet programs such as Excel(tm) but not so well for word\n";
    ss << "\\memo processing programs -- there tab may be a better choice.  fixed puts spaces between\n";
    ss << "\\memo the \"columns\".  HTML produces tables in HTML. XML produces an XML file.\n";
    ss << "\\memo note - if no OutputControl:Table:Style is included, the defaults are comma and None.\n";
    ss << "\\unique-object\n";
    ss << "A1, \\field Column Separator\n";
    ss << "\\type choice\n";
    ss << "\\key Comma\n";
    ss << "\\key Tab\n";
    ss << "\\key Fixed\n";
    ss << "\\key HTML\n";
    ss << "\\key XML\n";
    ss << "\\key CommaAndHTML\n";
    ss << "\\key CommaAndXML\n";
    ss << "\\key TabAndHTML\n";
    ss << "\\key XMLandHTML\n";
    ss << "\\key All\n";
    ss << "\\default Comma\n";
    ss << "A2; \\field Unit Conversion\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key JtoKWH\n";
    ss << "\\key JtoMJ\n";
    ss << "\\key JtoGJ\n";
    ss << "\\key InchPound\n";
    ss << "\\default None\n";

    IddObjectType objType(IddObjectType::OutputControl_Table_Style);
    OptionalIddObject oObj = IddObject::load("OutputControl:Table:Style",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OutputControl_Table_Style);
  return object;
}

IddObject createOutputControl_ReportingTolerancesIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OutputControl:ReportingTolerances,\n";
    ss << "\\memo Calculations of the time that setpoints are not met use a tolerance of 0.2C.\n";
    ss << "\\memo This object allows changing the tolerance used to determine when setpoints are being met.\n";
    ss << "\\unique-object\n";
    ss << "N1, \\field Tolerance for Time Heating Setpoint Not Met\n";
    ss << "\\note If the zone temperature is below the heating setpoint by more than\n";
    ss << "\\note this value, the following output variables will increment as appropriate\n";
    ss << "\\note Zone Heating Setpoint Not Met Time\n";
    ss << "\\note Zone Heating Setpoint Not Met While Occupied Time\n";
    ss << "\\note This also impacts table report \"Annual Building Utility Performance Summary\"\n";
    ss << "\\note subtable \"Comfort and Setpoint Not Met Summary\"\n";
    ss << "\\units deltaC\n";
    ss << "\\default .2\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 10\n";
    ss << "N2; \\field Tolerance for Time Cooling Setpoint Not Met\n";
    ss << "\\note If the zone temperature is above the cooling setpoint by more than\n";
    ss << "\\note this value, the following output variables will increment as appropriate\n";
    ss << "\\note Zone Cooling Setpoint Not Met Time\n";
    ss << "\\note Zone Cooling Setpoint Not Met While Occupied Time\n";
    ss << "\\note This also impacts table report \"Annual Building Utility Performance Summary\"\n";
    ss << "\\note subtable \"Comfort and Setpoint Not Met Summary\"\n";
    ss << "\\units deltaC\n";
    ss << "\\default .2\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 10\n";

    IddObjectType objType(IddObjectType::OutputControl_ReportingTolerances);
    OptionalIddObject oObj = IddObject::load("OutputControl:ReportingTolerances",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OutputControl_ReportingTolerances);
  return object;
}

IddObject createOutput_VariableIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:Variable,\n";
    ss << "\\memo each Output:Variable command picks variables to be put onto the standard output file (.eso)\n";
    ss << "\\memo some variables may not be reported for every simulation.\n";
    ss << "\\memo a list of variables that can be reported are available after a run on\n";
    ss << "\\memo the report dictionary file (.rdd) if the Output:VariableDictionary has been requested.\n";
    ss << "\\format singleLine\n";
    ss << "A1 , \\field Key Value\n";
    ss << "\\default *\n";
    ss << "\\note use '*' (without quotes) to apply this variable to all keys\n";
    ss << "A2 , \\field Variable Name\n";
    ss << "\\required-field\n";
    ss << "\\type external-list\n";
    ss << "\\external-list autoRDDvariable\n";
    ss << "A3 , \\field Reporting Frequency\n";
    ss << "\\type choice\n";
    ss << "\\key Detailed\n";
    ss << "\\note Detailed lists every instance (i.e. HVAC variable timesteps)\n";
    ss << "\\key Timestep\n";
    ss << "\\note Timestep refers to the zone Timestep/Number of Timesteps in hour value\n";
    ss << "\\note RunPeriod, Environment, and Annual are the same\n";
    ss << "\\key Hourly\n";
    ss << "\\key Daily\n";
    ss << "\\key Monthly\n";
    ss << "\\key RunPeriod\n";
    ss << "\\key Environment\n";
    ss << "\\key Annual\n";
    ss << "\\default Hourly\n";
    ss << "\\note RunPeriod, Environment, and Annual are synonymous\n";
    ss << "A4 ; \\field Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::Output_Variable);
    OptionalIddObject oObj = IddObject::load("Output:Variable",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_Variable);
  return object;
}

IddObject createOutput_MeterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:Meter,\n";
    ss << "\\memo Each Output:Meter command picks meters to be put onto the standard output file (.eso) and\n";
    ss << "\\memo meter file (.mtr). Not all meters are reported in every simulation. A list of\n";
    ss << "\\memo a list of meters that can be reported are available after a run on\n";
    ss << "\\memo the meter dictionary file (.mdd) if the Output:VariableDictionary has been requested.\n";
    ss << "\\format singleLine\n";
    ss << "A1 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type external-list\n";
    ss << "\\external-list autoRDDmeter\n";
    ss << "\\note Form is EnergyUseType:..., e.g. Electricity:* for all Electricity meters\n";
    ss << "\\note or EndUse:..., e.g. GeneralLights:* for all General Lights\n";
    ss << "\\note Output:Meter puts results on both the eplusout.mtr and eplusout.eso files\n";
    ss << "A2 ; \\field Reporting Frequency\n";
    ss << "\\type choice\n";
    ss << "\\key Timestep\n";
    ss << "\\note Timestep refers to the zone Timestep/Number of Timesteps in hour value\n";
    ss << "\\note RunPeriod, Environment, and Annual are the same\n";
    ss << "\\key Hourly\n";
    ss << "\\key Daily\n";
    ss << "\\key Monthly\n";
    ss << "\\key RunPeriod\n";
    ss << "\\key Environment\n";
    ss << "\\key Annual\n";
    ss << "\\default Hourly\n";
    ss << "\\note RunPeriod, Environment, and Annual are synonymous\n";

    IddObjectType objType(IddObjectType::Output_Meter);
    OptionalIddObject oObj = IddObject::load("Output:Meter",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_Meter);
  return object;
}

IddObject createOutput_Meter_MeterFileOnlyIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:Meter:MeterFileOnly,\n";
    ss << "\\memo Each Output:Meter:MeterFileOnly command picks meters to be put only onto meter file (.mtr).\n";
    ss << "\\memo Not all meters are reported in every simulation. A list of meters that can be reported\n";
    ss << "\\memo a list of meters that can be reported are available after a run on\n";
    ss << "\\memo the meter dictionary file (.mdd) if the Output:VariableDictionary has been requested.\n";
    ss << "\\format singleLine\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type external-list\n";
    ss << "\\external-list autoRDDmeter\n";
    ss << "\\note Form is EnergyUseType:..., e.g. Electricity:* for all Electricity meters\n";
    ss << "\\note or EndUse:..., e.g. GeneralLights:* for all General Lights\n";
    ss << "\\note Output:Meter:MeterFileOnly puts results on the eplusout.mtr file only\n";
    ss << "A2 ; \\field Reporting Frequency\n";
    ss << "\\type choice\n";
    ss << "\\key Timestep\n";
    ss << "\\note Timestep refers to the zone Timestep/Number of Timesteps in hour value\n";
    ss << "\\note RunPeriod, Environment, and Annual are the same\n";
    ss << "\\key Hourly\n";
    ss << "\\key Daily\n";
    ss << "\\key Monthly\n";
    ss << "\\key RunPeriod\n";
    ss << "\\key Environment\n";
    ss << "\\key Annual\n";
    ss << "\\default Hourly\n";
    ss << "\\note RunPeriod, Environment, and Annual are synonymous\n";

    IddObjectType objType(IddObjectType::Output_Meter_MeterFileOnly);
    OptionalIddObject oObj = IddObject::load("Output:Meter:MeterFileOnly",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_Meter_MeterFileOnly);
  return object;
}

IddObject createOutput_Meter_CumulativeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:Meter:Cumulative,\n";
    ss << "\\memo Each Output:Meter:Cumulative command picks meters to be reported cumulatively onto the\n";
    ss << "\\memo standard output file (.eso) and meter file (.mtr). Not all meters are reported in every\n";
    ss << "\\memo simulation.\n";
    ss << "\\memo a list of meters that can be reported are available after a run on\n";
    ss << "\\memo the meter dictionary file (.mdd) if the Output:VariableDictionary has been requested.\n";
    ss << "\\format singleLine\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type external-list\n";
    ss << "\\external-list autoRDDmeter\n";
    ss << "\\note Form is EnergyUseType:..., e.g. Electricity:* for all Electricity meters\n";
    ss << "\\note or EndUse:..., e.g. GeneralLights:* for all General Lights\n";
    ss << "\\note Output:Meter:Cumulative puts results on both the eplusout.mtr and eplusout.eso files\n";
    ss << "A2 ; \\field Reporting Frequency\n";
    ss << "\\type choice\n";
    ss << "\\key Timestep\n";
    ss << "\\note Timestep refers to the zone Timestep/Number of Timesteps in hour value\n";
    ss << "\\note RunPeriod, Environment, and Annual are the same\n";
    ss << "\\key Hourly\n";
    ss << "\\key Daily\n";
    ss << "\\key Monthly\n";
    ss << "\\key RunPeriod\n";
    ss << "\\key Environment\n";
    ss << "\\key Annual\n";
    ss << "\\default Hourly\n";
    ss << "\\note RunPeriod, Environment, and Annual are synonymous\n";

    IddObjectType objType(IddObjectType::Output_Meter_Cumulative);
    OptionalIddObject oObj = IddObject::load("Output:Meter:Cumulative",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_Meter_Cumulative);
  return object;
}

IddObject createOutput_Meter_Cumulative_MeterFileOnlyIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:Meter:Cumulative:MeterFileOnly,\n";
    ss << "\\memo Each Output:Meter:Cumulative:MeterFileOnly command picks meters to be reported cumulatively\n";
    ss << "\\memo onto the standard output file (.eso) and meter file (.mtr). Not all meters are reported in\n";
    ss << "\\memo every simulation.\n";
    ss << "\\memo a list of meters that can be reported are available after a run on\n";
    ss << "\\memo the meter dictionary file (.mdd) if the Output:VariableDictionary has been requested.\n";
    ss << "\\format singleLine\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type external-list\n";
    ss << "\\external-list autoRDDmeter\n";
    ss << "\\note Form is EnergyUseType:..., e.g. Electricity:* for all Electricity meters\n";
    ss << "\\note or EndUse:..., e.g. GeneralLights:* for all General Lights\n";
    ss << "\\note Output:Meter:Cumulative:MeterFileOnly puts results on the eplusout.mtr file only\n";
    ss << "A2 ; \\field Reporting Frequency\n";
    ss << "\\type choice\n";
    ss << "\\key Timestep\n";
    ss << "\\note Timestep refers to the zone Timestep/Number of Timesteps in hour value\n";
    ss << "\\note RunPeriod, Environment, and Annual are the same\n";
    ss << "\\key Hourly\n";
    ss << "\\key Daily\n";
    ss << "\\key Monthly\n";
    ss << "\\key RunPeriod\n";
    ss << "\\key Environment\n";
    ss << "\\key Annual\n";
    ss << "\\default Hourly\n";
    ss << "\\note RunPeriod, Environment, and Annual are synonymous\n";

    IddObjectType objType(IddObjectType::Output_Meter_Cumulative_MeterFileOnly);
    OptionalIddObject oObj = IddObject::load("Output:Meter:Cumulative:MeterFileOnly",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_Meter_Cumulative_MeterFileOnly);
  return object;
}

IddObject createMeter_CustomIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Meter:Custom,\n";
    ss << "\\extensible:2 - repeat last two fields, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\memo Used to allow users to combine specific variables and/or meters into\n";
    ss << "\\memo \"custom\" meter configurations. To access these meters by name, one must\n";
    ss << "\\memo first run a simulation to generate the RDD/MDD files and names.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key Water\n";
    ss << "\\key Generic\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "A3,  \\field Key Name 1\n";
    ss << "\\begin-extensible\n";
    ss << "A4;  \\field Output Variable or Meter Name 1\n";

    IddObjectType objType(IddObjectType::Meter_Custom);
    OptionalIddObject oObj = IddObject::load("Meter:Custom",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Meter_Custom);
  return object;
}

IddObject createMeter_CustomDecrementIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Meter:CustomDecrement,\n";
    ss << "\\extensible:2 - repeat last two fields, remembering to remove ; from \"inner\" fields.\n";
    ss << "\\memo Used to allow users to combine specific variables and/or meters into\n";
    ss << "\\memo \"custom\" meter configurations. To access these meters by name, one must\n";
    ss << "\\memo first run a simulation to generate the RDD/MDD files and names.\n";
    ss << "A1,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key Water\n";
    ss << "\\key Generic\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "A3,  \\field Source Meter Name\n";
    ss << "\\required-field\n";
    ss << "A4,  \\field Key Name 1\n";
    ss << "\\begin-extensible\n";
    ss << "A5;  \\field Output Variable or Meter Name 1\n";

    IddObjectType objType(IddObjectType::Meter_CustomDecrement);
    OptionalIddObject oObj = IddObject::load("Meter:CustomDecrement",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Meter_CustomDecrement);
  return object;
}

IddObject createOutput_SQLiteIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:SQLite,\n";
    ss << "\\memo Output from EnergyPlus can be written to an SQLite format file.\n";
    ss << "\\unique-object\n";
    ss << "A1 ; \\field Option Type\n";
    ss << "\\type choice\n";
    ss << "\\key Simple\n";
    ss << "\\key SimpleAndTabular\n";

    IddObjectType objType(IddObjectType::Output_SQLite);
    OptionalIddObject oObj = IddObject::load("Output:SQLite",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_SQLite);
  return object;
}

IddObject createOutput_EnvironmentalImpactFactorsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:EnvironmentalImpactFactors,\n";
    ss << "\\memo This is used to Automatically report the facility meters and turn on the Environmental Impact Report calculations\n";
    ss << "\\memo for all of the Environmental Factors.\n";
    ss << "A1 ; \\field Reporting Frequency\n";
    ss << "\\type choice\n";
    ss << "\\key Timestep\n";
    ss << "\\key Hourly\n";
    ss << "\\key Daily\n";
    ss << "\\key Monthly\n";
    ss << "\\key RunPeriod\n";

    IddObjectType objType(IddObjectType::Output_EnvironmentalImpactFactors);
    OptionalIddObject oObj = IddObject::load("Output:EnvironmentalImpactFactors",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_EnvironmentalImpactFactors);
  return object;
}

IddObject createEnvironmentalImpactFactorsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "EnvironmentalImpactFactors,\n";
    ss << "\\memo Used to help convert district and ideal energy use to a fuel type and provide total carbon equivalent with coefficients\n";
    ss << "\\memo Also used in Source=>Site conversions.\n";
    ss << "N1, \\field District Heating Efficiency\n";
    ss << "\\note District heating efficiency used when converted to natural gas\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.3\n";
    ss << "N2, \\field District Cooling COP\n";
    ss << "\\note District cooling COP used when converted to electricity\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.0\n";
    ss << "N3, \\field Steam Conversion Efficiency\n";
    ss << "\\note Steam conversion efficiency used to convert steam usage to natural gas\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.25\n";
    ss << "N4, \\field Total Carbon Equivalent Emission Factor From N2O\n";
    ss << "\\units kg/kg\n";
    ss << "\\default 80.7272\n";
    ss << "N5, \\field Total Carbon Equivalent Emission Factor From CH4\n";
    ss << "\\units kg/kg\n";
    ss << "\\default 6.2727\n";
    ss << "N6; \\field Total Carbon Equivalent Emission Factor From CO2\n";
    ss << "\\units kg/kg\n";
    ss << "\\default 0.2727\n";

    IddObjectType objType(IddObjectType::EnvironmentalImpactFactors);
    OptionalIddObject oObj = IddObject::load("EnvironmentalImpactFactors",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::EnvironmentalImpactFactors);
  return object;
}

IddObject createFuelFactorsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "FuelFactors,\n";
    ss << "\\memo Provides Fuel Factors for Emissions as well as Source=>Site conversions.\n";
    ss << "\\memo OtherFuel1, OtherFuel2 provide options for users who want to create and use\n";
    ss << "\\memo fuels that may not be mainstream (biomass, wood, pellets).\n";
    ss << "A1,   \\field Existing Fuel Resource Name\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Gasoline\n";
    ss << "\\key Propane\n";
    ss << "\\key Diesel\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "A2,   \\field Units of Measure\n";
    ss << "N1,   \\field Energy per Unit Factor\n";
    ss << "N2,   \\field Source Energy Factor\n";
    ss << "\\units J/J\n";
    ss << "A3,   \\field Source Energy Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N3,   \\field CO2 Emission Factor\n";
    ss << "\\units g/MJ\n";
    ss << "A4,   \\field CO2 Emission Factor Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N4,   \\field CO Emission Factor\n";
    ss << "\\units g/MJ\n";
    ss << "A5,   \\field CO Emission Factor Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N5,   \\field CH4 Emission Factor\n";
    ss << "\\units g/MJ\n";
    ss << "A6,   \\field CH4 Emission Factor Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N6,   \\field NOx Emission Factor\n";
    ss << "\\units g/MJ\n";
    ss << "A7,   \\field NOx Emission Factor Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N7,   \\field N2O Emission Factor\n";
    ss << "\\units g/MJ\n";
    ss << "A8,   \\field N2O Emission Factor Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N8,   \\field SO2 Emission Factor\n";
    ss << "\\units g/MJ\n";
    ss << "A9,   \\field SO2 Emission Factor Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N9,   \\field PM Emission Factor\n";
    ss << "\\units g/MJ\n";
    ss << "A10,  \\field PM Emission Factor Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N10,  \\field PM10 Emission Factor\n";
    ss << "\\units g/MJ\n";
    ss << "A11,  \\field PM10 Emission Factor Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N11,  \\field PM2.5 Emission Factor\n";
    ss << "\\units g/MJ\n";
    ss << "A12,  \\field PM2.5 Emission Factor Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N12,  \\field NH3 Emission Factor\n";
    ss << "\\units g/MJ\n";
    ss << "A13,  \\field NH3 Emission Factor Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N13,  \\field NMVOC Emission Factor\n";
    ss << "\\units g/MJ\n";
    ss << "A14,  \\field NMVOC Emission Factor Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N14,  \\field Hg Emission Factor\n";
    ss << "\\units g/MJ\n";
    ss << "A15,  \\field Hg Emission Factor Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N15,  \\field Pb Emission Factor\n";
    ss << "\\units g/MJ\n";
    ss << "A16,  \\field Pb Emission Factor Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N16,  \\field Water Emission Factor\n";
    ss << "\\units L/MJ\n";
    ss << "A17,  \\field Water Emission Factor Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N17,  \\field Nuclear High Level Emission Factor\n";
    ss << "\\units g/MJ\n";
    ss << "A18,  \\field Nuclear High Level Emission Factor Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N18,  \\field Nuclear Low Level Emission Factor\n";
    ss << "\\units m3/MJ\n";
    ss << "A19;  \\field Nuclear Low Level Emission Factor Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::FuelFactors);
    OptionalIddObject oObj = IddObject::load("FuelFactors",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::FuelFactors);
  return object;
}

IddObject createOutput_DiagnosticsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:Diagnostics,\n";
    ss << "\\memo Special keys to produce certain warning messages or effect certain simulation characteristics.\n";
    ss << "A1 , \\field Key 1\n";
    ss << "\\type choice\n";
    ss << "\\key DisplayAllWarnings\n";
    ss << "\\key DisplayExtraWarnings\n";
    ss << "\\key DisplayUnusedSchedules\n";
    ss << "\\key DisplayUnusedObjects\n";
    ss << "\\key DisplayAdvancedReportVariables\n";
    ss << "\\key DisplayZoneAirHeatBalanceOffBalance\n";
    ss << "\\key DoNotMirrorDetachedShading\n";
    ss << "\\key DisplayWeatherMissingDataWarnings\n";
    ss << "\\key ReportDuringWarmup\n";
    ss << "\\key ReportDetailedWarmupConvergence\n";
    ss << "\\key ReportDuringHVACSizingSimulation\n";
    ss << "A2 ; \\field Key 2\n";
    ss << "\\type choice\n";
    ss << "\\key DisplayAllWarnings\n";
    ss << "\\key DisplayExtraWarnings\n";
    ss << "\\key DisplayUnusedSchedules\n";
    ss << "\\key DisplayUnusedObjects\n";
    ss << "\\key DisplayAdvancedReportVariables\n";
    ss << "\\key DisplayZoneAirHeatBalanceOffBalance\n";
    ss << "\\key DoNotMirrorDetachedShading\n";
    ss << "\\key DisplayWeatherMissingDataWarnings\n";
    ss << "\\key ReportDuringWarmup\n";
    ss << "\\key ReportDetailedWarmupConvergence\n";
    ss << "\\key ReportDuringHVACSizingSimulation\n";

    IddObjectType objType(IddObjectType::Output_Diagnostics);
    OptionalIddObject oObj = IddObject::load("Output:Diagnostics",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_Diagnostics);
  return object;
}

IddObject createOutput_DebuggingDataIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:DebuggingData,\n";
    ss << "\\memo switch eplusout.dbg file on or off\n";
    ss << "\\unique-object\n";
    ss << "\\format singleLine\n";
    ss << "N1 , \\field Report Debugging Data\n";
    ss << "\\note value=1 then yes all others no\n";
    ss << "N2 ; \\field Report During Warmup\n";
    ss << "\\note value=1 then always even during warmup  all others no\n";

    IddObjectType objType(IddObjectType::Output_DebuggingData);
    OptionalIddObject oObj = IddObject::load("Output:DebuggingData",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_DebuggingData);
  return object;
}

IddObject createOutput_PreprocessorMessageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "Output:PreprocessorMessage,\n";
    ss << "\\memo This object does not come from a user input.  This is generated by a pre-processor\n";
    ss << "\\memo so that various conditions can be gracefully passed on by the InputProcessor.\n";
    ss << "A1,  \\field Preprocessor Name\n";
    ss << "\\retaincase\n";
    ss << "A2,  \\field Error Severity\n";
    ss << "\\note Depending on type, InputProcessor may terminate the program.\n";
    ss << "\\type choice\n";
    ss << "\\key Information\n";
    ss << "\\key Warning\n";
    ss << "\\key Severe\n";
    ss << "\\key Fatal\n";
    ss << "\\retaincase\n";
    ss << "A3,  \\field Message Line 1\n";
    ss << "\\retaincase\n";
    ss << "A4,  \\field Message Line 2\n";
    ss << "\\retaincase\n";
    ss << "A5,  \\field Message Line 3\n";
    ss << "\\retaincase\n";
    ss << "A6,  \\field Message Line 4\n";
    ss << "\\retaincase\n";
    ss << "A7,  \\field Message Line 5\n";
    ss << "\\retaincase\n";
    ss << "A8,  \\field Message Line 6\n";
    ss << "\\retaincase\n";
    ss << "A9,  \\field Message Line 7\n";
    ss << "\\retaincase\n";
    ss << "A10, \\field Message Line 8\n";
    ss << "\\retaincase\n";
    ss << "A11, \\field Message Line 9\n";
    ss << "\\retaincase\n";
    ss << "A12; \\field Message Line 10\n";
    ss << "\\retaincase\n";

    IddObjectType objType(IddObjectType::Output_PreprocessorMessage);
    OptionalIddObject oObj = IddObject::load("Output:PreprocessorMessage",
                                             "Output Reporting",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::Output_PreprocessorMessage);
  return object;
}
void IddFactorySingleton::registerEnergyPlusObjectsInCallbackMap() {
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::LeadInput,createLeadInputIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EndLeadInput,createEndLeadInputIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SimulationData,createSimulationDataIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EndSimulationData,createEndSimulationDataIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Version,createVersionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SimulationControl,createSimulationControlIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Building,createBuildingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ShadowCalculation,createShadowCalculationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceConvectionAlgorithm_Inside,createSurfaceConvectionAlgorithm_InsideIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceConvectionAlgorithm_Outside,createSurfaceConvectionAlgorithm_OutsideIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HeatBalanceAlgorithm,createHeatBalanceAlgorithmIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HeatBalanceSettings_ConductionFiniteDifference,createHeatBalanceSettings_ConductionFiniteDifferenceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneAirHeatBalanceAlgorithm,createZoneAirHeatBalanceAlgorithmIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneAirContaminantBalance,createZoneAirContaminantBalanceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneAirMassFlowConservation,createZoneAirMassFlowConservationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneCapacitanceMultiplier_ResearchSpecial,createZoneCapacitanceMultiplier_ResearchSpecialIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Timestep,createTimestepIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ConvergenceLimits,createConvergenceLimitsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ProgramControl,createProgramControlIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Compliance_Building,createCompliance_BuildingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Site_Location,createSite_LocationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SizingPeriod_DesignDay,createSizingPeriod_DesignDayIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SizingPeriod_WeatherFileDays,createSizingPeriod_WeatherFileDaysIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SizingPeriod_WeatherFileConditionType,createSizingPeriod_WeatherFileConditionTypeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RunPeriod,createRunPeriodIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RunPeriod_CustomRange,createRunPeriod_CustomRangeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RunPeriodControl_SpecialDays,createRunPeriodControl_SpecialDaysIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RunPeriodControl_DaylightSavingTime,createRunPeriodControl_DaylightSavingTimeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WeatherProperty_SkyTemperature,createWeatherProperty_SkyTemperatureIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Site_WeatherStation,createSite_WeatherStationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Site_HeightVariation,createSite_HeightVariationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Site_GroundTemperature_BuildingSurface,createSite_GroundTemperature_BuildingSurfaceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Site_GroundTemperature_FCfactorMethod,createSite_GroundTemperature_FCfactorMethodIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Site_GroundTemperature_Shallow,createSite_GroundTemperature_ShallowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Site_GroundTemperature_Deep,createSite_GroundTemperature_DeepIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Site_GroundTemperature_Undisturbed_FiniteDifference,createSite_GroundTemperature_Undisturbed_FiniteDifferenceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Site_GroundTemperature_Undisturbed_KusudaAchenbach,createSite_GroundTemperature_Undisturbed_KusudaAchenbachIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Site_GroundTemperature_Undisturbed_Xing,createSite_GroundTemperature_Undisturbed_XingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Site_GroundDomain_Slab,createSite_GroundDomain_SlabIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Site_GroundDomain_Basement,createSite_GroundDomain_BasementIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Site_GroundReflectance,createSite_GroundReflectanceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Site_GroundReflectance_SnowModifier,createSite_GroundReflectance_SnowModifierIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Site_WaterMainsTemperature,createSite_WaterMainsTemperatureIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Site_Precipitation,createSite_PrecipitationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RoofIrrigation,createRoofIrrigationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Site_SolarAndVisibleSpectrum,createSite_SolarAndVisibleSpectrumIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Site_SpectrumData,createSite_SpectrumDataIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ScheduleTypeLimits,createScheduleTypeLimitsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Schedule_Day_Hourly,createSchedule_Day_HourlyIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Schedule_Day_Interval,createSchedule_Day_IntervalIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Schedule_Day_List,createSchedule_Day_ListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Schedule_Week_Daily,createSchedule_Week_DailyIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Schedule_Week_Compact,createSchedule_Week_CompactIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Schedule_Year,createSchedule_YearIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Schedule_Compact,createSchedule_CompactIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Schedule_Constant,createSchedule_ConstantIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Schedule_File,createSchedule_FileIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Material,createMaterialIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Material_NoMass,createMaterial_NoMassIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Material_InfraredTransparent,createMaterial_InfraredTransparentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Material_AirGap,createMaterial_AirGapIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Material_RoofVegetation,createMaterial_RoofVegetationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowMaterial_SimpleGlazingSystem,createWindowMaterial_SimpleGlazingSystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowMaterial_Glazing,createWindowMaterial_GlazingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowMaterial_GlazingGroup_Thermochromic,createWindowMaterial_GlazingGroup_ThermochromicIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowMaterial_Glazing_RefractionExtinctionMethod,createWindowMaterial_Glazing_RefractionExtinctionMethodIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowMaterial_Gas,createWindowMaterial_GasIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowGap_SupportPillar,createWindowGap_SupportPillarIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowGap_DeflectionState,createWindowGap_DeflectionStateIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowMaterial_GasMixture,createWindowMaterial_GasMixtureIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowMaterial_Gap,createWindowMaterial_GapIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowMaterial_Shade,createWindowMaterial_ShadeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowMaterial_ComplexShade,createWindowMaterial_ComplexShadeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowMaterial_Blind,createWindowMaterial_BlindIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowMaterial_Screen,createWindowMaterial_ScreenIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowMaterial_Shade_EquivalentLayer,createWindowMaterial_Shade_EquivalentLayerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowMaterial_Drape_EquivalentLayer,createWindowMaterial_Drape_EquivalentLayerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowMaterial_Blind_EquivalentLayer,createWindowMaterial_Blind_EquivalentLayerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowMaterial_Screen_EquivalentLayer,createWindowMaterial_Screen_EquivalentLayerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowMaterial_Glazing_EquivalentLayer,createWindowMaterial_Glazing_EquivalentLayerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowMaterial_Gap_EquivalentLayer,createWindowMaterial_Gap_EquivalentLayerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::MaterialProperty_MoisturePenetrationDepth_Settings,createMaterialProperty_MoisturePenetrationDepth_SettingsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::MaterialProperty_PhaseChange,createMaterialProperty_PhaseChangeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::MaterialProperty_VariableThermalConductivity,createMaterialProperty_VariableThermalConductivityIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::MaterialProperty_HeatAndMoistureTransfer_Settings,createMaterialProperty_HeatAndMoistureTransfer_SettingsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::MaterialProperty_HeatAndMoistureTransfer_SorptionIsotherm,createMaterialProperty_HeatAndMoistureTransfer_SorptionIsothermIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::MaterialProperty_HeatAndMoistureTransfer_Suction,createMaterialProperty_HeatAndMoistureTransfer_SuctionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::MaterialProperty_HeatAndMoistureTransfer_Redistribution,createMaterialProperty_HeatAndMoistureTransfer_RedistributionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::MaterialProperty_HeatAndMoistureTransfer_Diffusion,createMaterialProperty_HeatAndMoistureTransfer_DiffusionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::MaterialProperty_HeatAndMoistureTransfer_ThermalConductivity,createMaterialProperty_HeatAndMoistureTransfer_ThermalConductivityIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::MaterialProperty_GlazingSpectralData,createMaterialProperty_GlazingSpectralDataIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Construction,createConstructionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Construction_CfactorUndergroundWall,createConstruction_CfactorUndergroundWallIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Construction_FfactorGroundFloor,createConstruction_FfactorGroundFloorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Construction_InternalSource,createConstruction_InternalSourceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowThermalModel_Params,createWindowThermalModel_ParamsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Construction_ComplexFenestrationState,createConstruction_ComplexFenestrationStateIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Construction_WindowEquivalentLayer,createConstruction_WindowEquivalentLayerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Construction_WindowDataFile,createConstruction_WindowDataFileIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GlobalGeometryRules,createGlobalGeometryRulesIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GeometryTransform,createGeometryTransformIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Zone,createZoneIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneList,createZoneListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneGroup,createZoneGroupIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::BuildingSurface_Detailed,createBuildingSurface_DetailedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Wall_Detailed,createWall_DetailedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RoofCeiling_Detailed,createRoofCeiling_DetailedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Floor_Detailed,createFloor_DetailedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Wall_Exterior,createWall_ExteriorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Wall_Adiabatic,createWall_AdiabaticIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Wall_Underground,createWall_UndergroundIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Wall_Interzone,createWall_InterzoneIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Roof,createRoofIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Ceiling_Adiabatic,createCeiling_AdiabaticIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Ceiling_Interzone,createCeiling_InterzoneIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Floor_GroundContact,createFloor_GroundContactIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Floor_Adiabatic,createFloor_AdiabaticIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Floor_Interzone,createFloor_InterzoneIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FenestrationSurface_Detailed,createFenestrationSurface_DetailedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Window,createWindowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Door,createDoorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GlazedDoor,createGlazedDoorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Window_Interzone,createWindow_InterzoneIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Door_Interzone,createDoor_InterzoneIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GlazedDoor_Interzone,createGlazedDoor_InterzoneIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowProperty_ShadingControl,createWindowProperty_ShadingControlIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowProperty_FrameAndDivider,createWindowProperty_FrameAndDividerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowProperty_AirflowControl,createWindowProperty_AirflowControlIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WindowProperty_StormWindow,createWindowProperty_StormWindowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::InternalMass,createInternalMassIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Shading_Site,createShading_SiteIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Shading_Building,createShading_BuildingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Shading_Site_Detailed,createShading_Site_DetailedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Shading_Building_Detailed,createShading_Building_DetailedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Shading_Overhang,createShading_OverhangIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Shading_Overhang_Projection,createShading_Overhang_ProjectionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Shading_Fin,createShading_FinIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Shading_Fin_Projection,createShading_Fin_ProjectionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Shading_Zone_Detailed,createShading_Zone_DetailedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ShadingProperty_Reflectance,createShadingProperty_ReflectanceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceProperty_HeatTransferAlgorithm,createSurfaceProperty_HeatTransferAlgorithmIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceProperty_HeatTransferAlgorithm_MultipleSurface,createSurfaceProperty_HeatTransferAlgorithm_MultipleSurfaceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceProperty_HeatTransferAlgorithm_SurfaceList,createSurfaceProperty_HeatTransferAlgorithm_SurfaceListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceProperty_HeatTransferAlgorithm_Construction,createSurfaceProperty_HeatTransferAlgorithm_ConstructionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceControl_MovableInsulation,createSurfaceControl_MovableInsulationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceProperty_OtherSideCoefficients,createSurfaceProperty_OtherSideCoefficientsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceProperty_OtherSideConditionsModel,createSurfaceProperty_OtherSideConditionsModelIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceConvectionAlgorithm_Inside_AdaptiveModelSelections,createSurfaceConvectionAlgorithm_Inside_AdaptiveModelSelectionsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceConvectionAlgorithm_Outside_AdaptiveModelSelections,createSurfaceConvectionAlgorithm_Outside_AdaptiveModelSelectionsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceConvectionAlgorithm_Inside_UserCurve,createSurfaceConvectionAlgorithm_Inside_UserCurveIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceConvectionAlgorithm_Outside_UserCurve,createSurfaceConvectionAlgorithm_Outside_UserCurveIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceProperty_ConvectionCoefficients,createSurfaceProperty_ConvectionCoefficientsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceProperty_ConvectionCoefficients_MultipleSurface,createSurfaceProperty_ConvectionCoefficients_MultipleSurfaceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceProperties_VaporCoefficients,createSurfaceProperties_VaporCoefficientsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceProperty_ExteriorNaturalVentedCavity,createSurfaceProperty_ExteriorNaturalVentedCavityIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceProperty_SolarIncidentInside,createSurfaceProperty_SolarIncidentInsideIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ComplexFenestrationProperty_SolarAbsorbedLayers,createComplexFenestrationProperty_SolarAbsorbedLayersIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneProperty_UserViewFactors_bySurfaceName,createZoneProperty_UserViewFactors_bySurfaceNameIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Control,createGroundHeatTransfer_ControlIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Slab_Materials,createGroundHeatTransfer_Slab_MaterialsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Slab_MatlProps,createGroundHeatTransfer_Slab_MatlPropsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Slab_BoundConds,createGroundHeatTransfer_Slab_BoundCondsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Slab_BldgProps,createGroundHeatTransfer_Slab_BldgPropsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Slab_Insulation,createGroundHeatTransfer_Slab_InsulationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Slab_EquivalentSlab,createGroundHeatTransfer_Slab_EquivalentSlabIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Slab_AutoGrid,createGroundHeatTransfer_Slab_AutoGridIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Slab_ManualGrid,createGroundHeatTransfer_Slab_ManualGridIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Slab_XFACE,createGroundHeatTransfer_Slab_XFACEIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Slab_YFACE,createGroundHeatTransfer_Slab_YFACEIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Slab_ZFACE,createGroundHeatTransfer_Slab_ZFACEIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Basement_SimParameters,createGroundHeatTransfer_Basement_SimParametersIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Basement_MatlProps,createGroundHeatTransfer_Basement_MatlPropsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Basement_Insulation,createGroundHeatTransfer_Basement_InsulationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Basement_SurfaceProps,createGroundHeatTransfer_Basement_SurfacePropsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Basement_BldgData,createGroundHeatTransfer_Basement_BldgDataIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Basement_Interior,createGroundHeatTransfer_Basement_InteriorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Basement_ComBldg,createGroundHeatTransfer_Basement_ComBldgIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Basement_EquivSlab,createGroundHeatTransfer_Basement_EquivSlabIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Basement_EquivAutoGrid,createGroundHeatTransfer_Basement_EquivAutoGridIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Basement_AutoGrid,createGroundHeatTransfer_Basement_AutoGridIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Basement_ManualGrid,createGroundHeatTransfer_Basement_ManualGridIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Basement_XFACE,createGroundHeatTransfer_Basement_XFACEIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Basement_YFACE,createGroundHeatTransfer_Basement_YFACEIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatTransfer_Basement_ZFACE,createGroundHeatTransfer_Basement_ZFACEIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RoomAirModelType,createRoomAirModelTypeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RoomAir_TemperaturePattern_UserDefined,createRoomAir_TemperaturePattern_UserDefinedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RoomAir_TemperaturePattern_ConstantGradient,createRoomAir_TemperaturePattern_ConstantGradientIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RoomAir_TemperaturePattern_TwoGradient,createRoomAir_TemperaturePattern_TwoGradientIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RoomAir_TemperaturePattern_NondimensionalHeight,createRoomAir_TemperaturePattern_NondimensionalHeightIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RoomAir_TemperaturePattern_SurfaceMapping,createRoomAir_TemperaturePattern_SurfaceMappingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RoomAir_Node,createRoomAir_NodeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RoomAirSettings_OneNodeDisplacementVentilation,createRoomAirSettings_OneNodeDisplacementVentilationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RoomAirSettings_ThreeNodeDisplacementVentilation,createRoomAirSettings_ThreeNodeDisplacementVentilationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RoomAirSettings_CrossVentilation,createRoomAirSettings_CrossVentilationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RoomAirSettings_UnderFloorAirDistributionInterior,createRoomAirSettings_UnderFloorAirDistributionInteriorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RoomAirSettings_UnderFloorAirDistributionExterior,createRoomAirSettings_UnderFloorAirDistributionExteriorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RoomAir_Node_AirflowNetwork,createRoomAir_Node_AirflowNetworkIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RoomAir_Node_AirflowNetwork_AdjacentSurfaceList,createRoomAir_Node_AirflowNetwork_AdjacentSurfaceListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RoomAir_Node_AirflowNetwork_InternalGains,createRoomAir_Node_AirflowNetwork_InternalGainsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RoomAir_Node_AirflowNetwork_HVACEquipment,createRoomAir_Node_AirflowNetwork_HVACEquipmentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::RoomAirSettings_AirflowNetwork,createRoomAirSettings_AirflowNetworkIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::People,createPeopleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ComfortViewFactorAngles,createComfortViewFactorAnglesIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Lights,createLightsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ElectricEquipment,createElectricEquipmentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GasEquipment,createGasEquipmentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HotWaterEquipment,createHotWaterEquipmentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SteamEquipment,createSteamEquipmentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OtherEquipment,createOtherEquipmentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ElectricEquipment_ITE_AirCooled,createElectricEquipment_ITE_AirCooledIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneBaseboard_OutdoorTemperatureControlled,createZoneBaseboard_OutdoorTemperatureControlledIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SwimmingPool_Indoor,createSwimmingPool_IndoorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneContaminantSourceAndSink_CarbonDioxide,createZoneContaminantSourceAndSink_CarbonDioxideIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneContaminantSourceAndSink_Generic_Constant,createZoneContaminantSourceAndSink_Generic_ConstantIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceContaminantSourceAndSink_Generic_PressureDriven,createSurfaceContaminantSourceAndSink_Generic_PressureDrivenIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneContaminantSourceAndSink_Generic_CutoffModel,createZoneContaminantSourceAndSink_Generic_CutoffModelIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneContaminantSourceAndSink_Generic_DecaySource,createZoneContaminantSourceAndSink_Generic_DecaySourceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceContaminantSourceAndSink_Generic_BoundaryLayerDiffusion,createSurfaceContaminantSourceAndSink_Generic_BoundaryLayerDiffusionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SurfaceContaminantSourceAndSink_Generic_DepositionVelocitySink,createSurfaceContaminantSourceAndSink_Generic_DepositionVelocitySinkIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneContaminantSourceAndSink_Generic_DepositionRateSink,createZoneContaminantSourceAndSink_Generic_DepositionRateSinkIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Daylighting_Controls,createDaylighting_ControlsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Daylighting_DELight_Controls,createDaylighting_DELight_ControlsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Daylighting_DELight_ReferencePoint,createDaylighting_DELight_ReferencePointIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Daylighting_DELight_ComplexFenestration,createDaylighting_DELight_ComplexFenestrationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::DaylightingDevice_Tubular,createDaylightingDevice_TubularIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::DaylightingDevice_Shelf,createDaylightingDevice_ShelfIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::DaylightingDevice_LightWell,createDaylightingDevice_LightWellIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_DaylightFactors,createOutput_DaylightFactorsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_IlluminanceMap,createOutput_IlluminanceMapIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OutputControl_IlluminanceMap_Style,createOutputControl_IlluminanceMap_StyleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneInfiltration_DesignFlowRate,createZoneInfiltration_DesignFlowRateIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneInfiltration_EffectiveLeakageArea,createZoneInfiltration_EffectiveLeakageAreaIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneInfiltration_FlowCoefficient,createZoneInfiltration_FlowCoefficientIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneVentilation_DesignFlowRate,createZoneVentilation_DesignFlowRateIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneVentilation_WindandStackOpenArea,createZoneVentilation_WindandStackOpenAreaIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneAirBalance_OutdoorAir,createZoneAirBalance_OutdoorAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneMixing,createZoneMixingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneCrossMixing,createZoneCrossMixingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneRefrigerationDoorMixing,createZoneRefrigerationDoorMixingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneEarthtube,createZoneEarthtubeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneCoolTower_Shower,createZoneCoolTower_ShowerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneThermalChimney,createZoneThermalChimneyIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_SimulationControl,createAirflowNetwork_SimulationControlIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_MultiZone_Zone,createAirflowNetwork_MultiZone_ZoneIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_MultiZone_Surface,createAirflowNetwork_MultiZone_SurfaceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_MultiZone_ReferenceCrackConditions,createAirflowNetwork_MultiZone_ReferenceCrackConditionsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_MultiZone_Surface_Crack,createAirflowNetwork_MultiZone_Surface_CrackIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_MultiZone_Surface_EffectiveLeakageArea,createAirflowNetwork_MultiZone_Surface_EffectiveLeakageAreaIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_MultiZone_Component_DetailedOpening,createAirflowNetwork_MultiZone_Component_DetailedOpeningIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_MultiZone_Component_SimpleOpening,createAirflowNetwork_MultiZone_Component_SimpleOpeningIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_MultiZone_Component_HorizontalOpening,createAirflowNetwork_MultiZone_Component_HorizontalOpeningIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_MultiZone_Component_ZoneExhaustFan,createAirflowNetwork_MultiZone_Component_ZoneExhaustFanIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_MultiZone_ExternalNode,createAirflowNetwork_MultiZone_ExternalNodeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_MultiZone_WindPressureCoefficientArray,createAirflowNetwork_MultiZone_WindPressureCoefficientArrayIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_MultiZone_WindPressureCoefficientValues,createAirflowNetwork_MultiZone_WindPressureCoefficientValuesIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_Distribution_Node,createAirflowNetwork_Distribution_NodeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_Distribution_Component_Leak,createAirflowNetwork_Distribution_Component_LeakIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_Distribution_Component_LeakageRatio,createAirflowNetwork_Distribution_Component_LeakageRatioIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_Distribution_Component_Duct,createAirflowNetwork_Distribution_Component_DuctIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_Distribution_Component_Fan,createAirflowNetwork_Distribution_Component_FanIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_Distribution_Component_Coil,createAirflowNetwork_Distribution_Component_CoilIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_Distribution_Component_HeatExchanger,createAirflowNetwork_Distribution_Component_HeatExchangerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_Distribution_Component_TerminalUnit,createAirflowNetwork_Distribution_Component_TerminalUnitIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_Distribution_Component_ConstantPressureDrop,createAirflowNetwork_Distribution_Component_ConstantPressureDropIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_Distribution_Linkage,createAirflowNetwork_Distribution_LinkageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_OccupantVentilationControl,createAirflowNetwork_OccupantVentilationControlIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirflowNetwork_IntraZone_Linkage,createAirflowNetwork_IntraZone_LinkageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Exterior_Lights,createExterior_LightsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Exterior_FuelEquipment,createExterior_FuelEquipmentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Exterior_WaterEquipment,createExterior_WaterEquipmentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Thermostat,createHVACTemplate_ThermostatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Zone_IdealLoadsAirSystem,createHVACTemplate_Zone_IdealLoadsAirSystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Zone_BaseboardHeat,createHVACTemplate_Zone_BaseboardHeatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Zone_FanCoil,createHVACTemplate_Zone_FanCoilIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Zone_PTAC,createHVACTemplate_Zone_PTACIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Zone_PTHP,createHVACTemplate_Zone_PTHPIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Zone_WaterToAirHeatPump,createHVACTemplate_Zone_WaterToAirHeatPumpIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Zone_VRF,createHVACTemplate_Zone_VRFIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Zone_Unitary,createHVACTemplate_Zone_UnitaryIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Zone_VAV,createHVACTemplate_Zone_VAVIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Zone_VAV_FanPowered,createHVACTemplate_Zone_VAV_FanPoweredIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Zone_VAV_HeatAndCool,createHVACTemplate_Zone_VAV_HeatAndCoolIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Zone_ConstantVolume,createHVACTemplate_Zone_ConstantVolumeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Zone_DualDuct,createHVACTemplate_Zone_DualDuctIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_System_VRF,createHVACTemplate_System_VRFIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_System_Unitary,createHVACTemplate_System_UnitaryIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_System_UnitaryHeatPump_AirToAir,createHVACTemplate_System_UnitaryHeatPump_AirToAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_System_UnitarySystem,createHVACTemplate_System_UnitarySystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_System_VAV,createHVACTemplate_System_VAVIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_System_PackagedVAV,createHVACTemplate_System_PackagedVAVIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_System_ConstantVolume,createHVACTemplate_System_ConstantVolumeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_System_DualDuct,createHVACTemplate_System_DualDuctIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_System_DedicatedOutdoorAir,createHVACTemplate_System_DedicatedOutdoorAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Plant_ChilledWaterLoop,createHVACTemplate_Plant_ChilledWaterLoopIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Plant_Chiller,createHVACTemplate_Plant_ChillerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Plant_Chiller_ObjectReference,createHVACTemplate_Plant_Chiller_ObjectReferenceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Plant_Tower,createHVACTemplate_Plant_TowerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Plant_Tower_ObjectReference,createHVACTemplate_Plant_Tower_ObjectReferenceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Plant_HotWaterLoop,createHVACTemplate_Plant_HotWaterLoopIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Plant_Boiler,createHVACTemplate_Plant_BoilerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Plant_Boiler_ObjectReference,createHVACTemplate_Plant_Boiler_ObjectReferenceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HVACTemplate_Plant_MixedWaterLoop,createHVACTemplate_Plant_MixedWaterLoopIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::DesignSpecification_OutdoorAir,createDesignSpecification_OutdoorAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::DesignSpecification_ZoneAirDistribution,createDesignSpecification_ZoneAirDistributionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Sizing_Parameters,createSizing_ParametersIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Sizing_Zone,createSizing_ZoneIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::DesignSpecification_ZoneHVAC_Sizing,createDesignSpecification_ZoneHVAC_SizingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Sizing_System,createSizing_SystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Sizing_Plant,createSizing_PlantIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OutputControl_Sizing_Style,createOutputControl_Sizing_StyleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneControl_Humidistat,createZoneControl_HumidistatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneControl_Thermostat,createZoneControl_ThermostatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneControl_Thermostat_OperativeTemperature,createZoneControl_Thermostat_OperativeTemperatureIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneControl_Thermostat_ThermalComfort,createZoneControl_Thermostat_ThermalComfortIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneControl_Thermostat_TemperatureAndHumidity,createZoneControl_Thermostat_TemperatureAndHumidityIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ThermostatSetpoint_SingleHeating,createThermostatSetpoint_SingleHeatingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ThermostatSetpoint_SingleCooling,createThermostatSetpoint_SingleCoolingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ThermostatSetpoint_SingleHeatingOrCooling,createThermostatSetpoint_SingleHeatingOrCoolingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ThermostatSetpoint_DualSetpoint,createThermostatSetpoint_DualSetpointIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ThermostatSetpoint_ThermalComfort_Fanger_SingleHeating,createThermostatSetpoint_ThermalComfort_Fanger_SingleHeatingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ThermostatSetpoint_ThermalComfort_Fanger_SingleCooling,createThermostatSetpoint_ThermalComfort_Fanger_SingleCoolingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ThermostatSetpoint_ThermalComfort_Fanger_SingleHeatingOrCooling,createThermostatSetpoint_ThermalComfort_Fanger_SingleHeatingOrCoolingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ThermostatSetpoint_ThermalComfort_Fanger_DualSetpoint,createThermostatSetpoint_ThermalComfort_Fanger_DualSetpointIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneControl_Thermostat_StagedDualSetpoint,createZoneControl_Thermostat_StagedDualSetpointIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneControl_ContaminantController,createZoneControl_ContaminantControllerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_IdealLoadsAirSystem,createZoneHVAC_IdealLoadsAirSystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_FourPipeFanCoil,createZoneHVAC_FourPipeFanCoilIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_WindowAirConditioner,createZoneHVAC_WindowAirConditionerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_PackagedTerminalAirConditioner,createZoneHVAC_PackagedTerminalAirConditionerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_PackagedTerminalHeatPump,createZoneHVAC_PackagedTerminalHeatPumpIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_WaterToAirHeatPump,createZoneHVAC_WaterToAirHeatPumpIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_Dehumidifier_DX,createZoneHVAC_Dehumidifier_DXIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_EnergyRecoveryVentilator,createZoneHVAC_EnergyRecoveryVentilatorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_EnergyRecoveryVentilator_Controller,createZoneHVAC_EnergyRecoveryVentilator_ControllerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_UnitVentilator,createZoneHVAC_UnitVentilatorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_UnitHeater,createZoneHVAC_UnitHeaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_EvaporativeCoolerUnit,createZoneHVAC_EvaporativeCoolerUnitIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_OutdoorAirUnit,createZoneHVAC_OutdoorAirUnitIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_OutdoorAirUnit_EquipmentList,createZoneHVAC_OutdoorAirUnit_EquipmentListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_TerminalUnit_VariableRefrigerantFlow,createZoneHVAC_TerminalUnit_VariableRefrigerantFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_Baseboard_RadiantConvective_Water,createZoneHVAC_Baseboard_RadiantConvective_WaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_Baseboard_RadiantConvective_Steam,createZoneHVAC_Baseboard_RadiantConvective_SteamIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_Baseboard_RadiantConvective_Electric,createZoneHVAC_Baseboard_RadiantConvective_ElectricIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_Baseboard_Convective_Water,createZoneHVAC_Baseboard_Convective_WaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_Baseboard_Convective_Electric,createZoneHVAC_Baseboard_Convective_ElectricIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_LowTemperatureRadiant_VariableFlow,createZoneHVAC_LowTemperatureRadiant_VariableFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_LowTemperatureRadiant_ConstantFlow,createZoneHVAC_LowTemperatureRadiant_ConstantFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_LowTemperatureRadiant_Electric,createZoneHVAC_LowTemperatureRadiant_ElectricIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_LowTemperatureRadiant_SurfaceGroup,createZoneHVAC_LowTemperatureRadiant_SurfaceGroupIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_HighTemperatureRadiant,createZoneHVAC_HighTemperatureRadiantIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_VentilatedSlab,createZoneHVAC_VentilatedSlabIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_VentilatedSlab_SlabGroup,createZoneHVAC_VentilatedSlab_SlabGroupIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirTerminal_SingleDuct_Uncontrolled,createAirTerminal_SingleDuct_UncontrolledIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirTerminal_SingleDuct_ConstantVolume_Reheat,createAirTerminal_SingleDuct_ConstantVolume_ReheatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirTerminal_SingleDuct_VAV_NoReheat,createAirTerminal_SingleDuct_VAV_NoReheatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirTerminal_SingleDuct_VAV_Reheat,createAirTerminal_SingleDuct_VAV_ReheatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirTerminal_SingleDuct_VAV_HeatAndCool_Reheat,createAirTerminal_SingleDuct_VAV_HeatAndCool_ReheatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirTerminal_SingleDuct_VAV_HeatAndCool_NoReheat,createAirTerminal_SingleDuct_VAV_HeatAndCool_NoReheatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirTerminal_SingleDuct_SeriesPIU_Reheat,createAirTerminal_SingleDuct_SeriesPIU_ReheatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirTerminal_SingleDuct_ParallelPIU_Reheat,createAirTerminal_SingleDuct_ParallelPIU_ReheatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirTerminal_SingleDuct_ConstantVolume_FourPipeInduction,createAirTerminal_SingleDuct_ConstantVolume_FourPipeInductionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirTerminal_SingleDuct_ConstantVolume_FourPipeBeam,createAirTerminal_SingleDuct_ConstantVolume_FourPipeBeamIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirTerminal_SingleDuct_ConstantVolume_CooledBeam,createAirTerminal_SingleDuct_ConstantVolume_CooledBeamIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirTerminal_SingleDuct_InletSideMixer,createAirTerminal_SingleDuct_InletSideMixerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirTerminal_SingleDuct_SupplySideMixer,createAirTerminal_SingleDuct_SupplySideMixerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirTerminal_DualDuct_ConstantVolume,createAirTerminal_DualDuct_ConstantVolumeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirTerminal_DualDuct_VAV,createAirTerminal_DualDuct_VAVIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirTerminal_DualDuct_VAV_OutdoorAir,createAirTerminal_DualDuct_VAV_OutdoorAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_AirDistributionUnit,createZoneHVAC_AirDistributionUnitIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_EquipmentList,createZoneHVAC_EquipmentListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_EquipmentConnections,createZoneHVAC_EquipmentConnectionsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Fan_ConstantVolume,createFan_ConstantVolumeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Fan_VariableVolume,createFan_VariableVolumeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Fan_OnOff,createFan_OnOffIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Fan_ZoneExhaust,createFan_ZoneExhaustIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FanPerformance_NightVentilation,createFanPerformance_NightVentilationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Fan_ComponentModel,createFan_ComponentModelIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Cooling_Water,createCoil_Cooling_WaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Cooling_Water_DetailedGeometry,createCoil_Cooling_Water_DetailedGeometryIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Cooling_DX_SingleSpeed,createCoil_Cooling_DX_SingleSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Cooling_DX_TwoSpeed,createCoil_Cooling_DX_TwoSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Cooling_DX_MultiSpeed,createCoil_Cooling_DX_MultiSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Cooling_DX_VariableSpeed,createCoil_Cooling_DX_VariableSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Cooling_DX_TwoStageWithHumidityControlMode,createCoil_Cooling_DX_TwoStageWithHumidityControlModeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::CoilPerformance_DX_Cooling,createCoilPerformance_DX_CoolingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Cooling_DX_VariableRefrigerantFlow,createCoil_Cooling_DX_VariableRefrigerantFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Heating_DX_VariableRefrigerantFlow,createCoil_Heating_DX_VariableRefrigerantFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Cooling_DX_VariableRefrigerantFlow_FluidTemperatureControl,createCoil_Cooling_DX_VariableRefrigerantFlow_FluidTemperatureControlIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Heating_DX_VariableRefrigerantFlow_FluidTemperatureControl,createCoil_Heating_DX_VariableRefrigerantFlow_FluidTemperatureControlIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Heating_Water,createCoil_Heating_WaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Heating_Steam,createCoil_Heating_SteamIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Heating_Electric,createCoil_Heating_ElectricIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Heating_Electric_MultiStage,createCoil_Heating_Electric_MultiStageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Heating_Gas,createCoil_Heating_GasIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Heating_Gas_MultiStage,createCoil_Heating_Gas_MultiStageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Heating_Desuperheater,createCoil_Heating_DesuperheaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Heating_DX_SingleSpeed,createCoil_Heating_DX_SingleSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Heating_DX_MultiSpeed,createCoil_Heating_DX_MultiSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Heating_DX_VariableSpeed,createCoil_Heating_DX_VariableSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Cooling_WaterToAirHeatPump_ParameterEstimation,createCoil_Cooling_WaterToAirHeatPump_ParameterEstimationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Heating_WaterToAirHeatPump_ParameterEstimation,createCoil_Heating_WaterToAirHeatPump_ParameterEstimationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Cooling_WaterToAirHeatPump_EquationFit,createCoil_Cooling_WaterToAirHeatPump_EquationFitIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Cooling_WaterToAirHeatPump_VariableSpeedEquationFit,createCoil_Cooling_WaterToAirHeatPump_VariableSpeedEquationFitIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Heating_WaterToAirHeatPump_EquationFit,createCoil_Heating_WaterToAirHeatPump_EquationFitIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Heating_WaterToAirHeatPump_VariableSpeedEquationFit,createCoil_Heating_WaterToAirHeatPump_VariableSpeedEquationFitIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_WaterHeating_AirToWaterHeatPump_Pumped,createCoil_WaterHeating_AirToWaterHeatPump_PumpedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_WaterHeating_AirToWaterHeatPump_Wrapped,createCoil_WaterHeating_AirToWaterHeatPump_WrappedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_WaterHeating_AirToWaterHeatPump_VariableSpeed,createCoil_WaterHeating_AirToWaterHeatPump_VariableSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_WaterHeating_Desuperheater,createCoil_WaterHeating_DesuperheaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::CoilSystem_Cooling_DX,createCoilSystem_Cooling_DXIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::CoilSystem_Heating_DX,createCoilSystem_Heating_DXIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::CoilSystem_Cooling_Water_HeatExchangerAssisted,createCoilSystem_Cooling_Water_HeatExchangerAssistedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::CoilSystem_Cooling_DX_HeatExchangerAssisted,createCoilSystem_Cooling_DX_HeatExchangerAssistedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_Cooling_DX_SingleSpeed_ThermalStorage,createCoil_Cooling_DX_SingleSpeed_ThermalStorageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EvaporativeCooler_Direct_CelDekPad,createEvaporativeCooler_Direct_CelDekPadIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EvaporativeCooler_Indirect_CelDekPad,createEvaporativeCooler_Indirect_CelDekPadIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EvaporativeCooler_Indirect_WetCoil,createEvaporativeCooler_Indirect_WetCoilIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EvaporativeCooler_Indirect_ResearchSpecial,createEvaporativeCooler_Indirect_ResearchSpecialIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EvaporativeCooler_Direct_ResearchSpecial,createEvaporativeCooler_Direct_ResearchSpecialIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Humidifier_Steam_Electric,createHumidifier_Steam_ElectricIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Humidifier_Steam_Gas,createHumidifier_Steam_GasIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Dehumidifier_Desiccant_NoFans,createDehumidifier_Desiccant_NoFansIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Dehumidifier_Desiccant_System,createDehumidifier_Desiccant_SystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HeatExchanger_AirToAir_FlatPlate,createHeatExchanger_AirToAir_FlatPlateIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HeatExchanger_AirToAir_SensibleAndLatent,createHeatExchanger_AirToAir_SensibleAndLatentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HeatExchanger_Desiccant_BalancedFlow,createHeatExchanger_Desiccant_BalancedFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HeatExchanger_Desiccant_BalancedFlow_PerformanceDataType1,createHeatExchanger_Desiccant_BalancedFlow_PerformanceDataType1IddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirLoopHVAC_UnitarySystem,createAirLoopHVAC_UnitarySystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::UnitarySystemPerformance_Multispeed,createUnitarySystemPerformance_MultispeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirLoopHVAC_Unitary_Furnace_HeatOnly,createAirLoopHVAC_Unitary_Furnace_HeatOnlyIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirLoopHVAC_Unitary_Furnace_HeatCool,createAirLoopHVAC_Unitary_Furnace_HeatCoolIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirLoopHVAC_UnitaryHeatOnly,createAirLoopHVAC_UnitaryHeatOnlyIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirLoopHVAC_UnitaryHeatCool,createAirLoopHVAC_UnitaryHeatCoolIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirLoopHVAC_UnitaryHeatPump_AirToAir,createAirLoopHVAC_UnitaryHeatPump_AirToAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirLoopHVAC_UnitaryHeatPump_WaterToAir,createAirLoopHVAC_UnitaryHeatPump_WaterToAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirLoopHVAC_UnitaryHeatCool_VAVChangeoverBypass,createAirLoopHVAC_UnitaryHeatCool_VAVChangeoverBypassIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirLoopHVAC_UnitaryHeatPump_AirToAir_MultiSpeed,createAirLoopHVAC_UnitaryHeatPump_AirToAir_MultiSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirConditioner_VariableRefrigerantFlow,createAirConditioner_VariableRefrigerantFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirConditioner_VariableRefrigerantFlow_FluidTemperatureControl,createAirConditioner_VariableRefrigerantFlow_FluidTemperatureControlIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneTerminalUnitList,createZoneTerminalUnitListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Controller_WaterCoil,createController_WaterCoilIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Controller_OutdoorAir,createController_OutdoorAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Controller_MechanicalVentilation,createController_MechanicalVentilationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirLoopHVAC_ControllerList,createAirLoopHVAC_ControllerListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirLoopHVAC,createAirLoopHVACIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirLoopHVAC_OutdoorAirSystem_EquipmentList,createAirLoopHVAC_OutdoorAirSystem_EquipmentListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirLoopHVAC_OutdoorAirSystem,createAirLoopHVAC_OutdoorAirSystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OutdoorAir_Mixer,createOutdoorAir_MixerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirLoopHVAC_ZoneSplitter,createAirLoopHVAC_ZoneSplitterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirLoopHVAC_SupplyPlenum,createAirLoopHVAC_SupplyPlenumIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirLoopHVAC_SupplyPath,createAirLoopHVAC_SupplyPathIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirLoopHVAC_ZoneMixer,createAirLoopHVAC_ZoneMixerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirLoopHVAC_ReturnPlenum,createAirLoopHVAC_ReturnPlenumIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirLoopHVAC_ReturnPath,createAirLoopHVAC_ReturnPathIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Branch,createBranchIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::BranchList,createBranchListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Connector_Splitter,createConnector_SplitterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Connector_Mixer,createConnector_MixerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ConnectorList,createConnectorListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::NodeList,createNodeListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OutdoorAir_Node,createOutdoorAir_NodeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OutdoorAir_NodeList,createOutdoorAir_NodeListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Pipe_Adiabatic,createPipe_AdiabaticIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Pipe_Adiabatic_Steam,createPipe_Adiabatic_SteamIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Pipe_Indoor,createPipe_IndoorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Pipe_Outdoor,createPipe_OutdoorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Pipe_Underground,createPipe_UndergroundIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PipingSystem_Underground_Domain,createPipingSystem_Underground_DomainIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PipingSystem_Underground_PipeCircuit,createPipingSystem_Underground_PipeCircuitIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PipingSystem_Underground_PipeSegment,createPipingSystem_Underground_PipeSegmentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Duct,createDuctIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Pump_VariableSpeed,createPump_VariableSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Pump_ConstantSpeed,createPump_ConstantSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Pump_VariableSpeed_Condensate,createPump_VariableSpeed_CondensateIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HeaderedPumps_ConstantSpeed,createHeaderedPumps_ConstantSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HeaderedPumps_VariableSpeed,createHeaderedPumps_VariableSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::TemperingValve,createTemperingValveIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::LoadProfile_Plant,createLoadProfile_PlantIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SolarCollectorPerformance_FlatPlate,createSolarCollectorPerformance_FlatPlateIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SolarCollector_FlatPlate_Water,createSolarCollector_FlatPlate_WaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SolarCollector_FlatPlate_PhotovoltaicThermal,createSolarCollector_FlatPlate_PhotovoltaicThermalIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SolarCollector_IntegralCollectorStorage,createSolarCollector_IntegralCollectorStorageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SolarCollectorPerformance_IntegralCollectorStorage,createSolarCollectorPerformance_IntegralCollectorStorageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SolarCollector_UnglazedTranspired,createSolarCollector_UnglazedTranspiredIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SolarCollectorPerformance_PhotovoltaicThermal_Simple,createSolarCollectorPerformance_PhotovoltaicThermal_SimpleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SolarCollector_UnglazedTranspired_Multisystem,createSolarCollector_UnglazedTranspired_MultisystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Boiler_HotWater,createBoiler_HotWaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Boiler_Steam,createBoiler_SteamIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Chiller_Electric_EIR,createChiller_Electric_EIRIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Chiller_Electric_ReformulatedEIR,createChiller_Electric_ReformulatedEIRIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Chiller_Electric,createChiller_ElectricIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Chiller_Absorption_Indirect,createChiller_Absorption_IndirectIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Chiller_Absorption,createChiller_AbsorptionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Chiller_ConstantCOP,createChiller_ConstantCOPIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Chiller_EngineDriven,createChiller_EngineDrivenIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Chiller_CombustionTurbine,createChiller_CombustionTurbineIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ChillerHeater_Absorption_DirectFired,createChillerHeater_Absorption_DirectFiredIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ChillerHeater_Absorption_DoubleEffect,createChillerHeater_Absorption_DoubleEffectIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HeatPump_WaterToWater_EquationFit_Heating,createHeatPump_WaterToWater_EquationFit_HeatingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HeatPump_WaterToWater_EquationFit_Cooling,createHeatPump_WaterToWater_EquationFit_CoolingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HeatPump_WaterToWater_ParameterEstimation_Cooling,createHeatPump_WaterToWater_ParameterEstimation_CoolingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HeatPump_WaterToWater_ParameterEstimation_Heating,createHeatPump_WaterToWater_ParameterEstimation_HeatingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::DistrictCooling,createDistrictCoolingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::DistrictHeating,createDistrictHeatingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PlantComponent_TemperatureSource,createPlantComponent_TemperatureSourceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::CentralHeatPumpSystem,createCentralHeatPumpSystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ChillerHeaterPerformance_Electric_EIR,createChillerHeaterPerformance_Electric_EIRIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::CoolingTower_SingleSpeed,createCoolingTower_SingleSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::CoolingTower_TwoSpeed,createCoolingTower_TwoSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::CoolingTower_VariableSpeed_Merkel,createCoolingTower_VariableSpeed_MerkelIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::CoolingTower_VariableSpeed,createCoolingTower_VariableSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::CoolingTowerPerformance_CoolTools,createCoolingTowerPerformance_CoolToolsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::CoolingTowerPerformance_YorkCalc,createCoolingTowerPerformance_YorkCalcIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EvaporativeFluidCooler_SingleSpeed,createEvaporativeFluidCooler_SingleSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EvaporativeFluidCooler_TwoSpeed,createEvaporativeFluidCooler_TwoSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FluidCooler_SingleSpeed,createFluidCooler_SingleSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FluidCooler_TwoSpeed,createFluidCooler_TwoSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatExchanger_Vertical,createGroundHeatExchanger_VerticalIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatExchanger_Pond,createGroundHeatExchanger_PondIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatExchanger_Surface,createGroundHeatExchanger_SurfaceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatExchanger_HorizontalTrench,createGroundHeatExchanger_HorizontalTrenchIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::GroundHeatExchanger_Slinky,createGroundHeatExchanger_SlinkyIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::HeatExchanger_FluidToFluid,createHeatExchanger_FluidToFluidIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WaterHeater_Mixed,createWaterHeater_MixedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WaterHeater_Stratified,createWaterHeater_StratifiedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WaterHeater_Sizing,createWaterHeater_SizingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WaterHeater_HeatPump_PumpedCondenser,createWaterHeater_HeatPump_PumpedCondenserIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WaterHeater_HeatPump_WrappedCondenser,createWaterHeater_HeatPump_WrappedCondenserIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ThermalStorage_Ice_Simple,createThermalStorage_Ice_SimpleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ThermalStorage_Ice_Detailed,createThermalStorage_Ice_DetailedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ThermalStorage_ChilledWater_Mixed,createThermalStorage_ChilledWater_MixedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ThermalStorage_ChilledWater_Stratified,createThermalStorage_ChilledWater_StratifiedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PlantLoop,createPlantLoopIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::CondenserLoop,createCondenserLoopIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PlantEquipmentList,createPlantEquipmentListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::CondenserEquipmentList,createCondenserEquipmentListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PlantEquipmentOperation_Uncontrolled,createPlantEquipmentOperation_UncontrolledIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PlantEquipmentOperation_CoolingLoad,createPlantEquipmentOperation_CoolingLoadIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PlantEquipmentOperation_HeatingLoad,createPlantEquipmentOperation_HeatingLoadIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PlantEquipmentOperation_OutdoorDryBulb,createPlantEquipmentOperation_OutdoorDryBulbIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PlantEquipmentOperation_OutdoorWetBulb,createPlantEquipmentOperation_OutdoorWetBulbIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PlantEquipmentOperation_OutdoorRelativeHumidity,createPlantEquipmentOperation_OutdoorRelativeHumidityIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PlantEquipmentOperation_OutdoorDewpoint,createPlantEquipmentOperation_OutdoorDewpointIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PlantEquipmentOperation_ComponentSetpoint,createPlantEquipmentOperation_ComponentSetpointIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PlantEquipmentOperation_ThermalEnergyStorage,createPlantEquipmentOperation_ThermalEnergyStorageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PlantEquipmentOperation_OutdoorDryBulbDifference,createPlantEquipmentOperation_OutdoorDryBulbDifferenceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PlantEquipmentOperation_OutdoorWetBulbDifference,createPlantEquipmentOperation_OutdoorWetBulbDifferenceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PlantEquipmentOperation_OutdoorDewpointDifference,createPlantEquipmentOperation_OutdoorDewpointDifferenceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PlantEquipmentOperationSchemes,createPlantEquipmentOperationSchemesIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::CondenserEquipmentOperationSchemes,createCondenserEquipmentOperationSchemesIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EnergyManagementSystem_Sensor,createEnergyManagementSystem_SensorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EnergyManagementSystem_Actuator,createEnergyManagementSystem_ActuatorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EnergyManagementSystem_ProgramCallingManager,createEnergyManagementSystem_ProgramCallingManagerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EnergyManagementSystem_Program,createEnergyManagementSystem_ProgramIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EnergyManagementSystem_Subroutine,createEnergyManagementSystem_SubroutineIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EnergyManagementSystem_GlobalVariable,createEnergyManagementSystem_GlobalVariableIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EnergyManagementSystem_OutputVariable,createEnergyManagementSystem_OutputVariableIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EnergyManagementSystem_MeteredOutputVariable,createEnergyManagementSystem_MeteredOutputVariableIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EnergyManagementSystem_TrendVariable,createEnergyManagementSystem_TrendVariableIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EnergyManagementSystem_InternalVariable,createEnergyManagementSystem_InternalVariableIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EnergyManagementSystem_CurveOrTableIndexVariable,createEnergyManagementSystem_CurveOrTableIndexVariableIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EnergyManagementSystem_ConstructionIndexVariable,createEnergyManagementSystem_ConstructionIndexVariableIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ExternalInterface,createExternalInterfaceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ExternalInterface_Schedule,createExternalInterface_ScheduleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ExternalInterface_Variable,createExternalInterface_VariableIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ExternalInterface_Actuator,createExternalInterface_ActuatorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ExternalInterface_FunctionalMockupUnitImport,createExternalInterface_FunctionalMockupUnitImportIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ExternalInterface_FunctionalMockupUnitImport_From_Variable,createExternalInterface_FunctionalMockupUnitImport_From_VariableIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ExternalInterface_FunctionalMockupUnitImport_To_Schedule,createExternalInterface_FunctionalMockupUnitImport_To_ScheduleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ExternalInterface_FunctionalMockupUnitImport_To_Actuator,createExternalInterface_FunctionalMockupUnitImport_To_ActuatorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ExternalInterface_FunctionalMockupUnitImport_To_Variable,createExternalInterface_FunctionalMockupUnitImport_To_VariableIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ExternalInterface_FunctionalMockupUnitExport_From_Variable,createExternalInterface_FunctionalMockupUnitExport_From_VariableIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ExternalInterface_FunctionalMockupUnitExport_To_Schedule,createExternalInterface_FunctionalMockupUnitExport_To_ScheduleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ExternalInterface_FunctionalMockupUnitExport_To_Actuator,createExternalInterface_FunctionalMockupUnitExport_To_ActuatorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ExternalInterface_FunctionalMockupUnitExport_To_Variable,createExternalInterface_FunctionalMockupUnitExport_To_VariableIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_ForcedAir_UserDefined,createZoneHVAC_ForcedAir_UserDefinedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AirTerminal_SingleDuct_UserDefined,createAirTerminal_SingleDuct_UserDefinedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Coil_UserDefined,createCoil_UserDefinedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PlantComponent_UserDefined,createPlantComponent_UserDefinedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PlantEquipmentOperation_UserDefined,createPlantEquipmentOperation_UserDefinedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AvailabilityManager_Scheduled,createAvailabilityManager_ScheduledIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AvailabilityManager_ScheduledOn,createAvailabilityManager_ScheduledOnIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AvailabilityManager_ScheduledOff,createAvailabilityManager_ScheduledOffIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AvailabilityManager_OptimumStart,createAvailabilityManager_OptimumStartIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AvailabilityManager_NightCycle,createAvailabilityManager_NightCycleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AvailabilityManager_DifferentialThermostat,createAvailabilityManager_DifferentialThermostatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AvailabilityManager_HighTemperatureTurnOff,createAvailabilityManager_HighTemperatureTurnOffIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AvailabilityManager_HighTemperatureTurnOn,createAvailabilityManager_HighTemperatureTurnOnIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AvailabilityManager_LowTemperatureTurnOff,createAvailabilityManager_LowTemperatureTurnOffIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AvailabilityManager_LowTemperatureTurnOn,createAvailabilityManager_LowTemperatureTurnOnIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AvailabilityManager_NightVentilation,createAvailabilityManager_NightVentilationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AvailabilityManager_HybridVentilation,createAvailabilityManager_HybridVentilationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::AvailabilityManagerAssignmentList,createAvailabilityManagerAssignmentListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_Scheduled,createSetpointManager_ScheduledIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_Scheduled_DualSetpoint,createSetpointManager_Scheduled_DualSetpointIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_OutdoorAirReset,createSetpointManager_OutdoorAirResetIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_SingleZone_Reheat,createSetpointManager_SingleZone_ReheatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_SingleZone_Heating,createSetpointManager_SingleZone_HeatingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_SingleZone_Cooling,createSetpointManager_SingleZone_CoolingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_SingleZone_Humidity_Minimum,createSetpointManager_SingleZone_Humidity_MinimumIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_SingleZone_Humidity_Maximum,createSetpointManager_SingleZone_Humidity_MaximumIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_MixedAir,createSetpointManager_MixedAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_OutdoorAirPretreat,createSetpointManager_OutdoorAirPretreatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_Warmest,createSetpointManager_WarmestIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_Coldest,createSetpointManager_ColdestIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_ReturnAirBypassFlow,createSetpointManager_ReturnAirBypassFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_WarmestTemperatureFlow,createSetpointManager_WarmestTemperatureFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_MultiZone_Heating_Average,createSetpointManager_MultiZone_Heating_AverageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_MultiZone_Cooling_Average,createSetpointManager_MultiZone_Cooling_AverageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_MultiZone_MinimumHumidity_Average,createSetpointManager_MultiZone_MinimumHumidity_AverageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_MultiZone_MaximumHumidity_Average,createSetpointManager_MultiZone_MaximumHumidity_AverageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_MultiZone_Humidity_Minimum,createSetpointManager_MultiZone_Humidity_MinimumIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_MultiZone_Humidity_Maximum,createSetpointManager_MultiZone_Humidity_MaximumIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_FollowOutdoorAirTemperature,createSetpointManager_FollowOutdoorAirTemperatureIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_FollowSystemNodeTemperature,createSetpointManager_FollowSystemNodeTemperatureIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_FollowGroundTemperature,createSetpointManager_FollowGroundTemperatureIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_CondenserEnteringReset,createSetpointManager_CondenserEnteringResetIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_CondenserEnteringReset_Ideal,createSetpointManager_CondenserEnteringReset_IdealIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_SingleZone_OneStageCooling,createSetpointManager_SingleZone_OneStageCoolingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_SingleZone_OneStageHeating,createSetpointManager_SingleZone_OneStageHeatingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_ReturnTemperature_ChilledWater,createSetpointManager_ReturnTemperature_ChilledWaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::SetpointManager_ReturnTemperature_HotWater,createSetpointManager_ReturnTemperature_HotWaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Refrigeration_Case,createRefrigeration_CaseIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Refrigeration_CompressorRack,createRefrigeration_CompressorRackIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Refrigeration_CaseAndWalkInList,createRefrigeration_CaseAndWalkInListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Refrigeration_Condenser_AirCooled,createRefrigeration_Condenser_AirCooledIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Refrigeration_Condenser_EvaporativeCooled,createRefrigeration_Condenser_EvaporativeCooledIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Refrigeration_Condenser_WaterCooled,createRefrigeration_Condenser_WaterCooledIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Refrigeration_Condenser_Cascade,createRefrigeration_Condenser_CascadeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Refrigeration_GasCooler_AirCooled,createRefrigeration_GasCooler_AirCooledIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Refrigeration_TransferLoadList,createRefrigeration_TransferLoadListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Refrigeration_Subcooler,createRefrigeration_SubcoolerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Refrigeration_Compressor,createRefrigeration_CompressorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Refrigeration_CompressorList,createRefrigeration_CompressorListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Refrigeration_System,createRefrigeration_SystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Refrigeration_TranscriticalSystem,createRefrigeration_TranscriticalSystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Refrigeration_SecondarySystem,createRefrigeration_SecondarySystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Refrigeration_WalkIn,createRefrigeration_WalkInIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Refrigeration_AirChiller,createRefrigeration_AirChillerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ZoneHVAC_RefrigerationChillerSet,createZoneHVAC_RefrigerationChillerSetIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::DemandManagerAssignmentList,createDemandManagerAssignmentListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::DemandManager_ExteriorLights,createDemandManager_ExteriorLightsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::DemandManager_Lights,createDemandManager_LightsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::DemandManager_ElectricEquipment,createDemandManager_ElectricEquipmentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::DemandManager_Thermostats,createDemandManager_ThermostatsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::DemandManager_Ventilation,createDemandManager_VentilationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Generator_InternalCombustionEngine,createGenerator_InternalCombustionEngineIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Generator_CombustionTurbine,createGenerator_CombustionTurbineIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Generator_MicroTurbine,createGenerator_MicroTurbineIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Generator_Photovoltaic,createGenerator_PhotovoltaicIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PhotovoltaicPerformance_Simple,createPhotovoltaicPerformance_SimpleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PhotovoltaicPerformance_EquivalentOneDiode,createPhotovoltaicPerformance_EquivalentOneDiodeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::PhotovoltaicPerformance_Sandia,createPhotovoltaicPerformance_SandiaIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Generator_FuelCell,createGenerator_FuelCellIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Generator_FuelCell_PowerModule,createGenerator_FuelCell_PowerModuleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Generator_FuelCell_AirSupply,createGenerator_FuelCell_AirSupplyIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Generator_FuelCell_WaterSupply,createGenerator_FuelCell_WaterSupplyIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Generator_FuelCell_AuxiliaryHeater,createGenerator_FuelCell_AuxiliaryHeaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Generator_FuelCell_ExhaustGasToWaterHeatExchanger,createGenerator_FuelCell_ExhaustGasToWaterHeatExchangerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Generator_FuelCell_ElectricalStorage,createGenerator_FuelCell_ElectricalStorageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Generator_FuelCell_Inverter,createGenerator_FuelCell_InverterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Generator_FuelCell_StackCooler,createGenerator_FuelCell_StackCoolerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Generator_MicroCHP,createGenerator_MicroCHPIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Generator_MicroCHP_NonNormalizedParameters,createGenerator_MicroCHP_NonNormalizedParametersIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Generator_FuelSupply,createGenerator_FuelSupplyIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Generator_WindTurbine,createGenerator_WindTurbineIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ElectricLoadCenter_Generators,createElectricLoadCenter_GeneratorsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ElectricLoadCenter_Inverter_Simple,createElectricLoadCenter_Inverter_SimpleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ElectricLoadCenter_Inverter_FunctionOfPower,createElectricLoadCenter_Inverter_FunctionOfPowerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ElectricLoadCenter_Inverter_LookUpTable,createElectricLoadCenter_Inverter_LookUpTableIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ElectricLoadCenter_Storage_Simple,createElectricLoadCenter_Storage_SimpleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ElectricLoadCenter_Storage_Battery,createElectricLoadCenter_Storage_BatteryIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ElectricLoadCenter_Transformer,createElectricLoadCenter_TransformerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ElectricLoadCenter_Distribution,createElectricLoadCenter_DistributionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ElectricLoadCenter_Storage_Converter,createElectricLoadCenter_Storage_ConverterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WaterUse_Equipment,createWaterUse_EquipmentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WaterUse_Connections,createWaterUse_ConnectionsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WaterUse_Storage,createWaterUse_StorageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WaterUse_Well,createWaterUse_WellIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::WaterUse_RainCollector,createWaterUse_RainCollectorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FaultModel_TemperatureSensorOffset_OutdoorAir,createFaultModel_TemperatureSensorOffset_OutdoorAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FaultModel_HumiditySensorOffset_OutdoorAir,createFaultModel_HumiditySensorOffset_OutdoorAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FaultModel_EnthalpySensorOffset_OutdoorAir,createFaultModel_EnthalpySensorOffset_OutdoorAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FaultModel_PressureSensorOffset_OutdoorAir,createFaultModel_PressureSensorOffset_OutdoorAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FaultModel_TemperatureSensorOffset_ReturnAir,createFaultModel_TemperatureSensorOffset_ReturnAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FaultModel_EnthalpySensorOffset_ReturnAir,createFaultModel_EnthalpySensorOffset_ReturnAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FaultModel_ThermostatOffset,createFaultModel_ThermostatOffsetIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FaultModel_HumidistatOffset,createFaultModel_HumidistatOffsetIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FaultModel_Fouling_AirFilter,createFaultModel_Fouling_AirFilterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FaultModel_Fouling_Coil,createFaultModel_Fouling_CoilIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Matrix_TwoDimension,createMatrix_TwoDimensionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_Linear,createCurve_LinearIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_QuadLinear,createCurve_QuadLinearIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_Quadratic,createCurve_QuadraticIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_Cubic,createCurve_CubicIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_Quartic,createCurve_QuarticIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_Exponent,createCurve_ExponentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_Bicubic,createCurve_BicubicIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_Biquadratic,createCurve_BiquadraticIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_QuadraticLinear,createCurve_QuadraticLinearIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_CubicLinear,createCurve_CubicLinearIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_Triquadratic,createCurve_TriquadraticIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_Functional_PressureDrop,createCurve_Functional_PressureDropIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_FanPressureRise,createCurve_FanPressureRiseIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_ExponentialSkewNormal,createCurve_ExponentialSkewNormalIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_Sigmoid,createCurve_SigmoidIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_RectangularHyperbola1,createCurve_RectangularHyperbola1IddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_RectangularHyperbola2,createCurve_RectangularHyperbola2IddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_ExponentialDecay,createCurve_ExponentialDecayIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_DoubleExponentialDecay,createCurve_DoubleExponentialDecayIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Curve_ChillerPartLoadWithLift,createCurve_ChillerPartLoadWithLiftIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Table_OneIndependentVariable,createTable_OneIndependentVariableIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Table_TwoIndependentVariables,createTable_TwoIndependentVariablesIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Table_MultiVariableLookup,createTable_MultiVariableLookupIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FluidProperties_Name,createFluidProperties_NameIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FluidProperties_GlycolConcentration,createFluidProperties_GlycolConcentrationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FluidProperties_Temperatures,createFluidProperties_TemperaturesIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FluidProperties_Saturated,createFluidProperties_SaturatedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FluidProperties_Superheated,createFluidProperties_SuperheatedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FluidProperties_Concentration,createFluidProperties_ConcentrationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::CurrencyType,createCurrencyTypeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ComponentCost_Adjustments,createComponentCost_AdjustmentsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ComponentCost_Reference,createComponentCost_ReferenceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::ComponentCost_LineItem,createComponentCost_LineItemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::UtilityCost_Tariff,createUtilityCost_TariffIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::UtilityCost_Qualify,createUtilityCost_QualifyIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::UtilityCost_Charge_Simple,createUtilityCost_Charge_SimpleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::UtilityCost_Charge_Block,createUtilityCost_Charge_BlockIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::UtilityCost_Ratchet,createUtilityCost_RatchetIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::UtilityCost_Variable,createUtilityCost_VariableIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::UtilityCost_Computation,createUtilityCost_ComputationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::LifeCycleCost_Parameters,createLifeCycleCost_ParametersIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::LifeCycleCost_RecurringCosts,createLifeCycleCost_RecurringCostsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::LifeCycleCost_NonrecurringCost,createLifeCycleCost_NonrecurringCostIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::LifeCycleCost_UsePriceEscalation,createLifeCycleCost_UsePriceEscalationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::LifeCycleCost_UseAdjustment,createLifeCycleCost_UseAdjustmentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Parametric_SetValueForRun,createParametric_SetValueForRunIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Parametric_Logic,createParametric_LogicIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Parametric_RunControl,createParametric_RunControlIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Parametric_FileNameSuffix,createParametric_FileNameSuffixIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_VariableDictionary,createOutput_VariableDictionaryIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_Surfaces_List,createOutput_Surfaces_ListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_Surfaces_Drawing,createOutput_Surfaces_DrawingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_Schedules,createOutput_SchedulesIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_Constructions,createOutput_ConstructionsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_EnergyManagementSystem,createOutput_EnergyManagementSystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OutputControl_SurfaceColorScheme,createOutputControl_SurfaceColorSchemeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_Table_SummaryReports,createOutput_Table_SummaryReportsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_Table_TimeBins,createOutput_Table_TimeBinsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_Table_Monthly,createOutput_Table_MonthlyIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_Table_Annual,createOutput_Table_AnnualIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OutputControl_Table_Style,createOutputControl_Table_StyleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OutputControl_ReportingTolerances,createOutputControl_ReportingTolerancesIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_Variable,createOutput_VariableIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_Meter,createOutput_MeterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_Meter_MeterFileOnly,createOutput_Meter_MeterFileOnlyIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_Meter_Cumulative,createOutput_Meter_CumulativeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_Meter_Cumulative_MeterFileOnly,createOutput_Meter_Cumulative_MeterFileOnlyIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Meter_Custom,createMeter_CustomIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Meter_CustomDecrement,createMeter_CustomDecrementIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_SQLite,createOutput_SQLiteIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_EnvironmentalImpactFactors,createOutput_EnvironmentalImpactFactorsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::EnvironmentalImpactFactors,createEnvironmentalImpactFactorsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::FuelFactors,createFuelFactorsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_Diagnostics,createOutput_DiagnosticsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_DebuggingData,createOutput_DebuggingDataIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::Output_PreprocessorMessage,createOutput_PreprocessorMessageIddObject));
}


} // openstudio
