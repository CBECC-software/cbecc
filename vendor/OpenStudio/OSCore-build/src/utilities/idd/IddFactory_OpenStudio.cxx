/**********************************************************************
*  Copyright (c) 2008-2016, Alliance for Sustainable Energy.
*  All rights reserved.
*
*  This library is free software; you can redistribute it and/or
*  modify it under the terms of the GNU Lesser General Public
*  License as published by the Free Software Foundation; either
*  version 2.1 of the License, or (at your option) any later version.
*
*  This library is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*  Lesser General Public License for more details.
*
*  You should have received a copy of the GNU Lesser General Public
*  License along with this library; if not, write to the Free Software
*  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
**********************************************************************/

#include <utilities/idd/IddFactory.hxx>
#include <utilities/idd/IddEnums.hxx>

#include <utilities/core/Assert.hpp>
#include <utilities/core/Compare.hpp>

#include <QMutexLocker>

namespace openstudio {

IddObject createOS_VersionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Version,\n";
    ss << "\\unique-object\n";
    ss << "\\required-object\n";
    ss << "\\format singleLine\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2; \\field Version Identifier\n";
    ss << "\\type alpha\n";
    ss << "\\default 0.7.5\n";

    IddObjectType objType(IddObjectType::OS_Version);
    OptionalIddObject oObj = IddObject::load("OS:Version",
                                             "OpenStudio Core",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Version);
  return object;
}

IddObject createOS_ComponentDataIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ComponentData,\n";
    ss << "\\memo Defines the meta-data and contents of a Component, that is, a\n";
    ss << "\\memo subset of an OpenStudio Model.\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 7\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note This should be the name of the Component as listed in the\n";
    ss << "\\note Component Library.\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ComponentNames\n";
    ss << "A3, \\field UUID\n";
    ss << "\\note This is a UUID that follows the Component throughout its life,\n";
    ss << "\\note both in Models and in the Component Library.\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A4, \\field Version UUID\n";
    ss << "\\note This UUID should be changed whenever the Component is modified.\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A5, \\field Creation Timestamp\n";
    ss << "\\note Unix timestamp from January 1, 1970 00:00 GMT, in seconds.\n";
    ss << "\\type integer\n";
    ss << "A6, \\field Version Timestamp\n";
    ss << "\\note Unix timestamp from January 1, 1970 00:00 GMT, in seconds.\n";
    ss << "\\type integer\n";
    ss << "A7; \\field Name of Object\n";
    ss << "\\note The first object listed should be the primary object, which\n";
    ss << "\\note indicates the overall Component type.\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\object-list AllObjects\n";

    IddObjectType objType(IddObjectType::OS_ComponentData);
    OptionalIddObject oObj = IddObject::load("OS:ComponentData",
                                             "OpenStudio Core",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ComponentData);
  return object;
}

IddObject createOS_ConvergenceLimitsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ConvergenceLimits,\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "N1, \\field Minimum System Timestep\n";
    ss << "\\note 0 sets the minimum to the zone timestep (ref: Timestep)\n";
    ss << "\\note 1 is normal (ratchet down to 1 minute)\n";
    ss << "\\note setting greater than zone timestep (in minutes) will effectively set to zone timestep\n";
    ss << "\\type integer\n";
    ss << "\\units minutes\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 60\n";
    ss << "N2, \\field Maximum HVAC Iterations\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 20\n";
    ss << "N3, \\field Minimum Plant Iterations\n";
    ss << "\\note Controls the minimum number of plant system solver iterations within a single HVAC iteration\n";
    ss << "\\note Larger values will increase runtime but might improve solution accuracy for complicated plant systems\n";
    ss << "\\note Complex plants include: several interconnected loops, heat recovery, thermal load following generators, etc.\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 2\n";
    ss << "N4; \\field Maximum Plant Iterations\n";
    ss << "\\note Controls the maximum number of plant system solver iterations within a single HVAC iteration\n";
    ss << "\\note Smaller values might decrease runtime but could decrease solution accuracy for complicated plant systems\n";
    ss << "\\type integer\n";
    ss << "\\minimum 2\n";
    ss << "\\default 8\n";

    IddObjectType objType(IddObjectType::OS_ConvergenceLimits);
    OptionalIddObject oObj = IddObject::load("OS:ConvergenceLimits",
                                             "OpenStudio Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ConvergenceLimits);
  return object;
}

IddObject createOS_ProgramControlIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ProgramControl,\n";
    ss << "\\memo used to support various efforts in time reduction for simulation including threading\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "N1; \\field Number of Threads Allowed\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\note This is currently used only in the Interior Radiant Exchange module -- view factors on # surfaces\n";
    ss << "\\note if value is 0, then maximum number allowed will be used.\n";

    IddObjectType objType(IddObjectType::OS_ProgramControl);
    OptionalIddObject oObj = IddObject::load("OS:ProgramControl",
                                             "OpenStudio Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ProgramControl);
  return object;
}

IddObject createOS_HeatBalanceAlgorithmIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:HeatBalanceAlgorithm,\n";
    ss << "\\memo Determines which Heat Balance Algorithm will be used ie.\n";
    ss << "\\memo CTF (Conduction Transfer Functions),\n";
    ss << "\\memo EMPD (Effective Moisture Penetration Depth with Conduction Transfer Functions).\n";
    ss << "\\memo Advanced/Research Usage: CondFD (Conduction Finite Difference)\n";
    ss << "\\memo Advanced/Research Usage: ConductionFiniteDifferenceSimplified\n";
    ss << "\\memo Advanced/Research Usage: HAMT (Combined Heat And Moisture Finite Element)\n";
    ss << "\\unique-object\n";
    ss << "\\format singleLine\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Algorithm\n";
    ss << "\\type choice\n";
    ss << "\\default ConductionTransferFunction\n";
    ss << "\\key ConductionTransferFunction\n";
    ss << "\\key MoisturePenetrationDepthConductionTransferFunction\n";
    ss << "\\key ConductionFiniteDifference\n";
    ss << "\\key CombinedHeatAndMoistureFiniteElement\n";
    ss << "N1, \\field Surface Temperature Upper Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 200\n";
    ss << "\\default 200.0\n";
    ss << "N2, \\field Minimum Surface Convection Heat Transfer Coefficient Value\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.1\n";
    ss << "N3; \\field Maximum Surface Convection Heat Transfer Coefficient Value\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1000\n";

    IddObjectType objType(IddObjectType::OS_HeatBalanceAlgorithm);
    OptionalIddObject oObj = IddObject::load("OS:HeatBalanceAlgorithm",
                                             "OpenStudio Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_HeatBalanceAlgorithm);
  return object;
}

IddObject createOS_RunPeriodIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:RunPeriod,\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 12\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note descriptive name (used in reporting mainly)\n";
    ss << "\\note if blank, weather file title is used.  if not blank, must be unique\n";
    ss << "\\note EnergyPlus Start Year field is captured in OS:YearDescription object\n";
    ss << "\\type alpha\n";
    ss << "\\reference RunPeriods\n";
    ss << "\\reference RunPeriodsAndDesignDays\n";
    ss << "N1, \\field Begin Month\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "N2, \\field Begin Day of Month\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "N3, \\field End Month\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "N4, \\field End Day of Month\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "A3, \\field Use Weather File Holidays and Special Days\n";
    ss << "\\note If yes or blank, use holidays as specified on Weatherfile.\n";
    ss << "\\note If no, do not use the holidays specified on the Weatherfile.\n";
    ss << "\\note Note: You can still specify holidays/special days using the RunPeriodControl:SpecialDays object(s).\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A4, \\field Use Weather File Daylight Saving Period\n";
    ss << "\\note If yes or blank, use daylight saving period as specified on Weatherfile.\n";
    ss << "\\note If no, do not use the daylight saving period as specified on the Weatherfile.\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A5, \\field Apply Weekend Holiday Rule\n";
    ss << "\\note if yes and single day holiday falls on weekend, \"holiday\" occurs on following Monday\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A6, \\field Use Weather File Rain Indicators\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A7, \\field Use Weather File Snow Indicators\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "N5; \\field Number of Times Runperiod to be Repeated\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";

    IddObjectType objType(IddObjectType::OS_RunPeriod);
    OptionalIddObject oObj = IddObject::load("OS:RunPeriod",
                                             "OpenStudio Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_RunPeriod);
  return object;
}

IddObject createOS_RunPeriodControl_DaylightSavingTimeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:RunPeriodControl:DaylightSavingTime,\n";
    ss << "\\memo This object sets up the daylight saving time period for any RunPeriod.\n";
    ss << "\\memo Ignores any daylight saving time period on the weather file and uses this definition.\n";
    ss << "\\memo These are not used with SizingPeriod:DesignDay objects.\n";
    ss << "\\memo Use with SizingPeriod:WeatherFileDays object can be controlled in that object.\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 3\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Start Date\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A3; \\field End Date\n";
    ss << "\\note Dates can be several formats:\n";
    ss << "\\note <number>/<number>  (month/day)\n";
    ss << "\\note <number> <Month>\n";
    ss << "\\note <Month> <number>\n";
    ss << "\\note <Nth> <Weekday> in <Month)\n";
    ss << "\\note Last <WeekDay> in <Month>\n";
    ss << "\\note <Month> can be January, February, March, April, May, June, July, August, September, October, November, December\n";
    ss << "\\note Months can be the first 3 letters of the month\n";
    ss << "\\note <Weekday> can be Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday\n";
    ss << "\\note <Nth> can be 1 or 1st, 2 or 2nd, etc. up to 5(?)\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_RunPeriodControl_DaylightSavingTime);
    OptionalIddObject oObj = IddObject::load("OS:RunPeriodControl:DaylightSavingTime",
                                             "OpenStudio Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_RunPeriodControl_DaylightSavingTime);
  return object;
}

IddObject createOS_RunPeriodControl_SpecialDaysIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:RunPeriodControl:SpecialDays,\n";
    ss << "\\memo This object sets up holidays/special days to be used during weather file\n";
    ss << "\\memo run periods.  (These are not used with SizingPeriod:* objects.)\n";
    ss << "\\memo Depending on the value in the run period, days on the weather file may also\n";
    ss << "\\memo be used.  However, the weather file specification will take precedence over\n";
    ss << "\\memo any specification shown here.  (No error message on duplicate days or overlapping\n";
    ss << "\\memo days).\n";
    ss << "\\min-fields 5\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A3, \\field Start Date\n";
    ss << "\\note Dates can be several formats:\n";
    ss << "\\note <number>/<number>  (month/day)\n";
    ss << "\\note <number> <Month>\n";
    ss << "\\note <Month> <number>\n";
    ss << "\\note <Nth> <Weekday> in <Month)\n";
    ss << "\\note Last <WeekDay> in <Month>\n";
    ss << "\\note <Month> can be January, February, March, April, May, June, July, August, September, October, November, December\n";
    ss << "\\note Months can be the first 3 letters of the month\n";
    ss << "\\note <Weekday> can be Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday\n";
    ss << "\\note <Nth> can be 1 or 1st, 2 or 2nd, etc. up to 5(?)\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "N1, \\field Duration\n";
    ss << "\\type real\n";
    ss << "\\units days\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 366\n";
    ss << "\\default 1\n";
    ss << "A4; \\field Special Day Type\n";
    ss << "\\note Special Day Type selects the schedules appropriate for each day so labeled\n";
    ss << "\\type choice\n";
    ss << "\\default Holiday\n";
    ss << "\\key Holiday\n";
    ss << "\\key SummerDesignDay\n";
    ss << "\\key WinterDesignDay\n";
    ss << "\\key CustomDay1\n";
    ss << "\\key CustomDay2\n";

    IddObjectType objType(IddObjectType::OS_RunPeriodControl_SpecialDays);
    OptionalIddObject oObj = IddObject::load("OS:RunPeriodControl:SpecialDays",
                                             "OpenStudio Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_RunPeriodControl_SpecialDays);
  return object;
}

IddObject createOS_ShadowCalculationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ShadowCalculation,\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 2\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "N1, \\field Calculation Frequency\n";
    ss << "\\note 0=Use Default Periodic Calculation|<else> calculate every <value> day\n";
    ss << "\\note only really applicable to RunPeriods\n";
    ss << "\\note warning issued if >31\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 20\n";
    ss << "N2, \\field Maximum Figures in Shadow Overlap Calculations\n";
    ss << "\\note Number of allowable figures in shadow overlap calculations\n";
    ss << "\\type integer\n";
    ss << "\\minimum 200\n";
    ss << "\\default 15000\n";
    ss << "A2, \\field Polygon Clipping Algorithm\n";
    ss << "\\note Advanced Feature.  Internal default is SutherlandHodgman\n";
    ss << "\\note Refer to InputOutput Reference and Engineering Reference for more information\n";
    ss << "\\type choice\n";
    ss << "\\key ConvexWeilerAtherton\n";
    ss << "\\key SutherlandHodgman\n";
    ss << "A3; \\field Sky Diffuse Modeling Algorithm\n";
    ss << "\\note Advanced Feature.  Internal default is SimpleSkyDiffuseModeling\n";
    ss << "\\note If you have shading elements that change transmittance over the\n";
    ss << "\\note year, you may wish to choose the detailed method.\n";
    ss << "\\note Refer to InputOutput Reference and Engineering Reference for more information\n";
    ss << "\\type choice\n";
    ss << "\\key SimpleSkyDiffuseModeling\n";
    ss << "\\key DetailedSkyDiffuseModeling\n";

    IddObjectType objType(IddObjectType::OS_ShadowCalculation);
    OptionalIddObject oObj = IddObject::load("OS:ShadowCalculation",
                                             "OpenStudio Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ShadowCalculation);
  return object;
}

IddObject createOS_SimulationControlIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SimulationControl,\n";
    ss << "\\memo Note that the following 3 fields are related to the Sizing:Zone, Sizing:System,\n";
    ss << "\\memo and Sizing:Plant objects.  Having these fields set to Yes but no corresponding\n";
    ss << "\\memo Sizing object will not cause the sizing to be done. However, having any of these\n";
    ss << "\\memo fields set to No, the corresponding Sizing object is ignored.\n";
    ss << "\\memo Note also, if you want to do system sizing, you must also do zone sizing in the same\n";
    ss << "\\memo run or an error will result.\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Do Zone Sizing Calculation\n";
    ss << "\\note If Yes, Zone sizing is accomplished from corresponding Sizing:Zone objects\n";
    ss << "\\note and autosize fields.\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A3, \\field Do System Sizing Calculation\n";
    ss << "\\note If Yes, System sizing is accomplished from corresponding Sizing:System objects\n";
    ss << "\\note and autosize fields.\n";
    ss << "\\note If Yes, Zone sizing (previous field) must also be Yes.\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A4, \\field Do Plant Sizing Calculation\n";
    ss << "\\note If Yes, Plant sizing is accomplished from corresponding Sizing:Plant objects\n";
    ss << "\\note and autosize fields.\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A5, \\field Run Simulation for Sizing Periods\n";
    ss << "\\note If Yes, SizingPeriod objects are executed and results from those may be displayed..\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A6, \\field Run Simulation for Weather File Run Periods\n";
    ss << "\\note If Yes, RunPeriod objects are executed and results from those may be displayed..\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "N1, \\field Loads Convergence Tolerance Value\n";
    ss << "\\note Loads Convergence Tolerance Value is a fraction of load\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default .04\n";
    ss << "N2, \\field Temperature Convergence Tolerance Value\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default .4\n";
    ss << "A7, \\field Solar Distribution\n";
    ss << "\\note MinimalShadowing | FullExterior | FullInteriorAndExterior | FullExteriorWithReflections | FullInteriorAndExteriorWithReflections\n";
    ss << "\\type choice\n";
    ss << "\\default FullExterior\n";
    ss << "\\key MinimalShadowing\n";
    ss << "\\key FullExterior\n";
    ss << "\\key FullInteriorAndExterior\n";
    ss << "\\key FullExteriorWithReflections\n";
    ss << "\\key FullInteriorAndExteriorWithReflections\n";
    ss << "N3, \\field Maximum Number of Warmup Days\n";
    ss << "\\note EnergyPlus will only use as many warmup days as needed to reach convergence tolerance.\n";
    ss << "\\note This field's value should NOT be set less than 25.\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 25\n";
    ss << "N5; \\field Minimum Number of Warmup Days\n";
    ss << "\\note The minimum number of warmup days that produce enough temperature and flux history\n";
    ss << "\\note to start EnergyPlus simulation for all reference buildings was suggested to be 6.\n";
    ss << "\\note When this field is greater than the maximum warmup days defined previous field\n";
    ss << "\\note the maximum number of warmup days will be reset to the minimum value entered here.\n";
    ss << "\\note Warmup days will be set to be the value you entered when it is less than the default 6.\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 6\n";

    IddObjectType objType(IddObjectType::OS_SimulationControl);
    OptionalIddObject oObj = IddObject::load("OS:SimulationControl",
                                             "OpenStudio Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SimulationControl);
  return object;
}

IddObject createOS_Sizing_ParametersIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Sizing:Parameters,\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 2\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "N1, \\field Heating Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1.0\n";
    ss << "N2, \\field Cooling Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1.0\n";
    ss << "N3; \\field Timesteps in Averaging Window\n";
    ss << "\\note blank => set the timesteps in averaging window to\n";
    ss << "\\note Number of Timesteps per Hour resulting in a 1 hour averaging window\n";
    ss << "\\note default is number of timesteps for 1 hour averaging window\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";

    IddObjectType objType(IddObjectType::OS_Sizing_Parameters);
    OptionalIddObject oObj = IddObject::load("OS:Sizing:Parameters",
                                             "OpenStudio Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Sizing_Parameters);
  return object;
}

IddObject createOS_SurfaceConvectionAlgorithm_InsideIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SurfaceConvectionAlgorithm:Inside,\n";
    ss << "\\memo Default indoor surface heat transfer convection algorithm to be used for all zones\n";
    ss << "\\unique-object\n";
    ss << "\\format singleLine\n";
    ss << "\\min-fields 2\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2; \\field Algorithm\n";
    ss << "\\note Simple = constant value natural convection (ASHRAE)\n";
    ss << "\\note TARP = variable natural convection based on temperature difference (ASHRAE, Walton)\n";
    ss << "\\note CeilingDiffuser = ACH-based forced and mixed convection correlations\n";
    ss << "\\note for ceiling diffuser configuration with simple natural convection limit\n";
    ss << "\\note AdaptiveConvectionAlgorithm = dynamic selection of convection models based on conditions\n";
    ss << "\\type choice\n";
    ss << "\\default TARP\n";
    ss << "\\key Simple\n";
    ss << "\\key TARP\n";
    ss << "\\key CeilingDiffuser\n";
    ss << "\\key AdaptiveConvectionAlgorithm\n";

    IddObjectType objType(IddObjectType::OS_SurfaceConvectionAlgorithm_Inside);
    OptionalIddObject oObj = IddObject::load("OS:SurfaceConvectionAlgorithm:Inside",
                                             "OpenStudio Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SurfaceConvectionAlgorithm_Inside);
  return object;
}

IddObject createOS_SurfaceConvectionAlgorithm_OutsideIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SurfaceConvectionAlgorithm:Outside,\n";
    ss << "\\memo Default outside surface heat transfer convection algorithm to be used for all zones\n";
    ss << "\\unique-object\n";
    ss << "\\format singleLine\n";
    ss << "\\min-fields 2\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2; \\field Algorithm\n";
    ss << "\\note SimpleCombined = Combined radiation and convection coefficient using simple ASHRAE model\n";
    ss << "\\note TARP = correlation from models developed by ASHRAE, Walton, and Sparrow et. al.\n";
    ss << "\\note MoWiTT = correlation from measurements by Klems and Yazdanian for smooth surfaces\n";
    ss << "\\note DOE-2 = correlation from measurements by Klems and Yazdanian for rough surfaces\n";
    ss << "\\note AdaptiveConvectionAlgorithm = dynamic selection of correlations based on conditions\n";
    ss << "\\type choice\n";
    ss << "\\default DOE-2\n";
    ss << "\\key SimpleCombined\n";
    ss << "\\key TARP\n";
    ss << "\\key MoWiTT\n";
    ss << "\\key DOE-2\n";
    ss << "\\key AdaptiveConvectionAlgorithm\n";

    IddObjectType objType(IddObjectType::OS_SurfaceConvectionAlgorithm_Outside);
    OptionalIddObject oObj = IddObject::load("OS:SurfaceConvectionAlgorithm:Outside",
                                             "OpenStudio Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SurfaceConvectionAlgorithm_Outside);
  return object;
}

IddObject createOS_TimestepIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Timestep,\n";
    ss << "\\unique-object\n";
    ss << "\\format singleLine\n";
    ss << "\\min-fields 2\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "N1; \\field Number of Timesteps per Hour\n";
    ss << "\\note Number in hour: normal validity 4 to 60: 6 suggested\n";
    ss << "\\note Must be evenly divisible into 60\n";
    ss << "\\note Allowable values include 1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, and 60\n";
    ss << "\\note Normal 6 is mimimum as lower values may cause inaccuracies\n";
    ss << "\\note A minimum value of 20 is suggested for both ConductionFiniteDifference\n";
    ss << "\\note and CombinedHeatAndMoistureFiniteElement surface heat balance alogorithms\n";
    ss << "\\note A minimum of 12 is suggested for simulations involving a Vegetated Roof (Material:RoofVegetation).\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 60\n";
    ss << "\\default 6\n";

    IddObjectType objType(IddObjectType::OS_Timestep);
    OptionalIddObject oObj = IddObject::load("OS:Timestep",
                                             "OpenStudio Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Timestep);
  return object;
}

IddObject createOS_YearDescriptionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:YearDescription,\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Calendar Year\n";
    ss << "\\type integer\n";
    ss << "A3, \\field Day of Week for Start Day\n";
    ss << "\\note Not used if calendar year is given\n";
    ss << "\\note =<blank - use WeatherFile>|Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday];\n";
    ss << "\\type choice\n";
    ss << "\\default UseWeatherFile\n";
    ss << "\\key Sunday\n";
    ss << "\\key Monday\n";
    ss << "\\key Tuesday\n";
    ss << "\\key Wednesday\n";
    ss << "\\key Thursday\n";
    ss << "\\key Friday\n";
    ss << "\\key Saturday\n";
    ss << "\\key UseWeatherFile\n";
    ss << "A4; \\field Is Leap Year\n";
    ss << "\\note Not used if calendar year is given\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";

    IddObjectType objType(IddObjectType::OS_YearDescription);
    OptionalIddObject oObj = IddObject::load("OS:YearDescription",
                                             "OpenStudio Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_YearDescription);
  return object;
}

IddObject createOS_ZoneAirContaminantBalanceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneAirContaminantBalance,\n";
    ss << "\\memo Determines which contaminant concentration will be simulates.\n";
    ss << "\\unique-object\n";
    ss << "\\format singleLine\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Carbon Dioxide Concentration\n";
    ss << "\\note If Yes, CO2 simulation will be performed.\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A3; \\field Outdoor Carbon Dioxide Schedule Name\n";
    ss << "\\note Schedule values should be in parts per million (ppm)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_ZoneAirContaminantBalance);
    OptionalIddObject oObj = IddObject::load("OS:ZoneAirContaminantBalance",
                                             "OpenStudio Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneAirContaminantBalance);
  return object;
}

IddObject createOS_ZoneAirHeatBalanceAlgorithmIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneAirHeatBalanceAlgorithm,\n";
    ss << "\\memo Determines which algorithm will be used to solve the zone air heat balance.\n";
    ss << "\\unique-object\n";
    ss << "\\format singleLine\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2; \\field Algorithm\n";
    ss << "\\type choice\n";
    ss << "\\default ThirdOrderBackwardDifference\n";
    ss << "\\key ThirdOrderBackwardDifference\n";
    ss << "\\key AnalyticalSolution\n";
    ss << "\\key EulerMethod\n";

    IddObjectType objType(IddObjectType::OS_ZoneAirHeatBalanceAlgorithm);
    OptionalIddObject oObj = IddObject::load("OS:ZoneAirHeatBalanceAlgorithm",
                                             "OpenStudio Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneAirHeatBalanceAlgorithm);
  return object;
}

IddObject createOS_ZoneAirMassFlowConservationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneAirMassFlowConservation,\n";
    ss << "\\memo Enforces the zone air mass flow balance by adjusting zone mixing object flow rates.\n";
    ss << "\\memo The infiltration object mass flow rate may also be adjusted or may add infiltration\n";
    ss << "\\memo air flow to the base infiltration air flow for source zones only.\n";
    ss << "\\unique-object\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Adjust Zone Mixing For Zone Air Mass Flow Balance\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "A3,  \\field Infiltration Balancing Method\n";
    ss << "\\type choice\n";
    ss << "\\key AddInfiltrationFlow\n";
    ss << "\\key AdjustInfiltrationFlow\n";
    ss << "\\key None\n";
    ss << "\\default AddInfiltrationFlow\n";
    ss << "A4;  \\field Infiltration Balancing Zones\n";
    ss << "\\type choice\n";
    ss << "\\key MixingSourceZonesOnly\n";
    ss << "\\key AllZones\n";
    ss << "\\default MixingSourceZonesOnly\n";

    IddObjectType objType(IddObjectType::OS_ZoneAirMassFlowConservation);
    OptionalIddObject oObj = IddObject::load("OS:ZoneAirMassFlowConservation",
                                             "OpenStudio Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneAirMassFlowConservation);
  return object;
}

IddObject createOS_ZoneCapacitanceMultiplier_ResearchSpecialIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneCapacitanceMultiplier:ResearchSpecial,\n";
    ss << "\\memo Multiplier altering the relative capacitance of the air compared to an empty zone\n";
    ss << "\\unique-object\n";
    ss << "\\format singleLine\n";
    ss << "\\min-fields 4\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "N1, \\field Temperature Capacity Multiplier\n";
    ss << "\\note Used to alter the capacitance of zone air with respect to heat or temperature\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1.0\n";
    ss << "N2, \\field Humidity Capacity Multiplier\n";
    ss << "\\note Used to alter the capacitance of zone air with respect to moisture or humidity ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1.0\n";
    ss << "N3; \\field Carbon Dioxide Capacity Multiplier\n";
    ss << "\\note Used to alter the capacitance of zone air with respect to zone air contaminant concentration\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::OS_ZoneCapacitanceMultiplier_ResearchSpecial);
    OptionalIddObject oObj = IddObject::load("OS:ZoneCapacitanceMultiplier:ResearchSpecial",
                                             "OpenStudio Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneCapacitanceMultiplier_ResearchSpecial);
  return object;
}

IddObject createOS_RadianceParametersIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:RadianceParameters,\n";
    ss << "\\memo Radiance simulation parameters\n";
    ss << "\\unique-object\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "N1, \\field Accumulated Rays per Record\n";
    ss << "\\note accumulated rays per record, -c option to rcontrib\n";
    ss << "\\note The -c option tells rcontrib how  many  rays  to  accumulate  for  each\n";
    ss << "\\note record.  The default value is 1, meaning a full record will be produced\n";
    ss << "\\note for each input ray.  For values greater than 1, contributions  will  be\n";
    ss << "\\note averaged together over the given number of input rays.\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";
    ss << "N2, \\field Direct Threshold\n";
    ss << "\\note direct sampling threshold, -dt option to rtrace/rpict. Sets the direct threshold to frac.\n";
    ss << "\\note Shadow testing will stop when the potential contribution of at least the next and at most\n";
    ss << "\\note all remaining light source samples is less than this fraction of the accumulated value.\n";
    ss << "\\note The remaining light source contributions are approximated statistically. A value of zero\n";
    ss << "\\note means that all light source samples will be tested for shadow.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N3, \\field Direct Certainty\n";
    ss << "\\note direct certainty, -dc option to rtrace/rpict.\n";
    ss << "\\note Sets the direct certainty to frac. A value of one guarantees that the absolute\n";
    ss << "\\note accuracy of the direct calculation will be equal to or better than that given\n";
    ss << "\\note in the -dt specification. A value of zero only insures that all shadow lines\n";
    ss << "\\note resulting in a contrast change greater than the -dt specification will be calculated.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N4, \\field Direct Jitter\n";
    ss << "\\note direct jitter, -dj option to rtrace/rpict.\n";
    ss << "\\note Sets the direct certainty to frac. A value of one guarantees that the absolute\n";
    ss << "\\note accuracy of the direct calculation will be equal to or better than that given\n";
    ss << "\\note in the -dt specification. A value of zero only insures that all shadow lines\n";
    ss << "\\note resulting in a contrast change greater than the -dt specification will be calculated.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N5, \\field Direct Pretest\n";
    ss << "\\note direct jitter, -dp option to rtrace/rpict.\n";
    ss << "\\note Set the secondary source presampling density to D. This is the number of\n";
    ss << "\\note samples per steradian that will be used to determine ahead of time whether\n";
    ss << "\\note or not it is worth following shadow rays through all the reflections and/or\n";
    ss << "\\note transmissions associated with a secondary source path. A value of 0 means that\n";
    ss << "\\note the full secondary source path will always be tested for shadows if it is tested at all.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N6, \\field Ambient Bounces VMX\n";
    ss << "\\note ambient bounces, -ab option to rtrace/rpict.\n";
    ss << "\\note Set the number of ambient bounces to N. This is the maximum number of diffuse\n";
    ss << "\\note bounces computed by the indirect calculation. A value of zero implies no indirect calculation.\n";
    ss << "\\note This is for view matrix (VMX) calculations with rcontrib.\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\default 6\n";
    ss << "N7, \\field Ambient Bounces DMX\n";
    ss << "\\note ambient bounces, -ab option to rtrace/rpict.\n";
    ss << "\\note Set the number of ambient bounces to N. This is the maximum number of diffuse\n";
    ss << "\\note bounces computed by the indirect calculation. A value of zero implies no indirect calculation.\n";
    ss << "\\note This is for daylight matrix (DMX) calculations with rcontrib, and classic renderings with rpict.\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\default 2\n";
    ss << "N8, \\field Ambient Divisions VMX\n";
    ss << "\\note ambient bounces, -ad option to rtrace/rpict.\n";
    ss << "\\note Set the number of ambient divisions to N. The error in the Monte Carlo\n";
    ss << "\\note calculation of indirect illuminance will be inversely proportional to the\n";
    ss << "\\note square root of this number. A value of zero implies no indirect calculation.\n";
    ss << "\\note This is for view matrix (VMX) calculations with rcontrib.\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\default 4050\n";
    ss << "N9, \\field Ambient Divisions DMX\n";
    ss << "\\note ambient bounces, -ad option to rtrace/rpict.\n";
    ss << "\\note Set the number of ambient divisions to N. The error in the Monte Carlo\n";
    ss << "\\note calculation of indirect illuminance will be inversely proportional to the\n";
    ss << "\\note square root of this number. A value of zero implies no indirect calculation.\n";
    ss << "\\note This is for daylight matrix (DMX) calculations with rcontrib, and classic renderings with rpict.\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\default 512\n";
    ss << "N10, \\field Ambient Supersamples\n";
    ss << "\\note ambient supersamples, -as option to rtrace/rpict.\n";
    ss << "\\note Set the number of ambient divisions to N. The error in the Monte Carlo\n";
    ss << "\\note calculation of indirect illuminance will be inversely proportional to the\n";
    ss << "\\note square root of this number. A value of zero implies no indirect calculation.\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\default 256\n";
    ss << "N11, \\field Limit Weight VMX\n";
    ss << "\\note limit weight, -lw option to rtrace/rpict.\n";
    ss << "\\note Limit the weight of each ray to a minimum of frac. During ray-tracing, a\n";
    ss << "\\note record is kept of the estimated contribution (weight) a ray would have in\n";
    ss << "\\note the image. If this weight is less than the specified minimum and the -lr\n";
    ss << "\\note setting (above) is positive, the ray is not traced. Otherwise, Russian\n";
    ss << "\\note roulette is used to continue rays with a probability equal to the ray weight\n";
    ss << "\\note divided by the given frac. (Ideally, this value is the -ad value^-1 for VMX calcs)\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.001\n";
    ss << "N12, \\field Limit Weight DMX\n";
    ss << "\\note limit weight, -lw option to rtrace/rpict.\n";
    ss << "\\note Limit the weight of each ray to a minimum of frac. During ray-tracing, a\n";
    ss << "\\note record is kept of the estimated contribution (weight) a ray would have in\n";
    ss << "\\note the image. If this weight is less than the specified minimum and the -lr\n";
    ss << "\\note setting (above) is positive, the ray is not traced. Otherwise, Russian\n";
    ss << "\\note roulette is used to continue rays with a probability equal to the ray weight\n";
    ss << "\\note divided by the given frac.\n";
    ss << "\\type real\n";
    ss << "\\default 0.001\n";
    ss << "N13, \\field Klems Sampling Density\n";
    ss << "\\note number of rays per outgoing Klems direction, -c option to rcontrib.\n";
    ss << "\\note Sets the Klems sampling density for daylight matrix calculations.\n";
    ss << "\\type integer\n";
    ss << "\\default 500\n";
    ss << "A2; \\field Sky Discretization Resolution\n";
    ss << "\\note number of rays per outgoing Klems direction, -m:n option to rcontrib.\n";
    ss << "\\note Sets sky discretization resolution for daylight coefficient calculations.\n";
    ss << "\\type choice\n";
    ss << "\\default 146\n";
    ss << "\\key 146\n";
    ss << "\\key 578\n";
    ss << "\\key 2306\n";

    IddObjectType objType(IddObjectType::OS_RadianceParameters);
    OptionalIddObject oObj = IddObject::load("OS:RadianceParameters",
                                             "OpenStudio Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_RadianceParameters);
  return object;
}

IddObject createOS_ClimateZonesIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ClimateZones,\n";
    ss << "\\unique-object\n";
    ss << "\\extensible:4\n";
    ss << "\\min-fields 7\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Active Institution\n";
    ss << "\\deprecated\n";
    ss << "\\type alpha\n";
    ss << "\\default ASHRAE\n";
    ss << "N1, \\field Active Year\n";
    ss << "\\deprecated\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\default 2006\n";
    ss << "A3, \\field Climate Zone Institution Name\n";
    ss << "\\type alpha\n";
    ss << "\\begin-extensible\n";
    ss << "\\default ASHRAE\n";
    ss << "A4, \\field Climate Zone Document Name\n";
    ss << "\\type alpha\n";
    ss << "\\default ANSI/ASHRAE Standard 169\n";
    ss << "N2, \\field Climate Zone Document Year\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\default 2006\n";
    ss << "A5; \\field Climate Zone Value\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_ClimateZones);
    OptionalIddObject oObj = IddObject::load("OS:ClimateZones",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ClimateZones);
  return object;
}

IddObject createOS_SiteIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Site,\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 7\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "N1, \\field Latitude\n";
    ss << "\\note + is North, - is South, degree minutes represented in decimal (i.e. 30 minutes is .5)\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\minimum -90\n";
    ss << "\\maximum 90\n";
    ss << "\\default 0.0\n";
    ss << "N2, \\field Longitude\n";
    ss << "\\note - is West, + is East, degree minutes represented in decimal (i.e. 30 minutes is .5)\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\minimum -180\n";
    ss << "\\maximum 180\n";
    ss << "\\default 0.0\n";
    ss << "N3, \\field Time Zone\n";
    ss << "\\note basic these limits on the WorldTimeZone Map (2003)\n";
    ss << "\\note Time relative to GMT. Decimal hours.\n";
    ss << "\\type real\n";
    ss << "\\units hr\n";
    ss << "\\minimum -12\n";
    ss << "\\maximum 14\n";
    ss << "\\default 0.0\n";
    ss << "N4, \\field Elevation\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum -300\n";
    ss << "\\maximum< 8900\n";
    ss << "\\default 0.0\n";
    ss << "A3; \\field Terrain\n";
    ss << "\\note Country=FlatOpenCountry | Suburbs=CountryTownsSuburbs | City=CityCenter | Ocean=body of water (5km) | Urban=Urban-Industrial-Forest\n";
    ss << "\\type choice\n";
    ss << "\\default Suburbs\n";
    ss << "\\key Country\n";
    ss << "\\key Suburbs\n";
    ss << "\\key City\n";
    ss << "\\key Ocean\n";
    ss << "\\key Urban\n";

    IddObjectType objType(IddObjectType::OS_Site);
    OptionalIddObject oObj = IddObject::load("OS:Site",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Site);
  return object;
}

IddObject createOS_Site_GroundTemperature_BuildingSurfaceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Site:GroundTemperature:BuildingSurface,\n";
    ss << "\\memo These temperatures are specifically for those surfaces that have the outside environment\n";
    ss << "\\memo of \"Ground\".  Documentation about what values these should be is located in the\n";
    ss << "\\memo Auxiliary programs document (Ground Heat Transfer) as well as the InputOutput Reference.\n";
    ss << "\\memo CAUTION - Do not use the \"undisturbed\" ground temperatures from the weather data.\n";
    ss << "\\memo These values are too extreme for the soil under a conditioned building.\n";
    ss << "\\memo For best results, use the Slab or Basement program to calculate custom monthly\n";
    ss << "\\memo average ground temperatures (see Auxiliary Programs).  For typical commercial\n";
    ss << "\\memo buildings in the USA, a reasonable default value is 2C less than the average indoor space temperature.\n";
    ss << "\\unique-object\n";
    ss << "\\format singleLine\n";
    ss << "\\min-fields 13\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "N1, \\field January Ground Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 18\n";
    ss << "N2, \\field February Ground Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 18\n";
    ss << "N3, \\field March Ground Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 18\n";
    ss << "N4, \\field April Ground Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 18\n";
    ss << "N5, \\field May Ground Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 18\n";
    ss << "N6, \\field June Ground Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 18\n";
    ss << "N7, \\field July Ground Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 18\n";
    ss << "N8, \\field August Ground Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 18\n";
    ss << "N9, \\field September Ground Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 18\n";
    ss << "N10, \\field October Ground Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 18\n";
    ss << "N11, \\field November Ground Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 18\n";
    ss << "N12; \\field December Ground Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 18\n";

    IddObjectType objType(IddObjectType::OS_Site_GroundTemperature_BuildingSurface);
    OptionalIddObject oObj = IddObject::load("OS:Site:GroundTemperature:BuildingSurface",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Site_GroundTemperature_BuildingSurface);
  return object;
}

IddObject createOS_Site_GroundTemperature_FCfactorMethodIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Site:GroundTemperature:FCfactorMethod,\n";
    ss << "\\memo These temperatures are specifically for underground walls and ground floors\n";
    ss << "\\memo defined with the C-factor and F-factor methods, and should be close to the\n";
    ss << "\\memo monthly average outdoor air temperature delayed by 3 months for the location.\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 13\n";
    ss << "\\format singleLine\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field January Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N2 , \\field February Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N3 , \\field March Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N4 , \\field April Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N5 , \\field May Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N6 , \\field June Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N7 , \\field July Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N8 , \\field August Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N9 , \\field September Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N10, \\field October Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N11, \\field November Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N12; \\field December Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";

    IddObjectType objType(IddObjectType::OS_Site_GroundTemperature_FCfactorMethod);
    OptionalIddObject oObj = IddObject::load("OS:Site:GroundTemperature:FCfactorMethod",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Site_GroundTemperature_FCfactorMethod);
  return object;
}

IddObject createOS_Site_GroundTemperature_ShallowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Site:GroundTemperature:Shallow,\n";
    ss << "\\memo These temperatures are specifically for the Surface Ground Heat Exchanger and\n";
    ss << "\\memo should probably be close to the average outdoor air temperature for the location.\n";
    ss << "\\memo They are not used in other models.\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 13\n";
    ss << "\\format singleLine\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field January Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N2 , \\field February Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N3 , \\field March Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N4 , \\field April Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N5 , \\field May Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N6 , \\field June Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N7 , \\field July Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N8 , \\field August Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N9 , \\field September Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N10, \\field October Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N11, \\field November Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";
    ss << "N12; \\field December Surface Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 13\n";

    IddObjectType objType(IddObjectType::OS_Site_GroundTemperature_Shallow);
    OptionalIddObject oObj = IddObject::load("OS:Site:GroundTemperature:Shallow",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Site_GroundTemperature_Shallow);
  return object;
}

IddObject createOS_Site_GroundTemperature_DeepIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Site:GroundTemperature:Deep,\n";
    ss << "\\memo These temperatures are specifically for the ground heat exchangers that would use\n";
    ss << "\\memo \"deep\" (3-4 m depth) ground temperatures for their heat source.\n";
    ss << "\\memo They are not used in other models.\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 13\n";
    ss << "\\format singleLine\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field January Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N2 , \\field February Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N3 , \\field March Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N4 , \\field April Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N5 , \\field May Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N6 , \\field June Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N7 , \\field July Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N8 , \\field August Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N9 , \\field September Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N10, \\field October Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N11, \\field November Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";
    ss << "N12; \\field December Deep Ground Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 16\n";

    IddObjectType objType(IddObjectType::OS_Site_GroundTemperature_Deep);
    OptionalIddObject oObj = IddObject::load("OS:Site:GroundTemperature:Deep",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Site_GroundTemperature_Deep);
  return object;
}

IddObject createOS_Site_GroundReflectanceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Site:GroundReflectance,\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 13\n";
    ss << "\\format singleLine\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field January Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N2 , \\field February Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N3 , \\field March Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N4 , \\field April Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N5 , \\field May Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N6 , \\field June Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N7 , \\field July Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N8 , \\field August Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N9 , \\field September Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N10 , \\field October Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N11 , \\field November Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "N12 ; \\field December Ground Reflectance\n";
    ss << "\\default 0.2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\units dimensionless\n";

    IddObjectType objType(IddObjectType::OS_Site_GroundReflectance);
    OptionalIddObject oObj = IddObject::load("OS:Site:GroundReflectance",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Site_GroundReflectance);
  return object;
}

IddObject createOS_Site_WaterMainsTemperatureIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Site:WaterMainsTemperature,\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Calculation Method\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Schedule\n";
    ss << "\\key Correlation\n";
    ss << "A3, \\field Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Annual Average Outdoor Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N2; \\field Maximum Difference In Monthly Average Outdoor Air Temperatures\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0\n";

    IddObjectType objType(IddObjectType::OS_Site_WaterMainsTemperature);
    OptionalIddObject oObj = IddObject::load("OS:Site:WaterMainsTemperature",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Site_WaterMainsTemperature);
  return object;
}

IddObject createOS_SizingPeriod_DesignDayIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SizingPeriod:DesignDay,\n";
    ss << "\\min-fields 16\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference DesignDays\n";
    ss << "\\reference RunPeriodsAndDesignDays\n";
    ss << "N1, \\field Maximum Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -70\n";
    ss << "\\maximum 70\n";
    ss << "\\default 23.0\n";
    ss << "N2, \\field Daily Dry-Bulb Temperature Range\n";
    ss << "\\note Must still produce appropriate maximum dry bulb (within range)\n";
    ss << "\\note This field is not needed if Dry-Bulb Temperature Range Modifier Type\n";
    ss << "\\note is \"delta\".\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N3, \\field Humidity Indicating Conditions at Maximum Dry-Bulb\n";
    ss << "\\note this will be a wet-bulb, dewpoint, humidity ratio, or enthalpy coincident with the\n";
    ss << "\\note maximum temperature depending on the value of the field\n";
    ss << "\\note Humidity Indicating Type\n";
    ss << "\\note required-field if Humidity Indicating Day Schedule is not used\n";
    ss << "\\type real\n";
    ss << "N4, \\field Barometric Pressure\n";
    ss << "\\note This field's value is also checked against the calculated \"standard barometric pressure\"\n";
    ss << "\\note for the location.  If out of range (>10%), then is replaced by standard value.\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inHg\n";
    ss << "\\minimum 31000\n";
    ss << "\\maximum 120000\n";
    ss << "\\default 31000.0\n";
    ss << "N5, \\field Wind Speed\n";
    ss << "\\type real\n";
    ss << "\\units m/s\n";
    ss << "\\ip-units miles/hr\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 40\n";
    ss << "\\default 0.0\n";
    ss << "N6, \\field Wind Direction\n";
    ss << "\\note North=0.0 East=90.0\n";
    ss << "\\note 0 and 360 are the same direction.\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 360\n";
    ss << "\\default 0.0\n";
    ss << "N7, \\field Sky Clearness\n";
    ss << "\\note Only used if Sky Model Indicator = ASHRAEClearSky\n";
    ss << "\\note 0.0 is totally unclear, 1.0 is totally clear\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.2\n";
    ss << "\\default 0.0\n";
    ss << "N8, \\field Rain Indicator\n";
    ss << "\\note 1 is raining, 0 is not\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "N9, \\field Snow Indicator\n";
    ss << "\\note 1 is Snow on Ground, 0 is no Snow on Ground\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "N10, \\field Day of Month\n";
    ss << "\\note must be valid for Month field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "\\default 1\n";
    ss << "N11, \\field Month\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "\\default 1\n";
    ss << "A3, \\field Day Type\n";
    ss << "\\note Day Type selects the schedules appropriate for this design day\n";
    ss << "\\type choice\n";
    ss << "\\default SummerDesignDay\n";
    ss << "\\key Sunday\n";
    ss << "\\key Monday\n";
    ss << "\\key Tuesday\n";
    ss << "\\key Wednesday\n";
    ss << "\\key Thursday\n";
    ss << "\\key Friday\n";
    ss << "\\key Saturday\n";
    ss << "\\key Holiday\n";
    ss << "\\key SummerDesignDay\n";
    ss << "\\key WinterDesignDay\n";
    ss << "\\key CustomDay1\n";
    ss << "\\key CustomDay2\n";
    ss << "N12, \\field Daylight Saving Time Indicator\n";
    ss << "\\note 1=Yes, 0=No\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "A4, \\field Humidity Indicating Type\n";
    ss << "\\note What Field \"Humidity Indicating Conditions at Maximum Dry-Bulb\" is.\n";
    ss << "\\note Units for WetBulb, DewPoint, WetBulbProfilexxx [C]\n";
    ss << "\\note Units for Humidity-Ratio []\n";
    ss << "\\note Units for Enthalpy [kJ/kg]\n";
    ss << "\\type choice\n";
    ss << "\\default WetBulb\n";
    ss << "\\key WetBulb\n";
    ss << "\\key DewPoint\n";
    ss << "\\key HumidityRatio\n";
    ss << "\\key Enthalpy\n";
    ss << "\\key Schedule\n";
    ss << "\\key WetBulbProfileMultiplierSchedule\n";
    ss << "\\key WetBulbProfileDifferenceSchedule\n";
    ss << "\\key WetBulbProfileDefaultMultipliers\n";
    ss << "A5, \\field Humidity Indicating Day Schedule Name\n";
    ss << "\\note only used when previous field is \"Schedule\", \"WetBulbProfileMultiplierSchedule\", or \"WetBulbProfileDifferenceSchedule\"\n";
    ss << "\\note For type \"Schedule\", the hour/time interval values should specify\n";
    ss << "\\note relative humidity (percent) from 0.0 to 100.0.\n";
    ss << "\\note For type \"WetBulbProfileMultiplierSchedule\" the hour/time interval values should specify\n";
    ss << "\\note the fraction (0-1) of the wet-bulb temperature range to be subtracted from the\n";
    ss << "\\note maximum wet-bulb temperature for each timestep in the day\n";
    ss << "\\note For type \"WetBulbProfileDifferenceSchedule\" the values should specify a number to be subtracted\n";
    ss << "\\note from the maximum wet-bulb temperature for each timestep in the day.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A6, \\field Dry-Bulb Temperature Range Modifier Type\n";
    ss << "\\note Type of modifier to the dry-bulb temperature calculated for the timestep\n";
    ss << "\\type choice\n";
    ss << "\\default DefaultMultipliers\n";
    ss << "\\key MultiplierSchedule\n";
    ss << "\\key DifferenceSchedule\n";
    ss << "\\key DefaultMultipliers\n";
    ss << "A7, \\field Dry-Bulb Temperature Range Modifier Schedule Name\n";
    ss << "\\note Only used when previous field is \"MultiplierSchedule\" or \"DifferenceSchedule\".\n";
    ss << "\\note For type \"MultiplierSchedule\"  the hour/time interval values should specify\n";
    ss << "\\note the fraction (0-1) of the dry-bulb temperature range to be subtracted\n";
    ss << "\\note from the maximum dry-bulb temperature for each timestep in the day\n";
    ss << "\\note For type \"DifferenceSchedule\" the values should specify a number to be subtracted\n";
    ss << "\\note from the maximum dry-bulb temperature for each timestep in the day.\n";
    ss << "\\note Note that numbers in the difference schedule cannot be negative as that\n";
    ss << "\\note would result in a higher maximum than the maximum previously specified.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A8, \\field Solar Model Indicator\n";
    ss << "\\type choice\n";
    ss << "\\default ASHRAEClearSky\n";
    ss << "\\key ASHRAEClearSky\n";
    ss << "\\key ZhangHuang\n";
    ss << "\\key Schedule\n";
    ss << "\\key ASHRAETau\n";
    ss << "A9, \\field Beam Solar Day Schedule Name\n";
    ss << "\\note if Solar Model Indicator = Schedule, then beam schedule name (for day)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A10, \\field Diffuse Solar Day Schedule Name\n";
    ss << "\\note if Solar Model Indicator = Schedule, then diffuse schedule name (for day)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "N13, \\field ASHRAE Taub\n";
    ss << "\\note Required if Solar Model Indicator = ASHRAETau\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "N14, \\field ASHRAE Taud\n";
    ss << "\\note Required if Solar Model Indicator = ASHRAETau\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 3\n";
    ss << "\\default 0\n";
    ss << "N15; \\field Daily Wet-Bulb Temperature Range\n";
    ss << "\\note Required only if Humidity Indicating Type = \"WetbulbProfileMultiplierSchedule\" or \"WetBulbProfileDefaultMultipliers\"\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";

    IddObjectType objType(IddObjectType::OS_SizingPeriod_DesignDay);
    OptionalIddObject oObj = IddObject::load("OS:SizingPeriod:DesignDay",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SizingPeriod_DesignDay);
  return object;
}

IddObject createOS_SizingPeriod_WeatherFileConditionTypeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SizingPeriod:WeatherFileConditionType,\n";
    ss << "\\memo Use a weather file period for design sizing calculations.\n";
    ss << "\\memo EPW weather files are created with typical and extreme periods\n";
    ss << "\\memo created heuristically from the weather file data.  For more\n";
    ss << "\\memo details on these periods, see AuxiliaryPrograms document.\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note user supplied name for reporting\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference DesignDays\n";
    ss << "\\reference RunPeriodsAndDesignDays\n";
    ss << "A3, \\field Period Selection\n";
    ss << "\\note Following is a list of all possible types of Extreme and Typical periods that\n";
    ss << "\\note might be identified in the Weather File. Not all possible types are available\n";
    ss << "\\note for all weather files.\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\retaincase\n";
    ss << "\\key SummerExtreme\n";
    ss << "\\key SummerTypical\n";
    ss << "\\key WinterExtreme\n";
    ss << "\\key WinterTypical\n";
    ss << "\\key AutumnTypical\n";
    ss << "\\key SpringTypical\n";
    ss << "\\key WetSeason\n";
    ss << "\\key DrySeason\n";
    ss << "\\key NoDrySeason\n";
    ss << "\\key NoWetSeason\n";
    ss << "\\key TropicalHot\n";
    ss << "\\key TropicalCold\n";
    ss << "\\key NoDrySeasonMax\n";
    ss << "\\key NoDrySeasonMin\n";
    ss << "\\key NoWetSeasonMax\n";
    ss << "\\key NoWetSeasonMin\n";
    ss << "A4, \\field Day of Week for Start Day\n";
    ss << "\\note =[|Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|SummerDesignDay|WinterDesignDay|\n";
    ss << "\\note |CustomDay1|CustomDay2];\n";
    ss << "\\note if you use SummerDesignDay or WinterDesignDay or the CustomDays then this will apply\n";
    ss << "\\note to the whole period; other days (i.e., Monday) will signify a start day and\n";
    ss << "\\note normal sequence ofsubsequent days\n";
    ss << "\\type choice\n";
    ss << "\\default Monday\n";
    ss << "\\key Sunday\n";
    ss << "\\key Monday\n";
    ss << "\\key Tuesday\n";
    ss << "\\key Wednesday\n";
    ss << "\\key Thursday\n";
    ss << "\\key Friday\n";
    ss << "\\key Saturday\n";
    ss << "\\key SummerDesignDay\n";
    ss << "\\key WinterDesignDay\n";
    ss << "\\key CustomDay1\n";
    ss << "\\key CustomDay2\n";
    ss << "A5, \\field Use Weather File Daylight Saving Period\n";
    ss << "\\note If yes or blank, use daylight saving period as specified on Weatherfile.\n";
    ss << "\\note If no, do not use the daylight saving period as specified on the Weatherfile.\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A6; \\field Use Weather File Rain and Snow Indicators\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";

    IddObjectType objType(IddObjectType::OS_SizingPeriod_WeatherFileConditionType);
    OptionalIddObject oObj = IddObject::load("OS:SizingPeriod:WeatherFileConditionType",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SizingPeriod_WeatherFileConditionType);
  return object;
}

IddObject createOS_SizingPeriod_WeatherFileDaysIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SizingPeriod:WeatherFileDays,\n";
    ss << "\\memo Use a weather file period for design sizing calculations.\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note user supplied name for reporting\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference DesignDays\n";
    ss << "\\reference RunPeriodsAndDesignDays\n";
    ss << "N1, \\field Begin Month\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "N2, \\field Begin Day of Month\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "N3, \\field End Month\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "N4, \\field End Day of Month\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "A3, \\field Day of Week for Start Day\n";
    ss << "\\note =[|Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|SummerDesignDay|WinterDesignDay|\n";
    ss << "\\note |CustomDay1|CustomDay2];\n";
    ss << "\\note if you use SummerDesignDay or WinterDesignDay or the CustomDays then this will apply\n";
    ss << "\\note to the whole period; other days (i.e., Monday) will signify a start day and\n";
    ss << "\\note normal sequence ofsubsequent days\n";
    ss << "\\type choice\n";
    ss << "\\default Monday\n";
    ss << "\\key Sunday\n";
    ss << "\\key Monday\n";
    ss << "\\key Tuesday\n";
    ss << "\\key Wednesday\n";
    ss << "\\key Thursday\n";
    ss << "\\key Friday\n";
    ss << "\\key Saturday\n";
    ss << "\\key SummerDesignDay\n";
    ss << "\\key WinterDesignDay\n";
    ss << "\\key CustomDay1\n";
    ss << "\\key CustomDay2\n";
    ss << "A4, \\field Use Weather File Daylight Saving Period\n";
    ss << "\\note If yes or blank, use daylight saving period as specified on Weatherfile.\n";
    ss << "\\note If no, do not use the daylight saving period as specified on the Weatherfile.\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A5; \\field Use Weather File Rain and Snow Indicators\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";

    IddObjectType objType(IddObjectType::OS_SizingPeriod_WeatherFileDays);
    OptionalIddObject oObj = IddObject::load("OS:SizingPeriod:WeatherFileDays",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SizingPeriod_WeatherFileDays);
  return object;
}

IddObject createOS_UtilityCost_Charge_BlockIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:UtilityCost:Charge:Block,\n";
    ss << "\\extensible:2\n";
    ss << "\\min-fields 1\n";
    ss << "\\max-fields 38\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note Charge Variable Name\n";
    ss << "\\note This is the name associated with the UtilityCost:Charge:Block object and will appear in the report.\n";
    ss << "\\note In addition the results of the UtilityCost:Charge:Block are stored in a variable with the same name.\n";
    ss << "\\note That way the results may be used for further calculation.\n";
    ss << "\\type alpha\n";
    ss << "A3, \\field Tariff Name\n";
    ss << "\\type alpha\n";
    ss << "A4, \\field Source Variable\n";
    ss << "\\note The name of the source used by the UtilityCost:Charge:Block.  This is usually the name of the variable\n";
    ss << "\\note holding the energy or demand but may also be the name of any variable including the subtotal or basis if\n";
    ss << "\\note other charges are based on those.\n";
    ss << "\\type alpha\n";
    ss << "A5, \\field Season\n";
    ss << "\\note If this is set to annual the calculations are performed for the UtilityCost:Charge:Block for the entire\n";
    ss << "\\note year (all months) otherwise it is calculated only for those months in the season defined.\n";
    ss << "\\type choice\n";
    ss << "\\key Annual\n";
    ss << "\\key Summer\n";
    ss << "\\key Winter\n";
    ss << "\\key Spring\n";
    ss << "\\key Fall\n";
    ss << "A6, \\field Category Variable Name\n";
    ss << "\\note This field shows where the charge should be added. The reason to enter this field appropriately is so\n";
    ss << "\\note that the charge gets reported in a reasonable category.  The charge automatically gets added to the\n";
    ss << "\\note variable that is the category.\n";
    ss << "\\type choice\n";
    ss << "\\key EnergyCharges\n";
    ss << "\\key DemandCharges\n";
    ss << "\\key ServiceCharges\n";
    ss << "\\key Basis\n";
    ss << "\\key Adjustment\n";
    ss << "\\key Surcharge\n";
    ss << "\\key Subtotal\n";
    ss << "\\key Taxes\n";
    ss << "\\key Total\n";
    ss << "\\key NotIncluded\n";
    ss << "A7, \\field Remaining Into Variable\n";
    ss << "\\note If the blocks do not use all of the energy or demand from the source some energy and demand remains\n";
    ss << "\\note then the remaining amount should be assigned to a variable. If no variable is assigned and some amount\n";
    ss << "\\note of energy or demand is not used in the block structure a warning will be issued.\n";
    ss << "\\type alpha\n";
    ss << "A8, \\field Block Size Multiplier Value or Variable Name\n";
    ss << "\\note The sizes of the blocks are usually used directly but if a value or a variable is entered here the block\n";
    ss << "\\note sizes entered in the rest of the charge are first multiplied by the entered value prior to being used.\n";
    ss << "\\note This is common for rates that are kWh/kW rates and in that case the variable that holds the monthly\n";
    ss << "\\note total electric demand would be entered.  If no value is entered a default value of one is assumed so\n";
    ss << "\\note that the block sizes remain exactly as entered.  This field is unusual for the EnergyPlus syntax because\n";
    ss << "\\note it can be either a number or a name of a variable.\n";
    ss << "\\type alpha\n";
    ss << "A9, \\field Block Size Value or Variable Name\n";
    ss << "\\note The size of the block of the charges is entered here. For most rates that use multiple blocks this will\n";
    ss << "\\note be the value for the block size. Using remaining may be used when the remaining amount should be included\n";
    ss << "\\note in that block.  This field is unusual because it can be either a number or a name of a variable.\n";
    ss << "\\type alpha\n";
    ss << "\\begin-extensible\n";
    ss << "A10; \\field Block Cost per Unit Value or Variable Name\n";
    ss << "\\note The cost of the block. This field is unusual for the EnergyPlus syntax because it can be either a number\n";
    ss << "\\note or a name of a variable.\n";
    ss << "\\type alpha\n";

    IddObjectType objType(IddObjectType::OS_UtilityCost_Charge_Block);
    OptionalIddObject oObj = IddObject::load("OS:UtilityCost:Charge:Block",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_UtilityCost_Charge_Block);
  return object;
}

IddObject createOS_UtilityCost_Charge_SimpleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:UtilityCost:Charge:Simple,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note Charge Variable Name\n";
    ss << "\\note This is the name associated with the UtilityCost:Charge:Simple object and will appear in the report.\n";
    ss << "\\note In addition the results of the UtilityCost:Charge:Simple calculation are stored in a variable with the\n";
    ss << "\\note same name.  That way the results may be used for further calculation.  Spaces are not significant in\n";
    ss << "\\note Charge variable names. They are removed during the utility bill calculation process.\n";
    ss << "\\type alpha\n";
    ss << "A3, \\field Tariff Name\n";
    ss << "\\type alpha\n";
    ss << "A4, \\field Source Variable\n";
    ss << "\\note The name of the source used by the UtilityCost:Charge:Simple.  This is usually the name of the variable\n";
    ss << "\\note holding the energy or demand but may also be the name of any variable including the subtotal or basis\n";
    ss << "\\note if other charges are based on those.\n";
    ss << "\\type alpha\n";
    ss << "A5, \\field Season\n";
    ss << "\\note If this is set to annual the calculations are performed for the UtilityCost:Charge:Simple for the entire\n";
    ss << "\\note year (all months) otherwise it is calculated only for those months in the season defined.\n";
    ss << "\\type choice\n";
    ss << "\\key Annual\n";
    ss << "\\key Summer\n";
    ss << "\\key Winter\n";
    ss << "\\key Spring\n";
    ss << "\\key Fall\n";
    ss << "A6, \\field Category Variable Name\n";
    ss << "\\note This field shows where the charge should be added. The reason to enter this field appropriately is so\n";
    ss << "\\note that the charge gets reported in a reasonable category.  The charge automatically gets added to the\n";
    ss << "\\note variable that is the category.\n";
    ss << "\\type choice\n";
    ss << "\\key EnergyCharges\n";
    ss << "\\key DemandCharges\n";
    ss << "\\key ServiceCharges\n";
    ss << "\\key Basis\n";
    ss << "\\key Adjustment\n";
    ss << "\\key Surcharge\n";
    ss << "\\key Subtotal\n";
    ss << "\\key Taxes\n";
    ss << "\\key Total\n";
    ss << "\\key NotIncluded\n";
    ss << "A7; \\field Cost per Unit Value or Variable Name\n";
    ss << "\\note This field contains either a single number or the name of a variable.  The number is multiplied with\n";
    ss << "\\note all of the energy or demand or other source that is specified in the source field.  If a variable is\n";
    ss << "\\note used then the monthly values of the variable are multiplied against the variable specified in the\n";
    ss << "\\note source field.  This field makes it easy to include a simple charge without specifying block sizes.\n";
    ss << "\\note This is a good way to include a tax or cost adjustment.\n";
    ss << "\\type alpha\n";

    IddObjectType objType(IddObjectType::OS_UtilityCost_Charge_Simple);
    OptionalIddObject oObj = IddObject::load("OS:UtilityCost:Charge:Simple",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_UtilityCost_Charge_Simple);
  return object;
}

IddObject createOS_UtilityCost_ComputationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:UtilityCost:Computation,\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 1\n";
    ss << "\\max-fields 33\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "A3, \\field Tariff Name\n";
    ss << "\\type alpha\n";
    ss << "A4; \\field Compute Step\n";
    ss << "\\note Contain a simple language that describes the steps used in the computation process similar to a\n";
    ss << "\\note programming language.\n";
    ss << "\\type alpha\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::OS_UtilityCost_Computation);
    OptionalIddObject oObj = IddObject::load("OS:UtilityCost:Computation",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_UtilityCost_Computation);
  return object;
}

IddObject createOS_UtilityCost_QualifyIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:UtilityCost:Qualify,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note Displayed in the report if the tariff does not qualify\n";
    ss << "\\type alpha\n";
    ss << "A3, \\field Tariff Name\n";
    ss << "\\note The name of the UtilityCost:Tariff that is associated with this UtilityCost:Qualify.\n";
    ss << "\\type alpha\n";
    ss << "A4, \\field Variable Name\n";
    ss << "\\note The name of the variable used. For energy and demand the automatically created variables totalEnergy\n";
    ss << "\\note and totalDemand should be used respectively.\n";
    ss << "\\type alpha\n";
    ss << "A5, \\field Qualify Type\n";
    ss << "\\type choice\n";
    ss << "\\key Minimum\n";
    ss << "\\key Maximum\n";
    ss << "A6, \\field Threshold Value or Variable Name\n";
    ss << "\\note The minimum or maximum value for the qualify. If the variable has values that are less than this value\n";
    ss << "\\note when the qualify type is minimum then the tariff may be disqualified.  If the variable has values that\n";
    ss << "\\note are greater than this value when the qualify type is maximum then the tariff may be disqualified.\n";
    ss << "\\type alpha\n";
    ss << "A7, \\field Season\n";
    ss << "\\note If the UtilityCost:Qualify only applies to a season enter the season name. If this field is left blank\n";
    ss << "\\note it defaults to Annual.\n";
    ss << "\\type choice\n";
    ss << "\\key Annual\n";
    ss << "\\key Summer\n";
    ss << "\\key Winter\n";
    ss << "\\key Spring\n";
    ss << "\\key Fall\n";
    ss << "A8, \\field Threshold Test\n";
    ss << "\\note Uses the number in Number of Months in one of two different ways depending on the Threshold  Test. If\n";
    ss << "\\note the Threshold Test is set to Count then the qualification is based on the count of the total number\n";
    ss << "\\note of months per year.  If the Threshold Test is set to consecutive then the qualification is based on\n";
    ss << "\\note a consecutive number of months.\n";
    ss << "\\type choice\n";
    ss << "\\key Count\n";
    ss << "\\key Consecutive\n";
    ss << "N1; \\field Number of Months\n";
    ss << "\\note A number from 1 to 12.  If no value entered 12 is assumed when the qualify type is minimum and 1 when\n";
    ss << "\\note the qualify type is maximum.  This is the number of months that the threshold test applies to determine\n";
    ss << "\\note if the rate qualifies or not.  If the season is less than 12 months (if it is not annual) then the\n";
    ss << "\\note value is automatically reduced to the number of months of the seaon.\n";
    ss << "\\type real\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";

    IddObjectType objType(IddObjectType::OS_UtilityCost_Qualify);
    OptionalIddObject oObj = IddObject::load("OS:UtilityCost:Qualify",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_UtilityCost_Qualify);
  return object;
}

IddObject createOS_UtilityCost_RatchetIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:UtilityCost:Ratchet,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note Ratchet Variable Name\n";
    ss << "\\note The name of the ratchet and the name of the result of this single ratchet.\n";
    ss << "\\type alpha\n";
    ss << "A3, \\field Tariff Name\n";
    ss << "\\type alpha\n";
    ss << "A4, \\field Baseline Source Variable\n";
    ss << "\\note When the ratcheted value exceeds the baseline value for a month the ratcheted value is used but when the\n";
    ss << "\\note baseline value is greater then the ratcheted value the baseline value is used. Usually the electric\n";
    ss << "\\note demand charge is used.  The baseline source variable can be the results of another ratchet object. This\n";
    ss << "\\note allows utility tariffs that have multiple ratchets to be modeled.\n";
    ss << "\\type alpha\n";
    ss << "A5, \\field Adjustment Source Variable\n";
    ss << "\\note The variable that the ratchet is calculated from. It is often but not always the same as the baseline\n";
    ss << "\\note source variable.  The ratcheting calculations using offset and multiplier are using the values from the\n";
    ss << "\\note adjustment source variable. If left blank the adjustment source variable is the same as the baseline\n";
    ss << "\\note source variable.\n";
    ss << "\\type alpha\n";
    ss << "A6, \\field Season From\n";
    ss << "\\note The name of the season that is being examined.  The maximum value for all of the months in the named\n";
    ss << "\\note season is what is used with the multiplier and offset.  This is most commonly Summer or Annual.  When\n";
    ss << "\\note Monthly is used the adjustment source variable is used directly for all months.\n";
    ss << "\\type choice\n";
    ss << "\\key Annual\n";
    ss << "\\key Summer\n";
    ss << "\\key Winter\n";
    ss << "\\key Spring\n";
    ss << "\\key Fall\n";
    ss << "\\key Monthly\n";
    ss << "A7, \\field Season To\n";
    ss << "\\note The name of the season when the ratchet would be calculated.  This is most commonly Winter.  The ratchet\n";
    ss << "\\note only is applied to the months in the named season. The resulting variable for months not in the Season To\n";
    ss << "\\note selection will contain the values as appear in the baseline source variable.\n";
    ss << "\\type choice\n";
    ss << "\\key Annual\n";
    ss << "\\key Summer\n";
    ss << "\\key Winter\n";
    ss << "\\key Spring\n";
    ss << "\\key Fall\n";
    ss << "A8, \\field Multiplier Value or Variable Name\n";
    ss << "\\note Often the ratchet has a clause such as \"the current month demand or 90% of the summer month demand\".  For\n";
    ss << "\\note this case a value of 0.9 would be entered here as the multiplier.  This value may be left blank if no\n";
    ss << "\\note multiplier is needed and a value of one will be used as a default.\n";
    ss << "\\type alpha\n";
    ss << "A9; \\field Offset Value or Variable Name\n";
    ss << "\\note A less common strategy is to say that the ratchet must be all demand greater than a value in this case\n";
    ss << "\\note an offset that is added to the demand may be entered here. If entered it is common for the offset value\n";
    ss << "\\note to be negative representing that the demand be reduced.   If no value is entered it is assumed to be\n";
    ss << "\\note zero and not affect the ratchet.\n";
    ss << "\\type alpha\n";

    IddObjectType objType(IddObjectType::OS_UtilityCost_Ratchet);
    OptionalIddObject oObj = IddObject::load("OS:UtilityCost:Ratchet",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_UtilityCost_Ratchet);
  return object;
}

IddObject createOS_UtilityCost_TariffIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:UtilityCost:Tariff,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note The name of the tariff. Tariffs are sometimes called rates. The name is used in identifying\n";
    ss << "\\note the output results and in associating all of the charges and other objects that make up a tariff.\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A3, \\field Output Meter Name\n";
    ss << "\\note The name of any standard meter or custom meter or but usually set to either Electricity:Facility or Gas:Facility\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A4, \\field Conversion Factor Choice\n";
    ss << "\\note A choice that allows several different predefined conversion factors to be used; otherwise user\n";
    ss << "\\note defined conversion factors are used as defined in the next two fields.\n";
    ss << "\\type choice\n";
    ss << "\\key UserDefined\n";
    ss << "\\key kWh\n";
    ss << "\\key Therm\n";
    ss << "\\key MMBtu\n";
    ss << "\\key MJ\n";
    ss << "\\key kBtu\n";
    ss << "\\key MCF\n";
    ss << "\\key CCF\n";
    ss << "N1, \\field Energy Conversion Factor\n";
    ss << "\\note Is a multiplier used to convert energy into the units specified by the utility in their tariff. If\n";
    ss << "\\note left blank it defaults to 1 (no conversion). This field should will be used only if Conversion Factor\n";
    ss << "\\note Choice is set to UserDefined.  Within EnergyPlus energy always has units of J (joules).  For\n";
    ss << "\\note conversion from J to kWh use the value of 0.0000002778. This is also used for all objects that\n";
    ss << "\\note reference the UtilityCost:Tariff.\n";
    ss << "\\type real\n";
    ss << "N2, \\field Demand Conversion Factor\n";
    ss << "\\note Is a multiplier used to convert demand into the units specified by the utility in their tariff. If\n";
    ss << "\\note left blank it defaults to 1 (no conversion).  This field should will be used only if Conversion\n";
    ss << "\\note Factor Choice is set to UserDefined.  Within EnergyPlus demand always has units of J/s (joules/sec)\n";
    ss << "\\note which equivalent to W (watts).  For conversion from W to kW use the value of 0.001. This is also used\n";
    ss << "\\note for all objects that reference the UtilityCost:Tariff.\n";
    ss << "\\type real\n";
    ss << "A5, \\field Time of Use Period Schedule Name\n";
    ss << "\\note The name of the schedule that defines the time-of-use periods that occur each day. The values for the\n";
    ss << "\\note different variables are: 1 for Peak. 2 for Shoulder. 3 for OffPeak. 4 for MidPeak.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6, \\field Season Schedule Name\n";
    ss << "\\note The name of a schedule that defines the seasons.  The schedule values are: 1 for Winter. 2 for Spring.\n";
    ss << "\\note 3 for Summer. 4 for Autumn.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A7, \\field Month Schedule Name\n";
    ss << "\\note The name of the schedule that defines the billing periods of the year. Normally this entry is allowed\n";
    ss << "\\note to default and a schedule will be internally used that has the breaks between billing periods occurring\n";
    ss << "\\note at the same time as the breaks between months i.e. at midnight prior to the first day of the month.\n";
    ss << "\\note If other billing periods are used such as two month cycles or a single bill for an entire season such\n";
    ss << "\\note as some natural gas companies do in the summer then the month schedule may be used to redefine it.\n";
    ss << "\\note Make sure that the month schedule and season schedule are consistent otherwise an error will be issued.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A8, \\field Demand Window Length\n";
    ss << "\\note The determination of demand can vary by utility. Some utilities use the peak instantaneous demand\n";
    ss << "\\note measured but most use a fifteen minute average demand or a one hour average demand. Some gas utilities\n";
    ss << "\\note measure demand as the use during the peak day or peak week.\n";
    ss << "\\type choice\n";
    ss << "\\key QuarterHour\n";
    ss << "\\key HalfHour\n";
    ss << "\\key FullHour\n";
    ss << "\\key Day\n";
    ss << "\\key Week\n";
    ss << "A9, \\field Monthly Charge or Variable Name\n";
    ss << "\\note The fixed monthly service charge that many utilities have.  The entry may be numeric and gets added to\n";
    ss << "\\note the ServiceCharges variable or if a variable name is entered here its values for each month are used.\n";
    ss << "\\type alpha\n";
    ss << "A10, \\field Minimum Monthly Charge or Variable Name\n";
    ss << "\\note The minimum total charge for the tariff or if a variable name is entered here its\n";
    ss << "\\note values for each month are used.\n";
    ss << "\\type alpha\n";
    ss << "A11, \\field Real Time Pricing Charge Schedule Name\n";
    ss << "\\note Used with real time pricing rates. The name of a schedule that contains the cost of\n";
    ss << "\\note energy for that particular time period of the year. Real time rates can be modeled using a charge\n";
    ss << "\\note schedule with the actual real time prices entered in the schedule.\n";
    ss << "\\type alpha\n";
    ss << "A12, \\field Customer Baseline Load Schedule Name\n";
    ss << "\\note Used with real time pricing rates. The name of a schedule that contains the baseline\n";
    ss << "\\note energy use for the customer. Many real time rates apply the charges as a credit or debit only to the\n";
    ss << "\\note difference between the baseline use and the actual use.\n";
    ss << "\\type alpha\n";
    ss << "A13, \\field Group Name\n";
    ss << "\\note The group name of the tariff such as distribution transmission supplier etc. If more than one tariff\n";
    ss << "\\note with the same group name is present and qualifies only the lowest cost tariff is used. Usually the group\n";
    ss << "\\note name field is left blank which results in all tariffs using the same meter variable being compared and\n";
    ss << "\\note the lowest cost one being selected.\n";
    ss << "\\type alpha\n";
    ss << "A14; \\field Buy Or Sell\n";
    ss << "\\note Sets whether the tariff is used for buying selling or both to the utility.  This\n";
    ss << "\\note should be allowed to default to buyFromUtility unless a power generation system is included in the\n";
    ss << "\\note building that may generate more power than the building needs during the year\n";
    ss << "\\type choice\n";
    ss << "\\key BuyFromUtility\n";
    ss << "\\key SellToUtility\n";
    ss << "\\key NetMetering\n";

    IddObjectType objType(IddObjectType::OS_UtilityCost_Tariff);
    OptionalIddObject oObj = IddObject::load("OS:UtilityCost:Tariff",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_UtilityCost_Tariff);
  return object;
}

IddObject createOS_UtilityCost_VariableIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:UtilityCost:Variable,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "A3, \\field Tariff Name\n";
    ss << "\\type alpha\n";
    ss << "A4, \\field Variable Type\n";
    ss << "\\type choice\n";
    ss << "\\key Energy\n";
    ss << "\\key Power\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Currency\n";
    ss << "N1, \\field January Value\n";
    ss << "\\type real\n";
    ss << "N2, \\field February Value\n";
    ss << "\\type real\n";
    ss << "N3, \\field March Value\n";
    ss << "\\type real\n";
    ss << "N4, \\field April Value\n";
    ss << "\\type real\n";
    ss << "N5, \\field May Value\n";
    ss << "\\type real\n";
    ss << "N6, \\field June Value\n";
    ss << "\\type real\n";
    ss << "N7, \\field July Value\n";
    ss << "\\type real\n";
    ss << "N8, \\field August Value\n";
    ss << "\\type real\n";
    ss << "N9, \\field September Value\n";
    ss << "\\type real\n";
    ss << "N10, \\field October Value\n";
    ss << "\\type real\n";
    ss << "N11, \\field November Value\n";
    ss << "\\type real\n";
    ss << "N12; \\field December Value\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::OS_UtilityCost_Variable);
    OptionalIddObject oObj = IddObject::load("OS:UtilityCost:Variable",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_UtilityCost_Variable);
  return object;
}

IddObject createOS_WeatherFileIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:WeatherFile,\n";
    ss << "\\unique-object\n";
    ss << "\\url-object\n";
    ss << "\\min-fields 12\n";
    ss << "\\memo OS:WeatherFile object uniquely identifies a weather file for lookup in a database\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field City\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A3, \\field State Province Region\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A4, \\field Country\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A5, \\field Data Source\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A6, \\field WMO Number\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "N1, \\field Latitude\n";
    ss << "\\note + is North, - is South, degree minutes represented in decimal (i.e. 30 minutes is .5)\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units deg\n";
    ss << "\\minimum -90\n";
    ss << "\\maximum 90\n";
    ss << "N2, \\field Longitude\n";
    ss << "\\note - is West, + is East, degree minutes represented in decimal (i.e. 30 minutes is .5)\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units deg\n";
    ss << "\\minimum -180\n";
    ss << "\\maximum 180\n";
    ss << "N3, \\field Time Zone\n";
    ss << "\\note Time relative to GMT. Decimal hours.\n";
    ss << "\\note basic these limits on the WorldTimeZone Map (2003)\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units hr\n";
    ss << "\\minimum -12\n";
    ss << "\\maximum 14\n";
    ss << "N4, \\field Elevation\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum -300\n";
    ss << "\\maximum< 8900\n";
    ss << "\\default 0.0\n";
    ss << "A7, \\field Url\n";
    ss << "\\retaincase\n";
    ss << "\\type url\n";
    ss << "A8; \\field Checksum\n";
    ss << "\\type alpha\n";

    IddObjectType objType(IddObjectType::OS_WeatherFile);
    OptionalIddObject oObj = IddObject::load("OS:WeatherFile",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_WeatherFile);
  return object;
}

IddObject createOS_WeatherProperty_SkyTemperatureIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:WeatherProperty:SkyTemperature,\n";
    ss << "\\memo This object is used to override internal sky temperature calculations.\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note blank in this field will apply to all run periods (that is, all objects=\n";
    ss << "\\note SizingPeriod:WeatherFileDays, SizingPeriod:WeatherFileConditionType or RunPeriod\n";
    ss << "\\note otherwise, this name must match one of the environment object names.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RunPeriodsAndDesignDays\n";
    ss << "A3, \\field Calculation Type\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key ScheduleValue\n";
    ss << "\\key DifferenceScheduleDryBulbValue\n";
    ss << "\\key DifferenceScheduleDewPointValue\n";
    ss << "A4; \\field Schedule Name\n";
    ss << "\\note if name matches a SizingPeriod:DesignDay, put in a day schedule of this name\n";
    ss << "\\note if name is for a SizingPeriod:WeatherFileDays, SizingPeriod:WeatherFileConditionType or\n";
    ss << "\\note RunPeriod, put in a full year schedule that covers the appropriate days.\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleAndDayScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_WeatherProperty_SkyTemperature);
    OptionalIddObject oObj = IddObject::load("OS:WeatherProperty:SkyTemperature",
                                             "OpenStudio Site",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_WeatherProperty_SkyTemperature);
  return object;
}

IddObject createOS_BuildingStoryIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:BuildingStory,\n";
    ss << "\\min-fields 7\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference BuildingStoryNames\n";
    ss << "\\reference SpaceAndSpaceGroupNames\n";
    ss << "N1, \\field Nominal Z Coordinate\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "N2, \\field Nominal Floor to Floor Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "A3, \\field Default Construction Set Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DefaultConstructionSetNames\n";
    ss << "A4, \\field Default Schedule Set Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DefaultScheduleSetNames\n";
    ss << "A5, \\field Group Rendering Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list GroupRenderingNames\n";
    ss << "N3; \\field Nominal Floor to Ceiling Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";

    IddObjectType objType(IddObjectType::OS_BuildingStory);
    OptionalIddObject oObj = IddObject::load("OS:BuildingStory",
                                             "OpenStudio Resources",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_BuildingStory);
  return object;
}

IddObject createOS_DefaultConstructionSetIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:DefaultConstructionSet,\n";
    ss << "\\min-fields 11\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference DefaultConstructionSetNames\n";
    ss << "A3, \\field Default Exterior Surface Constructions Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DefaultSurfaceConstructionsNames\n";
    ss << "A4, \\field Default Interior Surface Constructions Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DefaultSurfaceConstructionsNames\n";
    ss << "A5, \\field Default Ground Contact Surface Constructions Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DefaultSurfaceConstructionsNames\n";
    ss << "A6, \\field Default Exterior SubSurface Constructions Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DefaultSubSurfaceConstructionsNames\n";
    ss << "A7, \\field Default Interior SubSurface Constructions Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DefaultSubSurfaceConstructionsNames\n";
    ss << "A8, \\field Interior Partition Construction Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A9, \\field Space Shading Construction Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A10, \\field Building Shading Construction Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A11; \\field Site Shading Construction Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";

    IddObjectType objType(IddObjectType::OS_DefaultConstructionSet);
    OptionalIddObject oObj = IddObject::load("OS:DefaultConstructionSet",
                                             "OpenStudio Resources",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_DefaultConstructionSet);
  return object;
}

IddObject createOS_DefaultScheduleSetIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:DefaultScheduleSet,\n";
    ss << "\\min-fields 12\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference DefaultScheduleSetNames\n";
    ss << "A3, \\field Hours of Operation Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4, \\field Number of People Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5, \\field People Activity Level Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6, \\field Lighting Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A7, \\field Electric Equipment Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A8, \\field Gas Equipment Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A9, \\field Hot Water Equipment Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A10, \\field Infiltration Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A11, \\field Steam Equipment Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A12; \\field Other Equipment Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_DefaultScheduleSet);
    OptionalIddObject oObj = IddObject::load("OS:DefaultScheduleSet",
                                             "OpenStudio Resources",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_DefaultScheduleSet);
  return object;
}

IddObject createOS_DefaultSubSurfaceConstructionsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:DefaultSubSurfaceConstructions,\n";
    ss << "\\min-fields 10\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference DefaultSubSurfaceConstructionsNames\n";
    ss << "A3, \\field Fixed Window Construction Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A4, \\field Operable Window Construction Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A5, \\field Door Construction Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A6, \\field Glass Door Construction Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A7, \\field Overhead Door Construction Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A8, \\field Skylight Construction Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A9, \\field Tubular Daylight Dome Construction Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A10; \\field Tubular Daylight Diffuser Construction Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";

    IddObjectType objType(IddObjectType::OS_DefaultSubSurfaceConstructions);
    OptionalIddObject oObj = IddObject::load("OS:DefaultSubSurfaceConstructions",
                                             "OpenStudio Resources",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_DefaultSubSurfaceConstructions);
  return object;
}

IddObject createOS_DefaultSurfaceConstructionsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:DefaultSurfaceConstructions,\n";
    ss << "\\min-fields 5\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference DefaultSurfaceConstructionsNames\n";
    ss << "A3, \\field Floor Construction Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A4, \\field Wall Construction Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A5; \\field Roof Ceiling Construction Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";

    IddObjectType objType(IddObjectType::OS_DefaultSurfaceConstructions);
    OptionalIddObject oObj = IddObject::load("OS:DefaultSurfaceConstructions",
                                             "OpenStudio Resources",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_DefaultSurfaceConstructions);
  return object;
}

IddObject createOS_Rendering_ColorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Rendering:Color,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference AllRenderingNames\n";
    ss << "\\reference SurfaceRenderingNames\n";
    ss << "\\reference GroupRenderingNames\n";
    ss << "N1, \\field Rendering Red Value\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 255\n";
    ss << "N2, \\field Rendering Green Value\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 255\n";
    ss << "N3, \\field Rendering Blue Value\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 255\n";
    ss << "N4; \\field Rendering Alpha Value\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 255\n";
    ss << "\\default 255\n";

    IddObjectType objType(IddObjectType::OS_Rendering_Color);
    OptionalIddObject oObj = IddObject::load("OS:Rendering:Color",
                                             "OpenStudio Resources",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Rendering_Color);
  return object;
}

IddObject createOS_SpaceTypeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SpaceType,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference SpaceTypeNames\n";
    ss << "\\reference SpaceAndSpaceTypeNames\n";
    ss << "A3, \\field Default Construction Set Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DefaultConstructionSetNames\n";
    ss << "A4, \\field Default Schedule Set Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DefaultScheduleSetNames\n";
    ss << "A5, \\field Group Rendering Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list GroupRenderingNames\n";
    ss << "A6, \\field Design Specification Outdoor Air Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "A7, \\field Standards Building Type\n";
    ss << "\\type alpha\n";
    ss << "\\note This is a freeform field used to identify the building type for standards.\n";
    ss << "\\note Standards applied to this model will use this field to determine correct levels for lighting, occupancy, etc.\n";
    ss << "\\note More information can be found at https://github.com/NREL/openstudio-standards.\n";
    ss << "A8; \\field Standards Space Type\n";
    ss << "\\type alpha\n";
    ss << "\\note This is a freeform field used to identify the space type for standards.\n";
    ss << "\\note Standards applied to this model will use this field to determine correct levels for lighting, occupancy, etc.\n";
    ss << "\\note More information can be found at https://github.com/NREL/openstudio-standards.\n";

    IddObjectType objType(IddObjectType::OS_SpaceType);
    OptionalIddObject oObj = IddObject::load("OS:SpaceType",
                                             "OpenStudio Resources",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SpaceType);
  return object;
}

IddObject createOS_ModelObjectListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ModelObjectList,\n";
    ss << "\\min-fields 1\n";
    ss << "\\extensible:1 Just duplicate last field and comments (changing numbering, please)\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type Handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ModelObjectLists\n";
    ss << "A3; \\field Model Object 1\n";
    ss << "\\begin-extensible\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllObjects\n";

    IddObjectType objType(IddObjectType::OS_ModelObjectList);
    OptionalIddObject oObj = IddObject::load("OS:ModelObjectList",
                                             "OpenStudio Resources",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ModelObjectList);
  return object;
}

IddObject createOS_MaterialIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Material,\n";
    ss << "\\memo Regular materials described with full set of thermal properties\n";
    ss << "\\min-fields 7\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference MaterialNames\n";
    ss << "A3, \\field Roughness\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key VeryRough\n";
    ss << "\\key Rough\n";
    ss << "\\key MediumRough\n";
    ss << "\\key MediumSmooth\n";
    ss << "\\key Smooth\n";
    ss << "\\key VerySmooth\n";
    ss << "N1, \\field Thickness\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\ip-units in\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 3\n";
    ss << "N2, \\field Conductivity\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W/m-K\n";
    ss << "\\ip-units Btu-in/hr-ft2-R\n";
    ss << "\\minimum> 0\n";
    ss << "N3, \\field Density\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units kg/m3\n";
    ss << "\\minimum> 0\n";
    ss << "N4, \\field Specific Heat\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units J/kg-K\n";
    ss << "\\ip-units Btu/lb-R\n";
    ss << "\\minimum> 0\n";
    ss << "N5, \\field Thermal Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 0.99999\n";
    ss << "\\default .9\n";
    ss << "N6, \\field Solar Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default .7\n";
    ss << "N7; \\field Visible Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default .7\n";

    IddObjectType objType(IddObjectType::OS_Material);
    OptionalIddObject oObj = IddObject::load("OS:Material",
                                             "OpenStudio Materials",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Material);
  return object;
}

IddObject createOS_Material_AirGapIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Material:AirGap,\n";
    ss << "\\memo Air Space in Opaque Construction\n";
    ss << "\\min-fields 3\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference MaterialNames\n";
    ss << "N1; \\field Thermal Resistance\n";
    ss << "\\type real\n";
    ss << "\\units m2-K/W\n";
    ss << "\\minimum> 0\n";

    IddObjectType objType(IddObjectType::OS_Material_AirGap);
    OptionalIddObject oObj = IddObject::load("OS:Material:AirGap",
                                             "OpenStudio Materials",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Material_AirGap);
  return object;
}

IddObject createOS_Material_AirWallIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Material:AirWall,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2; \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference MaterialNames\n";

    IddObjectType objType(IddObjectType::OS_Material_AirWall);
    OptionalIddObject oObj = IddObject::load("OS:Material:AirWall",
                                             "OpenStudio Materials",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Material_AirWall);
  return object;
}

IddObject createOS_Material_InfraredTransparentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Material:InfraredTransparent,\n";
    ss << "\\memo Special infrared transparent material.  Similar to a Material:Nomass with low thermal resistance.\n";
    ss << "\\memo High absorptance in both wavelengths.\n";
    ss << "\\memo Area will be doubled internally to make internal radiant exchange accurate.\n";
    ss << "\\memo Should be only material in single layer surface construction.\n";
    ss << "\\memo All thermal properties are set internally. User needs only to supply name.\n";
    ss << "\\memo Cannot be used with ConductionFiniteDifference solution algorithms\n";
    ss << "\\min-fields 2\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2; \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference MaterialNames\n";

    IddObjectType objType(IddObjectType::OS_Material_InfraredTransparent);
    OptionalIddObject oObj = IddObject::load("OS:Material:InfraredTransparent",
                                             "OpenStudio Materials",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Material_InfraredTransparent);
  return object;
}

IddObject createOS_Material_NoMassIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Material:NoMass,\n";
    ss << "\\memo Regular materials properties described whose principal description is R (Thermal Resistance)\n";
    ss << "\\min-fields 4\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference MaterialNames\n";
    ss << "A3, \\field Roughness\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key VeryRough\n";
    ss << "\\key Rough\n";
    ss << "\\key MediumRough\n";
    ss << "\\key MediumSmooth\n";
    ss << "\\key Smooth\n";
    ss << "\\key VerySmooth\n";
    ss << "N1, \\field Thermal Resistance\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m2-K/W\n";
    ss << "\\minimum 0.001\n";
    ss << "N2, \\field Thermal Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 0.99999\n";
    ss << "\\default .9\n";
    ss << "N3, \\field Solar Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default .7\n";
    ss << "N4; \\field Visible Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default .7\n";

    IddObjectType objType(IddObjectType::OS_Material_NoMass);
    OptionalIddObject oObj = IddObject::load("OS:Material:NoMass",
                                             "OpenStudio Materials",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Material_NoMass);
  return object;
}

IddObject createOS_Material_RoofVegetationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Material:RoofVegetation,\n";
    ss << "\\memo EcoRoof model, plant layer plus soil layer\n";
    ss << "\\memo Implemented by Portland State University\n";
    ss << "\\memo (Sailor et al., January, 2007)\n";
    ss << "\\memo only one material must be referenced per simulation though the same EcoRoof material could be\n";
    ss << "\\memo used in multiple constructions. New moisture redistribution scheme (2010) requires higher\n";
    ss << "\\memo number of timesteps per hour (minimum 12 recommended).\n";
    ss << "\\min-fields 19\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference MaterialNames\n";
    ss << "N1, \\field Height of Plants\n";
    ss << "\\note The ecoroof module is designed for short plants and shrubs.\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.005\n";
    ss << "\\maximum 1\n";
    ss << "\\default .2\n";
    ss << "N2, \\field Leaf Area Index\n";
    ss << "\\note Entire surface is assumed covered, so decrease LAI accordingly.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.001\n";
    ss << "\\maximum 5\n";
    ss << "\\default 1.0\n";
    ss << "N3, \\field Leaf Reflectivity\n";
    ss << "\\note Leaf reflectivity (albedo) is typically 0.18-0.25\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.05\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.22\n";
    ss << "N4, \\field Leaf Emissivity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.8\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.95\n";
    ss << "N5, \\field Minimum Stomatal Resistance\n";
    ss << "\\note This depends upon plant type\n";
    ss << "\\type real\n";
    ss << "\\units s/m\n";
    ss << "\\minimum 50\n";
    ss << "\\maximum 300\n";
    ss << "\\default 180.0\n";
    ss << "A3, \\field Soil Layer Name\n";
    ss << "\\type alpha\n";
    ss << "\\default Green Roof Soil\n";
    ss << "A4, \\field Roughness\n";
    ss << "\\type choice\n";
    ss << "\\default MediumRough\n";
    ss << "\\key VeryRough\n";
    ss << "\\key MediumRough\n";
    ss << "\\key Rough\n";
    ss << "\\key Smooth\n";
    ss << "\\key MediumSmooth\n";
    ss << "\\key VerySmooth\n";
    ss << "N6, \\field Thickness\n";
    ss << "\\note thickness of the soil layer of the EcoRoof\n";
    ss << "\\note Soil depths of 0.15m (6in) and 0.30m (12in) are common.\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\ip-units in\n";
    ss << "\\minimum> 0.05\n";
    ss << "\\maximum 0.7\n";
    ss << "\\default 0.1\n";
    ss << "N7, \\field Conductivity of Dry Soil\n";
    ss << "\\note Thermal conductivity of dry soil.\n";
    ss << "\\note Typical ecoroof soils range from 0.3 to 0.5\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\ip-units Btu-in/hr-ft2-R\n";
    ss << "\\minimum 0.2\n";
    ss << "\\maximum 1.5\n";
    ss << "\\default 0.35\n";
    ss << "N8, \\field Density of Dry Soil\n";
    ss << "\\note Density of dry soil (the code modifies this as the soil becomes moist)\n";
    ss << "\\note Typical ecoroof soils range from 400 to 1000 (dry to wet)\n";
    ss << "\\type real\n";
    ss << "\\units kg/m3\n";
    ss << "\\minimum 300\n";
    ss << "\\maximum 2000\n";
    ss << "\\default 1100.0\n";
    ss << "N9, \\field Specific Heat of Dry Soil\n";
    ss << "\\note Specific heat of dry soil\n";
    ss << "\\type real\n";
    ss << "\\units J/kg-K\n";
    ss << "\\ip-units Btu/lb-R\n";
    ss << "\\minimum> 500\n";
    ss << "\\maximum 2000\n";
    ss << "\\default 1200.0\n";
    ss << "N10, \\field Thermal Absorptance\n";
    ss << "\\note Soil emissivity is typically in range of 0.90 to 0.98\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.8\n";
    ss << "\\maximum 1\n";
    ss << "\\default .9\n";
    ss << "N11, \\field Solar Absorptance\n";
    ss << "\\note Solar absorptance of dry soil (1-albedo) is typically 0.60 to 0.85\n";
    ss << "\\note corresponding to a dry albedo of 0.15 to 0.40\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.4\n";
    ss << "\\maximum 0.9\n";
    ss << "\\default .70\n";
    ss << "N12, \\field Visible Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.5\n";
    ss << "\\maximum 1\n";
    ss << "\\default .75\n";
    ss << "N13, \\field Saturation Volumetric Moisture Content of the Soil Layer\n";
    ss << "\\note Maximum moisture content is typically less than 0.5\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.1\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.3\n";
    ss << "N14, \\field Residual Volumetric Moisture Content of the Soil Layer\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.01\n";
    ss << "\\maximum 0.1\n";
    ss << "\\default 0.01\n";
    ss << "N15, \\field Initial Volumetric Moisture Content of the Soil Layer\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.05\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.1\n";
    ss << "A5; \\field Moisture Diffusion Calculation Method\n";
    ss << "\\note Advanced calculation requires increased number of timesteps (recommended >20).\n";
    ss << "\\type choice\n";
    ss << "\\default Advanced\n";
    ss << "\\key Simple\n";
    ss << "\\key Advanced\n";

    IddObjectType objType(IddObjectType::OS_Material_RoofVegetation);
    OptionalIddObject oObj = IddObject::load("OS:Material:RoofVegetation",
                                             "OpenStudio Materials",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Material_RoofVegetation);
  return object;
}

IddObject createOS_WindowMaterial_BlindIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:WindowMaterial:Blind,\n";
    ss << "\\memo Window blind thermal properties\n";
    ss << "\\min-fields 30\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference MaterialNames\n";
    ss << "\\reference WindowShadesScreensAndBlinds\n";
    ss << "A3, \\field Slat Orientation\n";
    ss << "\\type choice\n";
    ss << "\\default Horizontal\n";
    ss << "\\key Horizontal\n";
    ss << "\\key Vertical\n";
    ss << "N1, \\field Slat Width\n";
    ss << "\\type real\n";
    ss << "\\default 0.025\n";
    ss << "\\units m\n";
    ss << "\\ip-units in\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "N2, \\field Slat Separation\n";
    ss << "\\note Distance between adjacent slat faces\n";
    ss << "\\type real\n";
    ss << "\\default 0.01875\n";
    ss << "\\units m\n";
    ss << "\\ip-units in\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "N3, \\field Slat Thickness\n";
    ss << "\\note Distance between top and bottom surfaces of slat\n";
    ss << "\\note Slat is assumed to be rectangular in cross section and flat\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\ip-units in\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 0.1\n";
    ss << "\\default 0.001\n";
    ss << "N4, \\field Slat Angle\n";
    ss << "\\note If WindowProperty:ShadingControl for the window that incorporates this blind\n";
    ss << "\\note has Type of Slat Angle Control for Blinds = FixedSlatAngle,\n";
    ss << "\\note then this is the fixed value of the slat angle;\n";
    ss << "\\note If WindowProperty:ShadingControl for the window that incorporates this blind\n";
    ss << "\\note has Type of Slat Angle Control for Blinds = BlockBeamSolar,\n";
    ss << "\\note then this is the slat angle when slat angle control\n";
    ss << "\\note is not in effect (e.g., when there is no beam solar on the blind);\n";
    ss << "\\note Not used if WindowProperty:ShadingControl for the window that incorporates this blind\n";
    ss << "\\note has Type of Slat Angle Control for Blinds = ScheduledSlatAngle.\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "\\default 45\n";
    ss << "N5, \\field Slat Conductivity\n";
    ss << "\\note default is for aluminum\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\ip-units Btu-in/hr-ft2-R\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 221.0\n";
    ss << "N6, \\field Slat Beam Solar Transmittance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "\\default 0.0\n";
    ss << "N7, \\field Front Side Slat Beam Solar Reflectance\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N8, \\field Back Side Slat Beam Solar Reflectance\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N9, \\field Slat Diffuse Solar Transmittance\n";
    ss << "\\note Must equal \"Slat beam solar transmittance\"\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "\\default 0.0\n";
    ss << "N10, \\field Front Side Slat Diffuse Solar Reflectance\n";
    ss << "\\note Must equal \"Front Side Slat Beam Solar Reflectance\"\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N11, \\field Back Side Slat Diffuse Solar Reflectance\n";
    ss << "\\note Must equal \"Back Side Slat Beam Solar Reflectance\"\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N12, \\field Slat Beam Visible Transmittance\n";
    ss << "\\note Required for detailed daylighting calculation\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N13, \\field Front Side Slat Beam Visible Reflectance\n";
    ss << "\\note Required for detailed daylighting calculation\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N14, \\field Back Side Slat Beam Visible Reflectance\n";
    ss << "\\note Required for detailed daylighting calculation\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N15, \\field Slat Diffuse Visible Transmittance\n";
    ss << "\\note Used only for detailed daylighting calculation\n";
    ss << "\\note Must equal \"Slat Beam Visible Transmittance\"\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "\\default 0.0\n";
    ss << "N16, \\field Front Side Slat Diffuse Visible Reflectance\n";
    ss << "\\note Required for detailed daylighting calculation\n";
    ss << "\\note Must equal \"Front Side Slat Beam Visible Reflectance\"\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N17, \\field Back Side Slat Diffuse Visible Reflectance\n";
    ss << "\\note Required for detailed daylighting calculation\n";
    ss << "\\note Must equal \"Back Side Slat Beam Visible Reflectance\"\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N18, \\field Slat Infrared Hemispherical Transmittance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "\\default 0.0\n";
    ss << "N19, \\field Front Side Slat Infrared Hemispherical Emissivity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "\\default 0.9\n";
    ss << "N20, \\field Back Side Slat Infrared Hemispherical Emissivity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "\\default 0.9\n";
    ss << "N21, \\field Blind to Glass Distance\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\ip-units in\n";
    ss << "\\minimum 0.01\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.050\n";
    ss << "N22, \\field Blind Top Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.5\n";
    ss << "N23, \\field Blind Bottom Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.5\n";
    ss << "N24, \\field Blind Left Side Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.5\n";
    ss << "N25, \\field Blind Right Side Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.5\n";
    ss << "N26, \\field Minimum Slat Angle\n";
    ss << "\\note Used only if WindowProperty:ShadingControl for the window that incorporates\n";
    ss << "\\note this blind varies the slat angle (i.e., WindowProperty:ShadingControl with\n";
    ss << "\\note Type of Slat Angle Control for Blinds = ScheduledSlatAngle\n";
    ss << "\\note or BlockBeamSolar)\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "\\default 0\n";
    ss << "N27; \\field Maximum Slat Angle\n";
    ss << "\\note Used only if WindowProperty:ShadingControl for the window that incorporates\n";
    ss << "\\note this blind varies the slat angle (i.e., WindowProperty:ShadingControl with\n";
    ss << "\\note Type of Slat Angle Control for Blinds = ScheduledSlatAngle\n";
    ss << "\\note or BlockBeamSolar)\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 180\n";
    ss << "\\default 180\n";

    IddObjectType objType(IddObjectType::OS_WindowMaterial_Blind);
    OptionalIddObject oObj = IddObject::load("OS:WindowMaterial:Blind",
                                             "OpenStudio Materials",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_WindowMaterial_Blind);
  return object;
}

IddObject createOS_WindowMaterial_DaylightRedirectionDeviceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:WindowMaterial:DaylightRedirectionDevice,\n";
    ss << "\\memo This object is not in EnergyPlus, this represents a film or louver which redirects daylighting.\n";
    ss << "\\min-fields 2\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference MaterialNames\n";
    ss << "\\reference WindowShadesScreensAndBlinds\n";
    ss << "A3; \\field Daylight Redirection Device Type\n";
    ss << "\\type choice\n";
    ss << "\\default Louver\n";
    ss << "\\key Louver\n";
    ss << "\\key Film\n";

    IddObjectType objType(IddObjectType::OS_WindowMaterial_DaylightRedirectionDevice);
    OptionalIddObject oObj = IddObject::load("OS:WindowMaterial:DaylightRedirectionDevice",
                                             "OpenStudio Materials",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_WindowMaterial_DaylightRedirectionDevice);
  return object;
}

IddObject createOS_WindowMaterial_GasIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:WindowMaterial:Gas,\n";
    ss << "\\memo Gas material properties that are used in Windows or Glass Doors\n";
    ss << "\\min-fields 4\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference MaterialNames\n";
    ss << "A3, \\field Gas Type\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Air\n";
    ss << "\\key Argon\n";
    ss << "\\key Krypton\n";
    ss << "\\key Xenon\n";
    ss << "\\key Custom\n";
    ss << "N1, \\field Thickness\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\ip-units in\n";
    ss << "\\minimum> 0\n";
    ss << "N2, \\field Conductivity Coefficient A\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\ip-units Btu-in/hr-ft2-R\n";
    ss << "N3, \\field Conductivity Coefficient B\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K2\n";
    ss << "\\ip-units Btu-in/hr-ft2-R2\n";
    ss << "N4, \\field Conductivity Coefficient C\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K3\n";
    ss << "\\ip-units Btu-in/hr-ft2-R3\n";
    ss << "N5, \\field Viscosity Coefficient A\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "\\type real\n";
    ss << "\\units g/m-s\n";
    ss << "\\minimum> 0\n";
    ss << "N6, \\field Viscosity Coefficient B\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "\\type real\n";
    ss << "\\units g/m-s-K\n";
    ss << "N7, \\field Viscosity Coefficient C\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "\\type real\n";
    ss << "\\units g/m-s-K2\n";
    ss << "N8, \\field Specific Heat Coefficient A\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "\\type real\n";
    ss << "\\units J/kg-K\n";
    ss << "\\ip-units Btu/lb-R\n";
    ss << "\\minimum> 0\n";
    ss << "N9, \\field Specific Heat Coefficient B\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "\\type real\n";
    ss << "\\units J/kg-K2\n";
    ss << "\\ip-units Btu/lb-R2\n";
    ss << "N10, \\field Specific Heat Coefficient C\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "\\type real\n";
    ss << "\\units J/kg-K3\n";
    ss << "\\ip-units Btu/lb-R3\n";
    ss << "N11, \\field Molecular Weight\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "\\type real\n";
    ss << "\\minimum 20\n";
    ss << "\\maximum 200\n";
    ss << "N12; \\field Specific Heat Ratio\n";
    ss << "\\type real\n";
    ss << "\\note Used only if Gas Type = Custom\n";
    ss << "\\minimum >1.0\n";

    IddObjectType objType(IddObjectType::OS_WindowMaterial_Gas);
    OptionalIddObject oObj = IddObject::load("OS:WindowMaterial:Gas",
                                             "OpenStudio Materials",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_WindowMaterial_Gas);
  return object;
}

IddObject createOS_WindowMaterial_GasMixtureIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:WindowMaterial:GasMixture,\n";
    ss << "\\memo Gas mixtures that are used in Windows or Glass Doors\n";
    ss << "\\min-fields 8\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference MaterialNames\n";
    ss << "N1, \\field Thickness\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "N2, \\field Number of Gases in Mixture\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 4\n";
    ss << "A3, \\field Gas 1 Type\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Air\n";
    ss << "\\key Argon\n";
    ss << "\\key Krypton\n";
    ss << "\\key Xenon\n";
    ss << "N3, \\field Gas 1 Fraction\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "A4, \\field Gas 2 Type\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Air\n";
    ss << "\\key Argon\n";
    ss << "\\key Krypton\n";
    ss << "\\key Xenon\n";
    ss << "N4, \\field Gas 2 Fraction\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "A5, \\field Gas 3 Type\n";
    ss << "\\type choice\n";
    ss << "\\key Air\n";
    ss << "\\key Argon\n";
    ss << "\\key Krypton\n";
    ss << "\\key Xenon\n";
    ss << "N5, \\field Gas 3 Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "A6, \\field Gas 4 Type\n";
    ss << "\\type choice\n";
    ss << "\\key Air\n";
    ss << "\\key Argon\n";
    ss << "\\key Krypton\n";
    ss << "\\key Xenon\n";
    ss << "N6; \\field Gas 4 Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";

    IddObjectType objType(IddObjectType::OS_WindowMaterial_GasMixture);
    OptionalIddObject oObj = IddObject::load("OS:WindowMaterial:GasMixture",
                                             "OpenStudio Materials",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_WindowMaterial_GasMixture);
  return object;
}

IddObject createOS_WindowMaterial_GlazingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:WindowMaterial:Glazing,\n";
    ss << "\\memo Glass material properties for Windows or Glass Doors\n";
    ss << "\\memo Transmittance/Reflectance input method.\n";
    ss << "\\min-fields 15\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference MaterialNames\n";
    ss << "\\reference GlazingMaterialNames\n";
    ss << "A3, \\field Optical Data Type\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key SpectralAverage\n";
    ss << "\\key Spectral\n";
    ss << "A4, \\field Window Glass Spectral Data Set Name\n";
    ss << "\\note Used only when Optical Data Type = Spectral\n";
    ss << "\\type alpha\n";
    ss << "N1, \\field Thickness\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\ip-units in\n";
    ss << "\\minimum> 0\n";
    ss << "N2, \\field Solar Transmittance at Normal Incidence\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "N3, \\field Front Side Solar Reflectance at Normal Incidence\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\note Front Side is side closest to outdoor air\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "N4, \\field Back Side Solar Reflectance at Normal Incidence\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\note Back Side is side closest to zone air\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "N5, \\field Visible Transmittance at Normal Incidence\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "N6, \\field Front Side Visible Reflectance at Normal Incidence\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "N7, \\field Back Side Visible Reflectance at Normal Incidence\n";
    ss << "\\note Used only when Optical Data Type = SpectralAverage\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "N8, \\field Infrared Transmittance at Normal Incidence\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N9, \\field Front Side Infrared Hemispherical Emissivity\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum< 1\n";
    ss << "\\default 0.84\n";
    ss << "N10, \\field Back Side Infrared Hemispherical Emissivity\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum< 1\n";
    ss << "\\default 0.84\n";
    ss << "N11, \\field Conductivity\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\ip-units Btu-in/hr-ft2-R\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.9\n";
    ss << "N12, \\field Dirt Correction Factor for Solar and Visible Transmittance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 1.0\n";
    ss << "A5; \\field Solar Diffusing\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key No\n";
    ss << "\\key Yes\n";

    IddObjectType objType(IddObjectType::OS_WindowMaterial_Glazing);
    OptionalIddObject oObj = IddObject::load("OS:WindowMaterial:Glazing",
                                             "OpenStudio Materials",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_WindowMaterial_Glazing);
  return object;
}

IddObject createOS_WindowMaterial_GlazingGroup_ThermochromicIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:WindowMaterial:GlazingGroup:Thermochromic,\n";
    ss << "\\memo thermochromic glass at different temperatures\n";
    ss << "\\extensible:2\n";
    ss << "\\min-fields 4\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference MaterialNames\n";
    ss << "\\reference GlazingMaterialNames\n";
    ss << "N1, \\field Optical Data Temperature\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\units C\n";
    ss << "\\ip-units F\n";
    ss << "A3; \\field Window Material Glazing Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list GlazingMaterialNames\n";

    IddObjectType objType(IddObjectType::OS_WindowMaterial_GlazingGroup_Thermochromic);
    OptionalIddObject oObj = IddObject::load("OS:WindowMaterial:GlazingGroup:Thermochromic",
                                             "OpenStudio Materials",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_WindowMaterial_GlazingGroup_Thermochromic);
  return object;
}

IddObject createOS_WindowMaterial_Glazing_RefractionExtinctionMethodIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:WindowMaterial:Glazing:RefractionExtinctionMethod,\n";
    ss << "\\memo Glass material properties for Windows or Glass Doors\n";
    ss << "\\memo Index of Refraction/Extinction Coefficient input method\n";
    ss << "\\memo Not to be used for coated glass\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference MaterialNames\n";
    ss << "\\reference GlazingMaterialNames\n";
    ss << "N1, \\field Thickness\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\ip-units in\n";
    ss << "\\minimum> 0\n";
    ss << "N2, \\field Solar Index of Refraction\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 1\n";
    ss << "N3, \\field Solar Extinction Coefficient\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units 1/m\n";
    ss << "\\minimum> 0\n";
    ss << "N4, \\field Visible Index of Refraction\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 1\n";
    ss << "N5, \\field Visible Extinction Coefficient\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units 1/m\n";
    ss << "\\minimum> 0\n";
    ss << "N6, \\field Infrared Transmittance at Normal Incidence\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "\\default 0.0\n";
    ss << "N7, \\field Infrared Hemispherical Emissivity\n";
    ss << "\\note Emissivity of front and back side assumed equal\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum< 1\n";
    ss << "\\default 0.84\n";
    ss << "N8, \\field Conductivity\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\ip-units Btu-in/hr-ft2-R\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.9\n";
    ss << "N9, \\field Dirt Correction Factor for Solar and Visible Transmittance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 1.0\n";
    ss << "A3; \\field Solar Diffusing\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key No\n";
    ss << "\\key Yes\n";

    IddObjectType objType(IddObjectType::OS_WindowMaterial_Glazing_RefractionExtinctionMethod);
    OptionalIddObject oObj = IddObject::load("OS:WindowMaterial:Glazing:RefractionExtinctionMethod",
                                             "OpenStudio Materials",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_WindowMaterial_Glazing_RefractionExtinctionMethod);
  return object;
}

IddObject createOS_WindowMaterial_ScreenIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:WindowMaterial:Screen,\n";
    ss << "\\memo Window screen physical properties. Can only be located on the exterior side of a window construction.\n";
    ss << "\\min-fields 10\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note Enter a unique name for this window screen material.\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference MaterialNames\n";
    ss << "\\reference WindowShadesScreensAndBlinds\n";
    ss << "A3, \\field Reflected Beam Transmittance Accounting Method\n";
    ss << "\\note Select the method used to account for the beam solar reflected off the material surface.\n";
    ss << "\\type choice\n";
    ss << "\\default ModelAsDiffuse\n";
    ss << "\\key DoNotModel\n";
    ss << "\\key ModelAsDirectBeam\n";
    ss << "\\key ModelAsDiffuse\n";
    ss << "N1, \\field Diffuse Solar Reflectance\n";
    ss << "\\note Diffuse reflectance of the screen material over the entire solar radiation spectrum.\n";
    ss << "\\note Assumed to be the same for both sides of the screen.\n";
    ss << "\\type real\n";
    ss << "\\default 0.08\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N2, \\field Diffuse Visible Reflectance\n";
    ss << "\\note Diffuse visible reflectance of the screen material averaged over the solar spectrum\n";
    ss << "\\note and weighted by the response of the human eye.\n";
    ss << "\\note Assumed to be the same for both sides of the screen.\n";
    ss << "\\type real\n";
    ss << "\\default 0.08\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N3, \\field Thermal Hemispherical Emissivity\n";
    ss << "\\note Long-wave emissivity of the screen material.\n";
    ss << "\\note Assumed to be the same for both sides of the screen.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum< 1\n";
    ss << "\\default 0.9\n";
    ss << "N4, \\field Conductivity\n";
    ss << "\\note Thermal conductivity of the screen material.\n";
    ss << "\\note Default is for aluminum.\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\ip-units Btu-in/hr-ft2-R\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 221.0\n";
    ss << "N5, \\field Screen Material Spacing\n";
    ss << "\\note Spacing assumed to be the same in both directions.\n";
    ss << "\\type real\n";
    ss << "\\default 0.00157\n";
    ss << "\\units m\n";
    ss << "\\ip-units in\n";
    ss << "\\minimum> 0\n";
    ss << "N6, \\field Screen Material Diameter\n";
    ss << "\\note Diameter assumed to be the same in both directions.\n";
    ss << "\\type real\n";
    ss << "\\default 0.000381\n";
    ss << "\\units m\n";
    ss << "\\ip-units in\n";
    ss << "\\minimum> 0\n";
    ss << "N7, \\field Screen to Glass Distance\n";
    ss << "\\note Distance from the window screen to the adjacent glass surface.\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\ip-units in\n";
    ss << "\\minimum 0.001\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.025\n";
    ss << "N8, \\field Top Opening Multiplier\n";
    ss << "\\note Effective area for air flow at the top of the screen divided by the perpendicular\n";
    ss << "\\note area between the glass and the top of the screen.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N9, \\field Bottom Opening Multiplier\n";
    ss << "\\note Effective area for air flow at the bottom of the screen divided by the perpendicular\n";
    ss << "\\note area between the glass and the bottom of the screen.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N10, \\field Left Side Opening Multiplier\n";
    ss << "\\note Effective area for air flow at the left side of the screen divided by the perpendicular\n";
    ss << "\\note area between the glass and the left side of the screen.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N11, \\field Right Side Opening Multiplier\n";
    ss << "\\note Effective area for air flow at the right side of the screen divided by the perpendicular\n";
    ss << "\\note area between the glass and the right side of the screen.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N12; \\field Angle of Resolution for Screen Transmittance Output Map\n";
    ss << "\\note Select the resolution of azimuth and altitude angles for the screen transmittance map.\n";
    ss << "\\note A value of 0 means no transmittance map will be generated.\n";
    ss << "\\note Valid values for this field are 0, 1, 2, 3 and 5.\n";
    ss << "\\type choice\n";
    ss << "\\units deg\n";
    ss << "\\default 0\n";
    ss << "\\key 0\n";
    ss << "\\key 1\n";
    ss << "\\key 2\n";
    ss << "\\key 3\n";
    ss << "\\key 5\n";

    IddObjectType objType(IddObjectType::OS_WindowMaterial_Screen);
    OptionalIddObject oObj = IddObject::load("OS:WindowMaterial:Screen",
                                             "OpenStudio Materials",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_WindowMaterial_Screen);
  return object;
}

IddObject createOS_WindowMaterial_ShadeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:WindowMaterial:Shade,\n";
    ss << "\\memo Window shade thermal properties\n";
    ss << "\\min-fields 16\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference MaterialNames\n";
    ss << "\\reference WindowShadesScreensAndBlinds\n";
    ss << "N1, \\field Solar Transmittance\n";
    ss << "\\note Assumed independent of incidence angle\n";
    ss << "\\type real\n";
    ss << "\\default 0.4\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N2, \\field Solar Reflectance\n";
    ss << "\\note Assumed same for both sides\n";
    ss << "\\note Assumed independent of incidence angle\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N3, \\field Visible Transmittance\n";
    ss << "\\note Assumed independent of incidence angle\n";
    ss << "\\type real\n";
    ss << "\\default 0.4\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N4, \\field Visible Reflectance\n";
    ss << "\\note Assumed same for both sides\n";
    ss << "\\note Assumed independent of incidence angle\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N5, \\field Thermal Hemispherical Emissivity\n";
    ss << "\\type real\n";
    ss << "\\default 0.9\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum< 1\n";
    ss << "N6, \\field Thermal Transmittance\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum< 1\n";
    ss << "N7, \\field Thickness\n";
    ss << "\\type real\n";
    ss << "\\default 0.005\n";
    ss << "\\units m\n";
    ss << "\\ip-units in\n";
    ss << "\\minimum> 0\n";
    ss << "N8, \\field Conductivity\n";
    ss << "\\type real\n";
    ss << "\\default 0.1\n";
    ss << "\\units W/m-K\n";
    ss << "\\ip-units Btu-in/hr-ft2-R\n";
    ss << "\\minimum> 0\n";
    ss << "N9, \\field Shade to Glass Distance\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\ip-units in\n";
    ss << "\\minimum 0.001\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.050\n";
    ss << "N10, \\field Top Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N11, \\field Bottom Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N12, \\field Left-Side Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N13, \\field Right-Side Opening Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N14; \\field Airflow Permeability\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 0.8\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::OS_WindowMaterial_Shade);
    OptionalIddObject oObj = IddObject::load("OS:WindowMaterial:Shade",
                                             "OpenStudio Materials",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_WindowMaterial_Shade);
  return object;
}

IddObject createOS_WindowMaterial_SimpleGlazingSystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:WindowMaterial:SimpleGlazingSystem,\n";
    ss << "\\memo Alternate method of describing windows\n";
    ss << "\\memo This window material object is used to define an entire glazing system\n";
    ss << "\\memo using simple performance parameters.\n";
    ss << "\\min-fields 4\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference MaterialNames\n";
    ss << "\\reference GlazingMaterialNames\n";
    ss << "N1, \\field U-Factor\n";
    ss << "\\note Enter U-Factor including film coefficients\n";
    ss << "\\note Note that the effective upper limit for U-factor is 5.8 W/m2-K\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 7\n";
    ss << "N2, \\field Solar Heat Gain Coefficient\n";
    ss << "\\note SHGC at Normal Incidence\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum< 1\n";
    ss << "N3; \\field Visible Transmittance\n";
    ss << "\\note VT at Normal Incidence\n";
    ss << "\\note optional\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum< 1\n";

    IddObjectType objType(IddObjectType::OS_WindowMaterial_SimpleGlazingSystem);
    OptionalIddObject oObj = IddObject::load("OS:WindowMaterial:SimpleGlazingSystem",
                                             "OpenStudio Materials",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_WindowMaterial_SimpleGlazingSystem);
  return object;
}

IddObject createOS_StandardsInformation_MaterialIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:StandardsInformation:Material,\n";
    ss << "\\min-fields 2\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Material Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list MaterialNames\n";
    ss << "A3, \\field Material Standard\n";
    ss << "\\note This is a freeform field used to identify the standard which specifies this material.\n";
    ss << "\\note More information can be found at https://github.com/NREL/openstudio-standards.\n";
    ss << "\\type alpha\n";
    ss << "A4, \\field Material Standard Source\n";
    ss << "\\note This is a freeform field used to identify the table or section in the standard which specifies this material.\n";
    ss << "\\note More information can be found at https://github.com/NREL/openstudio-standards.\n";
    ss << "\\type alpha\n";
    ss << "A5, \\field Standards Category\n";
    ss << "\\note This is a freeform field used to identify the category of this material, e.g. 'Plastering Materials' 'Composite', or 'Roofing'.\n";
    ss << "\\note More information can be found at https://github.com/NREL/openstudio-standards.\n";
    ss << "\\type alpha\n";
    ss << "A6, \\field Standards Identifier\n";
    ss << "\\note This is a freeform field used to identify the id of this material within a standard.\n";
    ss << "\\note More information can be found at https://github.com/NREL/openstudio-standards.\n";
    ss << "\\type alpha\n";
    ss << "A7, \\field Composite Framing Material\n";
    ss << "\\note This is a freeform field used to identify the framing material for a composite layer.\n";
    ss << "\\note More information can be found at https://github.com/NREL/openstudio-standards.\n";
    ss << "\\type alpha\n";
    ss << "A8, \\field Composite Framing Configuration\n";
    ss << "\\note This is a freeform field used to identify the framing configuration for a composite layer.\n";
    ss << "\\note More information can be found at https://github.com/NREL/openstudio-standards.\n";
    ss << "\\type alpha\n";
    ss << "A9, \\field Composite Framing Depth\n";
    ss << "\\note This is a freeform field used to identify the framing depth for a composite layer.\n";
    ss << "\\note More information can be found at https://github.com/NREL/openstudio-standards.\n";
    ss << "\\type alpha\n";
    ss << "A10, \\field Composite Framing Size\n";
    ss << "\\note This is a freeform field used to identify the framing size for a composite layer.\n";
    ss << "\\note More information can be found at https://github.com/NREL/openstudio-standards.\n";
    ss << "\\type alpha\n";
    ss << "A11; \\field Composite Cavity Insulation\n";
    ss << "\\note This is a freeform field used to identify the cavity insulation for a composite layer.\n";
    ss << "\\note More information can be found at https://github.com/NREL/openstudio-standards.\n";
    ss << "\\type alpha\n";

    IddObjectType objType(IddObjectType::OS_StandardsInformation_Material);
    OptionalIddObject oObj = IddObject::load("OS:StandardsInformation:Material",
                                             "OpenStudio Materials",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_StandardsInformation_Material);
  return object;
}

IddObject createOS_ConstructionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Construction,\n";
    ss << "\\memo Start with outside layer and work your way to the inside layer\n";
    ss << "\\memo Up to 10 layers total, 8 for windows\n";
    ss << "\\memo Enter the material name for each layer\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 4\n";
    ss << "\\max-fields 13\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConstructionNames\n";
    ss << "A3, \\field Surface Rendering Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceRenderingNames\n";
    ss << "A4; \\field Layer\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\object-list MaterialNames\n";

    IddObjectType objType(IddObjectType::OS_Construction);
    OptionalIddObject oObj = IddObject::load("OS:Construction",
                                             "OpenStudio Constructions",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Construction);
  return object;
}

IddObject createOS_Construction_CfactorUndergroundWallIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Construction:CfactorUndergroundWall,\n";
    ss << "\\memo Alternate method of describing underground wall constructions\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConstructionNames\n";
    ss << "N1, \\field C-Factor\n";
    ss << "\\note Enter C-Factor without film coefficients or soil\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum> 0\n";
    ss << "N2, \\field Height\n";
    ss << "\\note Enter height of the underground wall\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "A3; \\field Surface Rendering Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceRenderingNames\n";

    IddObjectType objType(IddObjectType::OS_Construction_CfactorUndergroundWall);
    OptionalIddObject oObj = IddObject::load("OS:Construction:CfactorUndergroundWall",
                                             "OpenStudio Constructions",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Construction_CfactorUndergroundWall);
  return object;
}

IddObject createOS_Construction_FfactorGroundFloorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Construction:FfactorGroundFloor,\n";
    ss << "\\memo Alternate method of describing slab-on-grade or underground floor constructions\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConstructionNames\n";
    ss << "N1, \\field F-Factor\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W/m-K\n";
    ss << "\\ip-units Btu/h-ft-F\n";
    ss << "\\minimum> 0\n";
    ss << "N2, \\field Area\n";
    ss << "\\note Enter area of the floor\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m2\n";
    ss << "\\minimum> 0\n";
    ss << "N3, \\field PerimeterExposed\n";
    ss << "\\note Enter exposed perimeter of the floor\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\minimum 0\n";
    ss << "A3; \\field Surface Rendering Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceRenderingNames\n";

    IddObjectType objType(IddObjectType::OS_Construction_FfactorGroundFloor);
    OptionalIddObject oObj = IddObject::load("OS:Construction:FfactorGroundFloor",
                                             "OpenStudio Constructions",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Construction_FfactorGroundFloor);
  return object;
}

IddObject createOS_Construction_InternalSourceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Construction:InternalSource,\n";
    ss << "\\memo Start with outside layer and work your way to the inside Layer\n";
    ss << "\\memo Up to 10 layers total, 8 for windows\n";
    ss << "\\memo Enter the material name for each layer\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 8\n";
    ss << "\\max-fields 17\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConstructionNames\n";
    ss << "N1, \\field Source Present After Layer Number\n";
    ss << "\\note refers to the list of materials which follows\n";
    ss << "\\type integer\n";
    ss << "\\default 1\n";
    ss << "\\minimum 1\n";
    ss << "N2, \\field Temperature Calculation Requested After Layer Number\n";
    ss << "\\note refers to the list of materials which follows\n";
    ss << "\\type integer\n";
    ss << "\\default 1\n";
    ss << "\\minimum 1\n";
    ss << "N3, \\field Dimensions for the CTF Calculation\n";
    ss << "\\note 1 = 1-dimensional calculation, 2 = 2-dimensional calculation\n";
    ss << "\\type integer\n";
    ss << "\\default 1\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 2\n";
    ss << "N4, \\field Tube Spacing\n";
    ss << "\\note uniform spacing between tubes or resistance wires in direction\n";
    ss << "\\note perpendicular to main intended direction of heat transfer\n";
    ss << "\\type real\n";
    ss << "\\default 0.154\n";
    ss << "\\units m\n";
    ss << "A3, \\field Surface Rendering Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceRenderingNames\n";
    ss << "A4; \\field Layer\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\object-list MaterialNames\n";

    IddObjectType objType(IddObjectType::OS_Construction_InternalSource);
    OptionalIddObject oObj = IddObject::load("OS:Construction:InternalSource",
                                             "OpenStudio Constructions",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Construction_InternalSource);
  return object;
}

IddObject createOS_Construction_WindowDataFileIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Construction:WindowDataFile,\n";
    ss << "\\memo Initiates search of the Window5 data file for a window called Name.\n";
    ss << "\\url-object\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConstructionNames\n";
    ss << "A3, \\field Url\n";
    ss << "\\retaincase\n";
    ss << "\\retaincase\n";
    ss << "\\type url\n";
    ss << "A4; \\field Surface Rendering Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceRenderingNames\n";

    IddObjectType objType(IddObjectType::OS_Construction_WindowDataFile);
    OptionalIddObject oObj = IddObject::load("OS:Construction:WindowDataFile",
                                             "OpenStudio Constructions",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Construction_WindowDataFile);
  return object;
}

IddObject createOS_StandardsInformation_ConstructionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:StandardsInformation:Construction,\n";
    ss << "\\min-fields 2\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Construction Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A3, \\field Intended Surface Type\n";
    ss << "\\type choice\n";
    ss << "\\key AtticFloor\n";
    ss << "\\key AtticWall\n";
    ss << "\\key AtticRoof\n";
    ss << "\\key DemisingFloor\n";
    ss << "\\key DemisingWall\n";
    ss << "\\key DemisingRoof\n";
    ss << "\\key ExteriorFloor\n";
    ss << "\\key ExteriorWall\n";
    ss << "\\key ExteriorRoof\n";
    ss << "\\key ExteriorWindow\n";
    ss << "\\key ExteriorDoor\n";
    ss << "\\key GlassDoor\n";
    ss << "\\key GroundContactFloor\n";
    ss << "\\key GroundContactWall\n";
    ss << "\\key GroundContactRoof\n";
    ss << "\\key InteriorFloor\n";
    ss << "\\key InteriorWall\n";
    ss << "\\key InteriorCeiling\n";
    ss << "\\key InteriorPartition\n";
    ss << "\\key InteriorWindow\n";
    ss << "\\key InteriorDoor\n";
    ss << "\\key OverheadDoor\n";
    ss << "\\key Skylight\n";
    ss << "\\key TubularDaylightDome\n";
    ss << "\\key TubularDaylightDiffuser\n";
    ss << "A4, \\field Standards Construction Type\n";
    ss << "\\note This is a freeform field used to identify the construction type for standards.\n";
    ss << "\\note Standards applied to this model will use this field to determine correct constructions.\n";
    ss << "\\note More information can be found at https://github.com/NREL/openstudio-standards.\n";
    ss << "\\type alpha\n";
    ss << "N1, \\field Perturbable Layer\n";
    ss << "\\note If the construction is layered, this is the index (starting at 0)\n";
    ss << "\\note of the layer whose thickness can be adjusted to meet a u-factor\n";
    ss << "\\note requirement.\n";
    ss << "\\type integer\n";
    ss << "A5, \\field Perturbable Layer Type\n";
    ss << "\\type choice\n";
    ss << "\\default Not Applicable\n";
    ss << "\\key Not Applicable\n";
    ss << "\\key Insulation\n";
    ss << "\\key Other\n";
    ss << "A6, \\field Other Perturbable Layer Type\n";
    ss << "\\type alpha\n";
    ss << "A7, \\field Construction Standard\n";
    ss << "\\note This is a freeform field used to identify the standard which specifies this construction.\n";
    ss << "\\type alpha\n";
    ss << "A8, \\field Construction Standard Source\n";
    ss << "\\note This is a freeform field used to identify the table or section of the standard which specifies this construction.\n";
    ss << "\\type alpha\n";
    ss << "A9, \\field Fenestration Type\n";
    ss << "\\note Specific type of fenestration that this construction represents.\n";
    ss << "\\type choice\n";
    ss << "\\key Fixed Window\n";
    ss << "\\key Operable Window\n";
    ss << "\\key Curtain Wall\n";
    ss << "\\key Glazed Door\n";
    ss << "\\key Glass Skylight with Curb\n";
    ss << "\\key Plastic Skylight with Curb\n";
    ss << "\\key Glass Skylight without Curb\n";
    ss << "\\key Plastic Skylight without Curb\n";
    ss << "\\key Swinging Door\n";
    ss << "\\key Non-Swinging Door\n";
    ss << "A10,\\field Fenestration Assembly Context\n";
    ss << "\\note Where is this fenestration assembled.\n";
    ss << "\\type choice\n";
    ss << "\\key Manufactured\n";
    ss << "\\key Field Fabricated\n";
    ss << "\\key Site Built\n";
    ss << "A11,\\field Fenestration Number of Panes\n";
    ss << "\\note Number of panes for this fenestration construction.\n";
    ss << "\\note BCL taxonomy term 'Construction Assembly.Fenestration.Window.Number of Panes'\n";
    ss << "\\type choice\n";
    ss << "\\key Single Pane\n";
    ss << "\\key Double Pane\n";
    ss << "\\key Triple Pane\n";
    ss << "\\key Quadruple Pane\n";
    ss << "\\key Glass Block\n";
    ss << "A12,\\field Fenestration Frame Type\n";
    ss << "\\note Type of framing for this fenestration construction.\n";
    ss << "\\type choice\n";
    ss << "\\key Metal Framing\n";
    ss << "\\key Metal Framing with Thermal Break\n";
    ss << "\\key Non-Metal Framing\n";
    ss << "A13,\\field Fenestration Divider Type\n";
    ss << "\\note Type of divider for this fenestration construction.\n";
    ss << "\\type choice\n";
    ss << "\\key True Divided Lite\n";
    ss << "\\key Between Panes < 7/16\"\n";
    ss << "\\key Between Panes >= 7/16\"\n";
    ss << "A14,\\field Fenestration Tint\n";
    ss << "\\note Tint of this fenestration construction.\n";
    ss << "\\note BCL taxonomy term 'Construction Assembly.Fenestration.Window.Tint'\n";
    ss << "\\type choice\n";
    ss << "\\key Clear\n";
    ss << "\\key Bronze\n";
    ss << "\\key Grey\n";
    ss << "\\key Green\n";
    ss << "\\key Blue\n";
    ss << "\\key Tinted\n";
    ss << "A15,\\field Fenestration Gas Fill\n";
    ss << "\\note Type of gas used between panes of this fenestration construction.\n";
    ss << "\\note BCL taxonomy term 'Construction Assembly.Fenestration.Window.Gas Fill'\n";
    ss << "\\type choice\n";
    ss << "\\key Air\n";
    ss << "\\key Argon\n";
    ss << "\\key Krypton\n";
    ss << "A16;\\field Fenestration Low Emissivity Coating\n";
    ss << "\\note Does this fenestration construction include a low-e coating.\n";
    ss << "\\type choice\n";
    ss << "\\key True\n";
    ss << "\\key False\n";

    IddObjectType objType(IddObjectType::OS_StandardsInformation_Construction);
    OptionalIddObject oObj = IddObject::load("OS:StandardsInformation:Construction",
                                             "OpenStudio Constructions",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_StandardsInformation_Construction);
  return object;
}

IddObject createOS_InternalMass_DefinitionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:InternalMass:Definition,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference InternalMassDefinitionNames\n";
    ss << "\\reference SpaceComponentDefinitionNames\n";
    ss << "A3, \\field Construction Name\n";
    ss << "\\note Leave blank to match with default construction\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A4, \\field Design Level Calculation Method\n";
    ss << "\\note Choices: SurfaceArea => Surface Area -- simply enter surface area\n";
    ss << "\\note SurfaceArea/Area => Surface Area per Space Floor Area -- enter the number to apply.  Value * Floor Area = Surface Area\n";
    ss << "\\note SurfaceArea/Person => Surface Area per Person -- enter the number to apply.  Value * Occupants = Surface Area\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key SurfaceArea\n";
    ss << "\\key SurfaceArea/Area\n";
    ss << "\\key SurfaceArea/Person\n";
    ss << "N1, \\field Surface Area\n";
    ss << "\\type real\n";
    ss << "\\units m2\n";
    ss << "\\ip-units ft2\n";
    ss << "\\minimum 0\n";
    ss << "N2, \\field Surface Area per Space Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\ip-units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "N3; \\field Surface Area per Person\n";
    ss << "\\type real\n";
    ss << "\\units m2/person\n";
    ss << "\\ip-units ft2/person\n";
    ss << "\\minimum 0\n";

    IddObjectType objType(IddObjectType::OS_InternalMass_Definition);
    OptionalIddObject oObj = IddObject::load("OS:InternalMass:Definition",
                                             "OpenStudio Space Load Definitions",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_InternalMass_Definition);
  return object;
}

IddObject createOS_People_DefinitionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:People:Definition,\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 1\n";
    ss << "\\max-fields 16\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference PeopleDefinitionNames\n";
    ss << "\\reference SpaceComponentDefinitionNames\n";
    ss << "A3, \\field Number of People Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum number of people\n";
    ss << "\\note for this set of attributes (i.e. sensible fraction, schedule, etc)\n";
    ss << "\\note Choices: People -- simply enter number of occupants.\n";
    ss << "\\note People per Space Floor Area -- enter the number to apply.  Value * Floor Area = Number of people\n";
    ss << "\\note Space Floor Area per Person -- enter the number to apply.  Floor Area / Value = Number of people\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key People\n";
    ss << "\\key People/Area\n";
    ss << "\\key Area/Person\n";
    ss << "N1, \\field Number of People\n";
    ss << "\\type real\n";
    ss << "\\units people\n";
    ss << "\\minimum 0\n";
    ss << "N2, \\field People per Space Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units person/m2\n";
    ss << "\\minimum 0\n";
    ss << "N3, \\field Space Floor Area per Person\n";
    ss << "\\type real\n";
    ss << "\\units m2/person\n";
    ss << "\\minimum 0\n";
    ss << "N4, \\field Fraction Radiant\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "N5, \\field Sensible Heat Fraction\n";
    ss << "\\note if input, overrides program calculated sensible/latent split\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default autocalculate\n";
    ss << "N6, \\field Carbon Dioxide Generation Rate\n";
    ss << "\\note CO2 generation rate per unit of activity level.\n";
    ss << "\\note The default value is obtained from ASHRAE Std 62.1 at 0.0084 cfm/met/person over\n";
    ss << "\\note the general adult population.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-W\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 3.82e-07\n";
    ss << "\\default 3.82E-8\n";
    ss << "A4, \\field Enable ASHRAE 55 Comfort Warnings\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A5, \\field Mean Radiant Temperature Calculation Type\n";
    ss << "\\note optional (only required for thermal comfort runs)\n";
    ss << "\\type choice\n";
    ss << "\\default ZoneAveraged\n";
    ss << "\\key ZoneAveraged\n";
    ss << "\\key SurfaceWeighted\n";
    ss << "\\key AngleFactor\n";
    ss << "A6; \\field Thermal Comfort Model Type\n";
    ss << "\\note optional (only needed for people thermal comfort results reporting)\n";
    ss << "\\type choice\n";
    ss << "\\begin-extensible\n";
    ss << "\\key Fanger\n";
    ss << "\\key Pierce\n";
    ss << "\\key KSU\n";
    ss << "\\key AdaptiveASH55\n";
    ss << "\\key AdaptiveCEN15251\n";

    IddObjectType objType(IddObjectType::OS_People_Definition);
    OptionalIddObject oObj = IddObject::load("OS:People:Definition",
                                             "OpenStudio Space Load Definitions",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_People_Definition);
  return object;
}

IddObject createOS_Lights_DefinitionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Lights:Definition,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference LightsDefinitionNames\n";
    ss << "\\reference SpaceComponentDefinitionNames\n";
    ss << "A3, \\field Design Level Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum amount of lights\n";
    ss << "\\note for this set of attributes\n";
    ss << "\\note Choices: LightingLevel => Lighting Level -- simply enter watts of lights\n";
    ss << "\\note Watts/Area => Watts per Space Floor Area -- enter the number to apply.  Value * Floor Area = Lights\n";
    ss << "\\note Watts/Person => Watts per Person -- enter the number to apply.  Value * Occupants = Lights\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key LightingLevel\n";
    ss << "\\key Watts/Area\n";
    ss << "\\key Watts/Person\n";
    ss << "N1, \\field Lighting Level\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0\n";
    ss << "N2, \\field Watts per Space Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\ip-units W/ft2\n";
    ss << "\\minimum 0\n";
    ss << "N3, \\field Watts per Person\n";
    ss << "\\type real\n";
    ss << "\\units W/person\n";
    ss << "\\ip-units W/person\n";
    ss << "\\minimum 0\n";
    ss << "N4, \\field Fraction Radiant\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N5, \\field Fraction Visible\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N6, \\field Return Air Fraction\n";
    ss << "\\note Used only for sizing calculation if return-air-fraction\n";
    ss << "\\note coefficients are specified.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "A4, \\field Return Air Fraction Calculated from Plenum Temperature\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "N7, \\field Return Air Fraction Function of Plenum Temperature Coefficient 1\n";
    ss << "\\note Used only if Return Air Fraction Is Calculated from Plenum Temperature = Yes\n";
    ss << "\\note Equation is Return Air Fraction = Coefficient#1 - Coefficient#2 X PlenumTemp(degC)\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N8; \\field Return Air Fraction Function of Plenum Temperature Coefficient 2\n";
    ss << "\\note Used only if Return Air Fraction Is Calculated from Plenum Temperature = Yes\n";
    ss << "\\note Equation is Return Air Fraction = Coefficient#1 - Coefficient#2 X PlenumTemp(degC)\n";
    ss << "\\type real\n";
    ss << "\\units 1/K\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::OS_Lights_Definition);
    OptionalIddObject oObj = IddObject::load("OS:Lights:Definition",
                                             "OpenStudio Space Load Definitions",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Lights_Definition);
  return object;
}

IddObject createOS_Luminaire_DefinitionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Luminaire:Definition,\n";
    ss << "\\url-object\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference LuminaireDefinitionNames\n";
    ss << "\\reference SpaceComponentDefinitionNames\n";
    ss << "A3, \\field IES File Path\n";
    ss << "\\retaincase\n";
    ss << "\\retaincase\n";
    ss << "\\type url\n";
    ss << "N1, \\field Lighting Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "N2, \\field Fraction Radiant\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "N3, \\field Fraction Visible\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "N4, \\field Return Air Fraction\n";
    ss << "\\note Used only for sizing calculation if return-air-fraction\n";
    ss << "\\note coefficients are specified.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "A4, \\field Return Air Fraction Calculated from Plenum Temperature\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "N5, \\field Return Air Fraction Function of Plenum Temperature Coefficient 1\n";
    ss << "\\note Used only if Return Air Fraction Is Calculated from Plenum Temperature = Yes\n";
    ss << "\\note Equation is Return Air Fraction = Coefficient#1 - Coefficient#2 X PlenumTemp(degC)\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N6; \\field Return Air Fraction Function of Plenum Temperature Coefficient 2\n";
    ss << "\\note Used only if Return Air Fraction Is Calculated from Plenum Temperature = Yes\n";
    ss << "\\note Equation is Return Air Fraction = Coefficient#1 - Coefficient#2 X PlenumTemp(degC)\n";
    ss << "\\type real\n";
    ss << "\\units 1/K\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::OS_Luminaire_Definition);
    OptionalIddObject oObj = IddObject::load("OS:Luminaire:Definition",
                                             "OpenStudio Space Load Definitions",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Luminaire_Definition);
  return object;
}

IddObject createOS_ElectricEquipment_DefinitionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ElectricEquipment:Definition,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ElectricEquipmentDefinitionNames\n";
    ss << "\\reference SpaceComponentDefinitionNames\n";
    ss << "A3, \\field Design Level Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum amount of electric equipment\n";
    ss << "\\note for this set of attributes\n";
    ss << "\\note Choices: EquipmentLevel => Equipment Level -- simply enter watts of equipment\n";
    ss << "\\note Watts/Area => Watts per Space Floor Area -- enter the number to apply.  Value * Floor Area = Equipment Level\n";
    ss << "\\note Watts/Person => Watts per Person -- enter the number to apply.  Value * Occupants = Equipment Level\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key EquipmentLevel\n";
    ss << "\\key Watts/Area\n";
    ss << "\\key Watts/Person\n";
    ss << "N1, \\field Design Level\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0\n";
    ss << "N2, \\field Watts per Space Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\ip-units W/ft2\n";
    ss << "\\minimum 0\n";
    ss << "N3, \\field Watts per Person\n";
    ss << "\\type real\n";
    ss << "\\units W/person\n";
    ss << "\\ip-units W/person\n";
    ss << "\\minimum 0\n";
    ss << "N4, \\field Fraction Latent\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N5, \\field Fraction Radiant\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N6; \\field Fraction Lost\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::OS_ElectricEquipment_Definition);
    OptionalIddObject oObj = IddObject::load("OS:ElectricEquipment:Definition",
                                             "OpenStudio Space Load Definitions",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ElectricEquipment_Definition);
  return object;
}

IddObject createOS_GasEquipment_DefinitionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:GasEquipment:Definition,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference GasEquipmentDefinitionNames\n";
    ss << "\\reference SpaceComponentDefinitionNames\n";
    ss << "A3, \\field Design Level Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum amount of gas equipment\n";
    ss << "\\note for this set of attributes\n";
    ss << "\\note Choices: EquipmentLevel => Equipment Level -- simply enter watts of equipment\n";
    ss << "\\note Watts/Area => Watts per Space Floor Area -- enter the number to apply.  Value * Floor Area = Equipment Level\n";
    ss << "\\note Watts/Person => Watts per Person -- enter the number to apply.  Value * Occupants = Equipment Level\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key EquipmentLevel\n";
    ss << "\\key Watts/Area\n";
    ss << "\\key Watts/Person\n";
    ss << "N1, \\field Design Level\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\ip-units Btu/h\n";
    ss << "\\minimum 0\n";
    ss << "N2, \\field Watts per Space Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0\n";
    ss << "N3, \\field Watts per Person\n";
    ss << "\\type real\n";
    ss << "\\units W/Person\n";
    ss << "\\minimum 0\n";
    ss << "N4, \\field Fraction Latent\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N5, \\field Fraction Radiant\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N6, \\field Fraction Lost\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N7; \\field Carbon Dioxide Generation Rate\n";
    ss << "\\note CO2 generation rate per unit of power input\n";
    ss << "\\note The default value assumes the equipment is fully vented.\n";
    ss << "\\note For unvented equipment, a suggested value is 3.45E-8 m3/s-W. This value is\n";
    ss << "\\note converted from a natural gas CO2 emission rate of 117 lbs CO2 per million Btu.\n";
    ss << "\\note The maximum value assumes to be 10 times of the recommended value.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-W\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 4e-07\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::OS_GasEquipment_Definition);
    OptionalIddObject oObj = IddObject::load("OS:GasEquipment:Definition",
                                             "OpenStudio Space Load Definitions",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_GasEquipment_Definition);
  return object;
}

IddObject createOS_HotWaterEquipment_DefinitionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:HotWaterEquipment:Definition,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference HotWaterEquipmentDefinitionNames\n";
    ss << "\\reference SpaceComponentDefinitionNames\n";
    ss << "A3, \\field Design Level Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum amount of hot water equipment\n";
    ss << "\\note for this set of attributes\n";
    ss << "\\note Choices: Equipment Level -- simply enter watts of equipment\n";
    ss << "\\note Watts/Area - Watts per Space Floor Area -- enter the number to apply.  Value * Floor Area = Equipment Level\n";
    ss << "\\note Watts/Person - Watts per Person -- enter the number to apply.  Value * Occupants = Equipment Level\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key EquipmentLevel\n";
    ss << "\\key Watts/Area\n";
    ss << "\\key Watts/Person\n";
    ss << "N1, \\field Design Level\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\ip-units Btu/h\n";
    ss << "\\minimum 0\n";
    ss << "N2, \\field Watts per Space Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0\n";
    ss << "N3, \\field Watts per Person\n";
    ss << "\\type real\n";
    ss << "\\units W/Person\n";
    ss << "\\minimum 0\n";
    ss << "N4, \\field Fraction Latent\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N5, \\field Fraction Radiant\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N6; \\field Fraction Lost\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::OS_HotWaterEquipment_Definition);
    OptionalIddObject oObj = IddObject::load("OS:HotWaterEquipment:Definition",
                                             "OpenStudio Space Load Definitions",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_HotWaterEquipment_Definition);
  return object;
}

IddObject createOS_SteamEquipment_DefinitionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SteamEquipment:Definition,\n";
    ss << "\\memo Sets internal gains for steam equipment in the space.\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference SteamEquipmentDefinitionNames\n";
    ss << "\\reference SpaceComponentDefinitionNames\n";
    ss << "A3, \\field Design Level Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum amount of steam equipment\n";
    ss << "\\note for this set of attributes\n";
    ss << "\\note Choices: Equipment Level -- simply enter watts of equipment\n";
    ss << "\\note Watts/Area - Watts per Space Floor Area -- enter the number to apply.  Value * Floor Area = Equipment Level\n";
    ss << "\\note Watts/Person - Watts per Person -- enter the number to apply.  Value * Occupants = Equipment Level\n";
    ss << "\\type choice\n";
    ss << "\\default EquipmentLevel\n";
    ss << "\\key EquipmentLevel\n";
    ss << "\\key Watts/Area\n";
    ss << "\\key Watts/Person\n";
    ss << "N1, \\field Design Level\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\ip-units Btu/h\n";
    ss << "\\minimum 0\n";
    ss << "N2, \\field Watts per Space Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0\n";
    ss << "N3, \\field Watts per Person\n";
    ss << "\\type real\n";
    ss << "\\units W/Person\n";
    ss << "\\minimum 0\n";
    ss << "N4, \\field Fraction Latent\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N5, \\field Fraction Radiant\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N6; \\field Fraction Lost\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::OS_SteamEquipment_Definition);
    OptionalIddObject oObj = IddObject::load("OS:SteamEquipment:Definition",
                                             "OpenStudio Space Load Definitions",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SteamEquipment_Definition);
  return object;
}

IddObject createOS_OtherEquipment_DefinitionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:OtherEquipment:Definition,\n";
    ss << "\\memo Sets internal gains or losses for \"other\" equipment in the space.\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference OtherEquipmentDefinitionNames\n";
    ss << "\\reference SpaceComponentDefinitionNames\n";
    ss << "A3, \\field Design Level Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum amount of other equipment.\n";
    ss << "\\note to set a loss, use a negative value in the following fields.\n";
    ss << "\\note for this set of attributes\n";
    ss << "\\note Choices: Equipment Level -- simply enter watts of equipment\n";
    ss << "\\note Watts/Area - Watts per Space Floor Area -- enter the number to apply.  Value * Floor Area = Equipment Level\n";
    ss << "\\note Watts/Person - Watts per Person -- enter the number to apply.  Value * Occupants = Equipment Level\n";
    ss << "\\type choice\n";
    ss << "\\default EquipmentLevel\n";
    ss << "\\key EquipmentLevel\n";
    ss << "\\key Watts/Area\n";
    ss << "\\key Watts/Person\n";
    ss << "N1, \\field Design Level\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "N2, \\field Watts per Space Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0\n";
    ss << "N3, \\field Watts per Person\n";
    ss << "\\type real\n";
    ss << "\\units W/Person\n";
    ss << "\\minimum 0\n";
    ss << "N4, \\field Fraction Latent\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N5, \\field Fraction Radiant\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N6; \\field Fraction Lost\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::OS_OtherEquipment_Definition);
    OptionalIddObject oObj = IddObject::load("OS:OtherEquipment:Definition",
                                             "OpenStudio Space Load Definitions",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_OtherEquipment_Definition);
  return object;
}

IddObject createOS_Exterior_Lights_DefinitionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Exterior:Lights:Definition,\n";
    ss << "\\memo only used for Meter type reporting, does not affect building loads\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ExteriorLightsDefinitionNames\n";
    ss << "\\reference ExteriorEquipmentDefinitionNames\n";
    ss << "N1; \\field Design Level\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0\n";

    IddObjectType objType(IddObjectType::OS_Exterior_Lights_Definition);
    OptionalIddObject oObj = IddObject::load("OS:Exterior:Lights:Definition",
                                             "OpenStudio Exterior Equipment Definitions",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Exterior_Lights_Definition);
  return object;
}

IddObject createOS_Schedule_CompactIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Schedule:Compact,\n";
    ss << "\\memo Irregular object.  Does not follow the usual definition for fields.  Fields A3... are:\n";
    ss << "\\memo Through: Date\n";
    ss << "\\memo For: Applicable days (ref: Schedule:Week:Compact)\n";
    ss << "\\memo Interpolate: Yes/No (ref: Schedule:Day:Interval) -- optional, if not used will be \"No\"\n";
    ss << "\\memo Until: <Time> (ref: Schedule:Day:Interval)\n";
    ss << "\\memo <numeric value>\n";
    ss << "\\memo words \"Through\",\"For\",\"Interpolate\",\"Until\" must be included.\n";
    ss << "\\obsolete\n";
    ss << "\\extensible:1\n";
    ss << "\\format compactSchedule\n";
    ss << "\\min-fields 6\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ScheduleNames\n";
    ss << "A3, \\field Schedule Type Limits Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleTypeLimitsNames\n";
    ss << "A4; \\field Field\n";
    ss << "\\type alpha\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::OS_Schedule_Compact);
    OptionalIddObject oObj = IddObject::load("OS:Schedule:Compact",
                                             "OpenStudio Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Schedule_Compact);
  return object;
}

IddObject createOS_Schedule_DayIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Schedule:Day,\n";
    ss << "\\extensible:3\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference DayScheduleNames\n";
    ss << "\\reference ScheduleAndDayScheduleNames\n";
    ss << "A3, \\field Schedule Type Limits Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleTypeLimitsNames\n";
    ss << "A4, \\field Interpolate to Timestep\n";
    ss << "\\note when the interval does not match the user specified timestep a Yes choice will average between the intervals request (to\n";
    ss << "\\note timestep resolution.  a No choice will use the interval value at the simulation timestep without regard to if it matches\n";
    ss << "\\note the boundary or not.\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "N1, \\field Hour\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 24\n";
    ss << "N2, \\field Minute\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 59\n";
    ss << "N3; \\field Value Until Time\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_Schedule_Day);
    OptionalIddObject oObj = IddObject::load("OS:Schedule:Day",
                                             "OpenStudio Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Schedule_Day);
  return object;
}

IddObject createOS_Schedule_WeekIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Schedule:Week,\n";
    ss << "\\min-fields 15\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference WeekScheduleNames\n";
    ss << "A3, \\field Schedule Rendering Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleRenderingNames\n";
    ss << "A4, \\field Sunday Schedule:Day Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A5, \\field Monday Schedule:Day Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A6, \\field Tuesday Schedule:Day Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A7, \\field Wednesday Schedule:Day Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A8, \\field Thursday Schedule:Day Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A9, \\field Friday Schedule:Day Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A10, \\field Saturday Schedule:Day Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A11, \\field Holiday Schedule:Day Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A12, \\field SummerDesignDay Schedule:Day Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A13, \\field WinterDesignDay Schedule:Day Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A14, \\field CustomDay1 Schedule:Day Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A15; \\field CustomDay2 Schedule:Day Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_Schedule_Week);
    OptionalIddObject oObj = IddObject::load("OS:Schedule:Week",
                                             "OpenStudio Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Schedule_Week);
  return object;
}

IddObject createOS_Schedule_YearIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Schedule:Year,\n";
    ss << "\\extensible:3\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ScheduleNames\n";
    ss << "A3, \\field Schedule Type Limits Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleTypeLimitsNames\n";
    ss << "N1, \\field Month\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "N2, \\field Day\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "A4; \\field Week Schedule Until Date\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list WeekScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_Schedule_Year);
    OptionalIddObject oObj = IddObject::load("OS:Schedule:Year",
                                             "OpenStudio Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Schedule_Year);
  return object;
}

IddObject createOS_Schedule_RuleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Schedule:Rule,\n";
    ss << "\\extensible:2\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ScheduleRuleNames\n";
    ss << "A3, \\field Schedule Ruleset Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleRulesetNames\n";
    ss << "N1, \\field Rule Order\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0\n";
    ss << "A4, \\field Day Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A5, \\field Apply Sunday\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A6, \\field Apply Monday\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A7, \\field Apply Tuesday\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A8, \\field Apply Wednesday\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A9, \\field Apply Thursday\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A10, \\field Apply Friday\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A11, \\field Apply Saturday\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A12, \\field Apply Holiday\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A13, \\field Date Specification Type\n";
    ss << "\\type choice\n";
    ss << "\\default DateRange\n";
    ss << "\\key DateRange\n";
    ss << "\\key SpecificDates\n";
    ss << "N2, \\field Start Month\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "\\default 1\n";
    ss << "N3, \\field Start Day\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "\\default 1\n";
    ss << "N4, \\field End Month\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "\\default 12\n";
    ss << "N5, \\field End Day\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "\\default 31\n";
    ss << "N6, \\field Specific Month\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "N7; \\field Specific Day\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";

    IddObjectType objType(IddObjectType::OS_Schedule_Rule);
    OptionalIddObject oObj = IddObject::load("OS:Schedule:Rule",
                                             "OpenStudio Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Schedule_Rule);
  return object;
}

IddObject createOS_Schedule_RulesetIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Schedule:Ruleset,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ScheduleNames\n";
    ss << "\\reference ScheduleRulesetNames\n";
    ss << "A3, \\field Schedule Type Limits Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleTypeLimitsNames\n";
    ss << "A4, \\field Default Day Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A5, \\field Summer Design Day Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";
    ss << "A6; \\field Winter Design Day Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DayScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_Schedule_Ruleset);
    OptionalIddObject oObj = IddObject::load("OS:Schedule:Ruleset",
                                             "OpenStudio Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Schedule_Ruleset);
  return object;
}

IddObject createOS_Schedule_ConstantIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Schedule:Constant,\n";
    ss << "\\memo Constant hourly value for entire year.\n";
    ss << "\\format singleLine\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ScheduleNames\n";
    ss << "A3, \\field Schedule Type Limits Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleTypeLimitsNames\n";
    ss << "N1; \\field Value\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_Schedule_Constant);
    OptionalIddObject oObj = IddObject::load("OS:Schedule:Constant",
                                             "OpenStudio Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Schedule_Constant);
  return object;
}

IddObject createOS_Schedule_FixedIntervalIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Schedule:FixedInterval,\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ScheduleNames\n";
    ss << "A3, \\field Schedule Type Limits Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleTypeLimitsNames\n";
    ss << "A4, \\field Interpolate to Timestep\n";
    ss << "\\note when the interval does not match the user specified timestep a Yes choice will average between the intervals request (to\n";
    ss << "\\note timestep resolution.  a No choice will use the interval value at the simulation timestep without regard to if it matches\n";
    ss << "\\note the boundary or not.\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "N1, \\field Interval Length\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\units minutes\n";
    ss << "\\minimum 1\n";
    ss << "N2, \\field Out Of Range Value\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N3, \\field Start Month\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "\\default 1\n";
    ss << "N4, \\field Start Day\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "\\default 1\n";
    ss << "N5; \\field Value\n";
    ss << "\\note First value applies from 12:00 am (exclusive) on Start Month/Start Day until 12:00 am + Interval Length (inclusive)\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::OS_Schedule_FixedInterval);
    OptionalIddObject oObj = IddObject::load("OS:Schedule:FixedInterval",
                                             "OpenStudio Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Schedule_FixedInterval);
  return object;
}

IddObject createOS_Schedule_VariableIntervalIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Schedule:VariableInterval,\n";
    ss << "\\extensible:5\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ScheduleNames\n";
    ss << "A3, \\field Schedule Type Limits Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleTypeLimitsNames\n";
    ss << "A4, \\field Interpolate to Timestep\n";
    ss << "\\note when the interval does not match the user specified timestep a Yes choice will average between the intervals request (to\n";
    ss << "\\note timestep resolution.  a No choice will use the interval value at the simulation timestep without regard to if it matches\n";
    ss << "\\note the boundary or not.\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "N1, \\field Out Of Range Value\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N2, \\field Start Month\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "\\default 1\n";
    ss << "N3, \\field Start Day\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "\\default 1\n";
    ss << "N4, \\field Month\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "N5, \\field Day\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "N6, \\field Hour\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 24\n";
    ss << "N7, \\field Minute\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 59\n";
    ss << "N8; \\field Value Until Time\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_Schedule_VariableInterval);
    OptionalIddObject oObj = IddObject::load("OS:Schedule:VariableInterval",
                                             "OpenStudio Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Schedule_VariableInterval);
  return object;
}

IddObject createOS_ScheduleTypeLimitsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ScheduleTypeLimits,\n";
    ss << "\\memo ScheduleTypeLimits specifies the data types and limits for the values contained in schedules\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note used to validate schedule types in various schedule objects\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ScheduleTypeLimitsNames\n";
    ss << "N1, \\field Lower Limit Value\n";
    ss << "\\note lower limit (real or integer) for the Schedule Type.  e.g. if fraction, this is 0.0\n";
    ss << "\\type real\n";
    ss << "N2, \\field Upper Limit Value\n";
    ss << "\\note upper limit (real or integer) for the Schedule Type.  e.g. if fraction, this is 1.0\n";
    ss << "\\type real\n";
    ss << "A3, \\field Numeric Type\n";
    ss << "\\note Numeric type is either Continuous (all numbers within the min and\n";
    ss << "\\note max are valid or Discrete (only integer numbers between min and\n";
    ss << "\\note max are valid.  (Could also allow REAL and INTEGER to mean the\n";
    ss << "\\note same things)\n";
    ss << "\\type choice\n";
    ss << "\\key Continuous\n";
    ss << "\\key Discrete\n";
    ss << "A4; \\field Unit Type\n";
    ss << "\\note Temperature (C or F)\n";
    ss << "\\note DeltaTemperature (C or F)\n";
    ss << "\\note PrecipitationRate (m/hr or ft/hr)\n";
    ss << "\\note Angle (degrees)\n";
    ss << "\\note Convection Coefficient (W/m2-K or Btu/sqft-hr-F)\n";
    ss << "\\note Activity Level (W/person)\n";
    ss << "\\note Clothing Insulation (clo)\n";
    ss << "\\note Velocity (m/s or ft/min)\n";
    ss << "\\note Rotations Per Minute (rpm)\n";
    ss << "\\note Volumetric Flow Rate (m3/s or ft3/s)\n";
    ss << "\\note Mass Flow Rate (kg/s or lb_m/s)\n";
    ss << "\\note Capacity (W or Btu/h)\n";
    ss << "\\note Power (W)\n";
    ss << "\\note Pressure (Pa or psi)\n";
    ss << "\\note Solar Energy (Wh/m2)\n";
    ss << "\\note Availability (0-Off or 1-On)\n";
    ss << "\\note Linear Power Density (W/m or W/ft)\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key DeltaTemperature\n";
    ss << "\\key PrecipitationRate\n";
    ss << "\\key Angle\n";
    ss << "\\key ConvectionCoefficient\n";
    ss << "\\key ActivityLevel\n";
    ss << "\\key ClothingInsulation\n";
    ss << "\\key Velocity\n";
    ss << "\\key RotationsPerMinute\n";
    ss << "\\key VolumetricFlowRate\n";
    ss << "\\key MassFlowRate\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";
    ss << "\\key Pressure\n";
    ss << "\\key SolarEnergy\n";
    ss << "\\key Availability\n";
    ss << "\\key Percent\n";
    ss << "\\key ControlMode\n";
    ss << "\\key LinearPowerDensity\n";

    IddObjectType objType(IddObjectType::OS_ScheduleTypeLimits);
    OptionalIddObject oObj = IddObject::load("OS:ScheduleTypeLimits",
                                             "OpenStudio Schedules",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ScheduleTypeLimits);
  return object;
}

IddObject createOS_BuildingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Building,\n";
    ss << "\\unique-object\n";
    ss << "\\required-object\n";
    ss << "\\min-fields 8\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference BuildingNames\n";
    ss << "\\reference SpaceAndSpaceGroupNames\n";
    ss << "A3, \\field Building Sector Type\n";
    ss << "\\deprecated\n";
    ss << "\\type choice\n";
    ss << "\\default Commercial\n";
    ss << "\\key Commercial\n";
    ss << "\\key Residential\n";
    ss << "\\key Industrial\n";
    ss << "\\key Other\n";
    ss << "N1, \\field North Axis\n";
    ss << "\\note degrees from true North\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 0.0\n";
    ss << "N2, \\field Nominal Floor to Floor Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "A4, \\field Space Type Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceTypeNames\n";
    ss << "A5, \\field Default Construction Set Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DefaultConstructionSetNames\n";
    ss << "A6, \\field Default Schedule Set Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DefaultScheduleSetNames\n";
    ss << "N3, \\field Standards Number of Stories\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "N4, \\field Standards Number of Above Ground Stories\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "A7, \\field Standards Building Type\n";
    ss << "\\type alpha\n";
    ss << "\\note This is a freeform field used to identify the building type for standards.\n";
    ss << "\\note Standards applied to this model will use this field to determine correct levels for lighting, occupancy, etc.\n";
    ss << "\\note More information can be found at https://github.com/NREL/openstudio-standards.\n";
    ss << "N5, \\field Standards Number of Living Units\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "A8, \\field Relocatable\n";
    ss << "\\type choice\n";
    ss << "\\default False\n";
    ss << "\\key True\n";
    ss << "\\key False\n";
    ss << "N6; \\field Nominal Floor to Ceiling Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";

    IddObjectType objType(IddObjectType::OS_Building);
    OptionalIddObject oObj = IddObject::load("OS:Building",
                                             "OpenStudio Geometry",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Building);
  return object;
}

IddObject createOS_DaylightingDevice_ShelfIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:DaylightingDevice:Shelf,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference SpaceItemNames\n";
    ss << "A3, \\field Window Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list SubSurfNames\n";
    ss << "A4, \\field Inside Shelf Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list InteriorPartitionSurfaceNames\n";
    ss << "A5, \\field Outside Shelf Name\n";
    ss << "\\note This must refer to a Space level OS:Shading:Detailed object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AttachedShadingSurfNames\n";
    ss << "N1; \\field View Factor to Outside Shelf\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";

    IddObjectType objType(IddObjectType::OS_DaylightingDevice_Shelf);
    OptionalIddObject oObj = IddObject::load("OS:DaylightingDevice:Shelf",
                                             "OpenStudio Geometry",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_DaylightingDevice_Shelf);
  return object;
}

IddObject createOS_FacilityIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Facility,\n";
    ss << "\\unique-object\n";
    ss << "\\required-object\n";
    ss << "\\min-fields 1\n";
    ss << "A1; \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_Facility);
    OptionalIddObject oObj = IddObject::load("OS:Facility",
                                             "OpenStudio Geometry",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Facility);
  return object;
}

IddObject createOS_InteriorPartitionSurfaceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:InteriorPartitionSurface,\n";
    ss << "\\extensible:3\n";
    ss << "\\format vertices\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference InteriorPartitionSurfaceNames\n";
    ss << "A3, \\field Construction Name\n";
    ss << "\\note Leave blank to match with default construction\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A4, \\field Interior Partition Surface Group Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list InteriorPartitionSurfaceGroupNames\n";
    ss << "A5, \\field Convert to Internal Mass\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A6, \\field Surface Area\n";
    ss << "\\note Overrides actual surface area for translation to EnergyPlus if set,\n";
    ss << "\\note otherwise uses area as calculated by vertices\n";
    ss << "\\type real\n";
    ss << "\\units m2\n";
    ss << "\\minimum> 0\n";
    ss << "N1, \\field Number of Vertices\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 3\n";
    ss << "\\default autocalculate\n";
    ss << "N2, \\field Vertex X-coordinate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\units m\n";
    ss << "N3, \\field Vertex Y-coordinate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "N4; \\field Vertex Z-coordinate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::OS_InteriorPartitionSurface);
    OptionalIddObject oObj = IddObject::load("OS:InteriorPartitionSurface",
                                             "OpenStudio Geometry",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_InteriorPartitionSurface);
  return object;
}

IddObject createOS_InteriorPartitionSurfaceGroupIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:InteriorPartitionSurfaceGroup,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference PlanarSurfaceGroupNames\n";
    ss << "\\reference InteriorPartitionSurfaceGroupNames\n";
    ss << "A3, \\field Space Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceNames\n";
    ss << "N1, \\field Direction of Relative North\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 0\n";
    ss << "N2, \\field X Origin\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0\n";
    ss << "N3, \\field Y Origin\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0\n";
    ss << "N4, \\field Z Origin\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0\n";
    ss << "N5; \\field Multiplier\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";

    IddObjectType objType(IddObjectType::OS_InteriorPartitionSurfaceGroup);
    OptionalIddObject oObj = IddObject::load("OS:InteriorPartitionSurfaceGroup",
                                             "OpenStudio Geometry",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_InteriorPartitionSurfaceGroup);
  return object;
}

IddObject createOS_ShadingSurfaceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ShadingSurface,\n";
    ss << "\\extensible:3\n";
    ss << "\\format vertices\n";
    ss << "\\min-fields 14\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference AttachedShadingSurfNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "\\reference AllShadingSurfNames\n";
    ss << "A3, \\field Construction Name\n";
    ss << "\\note Leave blank to match with default construction\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A4, \\field Shading Surface Group Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ShadingSurfaceGroupNames\n";
    ss << "A5, \\field Transmittance Schedule Name\n";
    ss << "\\note Transmittance schedule for the shading device, defaults to zero (always opaque)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Number of Vertices\n";
    ss << "\\note shown with 6 vertex coordinates -- extensible object\n";
    ss << "\\note vertices are given in GlobalGeometryRules coordinates -- if relative, all surface coordinates\n";
    ss << "\\note are \"relative\" to the Space Origin.  if world, then building and zone origins are used\n";
    ss << "\\note for some internal calculations, but all coordinates are given in an \"absolute\" system.\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 3\n";
    ss << "\\default autocalculate\n";
    ss << "N2, \\field Vertex X-coordinate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\units m\n";
    ss << "N3, \\field Vertex Y-coordinate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "N4; \\field Vertex Z-coordinate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::OS_ShadingSurface);
    OptionalIddObject oObj = IddObject::load("OS:ShadingSurface",
                                             "OpenStudio Geometry",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ShadingSurface);
  return object;
}

IddObject createOS_ShadingSurfaceGroupIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ShadingSurfaceGroup,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference PlanarSurfaceGroupNames\n";
    ss << "\\reference ShadingSurfaceGroupNames\n";
    ss << "A3, \\field Shading Surface Type\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Site\n";
    ss << "\\key Building\n";
    ss << "\\key Space\n";
    ss << "A4, \\field Space Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceNames\n";
    ss << "N1, \\field Direction of Relative North\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 0\n";
    ss << "N2, \\field X Origin\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0\n";
    ss << "N3, \\field Y Origin\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0\n";
    ss << "N4, \\field Z Origin\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0\n";
    ss << "A5; \\field Shaded Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfAndSubSurfNames\n";

    IddObjectType objType(IddObjectType::OS_ShadingSurfaceGroup);
    OptionalIddObject oObj = IddObject::load("OS:ShadingSurfaceGroup",
                                             "OpenStudio Geometry",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ShadingSurfaceGroup);
  return object;
}

IddObject createOS_SpaceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Space,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference SpaceNames\n";
    ss << "\\reference SpaceAndSpaceTypeNames\n";
    ss << "\\reference SpaceAndSpaceGroupNames\n";
    ss << "\\reference PlanarSurfaceGroupNames\n";
    ss << "A3, \\field Space Type Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceTypeNames\n";
    ss << "A4, \\field Default Construction Set Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DefaultConstructionSetNames\n";
    ss << "A5, \\field Default Schedule Set Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DefaultScheduleSetNames\n";
    ss << "N1, \\field Direction of Relative North\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 0\n";
    ss << "N2, \\field X Origin\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0\n";
    ss << "N3, \\field Y Origin\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0\n";
    ss << "N4, \\field Z Origin\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0\n";
    ss << "A6, \\field Building Story Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BuildingStoryNames\n";
    ss << "A7, \\field Thermal Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A8, \\field Part of Total Floor Area\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A9; \\field Design Specification Outdoor Air Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";

    IddObjectType objType(IddObjectType::OS_Space);
    OptionalIddObject oObj = IddObject::load("OS:Space",
                                             "OpenStudio Geometry",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Space);
  return object;
}

IddObject createOS_SurfaceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Surface,\n";
    ss << "\\extensible:3\n";
    ss << "\\format vertices\n";
    ss << "\\min-fields 20\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference SurfaceNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference HeatTranBaseSurfNames\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference SurfGroupAndHTSurfNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "A3, \\field Surface Type\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Floor\n";
    ss << "\\key Wall\n";
    ss << "\\key RoofCeiling\n";
    ss << "A4, \\field Construction Name\n";
    ss << "\\note Leave blank to match with default construction\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A5, \\field Space Name\n";
    ss << "\\note Space the surface is a part of\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceNames\n";
    ss << "A6, \\field Outside Boundary Condition\n";
    ss << "\\note Zone option which creates mirrored surfaces in EnergyPlus, is not allowed\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Adiabatic\n";
    ss << "\\key Surface\n";
    ss << "\\key Outdoors\n";
    ss << "\\key Ground\n";
    ss << "\\key GroundFCfactorMethod\n";
    ss << "\\key OtherSideCoefficients\n";
    ss << "\\key OtherSideConditionsModel\n";
    ss << "\\key GroundSlabPreprocessorAverage\n";
    ss << "\\key GroundSlabPreprocessorCore\n";
    ss << "\\key GroundSlabPreprocessorPerimeter\n";
    ss << "\\key GroundBasementPreprocessorAverageWall\n";
    ss << "\\key GroundBasementPreprocessorAverageFloor\n";
    ss << "\\key GroundBasementPreprocessorUpperWall\n";
    ss << "\\key GroundBasementPreprocessorLowerWall\n";
    ss << "A7, \\field Outside Boundary Condition Object\n";
    ss << "\\note Non-blank only if the field Outside Boundary Condition is Surface,\n";
    ss << "\\note OtherSideCoefficients or OtherSideConditionsModel\n";
    ss << "\\note If Surface, specify name of corresponding surface in adjacent space\n";
    ss << "\\note If OtherSideCoefficients, specify name of SurfaceProperty:OtherSideCoefficients\n";
    ss << "\\note If OtherSideConditionsModel, specify name of SurfaceProperty:OtherSideConditionsModel\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutFaceEnvNames\n";
    ss << "A8, \\field Sun Exposure\n";
    ss << "\\type choice\n";
    ss << "\\default SunExposed\n";
    ss << "\\key SunExposed\n";
    ss << "\\key NoSun\n";
    ss << "A9, \\field Wind Exposure\n";
    ss << "\\type choice\n";
    ss << "\\default WindExposed\n";
    ss << "\\key WindExposed\n";
    ss << "\\key NoWind\n";
    ss << "N1, \\field View Factor to Ground\n";
    ss << "\\note From the exterior of the surface\n";
    ss << "\\note Unused if one uses the \"reflections\" options in Solar Distribution in Building input\n";
    ss << "\\note unless a DaylightingDevice:Shelf or DaylightingDevice:Tubular object has been specified.\n";
    ss << "\\note autocalculate will automatically calculate this value from the tilt of the surface\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default autocalculate\n";
    ss << "N2, \\field Number of Vertices\n";
    ss << "\\note shown with 120 vertex coordinates -- extensible object\n";
    ss << "\\note \"extensible\" -- duplicate last set of x,y,z coordinates (last 3 fields),\n";
    ss << "\\note remembering to remove ; from \"inner\" fields.\n";
    ss << "\\note for clarity in any error messages, renumber the fields as well.\n";
    ss << "\\note (and changing z terminator to a comma \",\" for all but last one which needs a semi-colon \";\")\n";
    ss << "\\note vertices are given in GlobalGeometryRules coordinates -- if relative, all surface coordinates\n";
    ss << "\\note are \"relative\" to the Zone Origin.  If world, then building and zone origins are used\n";
    ss << "\\note for some internal calculations, but all coordinates are given in an \"absolute\" system.\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 3\n";
    ss << "\\default autocalculate\n";
    ss << "N3, \\field Vertex X-coordinate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\units m\n";
    ss << "N4, \\field Vertex Y-coordinate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "N5; \\field Vertex Z-coordinate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::OS_Surface);
    OptionalIddObject oObj = IddObject::load("OS:Surface",
                                             "OpenStudio Geometry",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Surface);
  return object;
}

IddObject createOS_SubSurfaceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SubSurface,\n";
    ss << "\\memo Used for windows, doors, glass doors, tubular daylighting devices\n";
    ss << "\\extensible:3\n";
    ss << "\\format vertices\n";
    ss << "\\min-fields 20\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference SubSurfNames\n";
    ss << "\\reference SurfAndSubSurfNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference SurfGroupAndHTSurfNames\n";
    ss << "\\reference AllShadingAndHTSurfNames\n";
    ss << "A3, \\field Sub Surface Type\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key FixedWindow\n";
    ss << "\\key OperableWindow\n";
    ss << "\\key Door\n";
    ss << "\\key GlassDoor\n";
    ss << "\\key OverheadDoor\n";
    ss << "\\key Skylight\n";
    ss << "\\key TubularDaylightDome\n";
    ss << "\\key TubularDaylightDiffuser\n";
    ss << "A4, \\field Construction Name\n";
    ss << "\\note Leave blank to match with default construction\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A5, \\field Surface Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SurfaceNames\n";
    ss << "A6, \\field Outside Boundary Condition Object\n";
    ss << "\\note Non-blank only if base surface field Outside Boundary Condition is\n";
    ss << "\\note Surface or OtherSideCoefficients\n";
    ss << "\\note If Base Surface's Surface, specify name of corresponding subsurface in adjacent space\n";
    ss << "\\note If OtherSideCoefficients, specify name of SurfaceProperty:OtherSideCoefficients\n";
    ss << "\\note or leave blank to inherit Base Surface's OtherSide Coefficients\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutFaceEnvNames\n";
    ss << "N1, \\field View Factor to Ground\n";
    ss << "\\note From the exterior of the surface\n";
    ss << "\\note Unused if one uses the \"reflections\" options in Solar Distribution in Building input\n";
    ss << "\\note unless a DaylightingDevice:Shelf or DaylightingDevice:Tubular object has been specified.\n";
    ss << "\\note autocalculate will automatically calculate this value from the tilt of the surface\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default autocalculate\n";
    ss << "A7, \\field Shading Control Name\n";
    ss << "\\note enter the name of a WindowProperty:ShadingControl object\n";
    ss << "\\note used for windows and glass doors only\n";
    ss << "\\note If not specified, window or glass door has no shading (blind, roller shade, etc.)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowShadeControlNames\n";
    ss << "A8, \\field Frame and Divider Name\n";
    ss << "\\note Enter the name of a WindowProperty:FrameAndDivider object\n";
    ss << "\\note Used only for exterior windows (rectangular) and glass doors.\n";
    ss << "\\note Unused for triangular windows.\n";
    ss << "\\note If not specified (blank), window or glass door has no frame or divider\n";
    ss << "\\note and no beam solar reflection from reveal surfaces.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowFrameAndDividerNames\n";
    ss << "N2, \\field Multiplier\n";
    ss << "\\note Used only for Surface Type = WINDOW, GLASSDOOR or DOOR\n";
    ss << "\\note Non-integer values will be truncated to integer\n";
    ss << "\\type real\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1.0\n";
    ss << "N3, \\field Number of Vertices\n";
    ss << "\\note vertices are given in GlobalGeometryRules coordinates -- if relative, all surface coordinates\n";
    ss << "\\note are \"relative\" to the Space Origin.  If world, then building and zone origins are used\n";
    ss << "\\note for some internal calculations, but all coordinates are given in an \"absolute\" system.\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 3\n";
    ss << "\\maximum 4\n";
    ss << "\\default autocalculate\n";
    ss << "N4, \\field Vertex X-coordinate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\units m\n";
    ss << "N5, \\field Vertex Y-coordinate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "N6; \\field Vertex Z-coordinate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";

    IddObjectType objType(IddObjectType::OS_SubSurface);
    OptionalIddObject oObj = IddObject::load("OS:SubSurface",
                                             "OpenStudio Geometry",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SubSurface);
  return object;
}

IddObject createOS_ShadingControlIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ShadingControl,\n";
    ss << "\\min-fields 4\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WindowShadeControlNames\n";
    ss << "\\note Referenced by surfaces that are exterior windows\n";
    ss << "\\note Not used by interzone windows\n";
    ss << "A3 , \\field Shading Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key InteriorShade\n";
    ss << "\\key ExteriorShade\n";
    ss << "\\key ExteriorScreen\n";
    ss << "\\key InteriorBlind\n";
    ss << "\\key ExteriorBlind\n";
    ss << "\\key BetweenGlassShade\n";
    ss << "\\key BetweenGlassBlind\n";
    ss << "\\key SwitchableGlazing\n";
    ss << "\\key InteriorDaylightRedirectionDevice\n";
    ss << "A4 , \\field Construction with Shading Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "\\note Required if Shading Type = SwitchableGlazing\n";
    ss << "\\note Required if Shading Type = interior or exterior shade or blind, or exterior screen, and\n";
    ss << "\\note \"Shading Device Material Name\" is not specified.\n";
    ss << "\\note If both \"Construction with Shading Name\" and \"Shading Device Material Name\" are entered,\n";
    ss << "\\note the former takes precedence.\n";
    ss << "A5,  \\field Shading Device Material Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WindowShadesScreensAndBlinds\n";
    ss << "\\note Enter then name of a WindowMaterial:Shade, WindowMaterial:Screen or WindowMaterial:Blind object.\n";
    ss << "\\note Required if \"Construction with Shading Name\" is not specified.\n";
    ss << "\\note Not used if Shading Control Type = SwitchableGlazing, BetweenGlassShade, or BetweenGlassBlind.\n";
    ss << "\\note If both \"Construction with Shading Name\" and \"Shading Device Material Name\" are entered,\n";
    ss << "\\note the former takes precedence.\n";
    ss << "A6 , \\field Shading Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key AlwaysOn\n";
    ss << "\\key AlwaysOff\n";
    ss << "\\key OnIfScheduleAllows\n";
    ss << "\\key OnIfHighSolarOnWindow\n";
    ss << "\\default OnIfHighSolarOnWindow\n";
    ss << "A7 , \\field Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Required if Shading Control Is Scheduled = Yes.\n";
    ss << "\\note If schedule value = 1, shading control is active, i.e., shading can take place only\n";
    ss << "\\note if the control test passes. If schedule value = 0, shading is off whether or not\n";
    ss << "\\note the control test passes. Schedule Name is required if Shading Control Is Scheduled = Yes.\n";
    ss << "\\note If Schedule Name is not specified, shading control is assumed to be active at all times.\n";
    ss << "N1 , \\field Setpoint\n";
    ss << "\\note W/m2 for solar-based controls, W for cooling- or heating-based controls,\n";
    ss << "\\note deg C for temperature-based controls.\n";
    ss << "\\note Unused for Shading Control Type = AlwaysOn, AlwaysOff, OnIfScheduleAllows,\n";
    ss << "\\note OnIfHighGlare, Glare, and DaylightIlluminance\n";
    ss << "\\type real\n";
    ss << "A8 , \\field Shading Control Is Scheduled\n";
    ss << "\\type choice\n";
    ss << "\\key No\n";
    ss << "\\key Yes\n";
    ss << "\\default No\n";
    ss << "\\note If Yes, Schedule Name is required; if No, Schedule Name is not used.\n";
    ss << "\\note Shading Control Is Scheduled = Yes is required if Shading Control Type = OnIfScheduleAllows.\n";
    ss << "A9 , \\field Glare Control Is Active\n";
    ss << "\\type choice\n";
    ss << "\\key No\n";
    ss << "\\key Yes\n";
    ss << "\\default No\n";
    ss << "\\note If Yes and window is in a daylit zone, shading is on if zone's discomfort glare index exceeds\n";
    ss << "\\note the maximum discomfort glare index specified in the Daylighting object referenced by the zone.\n";
    ss << "\\note The glare test is OR'ed with the test specified by Shading Control Type.\n";
    ss << "\\note Glare Control Is Active = Yes is required if Shading Control Type = OnIfHighGlare.\n";
    ss << "A10, \\field Type of Slat Angle Control for Blinds\n";
    ss << "\\type choice\n";
    ss << "\\key FixedSlatAngle\n";
    ss << "\\key ScheduledSlatAngle\n";
    ss << "\\key BlockBeamSolar\n";
    ss << "\\default FixedSlatAngle\n";
    ss << "\\note Used only if Shading Type = InteriorBlind, ExteriorBlind or BetweenGlassBlind.\n";
    ss << "\\note If choice is ScheduledSlatAngle then Slat Angle Schedule Name is required.\n";
    ss << "A11, \\field Slat Angle Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Used only if Shading Type = InteriorBlind, ExteriorBlind or BetweenGlassBlind.\n";
    ss << "\\note Required if Type of Slat Angle Control for Blinds = ScheduledSlatAngle\n";
    ss << "\\note Schedule values should be degrees (0 minimum, 180 maximum)\n";
    ss << "N2 ; \\field Setpoint 2\n";
    ss << "\\note W/m2 for solar-based controls, deg C for temperature-based controls.\n";
    ss << "\\note Used only as the second setpoint for the following two-setpoint control types:\n";
    ss << "\\note OnIfHighOutdoorAirTempAndHighSolarOnWindow, OnIfHighOutdoorAirTempAndHighHorizontalSolar,\n";
    ss << "\\note OnIfHighZoneAirTempAndHighSolarOnWindow, and OnIfHighZoneAirTempAndHighHorizontalSolar\n";
    ss << "\\type real\n";
    ss << "\\ip-units unknown\n";

    IddObjectType objType(IddObjectType::OS_ShadingControl);
    OptionalIddObject oObj = IddObject::load("OS:ShadingControl",
                                             "OpenStudio Geometry",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ShadingControl);
  return object;
}

IddObject createOS_WindowProperty_FrameAndDividerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:WindowProperty:FrameAndDivider,\n";
    ss << "\\memo Specifies the dimensions of a window frame, dividers, and reveal surfaces.\n";
    ss << "\\memo Referenced by the sub surface objects for exterior windows and glass doors\n";
    ss << "\\min-fields 20\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WindowFrameAndDividerNames\n";
    ss << "\\note Referenced by surfaces that are exterior windows\n";
    ss << "\\note Not used by interzone windows\n";
    ss << "N1 , \\field Frame Width\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Width of frame in plane of window\n";
    ss << "\\note Frame width assumed the same on all sides of window\n";
    ss << "N2 , \\field Frame Outside Projection\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.0\n";
    ss << "\\note Amount that frame projects outward from the outside face of the glazing\n";
    ss << "N3 , \\field Frame Inside Projection\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.0\n";
    ss << "\\note Amount that frame projects inward from the inside face of the glazing\n";
    ss << "N4 , \\field Frame Conductance\n";
    ss << "\\units W/m2-K\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Effective conductance of frame\n";
    ss << "\\note Excludes air films\n";
    ss << "\\note Obtained from WINDOW 5 or other 2-D calculation\n";
    ss << "N5 , \\field Ratio of Frame-Edge Glass Conductance to Center-Of-Glass Conductance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 4.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Excludes air films; applies only to multipane windows\n";
    ss << "\\note Obtained from WINDOW 5 or other 2-D calculation\n";
    ss << "N6 , \\field Frame Solar Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "\\note Assumed same on outside and inside of frame\n";
    ss << "N7 , \\field Frame Visible Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "\\note Assumed same on outside and inside of frame\n";
    ss << "N8 , \\field Frame Thermal Hemispherical Emissivity\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.9\n";
    ss << "\\note Assumed same on outside and inside of frame\n";
    ss << "A3 , \\field Divider Type\n";
    ss << "\\type choice\n";
    ss << "\\key DividedLite\n";
    ss << "\\key Suspended\n";
    ss << "\\default DividedLite\n";
    ss << "N9 , \\field Divider Width\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.0\n";
    ss << "\\note Width of dividers in plane of window\n";
    ss << "\\note Width assumed the same for all dividers\n";
    ss << "N10, \\field Number of Horizontal Dividers\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note \"Horizontal\" means parallel to local window X-axis\n";
    ss << "N11, \\field Number of Vertical Dividers\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note \"Vertical\" means parallel to local window Y-axis\n";
    ss << "N12, \\field Divider Outside Projection\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.0\n";
    ss << "\\note Amount that divider projects outward from the outside face of the glazing\n";
    ss << "\\note Outside projection assumed the same for all divider elements\n";
    ss << "N13, \\field Divider Inside Projection\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.5\n";
    ss << "\\default 0.0\n";
    ss << "\\note Amount that divider projects inward from the inside face of the glazing\n";
    ss << "\\note Inside projection assumed the same for all divider elements\n";
    ss << "N14, \\field Divider Conductance\n";
    ss << "\\units W/m2-K\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Effective conductance of divider\n";
    ss << "\\note Excludes air films\n";
    ss << "\\note Obtained from WINDOW 5 or other 2-D calculation\n";
    ss << "N15, \\field Ratio of Divider-Edge Glass Conductance to Center-Of-Glass Conductance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 4.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Excludes air films\n";
    ss << "\\note Obtained from WINDOW 5 or other 2-D calculation\n";
    ss << "N16, \\field Divider Solar Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Assumed same on outside and inside of divider\n";
    ss << "N17, \\field Divider Visible Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Assumed same on outside and inside of divider\n";
    ss << "N18, \\field Divider Thermal Hemispherical Emissivity\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\default 0.9\n";
    ss << "\\note Assumed same on outside and inside of divider\n";
    ss << "N19, \\field Outside Reveal Depth\n";
    ss << "\\note On translation to EnergyPlus, sub surfaces are offset from their base surface by this amount\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 2.0\n";
    ss << "\\default 0.0\n";
    ss << "N20, \\field Outside Reveal Solar Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N21, \\field Inside Sill Depth\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 2.0\n";
    ss << "\\default 0.0\n";
    ss << "N22, \\field Inside Sill Solar Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N23, \\field Inside Reveal Depth\n";
    ss << "\\note Distance from plane of inside surface of glazing\n";
    ss << "\\note to plane of inside surface of wall.\n";
    ss << "\\note Outside reveal depth is determined from the geometry\n";
    ss << "\\note of the window and the wall it is on; it is non-zero if the plane of\n";
    ss << "\\note the outside surface of the glazing is set back from the plane of the\n";
    ss << "\\note outside surface of the wall.\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 2.0\n";
    ss << "\\default 0.0\n";
    ss << "N24; \\field Inside Reveal Solar Absorptance\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::OS_WindowProperty_FrameAndDivider);
    OptionalIddObject oObj = IddObject::load("OS:WindowProperty:FrameAndDivider",
                                             "OpenStudio Geometry",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_WindowProperty_FrameAndDivider);
  return object;
}

IddObject createOS_SurfaceProperty_ConvectionCoefficientsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SurfaceProperty:ConvectionCoefficients,\n";
    ss << "\\memo Allow user settable interior and/or exterior convection coefficients.\n";
    ss << "\\memo Note that some other factors may limit the lower bounds for these values, such as\n";
    ss << "\\memo for windows, the interior convection coefficient must be >.28,\n";
    ss << "\\memo for trombe wall algorithm selection (zone), the interior convection coefficient must be >.1\n";
    ss << "\\memo for TARP interior convection, the lower limit is also .1\n";
    ss << "\\memo Minimum and maximum limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\memo Defaults in HeatBalanceAlgorithm object are [.1,1000].\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Surface Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllHeatTranSurfNames\n";
    ss << "A3, \\field Convection Coefficient 1 Location\n";
    ss << "\\type choice\n";
    ss << "\\key Outside\n";
    ss << "\\key Inside\n";
    ss << "A4, \\field Convection Coefficient 1 Type\n";
    ss << "\\type choice\n";
    ss << "\\key Value\n";
    ss << "\\key Schedule\n";
    ss << "\\key UserCurve\n";
    ss << "\\key Simple\n";
    ss << "\\key SimpleCombined\n";
    ss << "\\key TARP\n";
    ss << "\\key DOE-2\n";
    ss << "\\key MoWitt\n";
    ss << "\\key AdaptiveConvectionAlgorithm\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key FisherPedersenCeilingDiffuserWalls\n";
    ss << "\\key FisherPedersenCeilingDiffuserCeiling\n";
    ss << "\\key FisherPedersenCeilingDiffuserFloor\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key KhalifaEq3WallAwayFromHeat\n";
    ss << "\\key KhalifaEq4CeilingAwayFromHeat\n";
    ss << "\\key KhalifaEq5WallNearHeat\n";
    ss << "\\key KhalifaEq6NonHeatedWalls\n";
    ss << "\\key KhalifaEq7Ceiling\n";
    ss << "\\key AwbiHattonHeatedFloor\n";
    ss << "\\key AwbiHattonHeatedWall\n";
    ss << "\\key BeausoleilMorrisonMixedAssistedWall\n";
    ss << "\\key BeausoleilMorrisonMixedOpposingWall\n";
    ss << "\\key BeausoleilMorrisonMixedStableFloor\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableFloor\n";
    ss << "\\key BeausoleilMorrisonMixedStableCeiling\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableCeiling\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key KaradagChilledCeiling\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWindow\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWalls\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserFloor\n";
    ss << "\\key NusseltJurges\n";
    ss << "\\key McAdams\n";
    ss << "\\key Mitchell\n";
    ss << "\\key EmmelVertical\n";
    ss << "\\key EmmelRoof\n";
    ss << "\\key ClearRoof\n";
    ss << "N1, \\field Convection Coefficient 1\n";
    ss << "\\note used if Convection Type=Value, min and max limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\note Default limits are Minimum >= 0.1 and Maximum <= 1000\n";
    ss << "\\units W/m2-K\n";
    ss << "A5, \\field Convection Coefficient 1 Schedule Name\n";
    ss << "\\note used if Convection Type=Schedule,  min and max limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\note Default limits are Minimum >= 0.1 and Maximum <= 1000\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6, \\field Convection Coefficient 1 User Curve Name\n";
    ss << "\\note used if Convection Type = UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionModels\n";
    ss << "A7, \\field Convection Coefficient 2 Location\n";
    ss << "\\type choice\n";
    ss << "\\key Outside\n";
    ss << "\\key Inside\n";
    ss << "A8, \\field Convection Coefficient 2 Type\n";
    ss << "\\type choice\n";
    ss << "\\key Value\n";
    ss << "\\key Schedule\n";
    ss << "\\key UserCurve\n";
    ss << "\\key Simple\n";
    ss << "\\key SimpleCombined\n";
    ss << "\\key TARP\n";
    ss << "\\key DOE-2\n";
    ss << "\\key MoWitt\n";
    ss << "\\key AdaptiveConvectionAlgorithm\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key FisherPedersenCeilingDiffuserWalls\n";
    ss << "\\key FisherPedersenCeilingDiffuserCeiling\n";
    ss << "\\key FisherPedersenCeilingDiffuserFloor\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key KhalifaEq3WallAwayFromHeat\n";
    ss << "\\key KhalifaEq4CeilingAwayFromHeat\n";
    ss << "\\key KhalifaEq5WallNearHeat\n";
    ss << "\\key KhalifaEq6NonHeatedWalls\n";
    ss << "\\key KhalifaEq7Ceiling\n";
    ss << "\\key AwbiHattonHeatedFloor\n";
    ss << "\\key AwbiHattonHeatedWall\n";
    ss << "\\key BeausoleilMorrisonMixedAssistedWall\n";
    ss << "\\key BeausoleilMorrisonMixedOpposingWall\n";
    ss << "\\key BeausoleilMorrisonMixedStableFloor\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableFloor\n";
    ss << "\\key BeausoleilMorrisonMixedStableCeiling\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableCeiling\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key KaradagChilledCeiling\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWindow\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWalls\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserFloor\n";
    ss << "\\key NusseltJurges\n";
    ss << "\\key McAdams\n";
    ss << "\\key Mitchell\n";
    ss << "\\key EmmelVertical\n";
    ss << "\\key EmmelRoof\n";
    ss << "\\key ClearRoof\n";
    ss << "N2, \\field Convection Coefficient 2\n";
    ss << "\\note used if Convection Type=Value, min and max limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\note Default limits are Minimum >= 0.1 and Maximum <= 1000\n";
    ss << "\\units W/m2-K\n";
    ss << "A9, \\field Convection Coefficient 2 Schedule Name\n";
    ss << "\\note used if Convection Type=Schedule,  min and max limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\note Default limits are Minimum >= 0.1 and Maximum <= 1000\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A10; \\field Convection Coefficient 2 User Curve Name\n";
    ss << "\\note used if Convection Type = UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionModels\n";

    IddObjectType objType(IddObjectType::OS_SurfaceProperty_ConvectionCoefficients);
    OptionalIddObject oObj = IddObject::load("OS:SurfaceProperty:ConvectionCoefficients",
                                             "OpenStudio Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SurfaceProperty_ConvectionCoefficients);
  return object;
}

IddObject createOS_SurfaceProperty_ConvectionCoefficients_MultipleSurfaceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SurfaceProperty:ConvectionCoefficients:MultipleSurface,\n";
    ss << "\\memo Allow user settable interior and/or exterior convection coefficients.\n";
    ss << "\\memo Note that some other factors may limit the lower bounds for these values, such as\n";
    ss << "\\memo for windows, the interior convection coefficient must be >.28,\n";
    ss << "\\memo for trombe wall algorithm selection (zone), the interior convection coefficient must be >.1\n";
    ss << "\\memo for TARP interior convection, the lower limit is also .1\n";
    ss << "\\memo Minimum and maximum limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\memo Defaults in HeatBalanceAlgorithm object are [.1,1000].\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Surface Type\n";
    ss << "\\type choice\n";
    ss << "\\key AllExteriorSurfaces\n";
    ss << "\\key AllExteriorWindows\n";
    ss << "\\key AllExteriorWalls\n";
    ss << "\\key AllExteriorRoofs\n";
    ss << "\\key AllExteriorFloors\n";
    ss << "\\key AllInteriorSurfaces\n";
    ss << "\\key AllInteriorWalls\n";
    ss << "\\key AllInteriorWindows\n";
    ss << "\\key AllInteriorCeilings\n";
    ss << "\\key AllInteriorFloors\n";
    ss << "A3, \\field Convection Coefficient 1 Location\n";
    ss << "\\type choice\n";
    ss << "\\key Outside\n";
    ss << "\\key Inside\n";
    ss << "A4, \\field Convection Coefficient 1 Type\n";
    ss << "\\type choice\n";
    ss << "\\key Value\n";
    ss << "\\key Schedule\n";
    ss << "\\key Simple\n";
    ss << "\\key SimpleCombined\n";
    ss << "\\key TARP\n";
    ss << "\\key DOE-2\n";
    ss << "\\key MoWitt\n";
    ss << "\\key AdaptiveConvectionAlgorithm\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key FisherPedersenCeilingDiffuserWalls\n";
    ss << "\\key FisherPedersenCeilingDiffuserCeiling\n";
    ss << "\\key FisherPedersenCeilingDiffuserFloor\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key KhalifaEq3WallAwayFromHeat\n";
    ss << "\\key KhalifaEq4CeilingAwayFromHeat\n";
    ss << "\\key KhalifaEq5WallNearHeat\n";
    ss << "\\key KhalifaEq6NonHeatedWalls\n";
    ss << "\\key KhalifaEq7Ceiling\n";
    ss << "\\key AwbiHattonHeatedFloor\n";
    ss << "\\key AwbiHattonHeatedWall\n";
    ss << "\\key BeausoleilMorrisonMixedAssistedWall\n";
    ss << "\\key BeausoleilMorrisonMixedOpposingWall\n";
    ss << "\\key BeausoleilMorrisonMixedStableFloor\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableFloor\n";
    ss << "\\key BeausoleilMorrisonMixedStableCeiling\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableCeiling\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key KaradagChilledCeiling\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWindow\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWalls\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserFloor\n";
    ss << "\\key NusseltJurges\n";
    ss << "\\key McAdams\n";
    ss << "\\key Mitchell\n";
    ss << "\\key BlockenWindard\n";
    ss << "\\key EmmelVertical\n";
    ss << "\\key EmmelRoof\n";
    ss << "\\key ClearRoof\n";
    ss << "\\key UserCurve\n";
    ss << "N1, \\field Convection Coefficient 1\n";
    ss << "\\note used if Convection Type=Value, min and max limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\note Default limits are Minimum >= 0.1 and Maximum <= 1000\n";
    ss << "\\units W/m2-K\n";
    ss << "A5, \\field Convection Coefficient 1 Schedule Name\n";
    ss << "\\note used if Convection Type=Schedule,  min and max limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\note Default limits are Minimum >= 0.1 and Maximum <= 1000\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6, \\field Convection Coefficient 1 User Curve Name\n";
    ss << "\\note used if Convection Type = UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionModels\n";
    ss << "A7, \\field Convection Coefficient 2 Location\n";
    ss << "\\type choice\n";
    ss << "\\key Outside\n";
    ss << "\\key Inside\n";
    ss << "A8, \\field Convection Coefficient 2 Type\n";
    ss << "\\type choice\n";
    ss << "\\key Value\n";
    ss << "\\key Schedule\n";
    ss << "\\key Simple\n";
    ss << "\\key SimpleCombined\n";
    ss << "\\key TARP\n";
    ss << "\\key DOE-2\n";
    ss << "\\key MoWitt\n";
    ss << "\\key AdaptiveConvectionAlgorithm\n";
    ss << "\\key ASHRAEVerticalWall\n";
    ss << "\\key WaltonUnstableHorizontalOrTilt\n";
    ss << "\\key WaltonStableHorizontalOrTilt\n";
    ss << "\\key FisherPedersenCeilingDiffuserWalls\n";
    ss << "\\key FisherPedersenCeilingDiffuserCeiling\n";
    ss << "\\key FisherPedersenCeilingDiffuserFloor\n";
    ss << "\\key AlamdariHammondStableHorizontal\n";
    ss << "\\key AlamdariHammondUnstableHorizontal\n";
    ss << "\\key AlamdariHammondVerticalWall\n";
    ss << "\\key KhalifaEq3WallAwayFromHeat\n";
    ss << "\\key KhalifaEq4CeilingAwayFromHeat\n";
    ss << "\\key KhalifaEq5WallNearHeat\n";
    ss << "\\key KhalifaEq6NonHeatedWalls\n";
    ss << "\\key KhalifaEq7Ceiling\n";
    ss << "\\key AwbiHattonHeatedFloor\n";
    ss << "\\key AwbiHattonHeatedWall\n";
    ss << "\\key BeausoleilMorrisonMixedAssistedWall\n";
    ss << "\\key BeausoleilMorrisonMixedOpposingWall\n";
    ss << "\\key BeausoleilMorrisonMixedStableFloor\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableFloor\n";
    ss << "\\key BeausoleilMorrisonMixedStableCeiling\n";
    ss << "\\key BeausoleilMorrisonMixedUnstableCeiling\n";
    ss << "\\key FohannoPolidoriVerticalWall\n";
    ss << "\\key KaradagChilledCeiling\n";
    ss << "\\key ISO15099Windows\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWindow\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserWalls\n";
    ss << "\\key GoldsteinNovoselacCeilingDiffuserFloor\n";
    ss << "\\key NusseltJurges\n";
    ss << "\\key McAdams\n";
    ss << "\\key Mitchell\n";
    ss << "\\key BlockenWindard\n";
    ss << "\\key EmmelVertical\n";
    ss << "\\key EmmelRoof\n";
    ss << "\\key ClearRoof\n";
    ss << "\\key UserCurve\n";
    ss << "N2, \\field Convection Coefficient 2\n";
    ss << "\\note used if Convection Type=Value, min and max limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\note Default limits are Minimum >= 0.1 and Maximum <= 1000\n";
    ss << "\\units W/m2-K\n";
    ss << "A9, \\field Convection Coefficient 2 Schedule Name\n";
    ss << "\\note used if Convection Type=Schedule,  min and max limits are set in HeatBalanceAlgorithm object.\n";
    ss << "\\note Default limits are Minimum >= 0.1 and Maximum <= 1000\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A10; \\field Convection Coefficient 2 User Curve Name\n";
    ss << "\\note used if Convection Type = UserCurve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UserConvectionModels\n";

    IddObjectType objType(IddObjectType::OS_SurfaceProperty_ConvectionCoefficients_MultipleSurface);
    OptionalIddObject oObj = IddObject::load("OS:SurfaceProperty:ConvectionCoefficients:MultipleSurface",
                                             "OpenStudio Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SurfaceProperty_ConvectionCoefficients_MultipleSurface);
  return object;
}

IddObject createOS_SurfaceProperty_OtherSideCoefficientsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SurfaceProperty:OtherSideCoefficients,\n";
    ss << "\\memo This object sets the other side conditions for a surface in a variety of ways.\n";
    ss << "\\min-fields 9\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "N1, \\field Combined Convective/Radiative Film Coefficient\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\type real\n";
    ss << "\\note if set, this field becomes the exterior convective/radiative film coefficient\n";
    ss << "\\note and the other fields are used to calculate the outdoor air temperature\n";
    ss << "\\note then exterior surface temperature based on outdoor air and specified coefficient\n";
    ss << "\\note if not set, then remaining fields calculate the outside surface temperature\n";
    ss << "\\note The following fields are used in the equation:\n";
    ss << "\\note OtherSideTemp=N2*N3 + N4*OutdoorDry-bulb + N5*GroundTemp + N6*WindSpeed*OutdoorDry-bulb + N7*TempZone + N9*TempPrev\n";
    ss << "N2, \\field Constant Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "\\note This parameter will be overwritten by the values from the Constant Temperature Schedule Name (below) if one is present\n";
    ss << "N3, \\field Constant Temperature Coefficient\n";
    ss << "\\note This coefficient is used even with a Schedule.  It should normally be 1.0 in that case.\n";
    ss << "\\note This field is ignored if Sinusoidal Variation of Constant Temperature Coefficient = Yes.\n";
    ss << "\\default 1\n";
    ss << "N4, \\field External Dry-Bulb Temperature Coefficient\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N5, \\field Ground Temperature Coefficient\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N6, \\field Wind Speed Coefficient\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N7, \\field Zone Air Temperature Coefficient\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "A3, \\field Constant Temperature Schedule Name\n";
    ss << "\\note Name of schedule for values of constant temperature.\n";
    ss << "\\note Schedule values replace any value specified in the field Constant Temperature.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4, \\field Sinusoidal Variation of Constant Temperature Coefficient\n";
    ss << "\\note Optionally used to vary Constant Temperature Coefficient with unitary sine wave\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N8, \\field Period of Sinusoidal Variation\n";
    ss << "\\note Use with sinusoidal variation to define the time period\n";
    ss << "\\type real\n";
    ss << "\\units hr\n";
    ss << "\\default 24\n";
    ss << "\\minimum> 0\n";
    ss << "N9, \\field Previous Other Side Temperature Coefficient\n";
    ss << "\\note This coefficient multiplies the other side temperature result from the\n";
    ss << "\\note previous zone timestep\n";
    ss << "\\type real\n";
    ss << "\\default 0\n";
    ss << "N10, \\field Minimum Other Side Temperature Limit\n";
    ss << "\\note This field specifies a lower limit for the other side temperature result.\n";
    ss << "\\note Blank indicates no limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N11; \\field Maximum Other Side Temperature Limit\n";
    ss << "\\note This field specifies an upper limit for the other side temperature result.\n";
    ss << "\\note Blank indicates no limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";

    IddObjectType objType(IddObjectType::OS_SurfaceProperty_OtherSideCoefficients);
    OptionalIddObject oObj = IddObject::load("OS:SurfaceProperty:OtherSideCoefficients",
                                             "OpenStudio Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SurfaceProperty_OtherSideCoefficients);
  return object;
}

IddObject createOS_SurfaceProperty_OtherSideConditionsModelIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SurfaceProperty:OtherSideConditionsModel,\n";
    ss << "\\memo This object sets up modifying the other side conditions for a surface from other model results.\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference OSCMNames\n";
    ss << "\\reference OutFaceEnvNames\n";
    ss << "A3; \\field Type of Modeling\n";
    ss << "\\type choice\n";
    ss << "\\key GapConvectionRadiation\n";
    ss << "\\key UndergroundPipingSystemSurface\n";
    ss << "\\key GroundCoupledSurface\n";
    ss << "\\note GapConvectionRadiation provides boundary conditions for convection\n";
    ss << "\\note  and linearized thermal radiation across a gap or cavity\n";
    ss << "\\note  on the other side of the surface that are modeled separately.\n";
    ss << "\\note UndergroundPipingSystemSurface provides boundary conditions for\n";
    ss << "\\note  surfaces in contact with PipingSystem:Underground domains\n";
    ss << "\\note GroundCoupledSurface provides boundary conditions for surfaces\n";
    ss << "\\note  in contact with GroundDomain objects\n";
    ss << "\\default GapConvectionRadiation\n";

    IddObjectType objType(IddObjectType::OS_SurfaceProperty_OtherSideConditionsModel);
    OptionalIddObject oObj = IddObject::load("OS:SurfaceProperty:OtherSideConditionsModel",
                                             "OpenStudio Advanced Construction, Surface, Zone Concepts",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SurfaceProperty_OtherSideConditionsModel);
  return object;
}

IddObject createOS_InternalMassIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:InternalMass,\n";
    ss << "\\memo Used to describe internal surface area that does not need to be part of geometric\n";
    ss << "\\memo representation. This should be the total surface area exposed to the space air.\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference InternalMassNames\n";
    ss << "\\reference AllHeatTranSurfNames\n";
    ss << "\\reference AllHeatTranAngFacNames\n";
    ss << "\\reference SurfGroupAndHTSurfNames\n";
    ss << "\\reference SpaceItemNames\n";
    ss << "\\reference SpaceLoadNames\n";
    ss << "\\reference SpaceComponentInstanceNames\n";
    ss << "A3, \\field Internal Mass Definition Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list InternalMassDefinitionNames\n";
    ss << "A4, \\field Space or SpaceType Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceAndSpaceTypeNames\n";
    ss << "N1; \\field Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::OS_InternalMass);
    OptionalIddObject oObj = IddObject::load("OS:InternalMass",
                                             "OpenStudio Space Loads",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_InternalMass);
  return object;
}

IddObject createOS_PeopleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:People,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference PeopleNames\n";
    ss << "\\reference SpaceItemNames\n";
    ss << "\\reference SpaceLoadNames\n";
    ss << "\\reference SpaceComponentInstanceNames\n";
    ss << "A3, \\field People Definition Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list PeopleDefinitionNames\n";
    ss << "A4, \\field Space or SpaceType Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceAndSpaceTypeNames\n";
    ss << "A5, \\field Number of People Schedule Name\n";
    ss << "\\note Leave blank to match with default schedule\n";
    ss << "\\note units in schedule should be fraction applied to number of people (0.0 - 1.0)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6, \\field Activity Level Schedule Name\n";
    ss << "\\note Note that W has to be converted to mets in TC routine, units in schedule are W/person\n";
    ss << "\\note Leave blank to match with default schedule\n";
    ss << "\\note units in schedule should be fraction applied to number of people (0.0 - 1.0)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A7, \\field Surface Name/Angle Factor List Name\n";
    ss << "\\note optional (only required for thermal comfort runs)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllHeatTranAngFacNames\n";
    ss << "A8, \\field Work Efficiency Schedule Name\n";
    ss << "\\note units in schedule are 0.0 to 1.0\n";
    ss << "\\note optional (only required for thermal comfort runs)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A9, \\field Clothing Insulation Schedule Name\n";
    ss << "\\note use \"Clo\" from ASHRAE or Thermal Comfort guides\n";
    ss << "\\note optional (only required for thermal comfort runs)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A10, \\field Air Velocity Schedule Name\n";
    ss << "\\note units in the schedule are m/s\n";
    ss << "\\note optional (only required for thermal comfort runs)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1; \\field Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::OS_People);
    OptionalIddObject oObj = IddObject::load("OS:People",
                                             "OpenStudio Space Loads",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_People);
  return object;
}

IddObject createOS_LightsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Lights,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference LightsNames\n";
    ss << "\\reference SpaceItemNames\n";
    ss << "\\reference SpaceLoadNames\n";
    ss << "\\reference SpaceComponentInstanceNames\n";
    ss << "A3, \\field Lights Definition Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list LightsDefinitionNames\n";
    ss << "A4, \\field Space or SpaceType Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceAndSpaceTypeNames\n";
    ss << "A5, \\field Schedule Name\n";
    ss << "\\note Leave blank to match with default schedule\n";
    ss << "\\note units in schedule should be fraction applied to design level of lights, generally (0.0 - 1.0)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Fraction Replaceable\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 1.0\n";
    ss << "N2, \\field Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "A6; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::OS_Lights);
    OptionalIddObject oObj = IddObject::load("OS:Lights",
                                             "OpenStudio Space Loads",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Lights);
  return object;
}

IddObject createOS_LuminaireIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Luminaire,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference LuminaireNames\n";
    ss << "\\reference SpaceItemNames\n";
    ss << "\\reference SpaceLoadNames\n";
    ss << "\\reference SpaceComponentInstanceNames\n";
    ss << "A3, \\field Luminaire Definition Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list LuminaireDefinitionNames\n";
    ss << "A4, \\field Space or SpaceType Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceAndSpaceTypeNames\n";
    ss << "A5, \\field Schedule Name\n";
    ss << "\\note Leave blank to match with default schedule\n";
    ss << "\\note units in schedule should be fraction applied to design level of lights, generally (0.0 - 1.0)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Position X-coordinate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "N2, \\field Position Y-coordinate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "N3, \\field Position Z-coordinate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "N4, \\field Psi Rotation Around X-axis\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 0\n";
    ss << "N5, \\field Theta Rotation Around Y-axis\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 0\n";
    ss << "N6, \\field Phi Rotation Around Z-axis\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 0\n";
    ss << "N8, \\field Fraction Replaceable\n";
    ss << "\\note For Daylighting:Controls and Daylighting:DElight:Controls,\n";
    ss << "\\note must be 0 or 1:  0 = no dimming control, 1 = full dimming control\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 1.0\n";
    ss << "N9, \\field Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "A6; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::OS_Luminaire);
    OptionalIddObject oObj = IddObject::load("OS:Luminaire",
                                             "OpenStudio Space Loads",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Luminaire);
  return object;
}

IddObject createOS_ElectricEquipmentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ElectricEquipment,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ElectricEquipmentNames\n";
    ss << "\\reference SpaceItemNames\n";
    ss << "\\reference SpaceLoadNames\n";
    ss << "\\reference SpaceComponentInstanceNames\n";
    ss << "A3, \\field Electric Equipment Definition Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ElectricEquipmentDefinitionNames\n";
    ss << "A4, \\field Space or SpaceType Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceAndSpaceTypeNames\n";
    ss << "A5, \\field Schedule Name\n";
    ss << "\\note Leave blank to match with default schedule\n";
    ss << "\\note units in schedule should be fraction applied to design level of electric equipment, generally (0.0 - 1.0)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "A6; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::OS_ElectricEquipment);
    OptionalIddObject oObj = IddObject::load("OS:ElectricEquipment",
                                             "OpenStudio Space Loads",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ElectricEquipment);
  return object;
}

IddObject createOS_GasEquipmentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:GasEquipment,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference GasEquipmentNames\n";
    ss << "\\reference SpaceItemNames\n";
    ss << "\\reference SpaceLoadNames\n";
    ss << "\\reference SpaceComponentInstanceNames\n";
    ss << "A3, \\field Gas Equipment Definition Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list GasEquipmentDefinitionNames\n";
    ss << "A4, \\field Space or SpaceType Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceAndSpaceTypeNames\n";
    ss << "A5, \\field Schedule Name\n";
    ss << "\\note Leave blank to match with default schedule\n";
    ss << "\\note units in Schedule should be fraction applied to design level of gas equipment, generally (0.0 - 1.0)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "A6; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::OS_GasEquipment);
    OptionalIddObject oObj = IddObject::load("OS:GasEquipment",
                                             "OpenStudio Space Loads",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_GasEquipment);
  return object;
}

IddObject createOS_HotWaterEquipmentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:HotWaterEquipment,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference HotWaterEquipmentNames\n";
    ss << "\\reference SpaceItemNames\n";
    ss << "\\reference SpaceLoadNames\n";
    ss << "\\reference SpaceComponentInstanceNames\n";
    ss << "A3, \\field Hot Water Equipment Definition Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list HotWaterEquipmentDefinitionNames\n";
    ss << "A4, \\field Space or SpaceType Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceAndSpaceTypeNames\n";
    ss << "A5, \\field Schedule Name\n";
    ss << "\\note Leave blank to match with default schedule\n";
    ss << "\\note units in Schedule should be fraction applied to design level of hot water equipment, generally (0.0 - 1.0)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "A6; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::OS_HotWaterEquipment);
    OptionalIddObject oObj = IddObject::load("OS:HotWaterEquipment",
                                             "OpenStudio Space Loads",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_HotWaterEquipment);
  return object;
}

IddObject createOS_SteamEquipmentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SteamEquipment,\n";
    ss << "\\memo Sets internal gains for steam equipment in the zone.\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference SteamEquipmentNames\n";
    ss << "\\reference SpaceItemNames\n";
    ss << "\\reference SpaceLoadNames\n";
    ss << "\\reference SpaceComponentInstanceNames\n";
    ss << "A3, \\field Steam Equipment Definition Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list SteamEquipmentDefinitionNames\n";
    ss << "A4, \\field Space or SpaceType Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceAndSpaceTypeNames\n";
    ss << "A5, \\field Schedule Name\n";
    ss << "\\note Leave blank to match with default schedule\n";
    ss << "\\note units in Schedule should be fraction applied to design level of steam equipment, generally (0.0 - 1.0)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "A6; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::OS_SteamEquipment);
    OptionalIddObject oObj = IddObject::load("OS:SteamEquipment",
                                             "OpenStudio Space Loads",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SteamEquipment);
  return object;
}

IddObject createOS_OtherEquipmentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:OtherEquipment,\n";
    ss << "\\memo Sets internal gains or losses for \"other\" equipment in the zone.\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference OtherEquipmentNames\n";
    ss << "\\reference SpaceItemNames\n";
    ss << "\\reference SpaceLoadNames\n";
    ss << "\\reference SpaceComponentInstanceNames\n";
    ss << "A3, \\field Other Equipment Definition Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list OtherEquipmentDefinitionNames\n";
    ss << "A4, \\field Space or SpaceType Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceAndSpaceTypeNames\n";
    ss << "A5, \\field Schedule Name\n";
    ss << "\\note Leave blank to match with default schedule\n";
    ss << "\\note units in Schedule should be fraction applied to design level of other equipment, generally (0.0 - 1.0)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1; \\field Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::OS_OtherEquipment);
    OptionalIddObject oObj = IddObject::load("OS:OtherEquipment",
                                             "OpenStudio Space Loads",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_OtherEquipment);
  return object;
}

IddObject createOS_SpaceInfiltration_DesignFlowRateIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SpaceInfiltration:DesignFlowRate,\n";
    ss << "\\memo Infiltration is specified as a design level which is modified by a Schedule fraction, temperature difference and wind speed:\n";
    ss << "\\memo Infiltration=Idesign * FSchedule * (A + B*|(Tzone-Todb)| + C*WindSpd + D * WindSpd**2)\n";
    ss << "\\min-fields 13\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference SpaceInfiltrationNames\n";
    ss << "\\reference SpaceItemNames\n";
    ss << "\\reference SpaceLoadNames\n";
    ss << "A3, \\field Space or SpaceType Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceAndSpaceTypeNames\n";
    ss << "A4, \\field Schedule Name\n";
    ss << "\\note Leave blank to match with default schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5, \\field Design Flow Rate Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum amount of infiltration\n";
    ss << "\\note for this set of attributes\n";
    ss << "\\note Choices: Flow/Space => Design Flow Rate -- simply enter Design Flow Rate\n";
    ss << "\\note Flow/Area => Flow per Space Floor Area - Value * Floor Area (space) = Design Flow Rate\n";
    ss << "\\note Flow/ExteriorArea => Flow per Exterior Surface Area - Value * Exterior Surface Area (space) = Design Flow Rate\n";
    ss << "\\note Flow/ExteriorWallArea => Flow per Exterior Surface Area - Value * Exterior Wall Surface Area (space) = Design Flow Rate\n";
    ss << "\\note AirChanges/Hour => Air Changes per Hour - Value * Floor Volume (space) adjusted for m3/s = Design Volume Flow Rate\n";
    ss << "\\note \"Idesign\" in Equation is the result.\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Flow/Space\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Flow/ExteriorArea\n";
    ss << "\\key Flow/ExteriorWallArea\n";
    ss << "\\key AirChanges/Hour\n";
    ss << "N1, \\field Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units ft3/min\n";
    ss << "\\minimum 0\n";
    ss << "N2, \\field Flow per Space Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0\n";
    ss << "N3, \\field Flow per Exterior Surface Area\n";
    ss << "\\note use key Flow/ExteriorArea for all exterior surface area\n";
    ss << "\\note use key Flow/ExteriorWallArea to include only exterior wall area\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0\n";
    ss << "N4, \\field Air Changes per Hour\n";
    ss << "\\units 1/hr\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N5, \\field Constant Term Coefficient\n";
    ss << "\\note \"A\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "N6, \\field Temperature Term Coefficient\n";
    ss << "\\note \"B\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "N7, \\field Velocity Term Coefficient\n";
    ss << "\\note \"C\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "N8; \\field Velocity Squared Term Coefficient\n";
    ss << "\\note \"D\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::OS_SpaceInfiltration_DesignFlowRate);
    OptionalIddObject oObj = IddObject::load("OS:SpaceInfiltration:DesignFlowRate",
                                             "OpenStudio Space Loads",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SpaceInfiltration_DesignFlowRate);
  return object;
}

IddObject createOS_SpaceInfiltration_EffectiveLeakageAreaIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SpaceInfiltration:EffectiveLeakageArea,\n";
    ss << "\\min-fields 7\n";
    ss << "\\memo  Infiltration is specified as effective leakage area at 4 Pa, schedule fraction, stack and wind coefficients, and\n";
    ss << "\\memo  is a function of temperature difference and wind speed:\n";
    ss << "\\memo  Infiltration=FSchedule * (AL /1000) SQRT(Cs*|(Tzone-Todb)| +  Cw*WindSpd**2 )\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SpaceInfiltrationNames\n";
    ss << "\\reference SpaceItemNames\n";
    ss << "\\reference SpaceLoadNames\n";
    ss << "A3 , \\field Space or SpaceType Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceAndSpaceTypeNames\n";
    ss << "A4 , \\field Schedule Name\n";
    ss << "\\note Leave blank to match with default schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Effective Air Leakage Area\n";
    ss << "\\units cm2\n";
    ss << "\\ip-units in2\n";
    ss << "\\note \"AL\" in Equation\n";
    ss << "\\minimum> 0\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N2 , \\field Stack Coefficient\n";
    ss << "\\note \"Cs\" in Equation\n";
    ss << "\\minimum> 0\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N3 ; \\field Wind Coefficient\n";
    ss << "\\note \"Cw\" in Equation\n";
    ss << "\\minimum> 0\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_SpaceInfiltration_EffectiveLeakageArea);
    OptionalIddObject oObj = IddObject::load("OS:SpaceInfiltration:EffectiveLeakageArea",
                                             "OpenStudio Space Loads",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SpaceInfiltration_EffectiveLeakageArea);
  return object;
}

IddObject createOS_Exterior_LightsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Exterior:Lights,\n";
    ss << "\\memo only used for Meter type reporting, does not affect building loads\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ExteriorLightsNames\n";
    ss << "\\reference ExteriorEquipmentNames\n";
    ss << "A3, \\field Exterior Lights Definition Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ExteriorLightsDefinitionNames\n";
    ss << "A4, \\field Schedule Name\n";
    ss << "\\note units in schedule should be fraction applied to capacity of the exterior lights equipment, generally (0.0 - 1.0)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5, \\field Control Option\n";
    ss << "\\note Astronomical Clock option overrides schedule to turn lights off when sun is up\n";
    ss << "\\type choice\n";
    ss << "\\default ScheduleNameOnly\n";
    ss << "\\key ScheduleNameOnly\n";
    ss << "\\key AstronomicalClock\n";
    ss << "N1, \\field Multiplier\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.0\n";
    ss << "A6; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::OS_Exterior_Lights);
    OptionalIddObject oObj = IddObject::load("OS:Exterior:Lights",
                                             "OpenStudio Exterior Equipment",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Exterior_Lights);
  return object;
}

IddObject createOS_Daylighting_ControlIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Daylighting:Control,\n";
    ss << "\\memo Dimming of overhead electric lighting is determined from\n";
    ss << "\\memo daylight illuminance calculated at reference point.\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference DaylightingControlNames\n";
    ss << "\\reference SpaceItemNames\n";
    ss << "A3, \\field Space Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceNames\n";
    ss << "N1, \\field Position X-Coordinate\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0.0\n";
    ss << "N2, \\field Position Y-Coordinate\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0.0\n";
    ss << "N3, \\field Position Z-Coordinate\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0.0\n";
    ss << "N4, \\field Psi Rotation Around X-Axis\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 0.0\n";
    ss << "N5, \\field Theta Rotation Around Y-Axis\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 0.0\n";
    ss << "N6, \\field Phi Rotation Around Z-Axis\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 0.0\n";
    ss << "N7, \\field Illuminance Setpoint\n";
    ss << "\\type real\n";
    ss << "\\units lux\n";
    ss << "\\minimum 0\n";
    ss << "\\default 500\n";
    ss << "N8, \\field Lighting Control Type\n";
    ss << "\\type choice\n";
    ss << "\\default Continuous\n";
    ss << "\\key None\n";
    ss << "\\key Continuous\n";
    ss << "\\key Stepped\n";
    ss << "\\key Continuous/Off\n";
    ss << "N9, \\field Minimum Input Power Fraction for Continuous Dimming Control\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 0.6\n";
    ss << "\\default 0.3\n";
    ss << "N10, \\field Minimum Light Output Fraction for Continuous Dimming Control\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 0.6\n";
    ss << "\\default 0.2\n";
    ss << "N11, \\field Number of Stepped Control Steps\n";
    ss << "\\type integer\n";
    ss << "\\default 1\n";
    ss << "N12, \\field Probability Lighting will be Reset When Needed in Manual Stepped Control\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 1.0\n";
    ss << "N13, \\field Number of Daylighting Views\n";
    ss << "\\note Number of views to render at this point, first view is rendered in local X direction\n";
    ss << "\\note subsequent views are spaced at equal rotations around the local Z axis\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\default 1\n";
    ss << "N14; \\field Maximum Allowable Discomfort Glare Index\n";
    ss << "\\note The default is for general office work\n";
    ss << "\\type real\n";
    ss << "\\minimum 1\n";

    IddObjectType objType(IddObjectType::OS_Daylighting_Control);
    OptionalIddObject oObj = IddObject::load("OS:Daylighting:Control",
                                             "OpenStudio Lighting Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Daylighting_Control);
  return object;
}

IddObject createOS_Glare_SensorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Glare:Sensor,\n";
    ss << "\\memo Will compute vertical eye illuminance around sensor\n";
    ss << "\\memo point for DGP(simplified) evaluation in Radiance.\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference GlareSensorNames\n";
    ss << "\\reference SpaceItemNames\n";
    ss << "A3, \\field Space Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceNames\n";
    ss << "N1, \\field Position X-Coordinate\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0.0\n";
    ss << "N2, \\field Position Y-Coordinate\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0.0\n";
    ss << "N3, \\field Position Z-Coordinate\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0.0\n";
    ss << "N4, \\field Psi Rotation Around X-Axis\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 0.0\n";
    ss << "N5, \\field Theta Rotation Around Y-Axis\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 0.0\n";
    ss << "N6, \\field Phi Rotation Around Z-Axis\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 0.0\n";
    ss << "N7, \\field Number of Glare View Vectors\n";
    ss << "\\note Number of views to compute about this point, first view is rendered in local X direction\n";
    ss << "\\note subsequent views are spaced at equal rotations around the local Z axis\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\default 1\n";
    ss << "N8; \\field Maximum Allowable Daylight Glare Probability\n";
    ss << "\\note The default is for general office work\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.2\n";
    ss << "\\default 0.6\n";

    IddObjectType objType(IddObjectType::OS_Glare_Sensor);
    OptionalIddObject oObj = IddObject::load("OS:Glare:Sensor",
                                             "OpenStudio Lighting Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Glare_Sensor);
  return object;
}

IddObject createOS_IlluminanceMapIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:IlluminanceMap,\n";
    ss << "\\memo A grid of points for calculating illuminance values.\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference IlluminanceMapNames\n";
    ss << "\\reference SpaceItemNames\n";
    ss << "A3, \\field Space Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceNames\n";
    ss << "N1, \\field Origin X-Coordinate\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0\n";
    ss << "N2, \\field Origin Y-Coordinate\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0\n";
    ss << "N3, \\field Origin Z-Coordinate\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 0\n";
    ss << "N4, \\field Psi Rotation Around X-Axis\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 0\n";
    ss << "N5, \\field Theta Rotation Around Y-Axis\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 0\n";
    ss << "N6, \\field Phi Rotation Around Z-Axis\n";
    ss << "\\type real\n";
    ss << "\\units deg\n";
    ss << "\\default 0\n";
    ss << "N7, \\field X Length\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 1.0\n";
    ss << "N8, \\field Number of X Grid Points\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 10\n";
    ss << "N9, \\field Y Length\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 1.0\n";
    ss << "N10; \\field Number of Y Grid Points\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 10\n";

    IddObjectType objType(IddObjectType::OS_IlluminanceMap);
    OptionalIddObject oObj = IddObject::load("OS:IlluminanceMap",
                                             "OpenStudio Lighting Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_IlluminanceMap);
  return object;
}

IddObject createOS_LightingDesignDayIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:LightingDesignDay,\n";
    ss << "\\extensible:2\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference LightingDesignDays\n";
    ss << "A3, \\field CIE Sky Model\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Clear\n";
    ss << "\\key Overcast\n";
    ss << "N1, \\field Snow Indicator\n";
    ss << "\\note Currently unsupported.\n";
    ss << "\\note 1 is Snow on Ground, 0 is no Snow on Ground\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0\n";
    ss << "N2, \\field Month\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "N3, \\field Day of Month\n";
    ss << "\\note must be valid for Month field\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "N4, \\field Hour to Simulate\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 24\n";
    ss << "N5; \\field Minute to Simulate\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 60\n";
    ss << "\\default 0\n";

    IddObjectType objType(IddObjectType::OS_LightingDesignDay);
    OptionalIddObject oObj = IddObject::load("OS:LightingDesignDay",
                                             "OpenStudio Lighting Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_LightingDesignDay);
  return object;
}

IddObject createOS_LightingSimulationControlIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:LightingSimulationControl,\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Run Simulation for Design Days\n";
    ss << "\\note If Yes, LightingDesignDay objects are executed and results from those may be displayed..\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A3; \\field Run Simulation for Weather File Run Periods\n";
    ss << "\\note If Yes, RunPeriod objects are executed and results from those may be displayed..\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";

    IddObjectType objType(IddObjectType::OS_LightingSimulationControl);
    OptionalIddObject oObj = IddObject::load("OS:LightingSimulationControl",
                                             "OpenStudio Lighting Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_LightingSimulationControl);
  return object;
}

IddObject createOS_LightingSimulationZoneIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:LightingSimulationZone,\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference LightingSimulationZoneNames\n";
    ss << "A3, \\field Group Rendering Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list GroupRenderingNames\n";
    ss << "A4; \\field Planar Surface Group Name\n";
    ss << "\\note Space, shading surface group, or interior surface partition group to include\n";
    ss << "\\note in the lighting simulation\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\object-list PlanarSurfaceGroupNames\n";

    IddObjectType objType(IddObjectType::OS_LightingSimulationZone);
    OptionalIddObject oObj = IddObject::load("OS:LightingSimulationZone",
                                             "OpenStudio Lighting Simulation",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_LightingSimulationZone);
  return object;
}

IddObject createOS_Refrigeration_CaseIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Refrigeration:Case,\n";
    ss << "\\min-fields 29\n";
    ss << "A1,   \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,   \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference AllObjects\n";
    ss << "A3,   \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Assumed to be always available if schedule name left blank\n";
    ss << "A4,   \\field Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "\\note This must be a controlled zone and appear in a ZoneHVAC:EquipmentConnections object.\n";
    ss << "N1,   \\field Rated Ambient Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 23.9\n";
    ss << "N2,   \\field Rated Ambient Relative Humidity\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 100.0\n";
    ss << "\\default 55.0\n";
    ss << "N3,   \\field Rated Total Cooling Capacity per Unit Length\n";
    ss << "\\type real\n";
    ss << "\\units W/m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1900.0\n";
    ss << "N4,   \\field Rated Latent Heat Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.3\n";
    ss << "N5,   \\field Rated Runtime Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.85\n";
    ss << "N6,   \\field Case Length\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.0\n";
    ss << "N7,   \\field Case Operating Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\maximum< 20.0\n";
    ss << "\\default 1.1\n";
    ss << "A5,   \\field Latent Case Credit Curve Type\n";
    ss << "\\type choice\n";
    ss << "\\key CaseTemperatureMethod\n";
    ss << "\\key RelativeHumidityMethod\n";
    ss << "\\key DewpointMethod\n";
    ss << "\\default CaseTemperatureMethod\n";
    ss << "A6,   \\field Latent Case Credit Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list CubicCurves\n";
    ss << "N8,   \\field Standard Case Fan Power per Unit Length\n";
    ss << "\\type real\n";
    ss << "\\units W/m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 75.0\n";
    ss << "N9,   \\field Operating Case Fan Power per Unit Length\n";
    ss << "\\type real\n";
    ss << "\\units W/m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 75.0\n";
    ss << "N10,  \\field Standard Case Lighting Power per Unit Length\n";
    ss << "\\type real\n";
    ss << "\\units W/m\n";
    ss << "\\default 90.0\n";
    ss << "N11,  \\field Installed Case Lighting Power per Unit Length\n";
    ss << "\\type real\n";
    ss << "\\units W/m\n";
    ss << "\\note Default set equal to Standard Case Lighting Power per Unit Length\n";
    ss << "A7,   \\field Case Lighting Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N12,  \\field Fraction of Lighting Energy to Case\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "N13,  \\field Case Anti-Sweat Heater Power per Unit Length\n";
    ss << "\\type real\n";
    ss << "\\units W/m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N14,  \\field Minimum Anti-Sweat Heater Power per Unit Length\n";
    ss << "\\type real\n";
    ss << "\\units W/m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This field is only applicable to the Linear, Dewpoint Method, and\n";
    ss << "\\note Heat Balance Method anti-sweat heater control types\n";
    ss << "A8,   \\field Anti-Sweat Heater Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Constant\n";
    ss << "\\key Linear\n";
    ss << "\\key DewpointMethod\n";
    ss << "\\key HeatBalanceMethod\n";
    ss << "\\default None\n";
    ss << "N15,  \\field Humidity at Zero Anti-Sweat Heater Energy\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\default -10.0\n";
    ss << "\\note This field is only applicable to Linear AS heater control type\n";
    ss << "\\note Zone relative humidity (%) where anti-sweat heater energy is zero\n";
    ss << "N16,  \\field Case Height\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 1.5\n";
    ss << "\\note This field only applicable to Heat Balance Method AS heater control type\n";
    ss << "\\note Height must be greater than zero if Heat Balance Method AS heater control is selected\n";
    ss << "N17,  \\field Fraction of Anti-Sweat Heater Energy to Case\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "N18,  \\field Case Defrost Power per Unit Length\n";
    ss << "\\type real\n";
    ss << "\\units W/m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Used to evaluate load on case as well as power or heat consumption\n";
    ss << "A9,   \\field Case Defrost Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key OffCycle\n";
    ss << "\\key HotGas\n";
    ss << "\\key Electric\n";
    ss << "\\key HotFluid\n";
    ss << "\\key HotGasWithTemperatureTermination\n";
    ss << "\\key ElectricWithTemperatureTermination\n";
    ss << "\\key HotFluidWithTemperatureTermination\n";
    ss << "\\default OffCycle\n";
    ss << "A10,  \\field Case Defrost Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note A case defrost schedule name is required unless case defrost type = None\n";
    ss << "A11,  \\field Case Defrost Drip-Down Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note If left blank, the defrost schedule will be used\n";
    ss << "\\note The start time for each defrost period in this drip-down schedule should coincide with\n";
    ss << "\\note the start time for each defrost period in the case defrost schedule (previous input\n";
    ss << "\\note field).The length of each defrost drip-down period must be greater than or equal to the\n";
    ss << "\\note corresponding defrost period specified in the case defrost schedule. This extra time\n";
    ss << "\\note allows the melted frost to drip from the coil before refrigeration is restarted.\n";
    ss << "A12,  \\field Defrost Energy Correction Curve Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key CaseTemperatureMethod\n";
    ss << "\\key RelativeHumidityMethod\n";
    ss << "\\key DewpointMethod\n";
    ss << "\\default None\n";
    ss << "\\note Case Temperature, Relative Humidity, and Dewpoint Method are applicable to case defrost\n";
    ss << "\\note types with temperature termination only.\n";
    ss << "A13,  \\field Defrost Energy Correction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\note Defrost Energy Correction Curve Name is applicable to case defrost types\n";
    ss << "\\note with temperature termination only.\n";
    ss << "N19,  \\field Under Case HVAC Return Air Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "A14,  \\field Refrigerated Case Restocking Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values should be in units of Watts per unit case length (W/m)\n";
    ss << "\\note Leave this field blank if no restocking is to be modeled\n";
    ss << "A15,  \\field Case Credit Fraction Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values should be from 0 to 1\n";
    ss << "\\note Leave this field blank if no case credit fraction is to be applied\n";
    ss << "N20,  \\field Design Evaporator Temperature or Brine Inlet Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -70.0\n";
    ss << "\\maximum 40.0\n";
    ss << "\\note Required for detailed refrigeration system, not for compressor rack\n";
    ss << "\\note For a DX system, enter the saturated temperature for refrigerant pressure leaving case\n";
    ss << "\\note For a brine-cooled cooled (secondary system) case, enter the brine inlet temperature\n";
    ss << "\\note Default is 5 C less than case operating temperature\n";
    ss << "N21,  \\field Average Refrigerant Charge Inventory\n";
    ss << "\\units kg/m\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "N22,  \\field Number Of Doors\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0\n";
    ss << "N23,  \\field Rated Total Cooling Capacity per Door\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "N24,  \\field Standard Case Fan Power per Door\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "N25,  \\field Operating Case Fan Power per Door\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "N26,  \\field Standard Case Lighting Power per Door\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "N27,  \\field Installed Case Lighting Power per Door\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "N28,  \\field Case Anti-Sweat Heater Power per Door\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "N29,  \\field Minimum Anti-Sweat Heater Power per Door\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note This field is only applicable to the Linear, Dewpoint Method, and\n";
    ss << "\\note Heat Balance Method anti-sweat heater control types\n";
    ss << "N30,  \\field Case Defrost Power per Door\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Used to evaluate load on case as well as power or heat consumption\n";
    ss << "A16,  \\field Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key UnitLength\n";
    ss << "\\key NumberOfDoors\n";
    ss << "\\default UnitLength\n";
    ss << "A17;  \\field Case Defrost Cycle Parameters Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationDefrostCycleParameters\n";

    IddObjectType objType(IddObjectType::OS_Refrigeration_Case);
    OptionalIddObject oObj = IddObject::load("OS:Refrigeration:Case",
                                             "OpenStudio Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Refrigeration_Case);
  return object;
}

IddObject createOS_Refrigeration_Condenser_AirCooledIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Refrigeration:Condenser:AirCooled,\n";
    ss << "\\min-fields 6\n";
    ss << "A1,   \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,   \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference RefrigerationAllTypesCondenserNames\n";
    ss << "\\reference DesuperHeatingCoilSources\n";
    ss << "A3,   \\field Rated Effective Total Heat Rejection Rate Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\note Rating as per ARI 460\n";
    ss << "\\note Be sure the rating corresponds to the correct refrigerant\n";
    ss << "\\note HeatRejection(W)=C1 +C2(Condensing Temp - Entering Air Temp, deg C)\n";
    ss << "\\note Will be adjusted for elevation automatically\n";
    ss << "N1,   \\field Rated Subcooling Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Must correspond to rating given for total heat rejection effect\n";
    ss << "A4,   \\field Condenser Fan Speed Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Fixed\n";
    ss << "\\key FixedLinear\n";
    ss << "\\key VariableSpeed\n";
    ss << "\\key TwoSpeed\n";
    ss << "\\default Fixed\n";
    ss << "N2,   \\field Rated Fan Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 250.0\n";
    ss << "\\note Power for condenser fan(s) corresponding to rated total heat rejection effect.\n";
    ss << "N3,   \\field Minimum Fan Air Flow Ratio\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.2\n";
    ss << "\\note Minimum air flow fraction through condenser fan\n";
    ss << "A5,   \\field Air Inlet Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "\\note If field is left blank,\n";
    ss << "\\note then the model assumes that the inlet air\n";
    ss << "\\note conditions are the outdoor air conditions for the current timestep\n";
    ss << "\\note (e.g., no adjustment for height above ground).\n";
    ss << "\\note If the condenser rejects heat to a conditioned zone, enter the zone name here.\n";
    ss << "A6,   \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";
    ss << "N4,   \\field Condenser Refrigerant Operating Charge Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note optional input\n";
    ss << "N5,   \\field Condensate Receiver Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note optional input\n";
    ss << "N6;   \\field Condensate Piping Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note optional input\n";

    IddObjectType objType(IddObjectType::OS_Refrigeration_Condenser_AirCooled);
    OptionalIddObject oObj = IddObject::load("OS:Refrigeration:Condenser:AirCooled",
                                             "OpenStudio Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Refrigeration_Condenser_AirCooled);
  return object;
}

IddObject createOS_Refrigeration_Condenser_EvaporativeCooledIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Refrigeration:Condenser:EvaporativeCooled,\n";
    ss << "\\min-fields 11\n";
    ss << "A1,   \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,   \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference RefrigerationAllTypesCondenserNames\n";
    ss << "\\reference DesuperHeatingCoilSources\n";
    ss << "N1,   \\field Rated Effective Total Heat Rejection Rate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Rating as per ARI 490\n";
    ss << "\\note Be sure the rating corresponds to the correct refrigerant\n";
    ss << "N2,   \\field Rated Subcooling Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Must correspond to rating given for total heat rejection effect\n";
    ss << "A3,   \\field Fan Speed Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Fixed\n";
    ss << "\\key FixedLinear\n";
    ss << "\\key VariableSpeed\n";
    ss << "\\key TwoSpeed\n";
    ss << "\\default Fixed\n";
    ss << "N3,   \\field Rated Fan Power\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Power for condenser fan(s) corresponding to rated total heat rejection effect.\n";
    ss << "N4,   \\field Minimum Fan Air Flow Ratio\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.2\n";
    ss << "\\note Minimum air flow fraction through condenser fan\n";
    ss << "N5,   \\field Approach Temperature Constant Term\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 20.0\n";
    ss << "\\default 6.63\n";
    ss << "\\note A1 in delta T = A1 + A2(hrcf) + A3/(hrcf) + A4(Twb)\n";
    ss << "N6,   \\field Approach Temperature Coefficient 2\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 20.0\n";
    ss << "\\default 0.468\n";
    ss << "\\note A2 in delta T = A1 + A2(hrcf) +A3/(hrcf) +A4(Twb)\n";
    ss << "N7,   \\field Approach Temperature Coefficient 3\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 30.0\n";
    ss << "\\default 17.93\n";
    ss << "\\note A3 in delta T = A1 + A2(hrcf) +A3/(hrcf) +A4(Twb)\n";
    ss << "N8,   \\field Approach Temperature Coefficient 4\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum -20.0\n";
    ss << "\\maximum 20.0\n";
    ss << "\\default -0.322\n";
    ss << "\\note A4 in deltaT=A1 + A2(hrcf) +A3/(hrcf) +A4(Twb)\n";
    ss << "N9,   \\field Minimum Capacity Factor\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 0.50\n";
    ss << "\\note Taken from manufacturer's Heat Rejection Capacity Factor Table\n";
    ss << "N10,  \\field Maximum Capacity Factor\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 5.0\n";
    ss << "\\note Taken from manufacturer's Heat Rejection Capacity Factor Table\n";
    ss << "A4,   \\field Air Inlet Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\note If field is left blank,\n";
    ss << "\\note then the model assumes that the inlet air\n";
    ss << "\\note conditions are the outdoor air conditions for the current timestep\n";
    ss << "\\note (e.g., no adjustment for height above ground).\n";
    ss << "N11,  \\field Rated Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autocalculatable\n";
    ss << "\\default autocalculate\n";
    ss << "\\note Used to calculate evaporative condenser water use and fan energy use.\n";
    ss << "N12,  \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 200.0\n";
    ss << "\\note This field is only used for periods\n";
    ss << "\\note when the evap condenser is available (field Evaporative Condenser Availability\n";
    ss << "\\note Schedule). For this situation, the heater heats the basin water when the\n";
    ss << "\\note outdoor air dry-bulb temperature falls below the set point temperature, but\n";
    ss << "\\note only when the condenser fans are off (i.e., no refrigerated case load).\n";
    ss << "N13,  \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note Enter the outdoor dry-bulb temperature at which the basin heater turns on.\n";
    ss << "N14,  \\field Rated Water Pump Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\autocalculatable\n";
    ss << "\\default 1000.0\n";
    ss << "\\note Design recirculating water pump power.\n";
    ss << "A5,   \\field Evaporative Water Supply Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "\\note If blank, water supply is from Mains.\n";
    ss << "A6,   \\field Evaporative Condenser Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values greater than 0 indicate that evaporative cooling of the\n";
    ss << "\\note condenser is available. This schedule allows the user to define seasonal\n";
    ss << "\\note shutdown/draining of the water cooling system in cold climate applications.\n";
    ss << "\\note For periods with schedule values of 0, the condenser operates as Air Cooled.\n";
    ss << "A7,   \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";
    ss << "N15,  \\field Condenser Refrigerant Operating Charge Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note optional input\n";
    ss << "N16,  \\field Condensate Receiver Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note optional input\n";
    ss << "N17;  \\field Condensate Piping Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note optional input\n";

    IddObjectType objType(IddObjectType::OS_Refrigeration_Condenser_EvaporativeCooled);
    OptionalIddObject oObj = IddObject::load("OS:Refrigeration:Condenser:EvaporativeCooled",
                                             "OpenStudio Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Refrigeration_Condenser_EvaporativeCooled);
  return object;
}

IddObject createOS_Refrigeration_Condenser_WaterCooledIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Refrigeration:Condenser:WaterCooled,\n";
    ss << "A1,   \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,   \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "\\reference RefrigerationAllTypesCondenserNames\n";
    ss << "\\reference DesuperHeatingCoilSources\n";
    ss << "N1,   \\field Rated Effective Total Heat Rejection Rate\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Rating as per ARI 450\n";
    ss << "\\note Be sure the rating corresponds to the correct refrigerant\n";
    ss << "\\note Not used in calculations, only for identification and output\n";
    ss << "N2,   \\field Rated Condensing Temperature\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Must correspond to rating given for total heat rejection effect\n";
    ss << "N3,   \\field Rated Subcooling Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Must correspond to rating given for total heat rejection effect\n";
    ss << "N4,   \\field Rated Water Inlet Temperature\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Must correspond to rating given for total heat rejection effect\n";
    ss << "A3,   \\field Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4,   \\field Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5,   \\field Water-Cooled Loop Flow Type\n";
    ss << "\\type choice\n";
    ss << "\\key VariableFlow\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\default VariableFlow\n";
    ss << "A6,   \\field Water Outlet Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Applicable only when loop flow type is Variable Flow.\n";
    ss << "N5,   \\field Water Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Note required units must be converted from L/s as specified in ARI 450-2007\n";
    ss << "\\note Applicable only when loop flow type is Constant Flow.\n";
    ss << "N6,   \\field Water Maximum Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "N7,   \\field Water Maximum Water Outlet Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 10.0\n";
    ss << "\\maximum 60.0\n";
    ss << "\\default 55.0\n";
    ss << "N8,   \\field Water Minimum Water Inlet Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 10.0\n";
    ss << "\\maximum 30.0\n";
    ss << "\\default 10.0\n";
    ss << "\\note related to the minimum allowed refrigeration system condensing temperature\n";
    ss << "A7,   \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";
    ss << "N9,   \\field Condenser Refrigerant Operating Charge Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\note optional input\n";
    ss << "N10,  \\field Condensate Receiver Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\note optional input\n";
    ss << "N11;  \\field Condensate Piping Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\note optional input\n";

    IddObjectType objType(IddObjectType::OS_Refrigeration_Condenser_WaterCooled);
    OptionalIddObject oObj = IddObject::load("OS:Refrigeration:Condenser:WaterCooled",
                                             "OpenStudio Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Refrigeration_Condenser_WaterCooled);
  return object;
}

IddObject createOS_Refrigeration_Condenser_CascadeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Refrigeration:Condenser:Cascade,\n";
    ss << "A1,   \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,   \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference RefrigerationAllTypesCondenserNames\n";
    ss << "\\reference AllObjects\n";
    ss << "N1,   \\field Rated Condensing Temperature\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\note This is the condensing temperature for the lower temperature secondary loop\n";
    ss << "N2,   \\field Rated Approach Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.0\n";
    ss << "\\note This is the difference between the condensing and evaporating temperatures\n";
    ss << "N3,   \\field Rated Effective Total Heat Rejection Rate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Used for identification and rough system size error checking\n";
    ss << "A3,   \\field Condensing Temperature Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Fixed\n";
    ss << "\\key Float\n";
    ss << "\\default Fixed\n";
    ss << "\\note Fixed keeps condensing temperature constant\n";
    ss << "\\note Float sets the condensing temperature according to\n";
    ss << "\\note      the other loads on the higher temperature system\n";
    ss << "N4,   \\field Condenser Refrigerant Operating Charge Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\note optional input\n";
    ss << "N5,   \\field Condensate Receiver Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\note optional input\n";
    ss << "N6;   \\field Condensate Piping Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\note optional input\n";

    IddObjectType objType(IddObjectType::OS_Refrigeration_Condenser_Cascade);
    OptionalIddObject oObj = IddObject::load("OS:Refrigeration:Condenser:Cascade",
                                             "OpenStudio Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Refrigeration_Condenser_Cascade);
  return object;
}

IddObject createOS_Refrigeration_CompressorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Refrigeration:Compressor,\n";
    ss << "\\min-fields 7\n";
    ss << "\\memo Data is available for many compressors in the RefrigerationCompressor.idf dataset\n";
    ss << "A1,   \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,   \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference AllObjects\n";
    ss << "A3,   \\field Refrigeration Compressor Power Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list BicubicCurves\n";
    ss << "\\note The input order for the Curve:Bicubic does not\n";
    ss << "\\note match the ARI 540-2004 Eq. 1 coefficient order\n";
    ss << "\\note N1 is ARI_C1, N2 is ARI_C2, N3 is ARI_C4, N4 is ARI_C3,\n";
    ss << "\\note N5 is ARI_C6, N6 is ARI_C5, N7 is ARI_C7, N8 is ARI_C10,\n";
    ss << "\\note N9 is ARI_C8, N10 is ARI_C9,\n";
    ss << "\\note N11 is Minimum Suction dewpoint temperature,\n";
    ss << "\\note N12 is Maximum Suction dewpoint temperature,\n";
    ss << "\\note N13 is Minimum Discharge dewpoint temperature,\n";
    ss << "\\note N14 is Maximum Discharge dewpoint temperature\n";
    ss << "A4,   \\field Refrigeration Compressor Capacity Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list BicubicCurves\n";
    ss << "\\note The input order for the Curve:Bicubic does not\n";
    ss << "\\note match the ARI 540-2004 Eq. 1 coefficient order\n";
    ss << "\\note N1 is ARI_C1, N2 is ARI_C2, N3 is ARI_C4, N4 is ARI_C3,\n";
    ss << "\\note N5 is ARI_C6, N6 is ARI_C5, N7 is ARI_C7, N8 is ARI_C10,\n";
    ss << "\\note N9 is ARI_C8, N10 is ARI_C9,\n";
    ss << "\\note N11 is Minimum Suction dewpoint temperature,\n";
    ss << "\\note N12 is Maximum Suction dewpoint temperature,\n";
    ss << "\\note N13 is Minimum Discharge dewpoint temperature,\n";
    ss << "\\note N14 is Maximum Discharge dewpoint temperature\n";
    ss << "N1,   \\field Rated Superheat\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Use this input field OR the next, not both\n";
    ss << "\\note This is used if the compressor rating is based upon\n";
    ss << "\\note degrees of superheat\n";
    ss << "N2,   \\field Rated Return Gas Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Use this input field OR the previous, not both\n";
    ss << "\\note This is used if the compressor rating is based upon\n";
    ss << "\\note rated return gas temperature (Rated Suction Temperature)\n";
    ss << "N3,   \\field Rated Liquid Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Use this input field OR the next, not both\n";
    ss << "\\note This is used if the compressor rating is based upon\n";
    ss << "\\note rated liquid temperature at the expansion valve\n";
    ss << "N4,   \\field Rated Subcooling\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Use this input field OR the previous, not both\n";
    ss << "\\note This is used if the compressor rating is based upon\n";
    ss << "\\note degrees of subcooling\n";
    ss << "A5,   \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";
    ss << "A6,   \\field Mode of Operation\n";
    ss << "\\type choice\n";
    ss << "\\retaincase\n";
    ss << "\\key Subcritical\n";
    ss << "\\key Transcritical\n";
    ss << "\\default Subcritical\n";
    ss << "A7,   \\field Transcritical Compressor Power Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BicubicCurves\n";
    ss << "A8;   \\field Transcritical Compressor Capacity Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BicubicCurves\n";

    IddObjectType objType(IddObjectType::OS_Refrigeration_Compressor);
    OptionalIddObject oObj = IddObject::load("OS:Refrigeration:Compressor",
                                             "OpenStudio Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Refrigeration_Compressor);
  return object;
}

IddObject createOS_Refrigeration_DefrostCycleParametersIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Refrigeration:DefrostCycleParameters,\n";
    ss << "\\min-fields 6\n";
    ss << "A1,   \\field Handle\n";
    ss << "\\type handle\n";
    ss << "A2,   \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RefrigerationDefrostCycleParameters\n";
    ss << "N1,   \\field Duration of Defrost Cycle\n";
    ss << "\\type integer\n";
    ss << "\\units minutes\n";
    ss << "\\minimum> 0\n";
    ss << "N2,   \\field Drip Down Time\n";
    ss << "\\type integer\n";
    ss << "\\units minutes\n";
    ss << "\\minimum> 0\n";
    ss << "N3,   \\field Defrost 1 Hour Start Time\n";
    ss << "\\type integer\n";
    ss << "\\units hr\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 23\n";
    ss << "N4,   \\field Defrost 1 Minute Start Time\n";
    ss << "\\type integer\n";
    ss << "\\units minutes\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 59\n";
    ss << "N5,   \\field Defrost 2 Hour Start Time\n";
    ss << "\\type integer\n";
    ss << "\\units hr\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 23\n";
    ss << "N6,   \\field Defrost 2 Minute Start Time\n";
    ss << "\\type integer\n";
    ss << "\\units minutes\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 59\n";
    ss << "N7,   \\field Defrost 3 Hour Start Time\n";
    ss << "\\type integer\n";
    ss << "\\units hr\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 23\n";
    ss << "N8,   \\field Defrost 3 Minute Start Time\n";
    ss << "\\type integer\n";
    ss << "\\units minutes\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 59\n";
    ss << "N9,   \\field Defrost 4 Hour Start Time\n";
    ss << "\\type integer\n";
    ss << "\\units hr\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 23\n";
    ss << "N10,  \\field Defrost 4 Minute Start Time\n";
    ss << "\\type integer\n";
    ss << "\\units minutes\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 59\n";
    ss << "N11,  \\field Defrost 5 Hour Start Time\n";
    ss << "\\type integer\n";
    ss << "\\units hr\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 23\n";
    ss << "N12,  \\field Defrost 5 Minute Start Time\n";
    ss << "\\type integer\n";
    ss << "\\units minutes\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 59\n";
    ss << "N13,  \\field Defrost 6 Hour Start Time\n";
    ss << "\\type integer\n";
    ss << "\\units hr\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 23\n";
    ss << "N14,  \\field Defrost 6 Minute Start Time\n";
    ss << "\\type integer\n";
    ss << "\\units minutes\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 59\n";
    ss << "N15,  \\field Defrost 7 Hour Start Time\n";
    ss << "\\type integer\n";
    ss << "\\units hr\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 23\n";
    ss << "N16,  \\field Defrost 7 Minute Start Time\n";
    ss << "\\type integer\n";
    ss << "\\units minutes\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 59\n";
    ss << "N17,  \\field Defrost 8 Hour Start Time\n";
    ss << "\\type integer\n";
    ss << "\\units hr\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 23\n";
    ss << "N18;  \\field Defrost 8 Minute Start Time\n";
    ss << "\\type integer\n";
    ss << "\\units minutes\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 59\n";

    IddObjectType objType(IddObjectType::OS_Refrigeration_DefrostCycleParameters);
    OptionalIddObject oObj = IddObject::load("OS:Refrigeration:DefrostCycleParameters",
                                             "OpenStudio Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Refrigeration_DefrostCycleParameters);
  return object;
}

IddObject createOS_Refrigeration_GasCooler_AirCooledIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Refrigeration:GasCooler:AirCooled,\n";
    ss << "\\memo The transcritical refrigeration system requires a single gas cooler to reject the\n";
    ss << "\\memo system heat.\n";
    ss << "\\min-fields 3\n";
    ss << "A1,   \\field Handle\n";
    ss << "\\type handle\n";
    ss << "A2,   \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RefrigerationAllTypesGasCoolerNames\n";
    ss << "A3,   \\field Rated Total Heat Rejection Rate Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\note Be sure the rating corresponds to the correct refrigerant (R744)\n";
    ss << "\\note HeatRejection(W)=C1 +C2(Gas Cooler Outlet Temp - Entering Air Temp, deg C)\n";
    ss << "\\note Will be adjusted for elevation automatically\n";
    ss << "A4,   \\field Gas Cooler Fan Speed Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Fixed\n";
    ss << "\\key FixedLinear\n";
    ss << "\\key VariableSpeed\n";
    ss << "\\key TwoSpeed\n";
    ss << "\\default Fixed\n";
    ss << "N1,   \\field Rated Fan Power\n";
    ss << "\\note Power for gas cooler fan(s) corresponding to rated total heat rejection effect.\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 5000.0\n";
    ss << "N2,   \\field Minimum Fan Air Flow Ratio\n";
    ss << "\\note Minimum air flow fraction through gas cooler fan\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.2\n";
    ss << "N3,   \\field Transition Temperature\n";
    ss << "\\note Temperature at which system transitions between subcritical and transcritical operation.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 27.0\n";
    ss << "N4,   \\field Transcritical Approach Temperature\n";
    ss << "\\note Temperature difference between the CO2 exiting the gas cooler and the air entering the\n";
    ss << "\\note gas cooler during transcritical operation.\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 3.0\n";
    ss << "N5,   \\field Subcritical Temperature Difference\n";
    ss << "\\note Temperature difference between the saturated condensing temperature and the air\n";
    ss << "\\note temperature during subcritical operation.\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default 10.0\n";
    ss << "N6,   \\field Minimum Condensing Temperature\n";
    ss << "\\note Minimum saturated condensing temperature during subcritical operation.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 10.0\n";
    ss << "A5,   \\field Air Inlet Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\note If field is left blank,\n";
    ss << "\\note then the model assumes that the inlet air\n";
    ss << "\\note conditions are the outdoor air conditions for the current timestep\n";
    ss << "\\note (e.g., no adjustment for height above ground).\n";
    ss << "A6,   \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";
    ss << "N7,   \\field Gas Cooler Refrigerant Operating Charge Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note optional input\n";
    ss << "N8,   \\field Gas Cooler Receiver Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note optional input\n";
    ss << "N9;   \\field Gas Cooler Outlet Piping Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note optional input\n";

    IddObjectType objType(IddObjectType::OS_Refrigeration_GasCooler_AirCooled);
    OptionalIddObject oObj = IddObject::load("OS:Refrigeration:GasCooler:AirCooled",
                                             "OpenStudio Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Refrigeration_GasCooler_AirCooled);
  return object;
}

IddObject createOS_Refrigeration_Subcooler_MechanicalIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Refrigeration:Subcooler:Mechanical,\n";
    ss << "\\min-fields 4\n";
    ss << "A1,   \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,   \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference RefrigerationSubcoolerNames\n";
    ss << "A3,   \\field Capacity-Providing System\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationSystemNames\n";
    ss << "\\note Name of the Detailed Refrigeration System providing cooling capacity\n";
    ss << "\\note Applicable only and required for mechanical subcoolers\n";
    ss << "N1;   \\field Outlet Control Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Control Temperature Out for subcooled liquid\n";
    ss << "\\note Applicable only and required for mechanical subcoolers\n";

    IddObjectType objType(IddObjectType::OS_Refrigeration_Subcooler_Mechanical);
    OptionalIddObject oObj = IddObject::load("OS:Refrigeration:Subcooler:Mechanical",
                                             "OpenStudio Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Refrigeration_Subcooler_Mechanical);
  return object;
}

IddObject createOS_Refrigeration_Subcooler_LiquidSuctionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Refrigeration:Subcooler:LiquidSuction,\n";
    ss << "\\min-fields 5\n";
    ss << "A1,   \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,   \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference RefrigerationSubcoolerNames\n";
    ss << "N1,   \\field Liquid Suction Design Subcooling Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Applicable only and required for liquid suction heat exchangers\n";
    ss << "\\note design liquid suction subcooling\n";
    ss << "N2,   \\field Design Liquid Inlet Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Design inlet temperature on liquid side\n";
    ss << "\\note Applicable only and required for liquid suction heat exchangers (LSHX)\n";
    ss << "N3;   \\field Design Vapor Inlet Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Design inlet temperature on vapor side\n";
    ss << "\\note Applicable only and required for liquid suction heat exchangers (LSHX)\n";
    ss << "\\note Design vapor inlet temperature must be less than or equal to\n";
    ss << "\\note      the Liquid inlet design temp\n";

    IddObjectType objType(IddObjectType::OS_Refrigeration_Subcooler_LiquidSuction);
    OptionalIddObject oObj = IddObject::load("OS:Refrigeration:Subcooler:LiquidSuction",
                                             "OpenStudio Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Refrigeration_Subcooler_LiquidSuction);
  return object;
}

IddObject createOS_Refrigeration_SystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Refrigeration:System,\n";
    ss << "\\min-fields 8\n";
    ss << "A1,   \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,   \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference RefrigerationSystemNames\n";
    ss << "A3,   \\field Refrigerated CaseAndWalkInList Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";
    ss << "\\note Enter the name of a Refrigeration:CaseAndWalkInList object.\n";
    ss << "\\note Only cases and walkins served directly by the system should be included in this list.\n";
    ss << "\\note Any cases served indirectly via a secondary chiller should NOT be included in this list\n";
    ss << "A4,   \\field Refrigeration TransferLoad List Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";
    ss << "\\note Enter the name of a Refrigeration:TransferLoadList object.\n";
    ss << "\\note A transfer load is identified as one which moves the load from one system to another.\n";
    ss << "\\note  So if you have more than one such load (including cascade condensers and secondary\n";
    ss << "\\note  loops) served by the same system, use a TransferLoadList object.\n";
    ss << "A5,   \\field Refrigeration Condenser Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list RefrigerationAllTypesCondenserNames\n";
    ss << "A6,   \\field CompressorList Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ModelObjectLists\n";
    ss << "N1,   \\field Minimum Condensing Temperature\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\note Related to the proper operation of the thermal expansion\n";
    ss << "\\note valves and compressors\n";
    ss << "A7,   \\field Refrigeration System Working Fluid Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key R11\n";
    ss << "\\key R12\n";
    ss << "\\key R22\n";
    ss << "\\key R123\n";
    ss << "\\key R134a\n";
    ss << "\\key R404a\n";
    ss << "\\key R407a\n";
    ss << "\\key R410a\n";
    ss << "\\key NH3\n";
    ss << "\\key R507a\n";
    ss << "\\key R744\n";
    ss << "A8,   \\field Suction Temperature Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key FloatSuctionTemperature\n";
    ss << "\\key ConstantSuctionTemperature\n";
    ss << "\\default ConstantSuctionTemperature\n";
    ss << "A9,   \\field Mechanical Subcooler Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationSubcoolerNames\n";
    ss << "\\note Optional Field\n";
    ss << "\\note Recipient of refrigeration capacity, that is receives cool liquid\n";
    ss << "\\note    from another refrigeraiton system to help meet aggregate case loads\n";
    ss << "A10,  \\field Liquid Suction Heat Exchanger Subcooler Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationSubcoolerNames\n";
    ss << "\\note Optional Field\n";
    ss << "\\note Liquid Suction Heat Exchanger Name, or leave blank\n";
    ss << "N2,   \\field Sum UA Suction Piping\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "\\note Use only if you want to include suction piping heat gain in refrigeration load\n";
    ss << "A11,  \\field Suction Piping Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "\\note This will be used to determine the temperature used for distribution piping heat gain\n";
    ss << "\\note  and the pipe heat gains  as cooling credit for the zone.\n";
    ss << "\\note  Required only if Sum UA Distribution Piping >0.0\n";
    ss << "A12,  \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";
    ss << "A13,  \\field Intercooler Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Flash Intercooler\n";
    ss << "\\key Shell-and-Coil Intercooler\n";
    ss << "\\default None\n";
    ss << "N3,   \\field Shell-and-Coil Intercooler Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\default 0.8\n";
    ss << "A14;  \\field High-Stage CompressorList Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";

    IddObjectType objType(IddObjectType::OS_Refrigeration_System);
    OptionalIddObject oObj = IddObject::load("OS:Refrigeration:System",
                                             "OpenStudio Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Refrigeration_System);
  return object;
}

IddObject createOS_Refrigeration_TranscriticalSystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Refrigeration:TranscriticalSystem,\n";
    ss << "\\min-fields 7\n";
    ss << "\\memo Detailed transcritical carbon dioxide (CO2) booster refrigeration systems used in\n";
    ss << "\\memo supermarkets.  The object allows for modeling either a single stage system with\n";
    ss << "\\memo medium-temperature loads or a two stage system with both medium- and low-temperature\n";
    ss << "\\memo loads.\n";
    ss << "A1,   \\field Handle\n";
    ss << "\\type handle\n";
    ss << "A2,   \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference RefrigerationSystemNames\n";
    ss << "A3,   \\field Medium Temperature Refrigerated CaseAndWalkInList Name\n";
    ss << "\\note Enter the name of a Refrigeration:Case or Refrigeration:WalkIn object.\n";
    ss << "\\note If there is more than one refrigerated case or walkin served by this system,\n";
    ss << "\\note enter the name of a Refrigeration:CaseAndWalkInList object.\n";
    ss << "\\note Only medium temperature cases and walkins served directly by the system should\n";
    ss << "\\note be included in this list.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";
    ss << "A4,   \\field Low Temperature Refrigerated CaseAndWalkInList Name\n";
    ss << "\\note Enter the name of a Refrigeration:Case or Refrigeration:WalkIn object.\n";
    ss << "\\note If there is more than one refrigerated case or walkin served by this system,\n";
    ss << "\\note enter the name of a Refrigeration:CaseAndWalkInList object.\n";
    ss << "\\note Only low temperature cases and walkins served directly by the system should be\n";
    ss << "\\note included in this list.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";
    ss << "A5,   \\field Refrigeration Gas Cooler Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationAllTypesGasCoolerNames\n";
    ss << "A6,   \\field High Pressure CompressorList Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";
    ss << "A7,   \\field Low Pressure CompressorList Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";
    ss << "N1,   \\field Receiver Pressure\n";
    ss << "\\type real\n";
    ss << "\\default 4000000\n";
    ss << "\\units Pa\n";
    ss << "N2,   \\field Subcooler Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\default 0.4\n";
    ss << "A8,   \\field Refrigeration System Working Fluid Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key R11\n";
    ss << "\\key R12\n";
    ss << "\\key R22\n";
    ss << "\\key R123\n";
    ss << "\\key R134a\n";
    ss << "\\key R404a\n";
    ss << "\\key R407a\n";
    ss << "\\key R410a\n";
    ss << "\\key NH3\n";
    ss << "\\key R507a\n";
    ss << "\\key R744\n";
    ss << "N3,   \\field Sum UA Suction Piping for Medium Temperature Loads\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "\\units W/K\n";
    ss << "\\note Use only if you want to include suction piping heat gain in refrigeration load\n";
    ss << "A9,   \\field Medium Temperature Suction Piping Zone Name\n";
    ss << "\\note This will be used to determine the temperature used for distribution piping heat\n";
    ss << "\\note gain and the pipe heat gains as cooling credit for the zone.\n";
    ss << "\\note Required only if Sum UA Distribution Piping for Medium Temperature Loads > 0.0\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "N4,   \\field Sum UA Suction Piping for Low Temperature Loads\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "\\units W/K\n";
    ss << "\\note Use only if you want to include suction piping heat gain in refrigeration load\n";
    ss << "A10,  \\field Low Temperature Suction Piping Zone Name\n";
    ss << "\\note This will be used to determine the temperature used for distribution piping heat\n";
    ss << "\\note gain and the pipe heat gains as cooling credit for the zone.\n";
    ss << "\\note Required only if Sum UA Distribution Piping for Low Temperature Loads > 0.0\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A11;  \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::OS_Refrigeration_TranscriticalSystem);
    OptionalIddObject oObj = IddObject::load("OS:Refrigeration:TranscriticalSystem",
                                             "OpenStudio Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Refrigeration_TranscriticalSystem);
  return object;
}

IddObject createOS_Refrigeration_SecondarySystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Refrigeration:SecondarySystem,\n";
    ss << "\\min-fields 15\n";
    ss << "A1,   \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,   \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference AllObjects\n";
    ss << "A3,   \\field Refrigerated CaseAndWalkInList Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";
    ss << "\\note Enter the name of a Refrigeration:Case or Refrigeration:WalkIn object.\n";
    ss << "\\note If there is more than one refrigerated case or walkin served by this secondary system,\n";
    ss << "\\note  enter the name of a Refrigeration:CaseAndWalkInList object.\n";
    ss << "A4,   \\field Circulating Fluid Name\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key PropyleneGlycol\n";
    ss << "\\key EthyleneGlycol\n";
    ss << "\\key R11\n";
    ss << "\\key R12\n";
    ss << "\\key R22\n";
    ss << "\\key R123\n";
    ss << "\\key R134a\n";
    ss << "\\key R404a\n";
    ss << "\\key R407a\n";
    ss << "\\key R410a\n";
    ss << "\\key NH3\n";
    ss << "\\key R507a\n";
    ss << "\\key R744\n";
    ss << "N1,   \\field Glycol Concentration\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 100\n";
    ss << "\\note Only used with either \"PropyleneGlycol\" or \"EthyleneGlycol\"\n";
    ss << "N2,   \\field Evaporator Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units W\n";
    ss << "\\note For \"FluidAlwaysLiquid\", at least one of the two, Evaporator Capacity OR\n";
    ss << "\\note    Evaporator Flow Rate for Secondary Fluid, is required.\n";
    ss << "\\note For \"FluidPhaseChange\", the default capacity is the sum of the rated capacities of the\n";
    ss << "\\note    Cases and Walk-ins served by the secondary loop.\n";
    ss << "N3,   \\field Evaporator Flow Rate for Secondary Fluid\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units M3/s\n";
    ss << "\\note For \"FluidAlwaysLiquid\", at least one of the two, Evaporator Capacity OR\n";
    ss << "\\note    Evaporator Flow Rate for Secondary Fluid, is required.\n";
    ss << "\\note For \"FluidPhaseChange\" loops, this input is not used. (see PhaseChange Circulating\n";
    ss << "\\note Rate)\n";
    ss << "N4,   \\field Evaporator Evaporating Temperature\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\note  This is the evaporating temperature in the heat exchanger\n";
    ss << "\\note      used to chill or condense the secondary loop circulating fluid.\n";
    ss << "\\note      It is NOT the temperature in any cases or walk-ins served by the\n";
    ss << "\\note      secondary loop.\n";
    ss << "N5,   \\field Evaporator Approach Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units deltaC\n";
    ss << "\\note  For \"FluidAlwaysLiquid\", this is the rated difference between the temperature of the\n";
    ss << "\\note      circulating fluid leaving the heat exchanger\n";
    ss << "\\note      and the heat exchanger's rated evaporating temperature.\n";
    ss << "\\note  For \"FluidPhaseChange\", this is the difference between the temperature of the\n";
    ss << "\\note      evaporating and condensing temperatures in the heat exchanger.\n";
    ss << "N6,   \\field Evaporator Range Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note  For \"FluidAlwaysLiquid\", this is the rated difference between the temperature of the\n";
    ss << "\\note      circulating fluid entering the heat exchanger and the temperature of the\n";
    ss << "\\note      circulating fluid leaving the heat exchanger, and is Required.\n";
    ss << "\\note  For \"FluidPhaseChange\", this input is not used.\n";
    ss << "N7,   \\field Number of Pumps in Loop\n";
    ss << "\\type integer\n";
    ss << "\\default 1\n";
    ss << "N8,   \\field Total Pump Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units M3/s\n";
    ss << "\\note For \"FluidAlwaysLiquid\",if not input, Evaporator Flow Rate for Secondary Fluid\n";
    ss << "\\note       will be used.\n";
    ss << "\\note For \"FluidPhaseChange\", if not input, this will be calculated using the\n";
    ss << "\\note       PhaseChange Circulating Rate.\n";
    ss << "N9,   \\field Total Pump Power\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units W\n";
    ss << "\\note Either the Total Pump Power or the Total Pump Head is required.\n";
    ss << "N10,   \\field Total Pump Head\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units Pa\n";
    ss << "\\note Either the Total Pump Power or the Total Pump Head is required.\n";
    ss << "N11,  \\field PhaseChange Circulating Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 1.0\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 2.5\n";
    ss << "\\note This is the total mass flow at the pump divided by the gaseous mass flow\n";
    ss << "\\note      leaving the refrigeration load.\n";
    ss << "A5,   \\field Pump Drive Type\n";
    ss << "\\type choice\n";
    ss << "\\key Constant\n";
    ss << "\\key Variable\n";
    ss << "\\default Constant\n";
    ss << "A6,   \\field Variable Speed Pump Cubic Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\note Variable Speed Pump Curve Name is applicable to variable speed pumps\n";
    ss << "N12,  \\field Pump Motor Heat to Fluid\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.85\n";
    ss << "\\note This is the portion of the pump motor heat added to secondary circulating fluid\n";
    ss << "\\note    and is equal to the motor efficiency for non-hermetic motor\n";
    ss << "\\note Enter 1.0 for a semi-hermetic motor\n";
    ss << "N13,  \\field Sum UA Distribution Piping\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "\\note Use only if you want to include distribution piping heat gain in refrigeration load\n";
    ss << "A7,   \\field Distribution Piping Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "\\note This will be used to determine the temperature used for distribution piping heat gain.\n";
    ss << "\\note  The pipe heat gains are also counted as cooling credit for the zone.\n";
    ss << "\\note  Required only if Sum UA Distribution Piping >0.0\n";
    ss << "N14,  \\field Sum UA Receiver/Separator Shell\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\default 0.0\n";
    ss << "\\note Use only if you want to include Receiver/Separator Shell heat gain in refrigeration load\n";
    ss << "A8,   \\field Receiver/Separator Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "\\note This will be used to determine the temperature used for Receiver/Separator Shell heat gain.\n";
    ss << "\\note  The shell heat gains are also counted as cooling credit for the zone.\n";
    ss << "\\note  Required only if Sum UA Receiver/Separator Shell >0.0\n";
    ss << "N15,  \\field Evaporator Refrigerant Inventory\n";
    ss << "\\type real\n";
    ss << "\\Units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note This value refers to the refrigerant circulating within the primary system providing\n";
    ss << "\\note    cooling to the chiller for the secondary loop, not to the fluid circulating\n";
    ss << "\\note    within the secondary loop itself\n";
    ss << "A9;   \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::OS_Refrigeration_SecondarySystem);
    OptionalIddObject oObj = IddObject::load("OS:Refrigeration:SecondarySystem",
                                             "OpenStudio Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Refrigeration_SecondarySystem);
  return object;
}

IddObject createOS_Refrigeration_WalkInIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Refrigeration:WalkIn,\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 23\n";
    ss << "A1,   \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,   \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference AllObjects\n";
    ss << "A3,   \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defaults to always available if schedule name left blank.\n";
    ss << "N1,   \\field Rated Coil Cooling Capacity\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "N2,   \\field Operating Temperature\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\maximum< 20.0\n";
    ss << "N3,   \\field Rated Cooling Source Temperature\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\minimum -70.0\n";
    ss << "\\maximum 40.\n";
    ss << "\\note If DXEvaporator, use evaporating temperature (saturated suction temperature)\n";
    ss << "\\note If BrineCoil, use Brine entering temperature\n";
    ss << "\\note Used to set minimum suction pressure for DX systems and\n";
    ss << "\\note    minimum brine temp for secondary systems\n";
    ss << "N4,   \\field Rated Total Heating Power\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\note Include total for all anti-sweat, door, drip-pan, and floor heater power\n";
    ss << "\\note Do not include defrost heater power\n";
    ss << "A4,   \\field Heating Power Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Values will be used to multiply the total heating power\n";
    ss << "\\note Values in the schedule should be between 0.0 and 1.0\n";
    ss << "\\note For example, this could be used if display door antisweat heaters\n";
    ss << "\\note are turned off at night\n";
    ss << "\\note Defaults to always on if schedule name left blank.\n";
    ss << "N5,   \\field Rated Cooling Coil Fan Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 375.0\n";
    ss << "N6,   \\field Rated Circulation Fan Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N7,   \\field Rated Total Lighting Power\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\note Enter the total (display + task) installed lighting power.\n";
    ss << "A5,   \\field Lighting Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note The schedule should contain values between 0 and 1\n";
    ss << "\\note Defaults to always on if schedule name left blank.\n";
    ss << "A6,   \\field Defrost Type\n";
    ss << "\\type choice\n";
    ss << "\\key HotFluid\n";
    ss << "\\key Electric\n";
    ss << "\\key None\n";
    ss << "\\key OffCycle\n";
    ss << "\\default Electric\n";
    ss << "\\note HotFluid includes either hot gas defrost for a DX system or\n";
    ss << "\\note   Hot Brine defrost if this walk in is cooled by brine from a secondary chiller\n";
    ss << "A7,   \\field Defrost Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key TimeSchedule\n";
    ss << "\\key TemperatureTermination\n";
    ss << "\\default TimeSchedule\n";
    ss << "A8,   \\field Defrost Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note The schedule values should be 0 (off) or 1 (on)\n";
    ss << "A9,   \\field Defrost Drip-Down Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note The schedule values should be 0 (off) or 1 (on)\n";
    ss << "\\note The start time for each defrost period in this drip-down schedule should coincide with\n";
    ss << "\\note the start time for each defrost period in the defrost schedule (previous input\n";
    ss << "\\note field).The length of each defrost drip-down period must be greater than or equal to the\n";
    ss << "\\note corresponding defrost period specified in the defrost schedule. This extra time\n";
    ss << "\\note allows the melted frost to drip from the coil before refrigeration is restarted.\n";
    ss << "N8,   \\field Defrost Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Needed for all defrost types except none and offcycle\n";
    ss << "N9,   \\field Temperature Termination Defrost Fraction to Ice\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note This is the portion of the defrost energy that is available to melt frost\n";
    ss << "\\note     Needed only for defrost control type TemperatureTermination\n";
    ss << "\\note     defaults to 0.7 for electric defrost and to 0.3 for hot fluid defrost\n";
    ss << "A10,  \\field Restocking Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values should be in units of Watts\n";
    ss << "\\note Leave this field blank if no restocking is to be modeled\n";
    ss << "N10,  \\field Average Refrigerant Charge Inventory\n";
    ss << "\\type real\n";
    ss << "\\Units kg\n";
    ss << "\\default 0.0\n";
    ss << "\\note This value is only used if the Cooling Source Type is DXEvaporator\n";
    ss << "N11,  \\field Insulated Floor Surface Area\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m2\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Floor area of walk-in cooler\n";
    ss << "N12,  \\field Insulated Floor U-Value\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.3154\n";
    ss << "\\note The default value corresponds to R18\n";
    ss << "\\note To convert other Archaic American R-values to U, divide 5.678 by the R-value\n";
    ss << "\\note Some examples:\n";
    ss << "\\note R15 is U 0.3785 W/m2-K\n";
    ss << "\\note R5 is U 1.136 W/m2-K\n";
    ss << "A11,  \\field WalkIn Defrost Cycle Parameters Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationDefrostCycleParameters\n";
    ss << "A12;  \\field WalkIn Zone Boundary\n";
    ss << "\\begin-extensible\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list RefrigerationWalkInZoneBoundaryNames\n";

    IddObjectType objType(IddObjectType::OS_Refrigeration_WalkIn);
    OptionalIddObject oObj = IddObject::load("OS:Refrigeration:WalkIn",
                                             "OpenStudio Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Refrigeration_WalkIn);
  return object;
}

IddObject createOS_Refrigeration_WalkIn_ZoneBoundaryIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Refrigeration:WalkIn:ZoneBoundary,\n";
    ss << "\\min-fields 9\n";
    ss << "A1,   \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,   \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference RefrigerationWalkInZoneBoundaryNames\n";
    ss << "A3,   \\field Zone Name\n";
    ss << "\\note This must be a controlled zone and appear in a ZoneHVAC:EquipmentConnections object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "N1,   \\field Total Insulated Surface Area Facing Zone\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m2\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Area should include walls and ceilings, but not doors\n";
    ss << "N2,   \\field Insulated Surface U-Value Facing Zone\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\default 0.3154\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note The default value corresponds to R18\n";
    ss << "\\note To convert other Archaic American R-values to U, divide 5.678 by the R-value\n";
    ss << "\\note Some examples:\n";
    ss << "\\note R15 is U 0.3785 W/m2-K\n";
    ss << "\\note R5 is U 1.136 W/m2-K\n";
    ss << "N3,   \\field Area of Glass Reach In Doors Facing Zone\n";
    ss << "\\type real\n";
    ss << "\\units m2\n";
    ss << "\\default 0.0\n";
    ss << "N4,   \\field Height of Glass Reach In Doors Facing Zone\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 1.5\n";
    ss << "N5,   \\field Glass Reach In Door U Value Facing Zone\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.136\n";
    ss << "\\note The default value corresponds to R5\n";
    ss << "\\note To convert other Archaic American R-values to U, divide 5.678 by the R-value\n";
    ss << "A4,   \\field Glass Reach In Door Opening Schedule Name Facing Zone\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values should all be between 0.0 and 1.0.\n";
    ss << "\\note For example, if the door is open 30% of the time during working hours,\n";
    ss << "\\note  then the schedule would hold the value 0.3 during working hours\n";
    ss << "\\note  and 0 during other hours\n";
    ss << "\\note  If no schedule name is entered, default is 5% open time during all hours\n";
    ss << "N6,   \\field Area of Stocking Doors Facing Zone\n";
    ss << "\\type real\n";
    ss << "\\units m2\n";
    ss << "\\default 0.0\n";
    ss << "N7,   \\field Height of Stocking Doors Facing Zone\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\default 3.0\n";
    ss << "N8,   \\field Stocking Door U Value Facing Zone\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.3785\n";
    ss << "\\note The default value corresponds to R15\n";
    ss << "\\note To convert other Archaic American R-values to U, divide 5.678 by the R-value\n";
    ss << "\\note Some examples:\n";
    ss << "\\note R5 is U 1.136 W/m2-K\n";
    ss << "\\note R18 is U 0.3154 W/m2-K\n";
    ss << "A5,   \\field Stocking Door Opening Schedule Name Facing Zone\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values should all be between 0.0 and 1.0.\n";
    ss << "\\note For example, if the door is open 30% of the time during working hours,\n";
    ss << "\\note  then the schedule would hold the value 0.3 during working hours\n";
    ss << "\\note  and 0 during other hours\n";
    ss << "\\note  If no schedule name is entered, default is 5% open time during all hours\n";
    ss << "A6;   \\field Stocking Door Opening Protection Type Facing Zone\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key AirCurtain\n";
    ss << "\\key StripCurtain\n";
    ss << "\\default AirCurtain\n";
    ss << "\\note Use StripCurtain for hanging strips or airlock vestibules\n";

    IddObjectType objType(IddObjectType::OS_Refrigeration_WalkIn_ZoneBoundary);
    OptionalIddObject oObj = IddObject::load("OS:Refrigeration:WalkIn:ZoneBoundary",
                                             "OpenStudio Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Refrigeration_WalkIn_ZoneBoundary);
  return object;
}

IddObject createOS_Refrigeration_AirChillerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Refrigeration:AirChiller,\n";
    ss << "\\memo Works in conjunction with a refrigeration chiller set, compressor rack, a\n";
    ss << "\\memo refrigeration system, or a refrigeration secondary system to simulate the performance\n";
    ss << "\\memo of an air chiller, similar to one found in a refrigerated warehouse. Energy use for\n";
    ss << "\\memo fans and heaters is modeled based on inputs for nominal power, schedules, and control\n";
    ss << "\\memo type. The air chiller model accounts for the sensible and latent heat exchange\n";
    ss << "\\memo with the surrounding environment.\n";
    ss << "\\min-fields 24\n";
    ss << "A1,   \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,   \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference AllObjects\n";
    ss << "\\reference RefrigerationAirChillerNames\n";
    ss << "A3,   \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4,   \\field Capacity Rating Type\n";
    ss << "\\note In each case, select the rating option that corresponds to the expected service conditions.\n";
    ss << "\\note For example, U.S. manufacturers quote a separate Unit Load Factor for wet or frosted coils.\n";
    ss << "\\note If the evaporating temperature is less than 0C, input the frosted coil value.\n";
    ss << "\\note Within the European convention, select SC1, 2, 3, 4, or 5 depending upon the expected evaporating temperature.\n";
    ss << "\\type choice\n";
    ss << "\\key UnitLoadFactorSensibleOnly\n";
    ss << "\\key EuropeanSC1Standard\n";
    ss << "\\key EuropeanSC1NominalWet\n";
    ss << "\\key EuropeanSC2Standard\n";
    ss << "\\key EuropeanSC2NominalWet\n";
    ss << "\\key EuropeanSC3Standard\n";
    ss << "\\key EuropeanSC3NominalWet\n";
    ss << "\\key EuropeanSC4Standard\n";
    ss << "\\key EuropeanSC4NominalWet\n";
    ss << "\\key EuropeanSC5Standard\n";
    ss << "\\key EuropeanSC5NominalWet\n";
    ss << "\\default UnitLoadFactorSensibleOnly\n";
    ss << "N1,   \\field Rated Unit Load Factor\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\note The sensible cooling capacity in watts (W/C) at rated conditions.\n";
    ss << "\\note  The value entered for this field must be greater than zero, with no default value.\n";
    ss << "\\note This value is only used if the Capacity Rating Type is UnitLoadFactorSensibleOnly.\n";
    ss << "\\note The value given must be based upon the difference between the chiller inlet and\n";
    ss << "\\note outlet air temperatures, not on the difference between the zone mean temperature\n";
    ss << "\\note and the outlet air temperature\n";
    ss << "N2,   \\field Rated Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\note This value is only used if the Capacity Rating Type is NOT UnitLoadFactorSensibleOnly.\n";
    ss << "\\note For CapacityTotalSpecificConditions, this capacity includes both sensible and latent\n";
    ss << "\\note at the conditions given in the next two fields.\n";
    ss << "\\note Note that the European Standard ratings are sensible only and\n";
    ss << "\\note the European Nominal ratings include latent capacity as well.\n";
    ss << "\\note The value given here must correspond to the capacity rating type given previously\n";
    ss << "N3,   \\field Rated Relative Humidity\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\maximum 100\n";
    ss << "\\default 85\n";
    ss << "\\note This field is ONLY used if the Capacity Rating Type is CapacityTotalSpecificConditions and\n";
    ss << "\\note represents the relative humidity at rated conditions. The default is 85.\n";
    ss << "N4,   \\field Rated Cooling Source Temperature\n";
    ss << "\\note If DXEvaporator, use evaporating temperature (saturated suction temperature)\n";
    ss << "\\note If BrineCoil, use Brine entering temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -70.0\n";
    ss << "\\maximum 40.\n";
    ss << "\\note used to set minimum suction pressure for DX systems and\n";
    ss << "\\note    minimum brine temp for secondary systems\n";
    ss << "N5,   \\field Rated Temperature Difference DT1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 20.\n";
    ss << "\\note The rated difference between the air entering the refrigeration chiller and the\n";
    ss << "\\note cooling source temperature in degree C.\n";
    ss << "N6,   \\field Maximum Temperature Difference Between Inlet Air and Evaporating Temperature\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 25.\n";
    ss << "\\note The maximum difference between the air entering the refrigeration chiller and the\n";
    ss << "\\note cooling source temperature in degree C used to limit capacity during pull-down.\n";
    ss << "\\note defaults to 1.3 times the Rated Temperature Difference DT1\n";
    ss << "N7,   \\field Coil Material Correction Factor\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 1.0\n";
    ss << "\\note This is the manufacturer's correction factor for coil material corresponding to rating\n";
    ss << "N8,   \\field Refrigerant Correction Factor\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 1.0\n";
    ss << "\\note This is the manufacturer's correction factor for refrigerant corresponding to rating\n";
    ss << "A5,   \\field Capacity Correction Curve Type\n";
    ss << "\\note In each case, select the correction curve type that corresponds to the rating type.\n";
    ss << "\\type choice\n";
    ss << "\\key LinearSHR60\n";
    ss << "\\key QuadraticSHR\n";
    ss << "\\key European\n";
    ss << "\\key TabularRHxDT1xTRoom\n";
    ss << "\\default LinearSHR60\n";
    ss << "\\note default LinearSHR60 unless Capcity Rating Type = CapacityTotalSpecificConditions\n";
    ss << "A6,   \\field Capacity Correction Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\note Can also be the name of a \"Table:OneIndependentVariable\" or a \"Table:MultiVariableLookup\"\n";
    ss << "\\note Should be blank for LinearSHR60 correction curve type\n";
    ss << "N9,   \\field SHR60 Correction Factor\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\default 1.48\n";
    ss << "\\maximum 1.67\n";
    ss << "\\note only used when the capacity correction curve type is LinearSHR60\n";
    ss << "N10,  \\field Rated Total Heating Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\required-field\n";
    ss << "\\note Include total for all heater power\n";
    ss << "\\note Do not include defrost heater power\n";
    ss << "A7,   \\field Heating Power Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Values will be used to multiply the total heating power\n";
    ss << "\\note Values in the schedule should be between 0.0 and 1.0\n";
    ss << "\\note Defaults to always on if schedule name left blank.\n";
    ss << "A8,   \\field Fan Speed Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Fixed\n";
    ss << "\\key FixedLinear\n";
    ss << "\\key VariableSpeed\n";
    ss << "\\key TwoSpeed\n";
    ss << "\\default Fixed\n";
    ss << "N11,  \\field Rated Fan Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\default 375.0\n";
    ss << "\\minimum 0.\n";
    ss << "N12,  \\field Rated Air Flow\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "N13,  \\field Minimum Fan Air Flow Ratio\n";
    ss << "\\note Minimum air flow fraction through fan\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.2\n";
    ss << "A9,   \\field Defrost Type\n";
    ss << "\\type choice\n";
    ss << "\\key HotFluid\n";
    ss << "\\key Electric\n";
    ss << "\\key None\n";
    ss << "\\key OffCycle\n";
    ss << "\\default Electric\n";
    ss << "\\note HotFluid includes either hot gas defrost for a DX system or\n";
    ss << "\\note   Hot Brine defrost if this walk in is cooled by brine from a secondary chiller\n";
    ss << "A10,  \\field Defrost Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key TimeSchedule\n";
    ss << "\\key TemperatureTermination\n";
    ss << "\\default TimeSchedule\n";
    ss << "A11,  \\field Defrost Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\required-field\n";
    ss << "\\note The schedule values should be 0 (off) or 1 (on)\n";
    ss << "A12,  \\field Defrost Drip-Down Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note The schedule values should be 0 (off) or 1 (on)\n";
    ss << "\\note The start time for each defrost period in this drip-down schedule should coincide with\n";
    ss << "\\note the start time for each defrost period in the defrost schedule (previous input\n";
    ss << "\\note field).The length of each defrost drip-down period must be greater than or equal to the\n";
    ss << "\\note corresponding defrost period specified in the defrost schedule. This extra time\n";
    ss << "\\note allows the melted frost to drip from the coil before refrigeration is restarted.\n";
    ss << "N14,  \\field Defrost Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note needed for all defrost types except none and offcycle\n";
    ss << "N15,  \\field Temperature Termination Defrost Fraction to Ice\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note This is the portion of the defrost energy that is available to melt frost\n";
    ss << "\\note     Needed only for defrost control type TemperatureTermination\n";
    ss << "\\note     defaults to 0.7 for electric defrost and to 0.3 for hot fluid defrost\n";
    ss << "A13,  \\field Vertical Location\n";
    ss << "\\type choice\n";
    ss << "\\key Ceiling\n";
    ss << "\\key Middle\n";
    ss << "\\key Floor\n";
    ss << "\\default Middle\n";
    ss << "N16;  \\field Average Refrigerant Charge Inventory\n";
    ss << "\\Units kg\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "\\note This value is only used if the Cooling Source Type is DXEvaporator\n";

    IddObjectType objType(IddObjectType::OS_Refrigeration_AirChiller);
    OptionalIddObject oObj = IddObject::load("OS:Refrigeration:AirChiller",
                                             "OpenStudio Refrigeration",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Refrigeration_AirChiller);
  return object;
}

IddObject createOS_AirConditioner_VariableRefrigerantFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirConditioner:VariableRefrigerantFlow,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field Rated Total Cooling Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "N2 , \\field Rated Cooling COP\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field Minimum Outdoor Temperature in Cooling Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "N4 , \\field Maximum Outdoor Temperature in Cooling Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "A4 , \\field Cooling Capacity Ratio Modifier Function of Low Temperature Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A5 , \\field Cooling Capacity Ratio Boundary Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A6 , \\field Cooling Capacity Ratio Modifier Function of High Temperature Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A7 , \\field Cooling Energy Input Ratio Modifier Function of Low Temperature Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A8 , \\field Cooling Energy Input Ratio Boundary Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A9 , \\field Cooling Energy Input Ratio Modifier Function of High Temperature Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A10 , \\field Cooling Energy Input Ratio Modifier Function of Low Part-Load Ratio Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A11, \\field Cooling Energy Input Ratio Modifier Function of High Part-Load Ratio Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A12, \\field Cooling Combination Ratio Correction Factor Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A13, \\field Cooling Part-Load Fraction Correlation Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "N5 , \\field Rated Total Heating Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "N6 , \\field Rated Total Heating Capacity Sizing Ratio\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum 1.0\n";
    ss << "\\required-field\n";
    ss << "N7 , \\field Rated Heating COP\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\required-field\n";
    ss << "N8 , \\field Minimum Outdoor Temperature in Heating Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "N9 , \\field Maximum Outdoor Temperature in Heating Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "A14, \\field Heating Capacity Ratio Modifier Function of Low Temperature Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A15, \\field Heating Capacity Ratio Boundary Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A16, \\field Heating Capacity Ratio Modifier Function of High Temperature Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A17, \\field Heating Energy Input Ratio Modifier Function of Low Temperature Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A18, \\field Heating Energy Input Ratio Boundary Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A19, \\field Heating Energy Input Ratio Modifier Function of High Temperature Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A20, \\field Heating Performance Curve Outdoor Temperature Type\n";
    ss << "\\type choice\n";
    ss << "\\key DryBulbTemperature\n";
    ss << "\\key WetBulbTemperature\n";
    ss << "\\required-field\n";
    ss << "A21, \\field Heating Energy Input Ratio Modifier Function of Low Part-Load Ratio Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A22, \\field Heating Energy Input Ratio Modifier Function of High Part-Load Ratio Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A23, \\field Heating Combination Ratio Correction Factor Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A24, \\field Heating Part-Load Fraction Correlation Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "N10, \\field Minimum Heat Pump Part-Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "A25, \\field Zone Name for Master Thermostat Location\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A26, \\field Master Thermostat Priority Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key LoadPriority\n";
    ss << "\\key ZonePriority\n";
    ss << "\\key ThermostatOffsetPriority\n";
    ss << "\\key MasterThermostatPriority\n";
    ss << "\\key Scheduled\n";
    ss << "\\required-field\n";
    ss << "A27, \\field Thermostat Priority Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A28, \\field Zone Terminal Unit List\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";
    ss << "A29, \\field Heat Pump Waste Heat Recovery\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "N11, \\field Equivalent Piping Length used for Piping Correction Factor in Cooling Mode\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\required-field\n";
    ss << "N12, \\field Vertical Height used for Piping Correction Factor\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\required-field\n";
    ss << "A30, \\field Piping Correction Factor for Length in Cooling Mode Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "N13, \\field Piping Correction Factor for Height in Cooling Mode Coefficient\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N14, \\field Equivalent Piping Length used for Piping Correction Factor in Heating Mode\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\required-field\n";
    ss << "A31, \\field Piping Correction Factor for Length in Heating Mode Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "N15, \\field Piping Correction Factor for Height in Heating Mode Coefficient\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N16, \\field Crankcase Heater Power per Compressor\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\required-field\n";
    ss << "N17, \\field Number of Compressors\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "N18, \\field Ratio of Compressor Size to Total Compressor Capacity\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N19, \\field Maximum Outdoor Dry-bulb Temperature for Crankcase Heater\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "A32, \\field Defrost Strategy\n";
    ss << "\\type choice\n";
    ss << "\\key ReverseCycle\n";
    ss << "\\key Resistive\n";
    ss << "\\required-field\n";
    ss << "A33, \\field Defrost Control\n";
    ss << "\\type choice\n";
    ss << "\\key Timed\n";
    ss << "\\key OnDemand\n";
    ss << "\\required-field\n";
    ss << "A34, \\field Defrost Energy Input Ratio Modifier Function of Temperature Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "N20, \\field Defrost Time Period Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "N21, \\field Resistive Defrost Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\required-field\n";
    ss << "N22, \\field Maximum Outdoor Dry-bulb Temperature for Defrost Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "A35, \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "! \\key EvaporativelyCooled\n";
    ss << "\\key WaterCooled\n";
    ss << "\\required-field\n";
    ss << "A36, \\field Condenser Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A37, \\field Condenser Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N23, \\field Water Condenser Volume Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "N24, \\field Evaporative Condenser Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\required-field\n";
    ss << "N25, \\field Evaporative Condenser Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "N26, \\field Evaporative Condenser Pump Rated Power Consumption\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "A38, \\field Supply Water Storage Tank\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "N27, \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "N28, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\required-field\n";
    ss << "A39, \\field Basin Heater Operating Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A40, \\field Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\required-field\n";
    ss << "N29, \\field Minimum Outdoor Temperature in Heat Recovery Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "N30, \\field Maximum Outdoor Temperature in Heat Recovery Mode\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "A41, \\field Heat Recovery Cooling Capacity Modifier Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "N31, \\field Initial Heat Recovery Cooling Capacity Fraction\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N32, \\field Heat Recovery Cooling Capacity Time Constant\n";
    ss << "\\type real\n";
    ss << "\\units hr\n";
    ss << "\\required-field\n";
    ss << "A42, \\field Heat Recovery Cooling Energy Modifier Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "N33, \\field Initial Heat Recovery Cooling Energy Fraction\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N34, \\field Heat Recovery Cooling Energy Time Constant\n";
    ss << "\\type real\n";
    ss << "\\units hr\n";
    ss << "\\required-field\n";
    ss << "A43, \\field Heat Recovery Heating Capacity Modifier Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "N35, \\field Initial Heat Recovery Heating Capacity Fraction\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N36, \\field Heat Recovery Heating Capacity Time Constant\n";
    ss << "\\type real\n";
    ss << "\\units hr\n";
    ss << "\\required-field\n";
    ss << "A44, \\field Heat Recovery Heating Energy Modifier Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "N37, \\field Initial Heat Recovery Heating Energy Fraction\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N38; \\field Heat Recovery Heating Energy Time Constant\n";
    ss << "\\type real\n";
    ss << "\\units hr\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_AirConditioner_VariableRefrigerantFlow);
    OptionalIddObject oObj = IddObject::load("OS:AirConditioner:VariableRefrigerantFlow",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirConditioner_VariableRefrigerantFlow);
  return object;
}

IddObject createOS_AirLoopHVACIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirLoopHVAC,\n";
    ss << "\\memo Defines a central forced air system\n";
    ss << "\\min-fields 12\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference AirPrimaryLoops\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Controller List Name\n";
    ss << "\\note Enter the name of an AirLoopHVAC:ControllerList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ControllerLists\n";
    ss << "A4, \\field Availability Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5, \\field Availability Manager\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagers\n";
    ss << "N1, \\field Design Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0\n";
    ss << "A6, \\field Branch List Name\n";
    ss << "\\note Name of a BranchList containing all the branches in this air loop\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list BranchLists\n";
    ss << "A7, \\field Connector List Name\n";
    ss << "\\note Name of a ConnectorList containing all the splitters and mixers in the loop\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectorLists\n";
    ss << "A8, \\field Supply Side Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A9, \\field Demand Side Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A10, \\field Demand Side Inlet Node A\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A11, \\field Supply Side Outlet Node A\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A12, \\field Demand Side Inlet Node B\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A13, \\field Supply Side Outlet Node B\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A14; \\field Return Air Bypass Flow Temperature Setpoint Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_AirLoopHVAC);
    OptionalIddObject oObj = IddObject::load("OS:AirLoopHVAC",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirLoopHVAC);
  return object;
}

IddObject createOS_AirLoopHVAC_ControllerListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirLoopHVAC:ControllerList,\n";
    ss << "\\memo List controllers in order of control sequence\n";
    ss << "\\extensible:2\n";
    ss << "\\min-fields 4\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ControllerLists\n";
    ss << "A3, \\field Controller Object Type\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\key Controller:WaterCoil\n";
    ss << "\\key Controller:OutdoorAir\n";
    ss << "A4; \\field Controller Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list AirLoopControllers\n";

    IddObjectType objType(IddObjectType::OS_AirLoopHVAC_ControllerList);
    OptionalIddObject oObj = IddObject::load("OS:AirLoopHVAC:ControllerList",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirLoopHVAC_ControllerList);
  return object;
}

IddObject createOS_AirLoopHVAC_OutdoorAirSystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirLoopHVAC:OutdoorAirSystem,\n";
    ss << "\\min-fields 4\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Controller Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list OutdoorAirController\n";
    ss << "A4, \\field Outdoor Air Equipment List Name\n";
    ss << "\\note Enter the name of an AirLoopHVAC:OutdoorAirSystem:EquipmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list AirLoopOAEquipmentLists\n";
    ss << "A5, \\field Availability Manager List Name\n";
    ss << "\\note Enter the name of an AvailabilityManagerAssignmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";
    ss << "A6, \\field Mixed Air Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A7, \\field Outdoor Air Stream Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A8, \\field Relief Air Stream Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A9; \\field Return Air Stream Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";

    IddObjectType objType(IddObjectType::OS_AirLoopHVAC_OutdoorAirSystem);
    OptionalIddObject oObj = IddObject::load("OS:AirLoopHVAC:OutdoorAirSystem",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirLoopHVAC_OutdoorAirSystem);
  return object;
}

IddObject createOS_AirLoopHVAC_ReturnPlenumIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirLoopHVAC:ReturnPlenum,\n";
    ss << "\\extensible:1 Just duplicate last field and comments (changing numbering, please)\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ReturnPathComponentNames\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field ThermalZone\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A4, \\field Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Induced Air Outlet Port List\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PortLists\n";
    ss << "\\required-field\n";
    ss << "A6; \\field Inlet 1 Node\n";
    ss << "\\begin-extensible\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";

    IddObjectType objType(IddObjectType::OS_AirLoopHVAC_ReturnPlenum);
    OptionalIddObject oObj = IddObject::load("OS:AirLoopHVAC:ReturnPlenum",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirLoopHVAC_ReturnPlenum);
  return object;
}

IddObject createOS_AirLoopHVAC_SupplyPlenumIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirLoopHVAC:SupplyPlenum,\n";
    ss << "\\extensible:1 Just duplicate last field and comments (changing numbering, please)\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SupplyPathComponentNames\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Thermal Zone\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A4, \\field Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5; \\field Outlet 1 Node\n";
    ss << "\\begin-extensible\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";

    IddObjectType objType(IddObjectType::OS_AirLoopHVAC_SupplyPlenum);
    OptionalIddObject oObj = IddObject::load("OS:AirLoopHVAC:SupplyPlenum",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirLoopHVAC_SupplyPlenum);
  return object;
}

IddObject createOS_AirLoopHVAC_UnitaryHeatPump_AirToAir_MultiSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirLoopHVAC:UnitaryHeatPump:AirToAir:MultiSpeed,\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,  \\field Availability Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4,  \\field Air Inlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5,  \\field Air Outlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6,  \\field Controlling Zone or Thermostat Location\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A7,  \\field Supply Air Fan\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOff\n";
    ss << "A8,  \\field Supply Air Fan Placement\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "A9 , \\field Supply Air Fan Operating Mode Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A10, \\field Heating Coil\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilsElectricMultiStage\n";
    ss << "\\object-list HeatingCoilsGasMultiStage\n";
    ss << "\\object-list HeatingCoilsDXMultiSpeed\n";
    ss << "N1 , \\field Minimum Outdoor Dry-Bulb Temperature for Compressor Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum -20.0\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "A11, \\field Cooling Coil\n";
    ss << "\\required-field\n";
    ss << "\\note Needs to match in the DX Cooling Coil object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsDXMultiSpeed\n";
    ss << "A12, \\field Supplemental Heating Coil\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N2 , \\field Maximum Supply Air Temperature from Supplemental Heater\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field Maximum Outdoor Dry-Bulb Temperature for Supplemental Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\maximum 21.0\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "N4 , \\field Auxiliary On-Cycle Electric Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N5 , \\field Auxiliary Off-Cycle Electric Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N6 , \\field Design Heat Recovery Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\note If non-zero, then the heat recovery inlet and outlet node names must be entered.\n";
    ss << "\\note Used for heat recovery to an EnergyPlus plant loop.\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "N7,  \\field Maximum Temperature for Heat Recovery\n";
    ss << "\\units C\n";
    ss << "\\maximum 100.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "A13, \\field Heat Recovery Water Inlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A14, \\field Heat Recovery Water Outlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N8 , \\field Supply Air Flow Rate When No Cooling or Heating is Needed\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "N9, \\field Number of Speeds for Heating\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 4\n";
    ss << "N10, \\field Number of Speeds for Cooling\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 2\n";
    ss << "\\maximum 4\n";
    ss << "N11, \\field Speed 1 Supply Air Flow Rate During Heating Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0\n";
    ss << "N12, \\field Speed 2 Supply Air Flow Rate During Heating Operation\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "N13, \\field Speed 3 Supply Air Flow Rate During Heating Operation\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "N14, \\field Speed 4 Supply Air Flow Rate During Heating Operation\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "N15, \\field Speed 1 Supply Air Flow Rate During Cooling Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "N16, \\field Speed 2 Supply Air Flow Rate During Cooling Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "N17, \\field Speed 3 Supply Air Flow Rate During Cooling Operation\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "N18; \\field Speed 4 Supply Air Flow Rate During Cooling Operation\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_AirLoopHVAC_UnitaryHeatPump_AirToAir_MultiSpeed);
    OptionalIddObject oObj = IddObject::load("OS:AirLoopHVAC:UnitaryHeatPump:AirToAir:MultiSpeed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirLoopHVAC_UnitaryHeatPump_AirToAir_MultiSpeed);
  return object;
}

IddObject createOS_AirLoopHVAC_UnitaryCoolOnlyIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirLoopHVAC:UnitaryCoolOnly,\n";
    ss << "\\min-fields 8\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4, \\field DX Cooling Coil System Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field DX Cooling Coil System Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6, \\field DX Cooling Coil System Sensor Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A7, \\field Cooling Coil Object Type\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Coil:Cooling:DX:SingleSpeed\n";
    ss << "\\key CoilSystem:Cooling:DX:HeatExchangerAssisted\n";
    ss << "\\key Coil:Cooling:DX:TwoSpeed\n";
    ss << "\\key Coil:Cooling:DX:TwoStageWithHumidityControlMode\n";
    ss << "A8, \\field Cooling Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list CoolingCoilsDX\n";
    ss << "A9, \\field Dehumidification Control Type\n";
    ss << "\\note None = meet sensible load only\n";
    ss << "\\note Multimode = activate enhanced dehumidification mode\n";
    ss << "\\note as needed and meet sensible load. If no sensible load\n";
    ss << "\\note exists, and Run on Latent Load = Yes, and a latent\n";
    ss << "\\note load exists, the unit will operate to meet the latent load.\n";
    ss << "\\note Valid only with Coil:Cooling:DX:TwoStageWithHumidityControlMode\n";
    ss << "\\note or CoilSystem:Cooling:DX:HeatExchangerAssisted.\n";
    ss << "\\note CoolReheat = cool beyond the dry bulb setpoint.\n";
    ss << "\\note as required to meet the humidity setpoint.\n";
    ss << "\\note Valid for all coil types.\n";
    ss << "\\note For all dehumidification controls, the max\n";
    ss << "\\note humidity setpoint on the Sensor Node is used.\n";
    ss << "\\note SetpointManager:SingleZone:Humidity:Maximum,\n";
    ss << "\\note SetpointManager:MultiZone:Humidity:Maximum, or\n";
    ss << "\\note SetpointManager:MultiZone:MaximumHumidity:Average, and\n";
    ss << "\\note SetpointManager:OutdoorAirPretreat (optional) objects.\n";
    ss << "\\type choice\n";
    ss << "\\default None\n";
    ss << "\\key None\n";
    ss << "\\key Multimode\n";
    ss << "\\key CoolReheat\n";
    ss << "A10, \\field Run on Sensible Load\n";
    ss << "\\note If Yes, unit will run if there is a sensible load.\n";
    ss << "\\note If No, unit will not run if there is only a sensible load.\n";
    ss << "\\note Dehumidification controls will be active if specified.\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A11; \\field Run on Latent Load\n";
    ss << "\\note If Yes, unit will run if there is a latent load.\n";
    ss << "\\note even if there is no sensible load.\n";
    ss << "\\note If No, unit will not run only if there is a latent load.\n";
    ss << "\\note Dehumidification controls will be active if specified.\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";

    IddObjectType objType(IddObjectType::OS_AirLoopHVAC_UnitaryCoolOnly);
    OptionalIddObject oObj = IddObject::load("OS:AirLoopHVAC:UnitaryCoolOnly",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirLoopHVAC_UnitaryCoolOnly);
  return object;
}

IddObject createOS_AirLoopHVAC_UnitaryHeatPump_AirToAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirLoopHVAC:UnitaryHeatPump:AirToAir,\n";
    ss << "\\min-fields 17\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\note A schedule value greater than zero (usually 1 is used) indicates that the unit is\n";
    ss << "\\note available to operate as needed. A value less than or equal to zero (usually zero\n";
    ss << "\\note is used) denotes that the unit must be off.\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4, \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1, \\field Supply Air Flow Rate During Cooling Operation\n";
    ss << "\\note Must be less than or equal to the fan's maximum flow rate.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "N2, \\field Supply Air Flow Rate During Heating Operation\n";
    ss << "\\note Must be less than or equal to the fan's maximum flow rate.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "N3, \\field Supply Air Flow Rate When No Cooling or Heating is Needed\n";
    ss << "\\note Must be less than or equal to the fan's maximum flow rate.\n";
    ss << "\\note Only used when fan operating mode is continuous (disregarded for cycling fan mode).\n";
    ss << "\\note This air flow rate is used when no heating or cooling is required (i.e., the DX coil\n";
    ss << "\\note compressor and supplemental heating coil are off). If this field is left blank or zero,\n";
    ss << "\\note the supply air flow rate from the previous on cycle (either cooling or heating) is used.\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "A6, \\field Controlling Zone or Thermostat Location\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A7, \\field Supply Air Fan Name\n";
    ss << "\\note Needs to match in the fan object\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list FansCVandOnOff\n";
    ss << "A8, \\field Heating Coil Name\n";
    ss << "\\note Needs to match in the DX heating coil object\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list HeatingCoilsDXSingleSpeed\n";
    ss << "A9, \\field Cooling Coil Name\n";
    ss << "\\note Needs to match in the DX cooling coil object\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list CoolingCoilsDXSingleSpeed\n";
    ss << "A10, \\field Supplemental Heating Coil Name\n";
    ss << "\\note Needs to match in the supplemental heating coil object\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list HeatingCoilsGasElec\n";
    ss << "N4, \\field Maximum Supply Air Temperature from Supplemental Heater\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units C\n";
    ss << "N5, \\field Maximum Outdoor Dry-Bulb Temperature for Supplemental Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\maximum 21\n";
    ss << "\\default 21.0\n";
    ss << "A11, \\field Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\default BlowThrough\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "A12, \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\note A fan operating mode schedule value of 0 indicates cycling fan mode (supply air\n";
    ss << "\\note fan cycles on and off in tandem with the cooling or heating coil).\n";
    ss << "\\note Any other schedule value indicates continuous fan mode (supply air fan operates\n";
    ss << "\\note continuously regardless of cooling or heating coil operation).\n";
    ss << "\\note Leaving this schedule name blank will default to cycling fan mode for the\n";
    ss << "\\note entire simulation period.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A13; \\field Dehumidification Control Type\n";
    ss << "\\note None = meet sensible load only\n";
    ss << "\\note Multimode = activate enhanced dehumidification mode\n";
    ss << "\\note as needed and meet sensible load.  Valid only with\n";
    ss << "\\note cooling coil type CoilSystem:Cooling:DX:HeatExchangerAssisted.\n";
    ss << "\\note This control mode allows the heat exchanger to be turned\n";
    ss << "\\note on and off based on the zone dehumidification requirements.\n";
    ss << "\\note A ZoneControl:Humidistat object is also required.\n";
    ss << "\\note CoolReheat = cool beyond the dry bulb setpoint.\n";
    ss << "\\note as required to meet the humidity setpoint.  Valid with all\n";
    ss << "\\note cooling coil types. When a heat exchanger assisted Cooling\n";
    ss << "\\note coil is used, the heat exchanger is locked on at all times.\n";
    ss << "\\note A ZoneControl:Humidistat object is also required.\n";
    ss << "\\type choice\n";
    ss << "\\default None\n";
    ss << "\\key None\n";
    ss << "\\key Multimode\n";
    ss << "\\key CoolReheat\n";

    IddObjectType objType(IddObjectType::OS_AirLoopHVAC_UnitaryHeatPump_AirToAir);
    OptionalIddObject oObj = IddObject::load("OS:AirLoopHVAC:UnitaryHeatPump:AirToAir",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirLoopHVAC_UnitaryHeatPump_AirToAir);
  return object;
}

IddObject createOS_AirLoopHVAC_UnitaryHeatCool_VAVChangeoverBypassIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirLoopHVAC:UnitaryHeatCool:VAVChangeoverBypass,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field System Air Flow Rate During Cooling Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\required-field\n";
    ss << "N2 , \\field System Air Flow Rate During Heating Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field System Air Flow Rate When No Cooling or Heating is Needed\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "N4 , \\field Outdoor Air Flow Rate During Cooling Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "N5 , \\field Outdoor Air Flow Rate During Heating Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "N6 , \\field Outdoor Air Flow Rate When No Cooling or Heating is Needed\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "A4 , \\field Outdoor Air Flow Rate Multiplier Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5 , \\field Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6 , \\field Bypass Duct Mixer Node\n";
    ss << "A7 , \\field Bypass Duct Splitter Node\n";
    ss << "A8 , \\field Air Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A9 , \\field Outdoor Air Mixer\n";
    ss << "A10, \\field Supply Air Fan\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOff\n";
    ss << "\\required-field\n";
    ss << "A11, \\field Supply Air Fan Placement\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\required-field\n";
    ss << "A12, \\field Supply Air Fan Operating Mode Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A13, \\field Cooling Coil\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsDXMultiModeOrSingleSpeed\n";
    ss << "\\required-field\n";
    ss << "A14, \\field Heating Coil\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "\\required-field\n";
    ss << "A15, \\field Priority Control Mode\n";
    ss << "\\type choice\n";
    ss << "\\key CoolingPriority\n";
    ss << "\\key HeatingPriority\n";
    ss << "\\key ZonePriority\n";
    ss << "\\required-field\n";
    ss << "N7 , \\field Minimum Outlet Air Temperature During Cooling Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\required-field\n";
    ss << "N8 , \\field Maximum Outlet Air Temperature During Heating Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\required-field\n";
    ss << "A16; \\field Dehumidification Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Multimode\n";
    ss << "\\key CoolReheat\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_AirLoopHVAC_UnitaryHeatCool_VAVChangeoverBypass);
    OptionalIddObject oObj = IddObject::load("OS:AirLoopHVAC:UnitaryHeatCool:VAVChangeoverBypass",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirLoopHVAC_UnitaryHeatCool_VAVChangeoverBypass);
  return object;
}

IddObject createOS_AirLoopHVAC_UnitarySystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirLoopHVAC:UnitarySystem,\n";
    ss << "\\memo AirloopHVAC:UnitarySystem is a generic HVAC system type that allows any\n";
    ss << "\\memo configuration of coils and/or fan. This object is a replacement of other\n";
    ss << "\\memo AirloopHVAC objects. This object can be used in outdoor air systems,\n";
    ss << "\\memo outdoor air units, air loops, and as zone equipment if desired.\n";
    ss << "\\min-fields 13\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "\\note Unique name for the Unitary System.\n";
    ss << "A3,  \\field Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Load\n";
    ss << "\\key SetPoint\n";
    ss << "\\default Load\n";
    ss << "\\note Load control requires a Controlling Zone name.\n";
    ss << "\\note SetPoint control requires set points at coil outlet node.\n";
    ss << "A4,  \\field Controlling Zone or Thermostat Location\n";
    ss << "\\note Used only for Load based control\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "\\note Zone name where thermostat is located. Required when Control Type = Load.\n";
    ss << "A5,  \\field Dehumidification Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Multimode\n";
    ss << "\\key CoolReheat\n";
    ss << "\\default None\n";
    ss << "\\note None = meet sensible load only\n";
    ss << "\\note Multimode = activate enhanced dehumidification mode\n";
    ss << "\\note as needed and meet sensible load.  Valid only with\n";
    ss << "\\note cooling coil type CoilSystem:Cooling:DX:HeatExchangerAssisted.\n";
    ss << "\\note This control mode allows the heat exchanger to be turned\n";
    ss << "\\note on and off based on the zone dehumidification requirements.\n";
    ss << "\\note A ZoneControl:Humidistat object is also required.\n";
    ss << "\\note CoolReheat = cool beyond the dry bulb setpoint.\n";
    ss << "\\note as required to meet the humidity setpoint.  Valid with all\n";
    ss << "\\note cooling coil types. When a heat exchanger assisted cooling\n";
    ss << "\\note coil is used, the heat exchanger is locked on at all times.\n";
    ss << "\\note A ZoneControl:Humidistat object is also required.\n";
    ss << "A6,  \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\note A schedule value greater than zero (usually 1 is used) indicates that the unit is\n";
    ss << "\\note available to operate as needed. A value less than or equal to zero (usually zero\n";
    ss << "\\note is used) denotes that the unit must be off.\n";
    ss << "A7,  \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note Enter the node name used as the inlet air node for the unitary system.\n";
    ss << "A8,  \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note Enter the node name used as the outlet air node for the unitary system.\n";
    ss << "A9, \\field Supply Fan Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOffandVAV\n";
    ss << "\\note Enter the name of the supply air fan if included in the unitary system.\n";
    ss << "A10, \\field Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\note Enter the type of supply air fan if included in the unitary system.\n";
    ss << "A11, \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note A fan operating mode schedule value of 0 indicates cycling fan mode (supply air\n";
    ss << "\\note fan cycles on and off in tandem with the cooling or heating coil).\n";
    ss << "\\note Any other schedule value indicates continuous fan mode (supply air fan operates\n";
    ss << "\\note continuously regardless of cooling or heating coil operation). Provide a schedule\n";
    ss << "\\note with non-zero values when high humidity control is specified.\n";
    ss << "\\note Leaving this schedule name blank will default to constant fan mode for the\n";
    ss << "\\note entire simulation period.\n";
    ss << "\\note This field is not used when set point based control is used where a set point\n";
    ss << "\\note controls the coil (i.e., model assumes constant fan mode operation).\n";
    ss << "A12, \\field Heating Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilsDX\n";
    ss << "\\object-list HeatingCoilsDXMultiSpeed\n";
    ss << "\\object-list HeatingCoilsDXVariableSpeed\n";
    ss << "\\object-list HeatingCoilsWaterToAirHP\n";
    ss << "\\object-list HeatingCoilsWaterToAirVSHP\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "\\object-list HeatingCoilsElectricMultiStage\n";
    ss << "\\object-list HeatingCoilsGasMultiStage\n";
    ss << "\\object-list HeatingCoilsDesuperheater\n";
    ss << "\\note Enter the name of the heating coil if included in the unitary system.\n";
    ss << "N1,  \\field DX Heating Coil Sizing Ratio\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Used to adjust heat pump heating capacity with respect to DX cooling capacity\n";
    ss << "\\note used only for heat pump configurations (i.e., a cooling and DX heating coil is used).\n";
    ss << "A13, \\field Cooling Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsDX\n";
    ss << "\\object-list CoolingCoilsDXMultiSpeed\n";
    ss << "\\object-list CoolingCoilsDXVariableSpeed\n";
    ss << "\\object-list CoolingCoilsWaterToAirHP\n";
    ss << "\\object-list CoolingCoilsWaterToAirVSHP\n";
    ss << "\\object-list CoolingCoilsWater\n";
    ss << "\\note Enter the name of the cooling coil if included in the unitary system.\n";
    ss << "A14, \\field Use DOAS DX Cooling Coil\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "\\note If Yes, the DX cooling coil runs as 100% DOAS DX coil.\n";
    ss << "\\note If No, the DX cooling coil runs as a regular DX coil.\n";
    ss << "\\note If left blank the default is regular dx coil.\n";
    ss << "N2,  \\field DOAS DX Cooling Coil Leaving Minimum Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 7.2\n";
    ss << "\\default 2.0\n";
    ss << "\\note DX cooling coil leaving minimum air temperature defines the minimum DOAS DX cooling coil\n";
    ss << "\\note leaving air temperature that should be maintained to avoid frost formation. This input\n";
    ss << "\\note field is optional and only used along with the input field above.\n";
    ss << "A15, \\field Latent Load Control\n";
    ss << "\\type choice\n";
    ss << "\\key SensibleOnlyLoadControl\n";
    ss << "\\key LatentOnlyLoadControl\n";
    ss << "\\key LatentWithSensibleLoadControl\n";
    ss << "\\key LatentOrSensibleLoadControl\n";
    ss << "\\Default SensibleOnlyLoadControl\n";
    ss << "\\note SensibleOnlyLoadControl is selected when thermostat control is used.\n";
    ss << "\\note LatentOnlyLoadControl is selected when humidistat control is used.\n";
    ss << "\\note LatentWithSensibleLoadControl is selected when thermostat control is used and\n";
    ss << "\\note dehumidification is required only when a sensible load exists.\n";
    ss << "\\note LatentOrSensibleLoadControl is selected when thermostat control is used and\n";
    ss << "\\note dehumidification is required any time the humidistat set point is exceeded.\n";
    ss << "A16, \\field Supplemental Heating Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "\\object-list HeatingCoilsDesuperheater\n";
    ss << "\\note Enter the name of the supplemental heating coil if included in the unitary system.\n";
    ss << "\\note Only required if dehumidification control type is \"CoolReheat\".\n";
    ss << "A17, \\field Supply Air Flow Rate Method During Cooling Operation\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key SupplyAirFlowRate\n";
    ss << "\\key FlowPerFloorArea\n";
    ss << "\\key FractionOfAutosizedCoolingValue\n";
    ss << "\\key FlowPerCoolingCapacity\n";
    ss << "\\note Enter the method used to determine the cooling supply air volume flow rate.\n";
    ss << "\\note None is used when a cooling coil is not included in the unitary system or this field may be blank.\n";
    ss << "\\note SupplyAirFlowRate is selected when the magnitude of the supply air volume is used.\n";
    ss << "\\note FlowPerFloorArea is selected when the supply air volume flow rate is based on total floor area\n";
    ss << "\\note served by the unitary system.\n";
    ss << "\\note FractionOfAutosizedCoolingValue is selected when the supply air volume is a fraction of the\n";
    ss << "\\note value determined by the simulation.\n";
    ss << "\\note FlowPerCoolingCapacity is selected when the supply air volume is a fraction of the cooling\n";
    ss << "\\note capacity as determined by the simulation.\n";
    ss << "N3,  \\field Supply Air Flow Rate During Cooling Operation\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Enter the magnitude of the supply air volume flow rate during cooling operation.\n";
    ss << "\\note Required field when Supply air Flow Rate Method During Cooling Operation is SupplyAirFlowRate.\n";
    ss << "\\note This field may be blank if a cooling coil is not included in the unitary system.\n";
    ss << "N4,  \\field Supply Air Flow Rate Per Floor Area During Cooling Operation\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate per total floor area fraction.\n";
    ss << "\\note Required field when Supply air Flow Rate Method During Cooling Operation is FlowPerFloorArea.\n";
    ss << "\\note This field may be blank if a cooling coil is not included in the unitary system.\n";
    ss << "N5,  \\field Fraction of Autosized Design Cooling Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the cooling supply air flow rate.\n";
    ss << "\\note Required field when Supply air Flow Rate Method During Cooling Operation is FractionOfAutosizedCoolingValue.\n";
    ss << "\\note This field may be blank if a cooling coil is not included in the unitary system.\n";
    ss << "N6,  \\field Design Supply Air Flow Rate Per Unit of Capacity During Cooling Operation\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the cooling capacity.\n";
    ss << "\\note Required field when Supply air Flow Rate Method During Cooling Operation is FlowPerCoolingCapacity.\n";
    ss << "\\note This field may be blank if a cooling coil is not included in the unitary system.\n";
    ss << "A18, \\field Supply Air Flow Rate Method During Heating Operation\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key SupplyAirFlowRate\n";
    ss << "\\key FlowPerFloorArea\n";
    ss << "\\key FractionOfAutosizedHeatingValue\n";
    ss << "\\key FlowPerHeatingCapacity\n";
    ss << "\\note Enter the method used to determine the heating supply air volume flow rate.\n";
    ss << "\\note None is used when a heating coil is not included in the unitary system or this field may be blank.\n";
    ss << "\\note SupplyAirFlowRate is selected when the magnitude of the supply air volume is used.\n";
    ss << "\\note FlowPerFloorArea is selected when the supply air volume flow rate is based on total floor area\n";
    ss << "\\note served by the unitary system.\n";
    ss << "\\note FractionOfAutosizedHeatingValue is selected when the supply air volume is a fraction of the\n";
    ss << "\\note value determined by the simulation.\n";
    ss << "\\note FlowPerHeatingCapacity is selected when the supply air volume is a fraction of the heating\n";
    ss << "\\note capacity as determined by the simulation.\n";
    ss << "N7,  \\field Supply Air Flow Rate During Heating Operation\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Enter the magnitude of the supply air volume flow rate during heating operation.\n";
    ss << "\\note Required field when Supply air Flow Rate Method During Heating Operation is SupplyAirFlowRate.\n";
    ss << "\\note This field may be blank if a heating coil is not included in the unitary system.\n";
    ss << "N8,  \\field Supply Air Flow Rate Per Floor Area during Heating Operation\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate per total floor area fraction.\n";
    ss << "\\note Required field when Supply air Flow Rate Method During Heating Operation is FlowPerFloorArea.\n";
    ss << "\\note This field may be blank if a heating coil is not included in the unitary system.\n";
    ss << "N9,  \\field Fraction of Autosized Design Heating Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the heating supply air flow rate.\n";
    ss << "\\note Required field when Supply air Flow Rate Method During Heating Operation is FractionOfAutosizedHeatingValue.\n";
    ss << "\\note This field may be blank if a heating coil is not included in the unitary system.\n";
    ss << "N10, \\field Design Supply Air Flow Rate Per Unit of Capacity During Heating Operation\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the heating capacity.\n";
    ss << "\\note Required field when Supply air Flow Rate Method During Heating Operation is FlowPerHeatingCapacity.\n";
    ss << "\\note This field may be blank if a heating coil is not included in the unitary system.\n";
    ss << "A19, \\field Supply Air Flow Rate Method When No Cooling or Heating is Required\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key SupplyAirFlowRate\n";
    ss << "\\key FlowPerFloorArea\n";
    ss << "\\key FractionOfAutosizedCoolingValue\n";
    ss << "\\key FractionOfAutosizedHeatingValue\n";
    ss << "\\key FlowPerCoolingCapacity\n";
    ss << "\\key FlowPerHeatingCapacity\n";
    ss << "\\note Enter the method used to determine the supply air volume flow rate when no cooling or heating is required.\n";
    ss << "\\note None is used when a heating coil is not included in the unitary system or this field may be blank.\n";
    ss << "\\note SupplyAirFlowRate is selected when the magnitude of the supply air volume is used.\n";
    ss << "\\note FlowPerFloorArea is selected when the supply air volume flow rate is based on total floor area\n";
    ss << "\\note served by the unitary system.\n";
    ss << "\\note FractionOfAutosizedCoolingValue is selected when the supply air volume is a fraction of the\n";
    ss << "\\note cooling value determined by the simulation.\n";
    ss << "\\note FractionOfAutosizedHeatingValue is selected when the supply air volume is a fraction of the\n";
    ss << "\\note heating value determined by the simulation.\n";
    ss << "\\note FlowPerCoolingCapacity is selected when the supply air volume is a fraction of the cooling\n";
    ss << "\\note capacity as determined by the simulation.\n";
    ss << "\\note FlowPerHeatingCapacity is selected when the supply air volume is a fraction of the heating\n";
    ss << "\\note capacity as determined by the simulation.\n";
    ss << "N11, \\field Supply Air Flow Rate When No Cooling or Heating is Required\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Enter the magnitude of the supply air volume flow rate during when no cooling or heating is required.\n";
    ss << "\\note Required field when Supply air Flow Rate Method When No Cooling or Heating is Required is SupplyAirFlowRate.\n";
    ss << "N12, \\field Supply Air Flow Rate Per Floor Area When No Cooling or Heating is Required\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate per total floor area fraction.\n";
    ss << "\\note Required field when Supply air Flow Rate Method When No Cooling or Heating is Required is FlowPerFloorArea.\n";
    ss << "N13, \\field Fraction of Autosized Design Cooling Supply Air Flow Rate When No Cooling or Heating is Required\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the cooling supply air flow rate.\n";
    ss << "\\note Required field when Supply air Flow Rate Method When No Cooling or Heating is Required is FractionOfAutosizedCoolingValue.\n";
    ss << "N14, \\field Fraction of Autosized Design Heating Supply Air Flow Rate When No Cooling or Heating is Required\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the heating supply air flow rate.\n";
    ss << "\\note Required field when Supply air Flow Rate Method When No Cooling or Heating is Required is FractionOfAutosizedHeatingValue.\n";
    ss << "N15, \\field Design Supply Air Flow Rate Per Unit of Capacity During Cooling Operation When No Cooling or Heating is Required\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the cooling capacity.\n";
    ss << "\\note Required field when Supply air Flow Rate Method During Heating Operation is FlowPerCoolingCapacity.\n";
    ss << "N16, \\field Design Supply Air Flow Rate Per Unit of Capacity During Heating Operation When No Cooling or Heating is Required\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the heating capacity.\n";
    ss << "\\note Required field when Supply air Flow Rate Method During Heating Operation is FlowPerHeatingCapacity.\n";
    ss << "N17, \\field Maximum Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "\\default 80.0\n";
    ss << "\\note Enter the maximum supply air temperature leaving the heating coil.\n";
    ss << "N18, \\field Maximum Outdoor Dry-Bulb Temperature for Supplemental Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 21.0\n";
    ss << "\\note Enter the maximum outdoor dry-bulb temperature for supplemental heater operation.\n";
    ss << "A20, \\field Outdoor Dry-Bulb Temperature Sensor Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\note If this field is blank, outdoor temperature from the weather file is used.\n";
    ss << "\\note If this field is not blank, the node name specified determines the outdoor temperature used\n";
    ss << "\\note for controlling supplemental heater operation.\n";
    ss << "N19, \\field Maximum Cycling Rate\n";
    ss << "\\type real\n";
    ss << "\\units cycles/hr\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 5.0\n";
    ss << "\\default 2.5\n";
    ss << "\\note Used only for water source heat pump.\n";
    ss << "\\note The maximum on-off cycling rate for the compressor.\n";
    ss << "\\note Suggested value is 2.5 for a typical heat pump.\n";
    ss << "N20, \\field Heat Pump Time Constant\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 500.0\n";
    ss << "\\default 60.0\n";
    ss << "\\note Used only for water source heat pump.\n";
    ss << "\\note Time constant for the cooling coil's capacity to reach steady state after startup.\n";
    ss << "\\note Suggested value is 60 for a typical heat pump.\n";
    ss << "N21, \\field Fraction of On-Cycle Power Use\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.05\n";
    ss << "\\default 0.01\n";
    ss << "\\note Used only for water source heat pump.\n";
    ss << "\\note The fraction of on-cycle power use to adjust the part load fraction based on\n";
    ss << "\\note the off-cycle power consumption due to crankcase heaters, controls, fans, and etc.\n";
    ss << "\\note Suggested value is 0.01 for a typical heat pump.\n";
    ss << "N22, \\field Heat Pump Fan Delay Time\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 60\n";
    ss << "\\note Used only for water source heat pump.\n";
    ss << "\\note Programmed time delay for heat pump fan to shut off after compressor cycle off.\n";
    ss << "\\note Only required when fan operating mode is cycling.\n";
    ss << "\\note Enter 0 when fan operating mode is continuous.\n";
    ss << "N23, \\field Ancilliary On-Cycle Electric Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note Enter the value of ancilliary electric power for controls or other devices consumed during the on cycle.\n";
    ss << "N24, \\field Ancilliary Off-Cycle Electric Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note Enter the value of ancilliary electric power for controls or other devices consumed during the off cycle.\n";
    ss << "N25, \\field Design Heat Recovery Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note If non-zero, then the heat recovery inlet and outlet node names must be entered.\n";
    ss << "\\note Used for heat recovery to an EnergyPlus plant loop.\n";
    ss << "N26, \\field Maximum Temperature for Heat Recovery\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\maximum 100.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 80.0\n";
    ss << "\\note Enter the maximum heat recovery inlet temperature allowed for heat recovery.\n";
    ss << "A21, \\field Heat Recovery Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note Enter the name of the heat recovery water inlet node if plant water loop connections are present.\n";
    ss << "A22, \\field Heat Recovery Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note Enter the name of the heat recovery water outlet node if plant water loop connections are present.\n";
    ss << "A23; \\field Design Specification Multispeed Heat Pump Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list UnitarySystemPerformaceNames\n";
    ss << "\\note Enter the name of the performance specification object used to describe the multispeed coil.\n";

    IddObjectType objType(IddObjectType::OS_AirLoopHVAC_UnitarySystem);
    OptionalIddObject oObj = IddObject::load("OS:AirLoopHVAC:UnitarySystem",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirLoopHVAC_UnitarySystem);
  return object;
}

IddObject createOS_AirLoopHVAC_ZoneMixerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirLoopHVAC:ZoneMixer,\n";
    ss << "\\memo Mix N inlet air streams into one (currently 50 per air loop, but extensible).  Node names cannot\n";
    ss << "\\memo be duplicated within a single zone mixer (AirLoopHVAC:ZoneMixer) list.\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ZoneMixers\n";
    ss << "\\reference ReturnPathComponentNames\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4; \\field Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\object-list ConnectionNames\n";

    IddObjectType objType(IddObjectType::OS_AirLoopHVAC_ZoneMixer);
    OptionalIddObject oObj = IddObject::load("OS:AirLoopHVAC:ZoneMixer",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirLoopHVAC_ZoneMixer);
  return object;
}

IddObject createOS_AirLoopHVAC_ZoneSplitterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirLoopHVAC:ZoneSplitter,\n";
    ss << "\\memo Split one air stream into N outlet streams (currently 50 per air loop, but extensible).  Node names\n";
    ss << "\\memo cannot be duplicated within a single zone splitter (AirLoopHVAC:ZoneSplitter) list.\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ZoneSplitters\n";
    ss << "\\reference SupplyPathComponentNames\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4; \\field Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\object-list ConnectionNames\n";

    IddObjectType objType(IddObjectType::OS_AirLoopHVAC_ZoneSplitter);
    OptionalIddObject oObj = IddObject::load("OS:AirLoopHVAC:ZoneSplitter",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirLoopHVAC_ZoneSplitter);
  return object;
}

IddObject createOS_AirTerminal_SingleDuct_VAV_HeatAndCool_NoReheatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirTerminal:SingleDuct:VAV:HeatAndCool:NoReheat,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4,  \\field Air Outlet\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5,  \\field Air Inlet\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1,  \\field Maximum Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2;  \\field Zone Minimum Air Flow Fraction\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";

    IddObjectType objType(IddObjectType::OS_AirTerminal_SingleDuct_VAV_HeatAndCool_NoReheat);
    OptionalIddObject oObj = IddObject::load("OS:AirTerminal:SingleDuct:VAV:HeatAndCool:NoReheat",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirTerminal_SingleDuct_VAV_HeatAndCool_NoReheat);
  return object;
}

IddObject createOS_AirTerminal_SingleDuct_VAV_HeatAndCool_ReheatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirTerminal:SingleDuct:VAV:HeatAndCool:Reheat,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4,  \\field Damper Air Outlet\n";
    ss << "A5,  \\field Air Inlet\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1,  \\field Maximum Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2,  \\field Zone Minimum Air Flow Fraction\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A6,  \\field Reheat Coil\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N3,  \\field Maximum Hot Water or Steam Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N4,  \\field Minimum Hot Water or Steam Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "A7,  \\field Air Outlet\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N5,  \\field Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\required-field\n";
    ss << "N6; \\field Maximum Reheat Air Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";

    IddObjectType objType(IddObjectType::OS_AirTerminal_SingleDuct_VAV_HeatAndCool_Reheat);
    OptionalIddObject oObj = IddObject::load("OS:AirTerminal:SingleDuct:VAV:HeatAndCool:Reheat",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirTerminal_SingleDuct_VAV_HeatAndCool_Reheat);
  return object;
}

IddObject createOS_AirTerminal_SingleDuct_InletSideMixerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirTerminal:SingleDuct:InletSideMixer,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Terminal Unit Outlet\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4, \\field Terminal Unit Primary Air Inlet\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5; \\field Terminal Unit Secondary Air Inlet\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";

    IddObjectType objType(IddObjectType::OS_AirTerminal_SingleDuct_InletSideMixer);
    OptionalIddObject oObj = IddObject::load("OS:AirTerminal:SingleDuct:InletSideMixer",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirTerminal_SingleDuct_InletSideMixer);
  return object;
}

IddObject createOS_AirTerminal_SingleDuct_ConstantVolume_ReheatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirTerminal:SingleDuct:ConstantVolume:Reheat,\n";
    ss << "\\min-fields 5\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4, \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1, \\field Maximum Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "A6, \\field Reheat Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N2, \\field Maximum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when reheat coil type is gas or electric\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0\n";
    ss << "N3, \\field Minimum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when reheat coil type is gas or electric\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N4, \\field Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.001\n";
    ss << "N5; \\field Maximum Reheat Air Temperature\n";
    ss << "\\note Specifies the maximum allowable supply air temperature leaving the reheat coil.\n";
    ss << "\\note If left blank, there is no limit and no default. If unknown, 35C (95F) is recommended.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 35.0\n";

    IddObjectType objType(IddObjectType::OS_AirTerminal_SingleDuct_ConstantVolume_Reheat);
    OptionalIddObject oObj = IddObject::load("OS:AirTerminal:SingleDuct:ConstantVolume:Reheat",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirTerminal_SingleDuct_ConstantVolume_Reheat);
  return object;
}

IddObject createOS_AirTerminal_SingleDuct_SeriesPIU_ReheatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirTerminal:SingleDuct:SeriesPIU:Reheat,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1,  \\field Maximum Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2,  \\field Maximum Primary Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N3,  \\field Minimum Primary Air Flow Fraction\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\autosizable\n";
    ss << "A4,  \\field Supply Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5,  \\field Secondary Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6,  \\field Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A7,  \\field Reheat Coil Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A8,  \\field Zone Mixer Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneMixers\n";
    ss << "A9,  \\field Fan Name\n";
    ss << "\\note Fan type must be Fan:ConstantVolume\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCV\n";
    ss << "A10, \\field Reheat Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N4,  \\field Maximum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when reheat coil type is gas or electric\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N5,  \\field Minimum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when reheat coil type is gas or electric\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\required-field\n";
    ss << "N6;  \\field Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_AirTerminal_SingleDuct_SeriesPIU_Reheat);
    OptionalIddObject oObj = IddObject::load("OS:AirTerminal:SingleDuct:SeriesPIU:Reheat",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirTerminal_SingleDuct_SeriesPIU_Reheat);
  return object;
}

IddObject createOS_AirTerminal_SingleDuct_ParallelPIU_ReheatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirTerminal:SingleDuct:ParallelPIU:Reheat,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Maximum Primary Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "N2, \\field Maximum Secondary Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "N3, \\field Minimum Primary Air Flow Fraction\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "N4, \\field Fan On Flow Fraction\n";
    ss << "\\note the fraction of the primary air flow at which fan turns on\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "A4, \\field Supply Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Secondary Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6, \\field Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A7, \\field Reheat Coil Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A8, \\field Zone Mixer Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneMixers\n";
    ss << "A9, \\field Fan Name\n";
    ss << "\\note Fan type must be Fan:ConstantVolume\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCV\n";
    ss << "A11, \\field Reheat Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N5, \\field Maximum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when reheat coil type is gas or electric\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N6, \\field Minimum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when reheat coil type is gas or electric\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N7; \\field Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.001\n";

    IddObjectType objType(IddObjectType::OS_AirTerminal_SingleDuct_ParallelPIU_Reheat);
    OptionalIddObject oObj = IddObject::load("OS:AirTerminal:SingleDuct:ParallelPIU:Reheat",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirTerminal_SingleDuct_ParallelPIU_Reheat);
  return object;
}

IddObject createOS_AirTerminal_SingleDuct_ConstantVolume_FourPipeInductionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirTerminal:SingleDuct:ConstantVolume:FourPipeInduction,\n";
    ss << "\\memo Central air system terminal unit, single duct, variable volume, induction unit with\n";
    ss << "\\memo hot water reheat coil and chilled water recool coil.\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1,  \\field Maximum Total Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.0\n";
    ss << "N2,  \\field Induction Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 2.5\n";
    ss << "\\note ratio of induced air flow rate to primary air flow rate\n";
    ss << "A4,  \\field Supply Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\required-field\n";
    ss << "A5,  \\field Induced Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\required-field\n";
    ss << "\\note should be a zone exhaust node, also the heating coil inlet node\n";
    ss << "A6,  \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\required-field\n";
    ss << "\\note should be a zone inlet node\n";
    ss << "A7,  \\field Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N3,  \\field Maximum Hot Water Flow Rate\n";
    ss << "\\note Not used when heating coil type is gas or electric\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N4,  \\field Minimum Hot Water Flow Rate\n";
    ss << "\\note Not used when heating coil type is gas or electric\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N5,  \\field Heating Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "A8,  \\field Cooling Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilName\n";
    ss << "N6,  \\field Maximum Cold Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N7,  \\field Minimum Cold Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N8,  \\field Cooling Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "A9;  \\field Zone Mixer Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneMixers\n";

    IddObjectType objType(IddObjectType::OS_AirTerminal_SingleDuct_ConstantVolume_FourPipeInduction);
    OptionalIddObject oObj = IddObject::load("OS:AirTerminal:SingleDuct:ConstantVolume:FourPipeInduction",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirTerminal_SingleDuct_ConstantVolume_FourPipeInduction);
  return object;
}

IddObject createOS_AirTerminal_SingleDuct_ConstantVolume_CooledBeamIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirTerminal:SingleDuct:ConstantVolume:CooledBeam,\n";
    ss << "\\memo Central air system terminal unit, single duct, constant volume, with cooled beam\n";
    ss << "\\memo (active or passive).\n";
    ss << "\\min-fields 14\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4, \\field Cooled Beam Type\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Active\n";
    ss << "\\key Passive\n";
    ss << "A5, \\field Supply Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6, \\field Supply Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A7, \\field Cooling Coil Name\n";
    ss << "\\note  Needs to match the cooled beam cooling coil object CoolingCoilCooledBeam\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list CoolingCoilCooledBeam\n";
    ss << "N1, \\field Supply Air Volumetric Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N2, \\field Maximum Total Chilled Water Volumetric Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N3, \\field Number of Beams\n";
    ss << "\\note Number of individual beam units in the zone\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N4, \\field Beam Length\n";
    ss << "\\note Length of an individual beam unit\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "N5, \\field Design Inlet Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 15.0\n";
    ss << "N6, \\field Design Outlet Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 17.0\n";
    ss << "N7; \\field Coefficient of Induction Kin\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 4.0\n";
    ss << "\\default Autocalculate\n";

    IddObjectType objType(IddObjectType::OS_AirTerminal_SingleDuct_ConstantVolume_CooledBeam);
    OptionalIddObject oObj = IddObject::load("OS:AirTerminal:SingleDuct:ConstantVolume:CooledBeam",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirTerminal_SingleDuct_ConstantVolume_CooledBeam);
  return object;
}

IddObject createOS_AirTerminal_SingleDuct_UncontrolledIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirTerminal:SingleDuct:Uncontrolled,\n";
    ss << "\\min-fields 6\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4, \\field Inlet Air Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Zone Supply Air Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1; \\field Maximum Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";

    IddObjectType objType(IddObjectType::OS_AirTerminal_SingleDuct_Uncontrolled);
    OptionalIddObject oObj = IddObject::load("OS:AirTerminal:SingleDuct:Uncontrolled",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirTerminal_SingleDuct_Uncontrolled);
  return object;
}

IddObject createOS_AirTerminal_SingleDuct_VAV_NoReheatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirTerminal:SingleDuct:VAV:NoReheat,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,  \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4,  \\field Air Outlet Node Name\n";
    ss << "\\note the inlet node to the terminal unit and the damper\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5,  \\field Air Inlet Node Name\n";
    ss << "\\note the inlet node to the terminal unit and the damper\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1,  \\field Maximum Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "A6 , \\field Zone Minimum Air Flow Input Method\n";
    ss << "\\note Constant = Constant Minimum Air Flow Fraction (a fraction of Maximum Air Flow Rate)\n";
    ss << "\\note FixedFlowRate = Fixed Minimum Air Flow Rate (a fixed minimum air volume flow rate)\n";
    ss << "\\note Scheduled = Scheduled Minimum Air Flow Fraction (a fraction of Maximum Air Flow\n";
    ss << "\\type choice\n";
    ss << "\\key Constant\n";
    ss << "\\key FixedFlowRate\n";
    ss << "\\key Scheduled\n";
    ss << "N2 , \\field Constant Minimum Air Flow Fraction\n";
    ss << "\\note This field is used if the field Zone Minimum Air Flow Input Method is Constant\n";
    ss << "\\note If the field Zone Minimum Air Flow Input Method is Scheduled, then this field\n";
    ss << "\\note is optional; if a value is entered, then it is used for sizing normal-action reheat coils.\n";
    ss << "\\note If both this field and the following field are entered, the larger result is used.\n";
    ss << "\\type real\n";
    ss << "\\default 0.3\n";
    ss << "N3 , \\field Fixed Minimum Air Flow Rate\n";
    ss << "\\note This field is used if the field Zone Minimum Air Flow Input Method is FixedFlowRate.\n";
    ss << "\\note If the field Zone Minimum Air Flow Input Method is Scheduled, then this field\n";
    ss << "\\note is optional; if a value is entered, then it is used for sizing normal-action reheat coils.\n";
    ss << "\\note If both this field and the previous field are entered, the larger result is used.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0.0\n";
    ss << "A7 , \\field Minimum Air Flow Fraction Schedule Name\n";
    ss << "\\note This field is used if the field Zone Minimum Air Flow Input Method is Scheduled\n";
    ss << "\\note Schedule values are fractions, 0.0 to 1.0.\n";
    ss << "\\note If the field Constant Minimum Air Flow Fraction is blank, then the average of the\n";
    ss << "\\note minimum and maximum schedule values is used for sizing normal-action reheat coils.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A8 ; \\field Control For Outdoor Air\n";
    ss << "\\note This field replaces the E+ field Design Specification Outdoor Air Object Name\n";
    ss << "\\note Refer to OpenStudio API for details\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_AirTerminal_SingleDuct_VAV_NoReheat);
    OptionalIddObject oObj = IddObject::load("OS:AirTerminal:SingleDuct:VAV:NoReheat",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirTerminal_SingleDuct_VAV_NoReheat);
  return object;
}

IddObject createOS_AirTerminal_SingleDuct_VAV_ReheatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirTerminal:SingleDuct:VAV:Reheat,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5, \\field Air Inlet Node Name\n";
    ss << "\\note the inlet node to the terminal unit and the damper\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1, \\field Maximum Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "A6, \\field Zone Minimum Air Flow Input Method\n";
    ss << "\\note Constant = Constant Minimum Air Flow Fraction (a fraction of Maximum Air Flow Rate)\n";
    ss << "\\note FixedFlowRate = Fixed Minimum Air Flow Rate (a fixed minimum air volume flow rate)\n";
    ss << "\\note Scheduled = Scheduled Minimum Air Flow Fraction (a fraction of Maximum Air Flow\n";
    ss << "\\type choice\n";
    ss << "\\key Constant\n";
    ss << "\\key FixedFlowRate\n";
    ss << "\\key Scheduled\n";
    ss << "N2, \\field Constant Minimum Air Flow Fraction\n";
    ss << "\\note This field is used if the field Zone Minimum Air Flow Input Method is Constant\n";
    ss << "\\note If the field Zone Minimum Air Flow Input Method is Scheduled, then this field\n";
    ss << "\\note is optional; if a value is entered, then it is used for sizing normal-action reheat coils.\n";
    ss << "\\note If both this field and the following field are entered, the larger result is used.\n";
    ss << "\\type real\n";
    ss << "\\default 0.3\n";
    ss << "N3, \\field Fixed Minimum Air Flow Rate\n";
    ss << "\\note This field is used if the field Zone Minimum Air Flow Input Method is FixedFlowRate.\n";
    ss << "\\note If the field Zone Minimum Air Flow Input Method is Scheduled, then this field\n";
    ss << "\\note is optional; if a value is entered, then it is used for sizing normal-action reheat coils.\n";
    ss << "\\note If both this field and the previous field are entered, the larger result is used.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0.0\n";
    ss << "A7, \\field Minimum Air Flow Fraction Schedule Name\n";
    ss << "\\note This field is used if the field Zone Minimum Air Flow Input Method is Scheduled\n";
    ss << "\\note Schedule values are fractions, 0.0 to 1.0.\n";
    ss << "\\note If the field Constant Minimum Air Flow Fraction is blank, then the average of the\n";
    ss << "\\note minimum and maximum schedule values is used for sizing normal-action reheat coils.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A9, \\field Reheat Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N4, \\field Maximum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when reheat coil type is gas or electric\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0\n";
    ss << "N5, \\field Minimum Hot Water or Steam Flow Rate\n";
    ss << "\\note Not used when reheat coil type is gas or electric\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "A10, \\field Air Outlet Node Name\n";
    ss << "\\note The outlet node of the terminal unit and the reheat coil.\n";
    ss << "\\note This is also the zone inlet node.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N6, \\field Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.001\n";
    ss << "A11, \\field Damper Heating Action\n";
    ss << "\\type choice\n";
    ss << "\\default Normal\n";
    ss << "\\key Normal\n";
    ss << "\\key Reverse\n";
    ss << "N7, \\field Maximum Flow per Zone Floor Area During Reheat\n";
    ss << "\\note Used only when Reheat Coil Object Type = Coil:Heating:Water and Damper Heating Action = Reverse\n";
    ss << "\\note When autocalculating, the maximum flow per zone is set to 0.002032 m3/s-m2 (0.4 cfm/sqft)\n";
    ss << "\\note This optional field limits the maximum flow allowed in reheat mode.\n";
    ss << "\\note If this field and the following field are left blank, the maximum flow will not be limited.\n";
    ss << "\\note At no time will the maximum flow rate calculated here exceed the value of\n";
    ss << "\\note Maximum Air Flow Rate.\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s-m2\n";
    ss << "N8, \\field Maximum Flow Fraction During Reheat\n";
    ss << "\\note Used only when Reheat Coil Object Type = Coil:Heating:Water and Damper Heating Action = Reverse\n";
    ss << "\\note When autocalculating, the maximum flow fraction is set to the ratio of\n";
    ss << "\\note 0.002032 m3/s-m2 (0.4 cfm/sqft) multiplied by the zone floor area and the\n";
    ss << "\\note Maximum Air Flow Rate.\n";
    ss << "\\note This optional field limits the maximum flow allowed in reheat mode.\n";
    ss << "\\note If this field and the previous field are left blank, the maximum flow will not be limited.\n";
    ss << "\\note At no time will the maximum flow rate calculated here exceed the value of\n";
    ss << "\\note Maximum Air Flow Rate.\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "N9, \\field Maximum Reheat Air Temperature\n";
    ss << "\\note Specifies the maximum allowable supply air temperature leaving the reheat coil.\n";
    ss << "\\note If left blank, there is no limit and no default. If unknown, 35C (95F) is recommended.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 35.0\n";
    ss << "A12; \\field Control For Outdoor Air\n";
    ss << "\\note This field replaces the E+ field Design Specification Outdoor Air Object Name\n";
    ss << "\\note Refer to OpenStudio API for details\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_AirTerminal_SingleDuct_VAV_Reheat);
    OptionalIddObject oObj = IddObject::load("OS:AirTerminal:SingleDuct:VAV:Reheat",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirTerminal_SingleDuct_VAV_Reheat);
  return object;
}

IddObject createOS_AirTerminal_DualDuct_VAV_OutdoorAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirTerminal:DualDuct:VAV:OutdoorAir,\n";
    ss << "\\memo Central air system terminal unit, dual duct, variable volume with special controls.\n";
    ss << "\\memo One VAV duct is controlled to supply ventilation air and the other VAV duct is\n";
    ss << "\\memo controlled to meet the zone cooling load.\n";
    ss << "\\min-fields 9\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Air Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note The outlet node of the terminal unit.\n";
    ss << "\\note This is also the zone inlet node.\n";
    ss << "A5 , \\field Outdoor Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6 , \\field Recirculated Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 , \\field Maximum Terminal Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\note If autosized this is the sum of flow needed for cooling and maximum required outdoor air\n";
    ss << "A7 , \\field Design Specification Outdoor Air Object\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "\\note When the name of a DesignSpecification:OutdoorAir object is entered, the terminal\n";
    ss << "\\note unit will increase flow as needed to meet this outdoor air requirement.\n";
    ss << "\\note If Outdoor Air Flow per Person is non-zero, then the outdoor air requirement will\n";
    ss << "\\note be computed based mode selected in the next field.\n";
    ss << "\\note At no time will the supply air flow rate exceed the value for Maximum Air Flow Rate.\n";
    ss << "A8 ; \\field Per Person Ventilation Rate Mode\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key CurrentOccupancy\n";
    ss << "\\key DesignOccupancy\n";
    ss << "\\note CurrentOccupancy models demand controlled ventilation using the current number of people\n";
    ss << "\\note DesignOccupancy uses the total Number of People in the zone and is constant\n";

    IddObjectType objType(IddObjectType::OS_AirTerminal_DualDuct_VAV_OutdoorAir);
    OptionalIddObject oObj = IddObject::load("OS:AirTerminal:DualDuct:VAV:OutdoorAir",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirTerminal_DualDuct_VAV_OutdoorAir);
  return object;
}

IddObject createOS_AirTerminal_DualDuct_ConstantVolumeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirTerminal:DualDuct:ConstantVolume,\n";
    ss << "\\memo Central air system terminal unit, dual duct, constant volume.\n";
    ss << "\\min-fields 7\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Air Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note The outlet node of the terminal unit.\n";
    ss << "\\note This is also the zone inlet node.\n";
    ss << "A5 , \\field Hot Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6 , \\field Cold Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 ; \\field Maximum Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";

    IddObjectType objType(IddObjectType::OS_AirTerminal_DualDuct_ConstantVolume);
    OptionalIddObject oObj = IddObject::load("OS:AirTerminal:DualDuct:ConstantVolume",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirTerminal_DualDuct_ConstantVolume);
  return object;
}

IddObject createOS_AirTerminal_DualDuct_VAVIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AirTerminal:DualDuct:VAV,\n";
    ss << "\\memo Central air system terminal unit, dual duct, variable volume.\n";
    ss << "\\min-fields 9\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Air Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note The outlet node of the terminal unit.\n";
    ss << "\\note This is also the zone inlet node.\n";
    ss << "A5 , \\field Hot Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6 , \\field Cold Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 , \\field Maximum Damper Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Zone Minimum Air Flow Fraction\n";
    ss << "\\note fraction of maximum air flow\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "A7 ; \\field Design Specification Outdoor Air Object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "\\note When the name of a DesignSpecification:OutdoorAir object is entered, the terminal\n";
    ss << "\\note unit will increase flow as needed to meet this outdoor air requirement.\n";
    ss << "\\note If Outdoor Air Flow per Person is non-zero, then the outdoor air requirement will\n";
    ss << "\\note be computed based on the current number of occupants in the zone.\n";
    ss << "\\note At no time will the supply air flow rate exceed the value for Maximum Air Flow Rate.\n";
    ss << "\\note If this field is blank, then the terminal unit will not be controlled for outdoor air flow.\n";

    IddObjectType objType(IddObjectType::OS_AirTerminal_DualDuct_VAV);
    OptionalIddObject oObj = IddObject::load("OS:AirTerminal:DualDuct:VAV",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AirTerminal_DualDuct_VAV);
  return object;
}

IddObject createOS_AvailabilityManagerAssignmentListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AvailabilityManagerAssignmentList,\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference SystemAvailabilityManagerLists\n";
    ss << "A3; \\field Availability Manager Name\n";
    ss << "\\type object-list\n";
    ss << "\\begin-extensible\n";
    ss << "\\object-list SystemAvailabilityManagers\n";

    IddObjectType objType(IddObjectType::OS_AvailabilityManagerAssignmentList);
    OptionalIddObject oObj = IddObject::load("OS:AvailabilityManagerAssignmentList",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AvailabilityManagerAssignmentList);
  return object;
}

IddObject createOS_AvailabilityManager_ScheduledIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AvailabilityManager:Scheduled,\n";
    ss << "\\memo Determines the availability of a loop or system: whether it is on or off.\n";
    ss << "\\memo Schedule overrides fan/pump schedule.\n";
    ss << "\\min-fields 3\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference SystemAvailabilityManagers\n";
    ss << "A3; \\field Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_AvailabilityManager_Scheduled);
    OptionalIddObject oObj = IddObject::load("OS:AvailabilityManager:Scheduled",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AvailabilityManager_Scheduled);
  return object;
}

IddObject createOS_AvailabilityManager_NightCycleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AvailabilityManager:NightCycle,\n";
    ss << "\\min-fields 7\n";
    ss << "\\memo Determines the availability of a loop or system: whether it is on or off.\n";
    ss << "\\memo Depending on zone temperatures, overrides Schedules and forces system Fans on.\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SystemAvailabilityManagers\n";
    ss << "A3 , \\field Applicability Schedule\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Fan Schedule\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5 , \\field Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key StayOff\n";
    ss << "\\key CycleOnAny\n";
    ss << "\\key CycleOnControlZone\n";
    ss << "\\key CycleOnAnyZoneFansOnly\n";
    ss << "\\default StayOff\n";
    ss << "\\note When AvailabilityManager:NightCycle is used in the zone component availability\n";
    ss << "\\note manager assignment list, the key choices for Control Type would only be\n";
    ss << "\\note StayOff and CycleOnControlZone\n";
    ss << "N1 , \\field Thermostat Tolerance\n";
    ss << "\\default 1.0\n";
    ss << "\\units deltaC\n";
    ss << "N2 , \\field Cycling Run Time\n";
    ss << "\\default 3600.\n";
    ss << "\\units s\n";
    ss << "A6 ; \\field Control Thermal Zone\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "\\note When AvailabilityManager:NightCycle is used in the zone component availability\n";
    ss << "\\note manager assignment list, the Control Zone Name should be the name of the zone in which the\n";
    ss << "\\note zone component is.\n";

    IddObjectType objType(IddObjectType::OS_AvailabilityManager_NightCycle);
    OptionalIddObject oObj = IddObject::load("OS:AvailabilityManager:NightCycle",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AvailabilityManager_NightCycle);
  return object;
}

IddObject createOS_AvailabilityManager_OptimumStartIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AvailabilityManager:OptimumStart,\n";
    ss << "\\memo Determines the optimal start of HVAC systems before occupancy.\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SystemAvailabilityManagers\n";
    ss << "A3 , \\field Applicability Schedule\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Fan Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5 , \\field Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key StayOff\n";
    ss << "\\key ControlZone\n";
    ss << "\\key MaximumofZoneList\n";
    ss << "\\required-field\n";
    ss << "A6 , \\field Control Zone\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A7 , \\field Zone List\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ZoneListNames\n";
    ss << "N1 , \\field Maximum Value for Optimum Start Time\n";
    ss << "\\required-field\n";
    ss << "\\units hr\n";
    ss << "\\note this is the maximum number of hours that a system can start before occupancy\n";
    ss << "A8 , \\field Control Algorithm\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantTemperatureGradient\n";
    ss << "\\key AdaptiveTemperatureGradient\n";
    ss << "\\key AdaptiveASHRAE\n";
    ss << "\\key ConstantStartTime\n";
    ss << "\\required-field\n";
    ss << "N2,  \\field Constant Temperature Gradient during Cooling\n";
    ss << "\\units deltaC/hr\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N3,  \\field Constant Temperature Gradient during Heating\n";
    ss << "\\units deltaC/hr\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N4,  \\field Initial Temperature Gradient during Cooling\n";
    ss << "\\units deltaC/hr\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N5,  \\field Initial Temperature Gradient during Heating\n";
    ss << "\\units deltaC/hr\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N6,  \\field Constant Start Time\n";
    ss << "\\units hr\n";
    ss << "\\type real\n";
    ss << "\\note this is the number of hours before occupancy for a system\n";
    ss << "\\required-field\n";
    ss << "N7;  \\field Number of Previous Days\n";
    ss << "\\type integer\n";
    ss << "\\units days\n";
    ss << "\\minimum 2\n";
    ss << "\\maximum 5\n";
    ss << "\\required-field\n";
    ss << "\\note this is the number of days that their actual temperature\n";
    ss << "\\note gradients will be used in the AdaptiveTemperatureGradient method\n";

    IddObjectType objType(IddObjectType::OS_AvailabilityManager_OptimumStart);
    OptionalIddObject oObj = IddObject::load("OS:AvailabilityManager:OptimumStart",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AvailabilityManager_OptimumStart);
  return object;
}

IddObject createOS_AvailabilityManager_DifferentialThermostatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AvailabilityManager:DifferentialThermostat,\n";
    ss << "\\memo Overrides fan/pump schedules depending on temperature difference between two nodes.\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SystemAvailabilityManagers\n";
    ss << "A3 , \\field Hot Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "A4 , \\field Cold Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "N1 , \\field Temperature Difference On Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "N2 ; \\field Temperature Difference Off Limit\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_AvailabilityManager_DifferentialThermostat);
    OptionalIddObject oObj = IddObject::load("OS:AvailabilityManager:DifferentialThermostat",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AvailabilityManager_DifferentialThermostat);
  return object;
}

IddObject createOS_AvailabilityManager_NightVentilationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AvailabilityManager:NightVentilation,\n";
    ss << "\\memo depending on zone and outdoor conditions overrides fan schedule to do\n";
    ss << "\\memo precooling with outdoor air\n";
    ss << "\\min-fields 9\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SystemAvailabilityManagers\n";
    ss << "A3 , \\field Applicability Schedule\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Fan Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5 , \\field Ventilation Temperature Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note One zone temperature must be above this scheduled temperature\n";
    ss << "\\note for night ventilation to be enabled\n";
    ss << "N1 , \\field Ventilation Temperature Difference\n";
    ss << "\\units deltaC\n";
    ss << "\\required-field\n";
    ss << "\\note The outdoor air temperature minus the control zone temperature\n";
    ss << "\\note must be greater than the ventilation delta T\n";
    ss << "N2 , \\field Ventilation Temperature Low Limit\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "\\note Night ventilation is disabled if any conditioned zone served by\n";
    ss << "\\note the system falls below this temperature\n";
    ss << "N3 , \\field Night Venting Flow Fraction\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "\\note the fraction (could be > 1) of the design system Flow Rate at which\n";
    ss << "\\note night ventilation will be done\n";
    ss << "A6 ; \\field Control Zone\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "\\note When AvailabilityManager:NightVentilation is used in the zone component availability\n";
    ss << "\\note manager assignment list, the Control Zone Name should be the name of the zone in which the\n";
    ss << "\\note zone component is.\n";

    IddObjectType objType(IddObjectType::OS_AvailabilityManager_NightVentilation);
    OptionalIddObject oObj = IddObject::load("OS:AvailabilityManager:NightVentilation",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AvailabilityManager_NightVentilation);
  return object;
}

IddObject createOS_AvailabilityManager_HybridVentilationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:AvailabilityManager:HybridVentilation,\n";
    ss << "\\min-fields 12\n";
    ss << "\\memo Depending on zone and outdoor conditions overrides window/door opening controls\n";
    ss << "\\memo to maximize natural ventilation and turn off an HVAC system when ventilation control\n";
    ss << "\\memo conditions are met.\n";
    ss << "\\memo This object (zone ventilation object name) has not been instrumented to work with\n";
    ss << "\\memo global Zone or Zone List names option for Ventilation:DesignFlowRate.  In order to\n";
    ss << "\\memo use, you must enter the single <Ventilation:DesignFlowRate> name in that\n";
    ss << "\\memo field. If it is a part of a global ventilation assignment the name will be\n";
    ss << "\\memo <Zone Name> <global Ventilation:DesignFlowRate> name.\n";
    ss << "\\memo Currently, hybrid ventilation manager is restricted to one per zone. It can either be applied\n";
    ss << "\\memo through the air loop or directly to the zone. If hybrid ventilation manager is applied to an\n";
    ss << "\\memo air loop and one of the zones served by that air loop also has hybrid ventilation manager,\n";
    ss << "\\memo then zone hybrid ventilation manager is disabled.\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference SystemAvailabilityManagers\n";
    ss << "A3 , \\field Controlled Zone\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "\\note the controlled zone name should be a zone where a thermostat or humidistat is located\n";
    ss << "\\note served by an air primary loop.\n";
    ss << "A4 , \\field Ventilation Control Mode Schedule\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note The Ventilation control mode contains appropriate integer control types.\n";
    ss << "\\note 0 - uncontrolled (Natural ventilation and HVAC system are controlled by themselves)\n";
    ss << "\\note 1 = Temperature control\n";
    ss << "\\note 2 = Enthalpy control\n";
    ss << "\\note 3 = Dewpoint control\n";
    ss << "\\note 4 = Outdoor ventilation air control\n";
    ss << "A5 , \\field Use Weather File Rain Indicators\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\required-field\n";
    ss << "\\note If Yes, ventilation is shutoff when there is rain\n";
    ss << "\\note If No, there is no rain control\n";
    ss << "N1 , \\field Maximum Wind Speed\n";
    ss << "\\type real\n";
    ss << "\\units m/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 40.0\n";
    ss << "\\required-field\n";
    ss << "\\note this is the wind speed above which ventilation is shutoff\n";
    ss << "N2 , \\field Minimum Outdoor Temperature\n";
    ss << "\\note this is the outdoor temperature below which ventilation is shutoff\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field Maximum Outdoor Temperature\n";
    ss << "\\note this is the outdoor temperature above which ventilation is shutoff\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\required-field\n";
    ss << "N4 , \\field Minimum Outdoor Enthalpy\n";
    ss << "\\note this is the outdoor Enthalpy below which ventilation is shutoff\n";
    ss << "\\units J/kg\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 300000.0\n";
    ss << "\\required-field\n";
    ss << "N5 , \\field Maximum Outdoor Enthalpy\n";
    ss << "\\note this is the outdoor Enthalpy above which ventilation is shutoff\n";
    ss << "\\units J/kg\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum< 300000.0\n";
    ss << "\\required-field\n";
    ss << "N6 , \\field Minimum Outdoor Dewpoint\n";
    ss << "\\note this is the outdoor temperature below which ventilation is shutoff\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\required-field\n";
    ss << "\\note Applicable only if Ventilation Control Mode = 3\n";
    ss << "N7 , \\field Maximum Outdoor Dewpoint\n";
    ss << "\\note this is the outdoor dewpoint above which ventilation is shutoff\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\required-field\n";
    ss << "\\note Applicable only if Ventilation Control Mode = 3\n";
    ss << "A6 , \\field Minimum Outdoor Ventilation Air Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Used only if Ventilation Control Mode = 4\n";
    ss << "A7 , \\field Opening Factor Function of Wind Speed Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearOrQuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note linear curve = a + b*WS\n";
    ss << "\\note quadratic curve = a + b*WS + c*WS**2\n";
    ss << "\\note WS = wind speed (m/s)\n";
    ss << "A8 , \\field AirflowNetwork Control Type Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note The schedule is used to incorporate operation of AirflowNetwork large opening\n";
    ss << "\\note objects and HVAC system operation.\n";
    ss << "A9 , \\field Simple Airflow Control Type Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note The schedule is used to incorporate operation of simple airflow objects and HVAC\n";
    ss << "\\note system operation.\n";
    ss << "\\note The simple airflow objects are Ventilation and Mixing only\n";
    ss << "A10; \\field ZoneVentilation Object\n";
    ss << "\\note This field has not been instrumented to work with\n";
    ss << "\\note global Zone or Zone List names option for Ventilation:DesignFlowRate.  In order to\n";
    ss << "\\note use, you must enter the single <Ventilation:DesignFlowRate> name in this field.\n";
    ss << "\\note If it is a part of a global ventilation assignment the name will be\n";
    ss << "\\note <Zone Name> <global Ventilation:DesignFlowRate> name.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list VentilationNames\n";
    ss << "\\note The other ZoneVentilation:* and ZoneMixing objects controlled in the same AirLoopHVAC\n";
    ss << "\\note will work in the same way as this ventilation object.\n";

    IddObjectType objType(IddObjectType::OS_AvailabilityManager_HybridVentilation);
    OptionalIddObject oObj = IddObject::load("OS:AvailabilityManager:HybridVentilation",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_AvailabilityManager_HybridVentilation);
  return object;
}

IddObject createOS_Boiler_HotWaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Boiler:HotWater,\n";
    ss << "\\memo This boiler model is an adaptation of the empirical model from the Building\n";
    ss << "\\memo Loads and System Thermodynamics (BLAST) program.  Boiler performance\n";
    ss << "\\memo curves are generated by fitting catalog data to polynomial equations.\n";
    ss << "\\memo A constant efficiency boiler may be modeled by leaving the normalized\n";
    ss << "\\memo boiler efficiency curve name input blank.\n";
    ss << "\\min-fields 14\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\default NaturalGas\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "N1, \\field Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default autosize\n";
    ss << "N2, \\field Nominal Thermal Efficiency\n";
    ss << "\\note Based on the higher heating value of fuel.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.8\n";
    ss << "A4, \\field Efficiency Curve Temperature Evaluation Variable\n";
    ss << "\\type choice\n";
    ss << "\\key EnteringBoiler\n";
    ss << "\\key LeavingBoiler\n";
    ss << "A5, \\field Normalized Boiler Efficiency Curve Name\n";
    ss << "\\note Linear, Quadratic and Cubic efficiency curves are solely a function of PLR.\n";
    ss << "\\note All other efficiency curve types are a function of PLR and boiler water temperature.\n";
    ss << "\\note Linear = C1 + C2*PLR\n";
    ss << "\\note Quadratic = C1 + C2*PLR + C3*PLR^2\n";
    ss << "\\note Cubic = C1 + C2*PLR + C3*PLR^2 + C4*PLR^3\n";
    ss << "\\note Biquadratic = C1 + C2*PLR + C3*PLR^2 + C4*T + C5*T^2 + C6*PLR*T\n";
    ss << "\\note QuadraticLinear = C1 + C2*PLR + C3*PLR^2 + (C4 + C5*PLR + C6*PLR^2)*T\n";
    ss << "\\note BiCubic = C1+C2*PLR+C3*PLR^2+C4*T+C5*T^2+C6*PLR*T+C7*PLR^3+C8*T^3+C9*PLR^2*T+C10*PLR*T^2\n";
    ss << "\\note TriQuadratic curves are not allowed.\n";
    ss << "\\note PLR = part-load ratio\n";
    ss << "\\note T = boiler water temperature (either entering or leaving).\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllCurves\n";
    ss << "N3, \\field Design Water Outlet Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 82.0\n";
    ss << "N4, \\field Design Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0\n";
    ss << "\\default autosize\n";
    ss << "N5, \\field Minimum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N6, \\field Maximum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 1.0\n";
    ss << "N7, \\field Optimum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 1.0\n";
    ss << "A6, \\field Boiler Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A7, \\field Boiler Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N8, \\field Water Outlet Upper Temperature Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 99.9\n";
    ss << "A8, \\field Boiler Flow Mode\n";
    ss << "\\note Sets this boiler to either a variable or constant flow simulation\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\key LeavingSetpointModulated\n";
    ss << "\\key NotModulated\n";
    ss << "\\default NotModulated\n";
    ss << "N9, \\field Parasitic Electric Load\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N10; \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::OS_Boiler_HotWater);
    OptionalIddObject oObj = IddObject::load("OS:Boiler:HotWater",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Boiler_HotWater);
  return object;
}

IddObject createOS_Boiler_SteamIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Boiler:Steam,\n";
    ss << "\\memo This boiler model is an adaptation of the empirical model from the Building\n";
    ss << "\\memo Loads and System Thermodynamics (BLAST) program.  Boiler performance\n";
    ss << "\\memo curves are generated by fitting catalog data to third order\n";
    ss << "\\memo polynomial equations.  A constant efficiency boiler is modeled by setting\n";
    ss << "\\memo the fuel use coefficients as follows: N9=1, N10=0, N11=0\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Fuel Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "N1 , \\field Maximum Operating Pressure\n";
    ss << "\\units kPa\n";
    ss << "N2 , \\field Theoretical Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N3 , \\field Design Outlet Steam Temperature\n";
    ss << "\\units C\n";
    ss << "N4 , \\field Nominal Capacity\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "N5 , \\field Minimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N6 , \\field Maximum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N7 , \\field Optimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "N8 , \\field Coefficient 1 of Fuel Use Function of Part Load Ratio Curve\n";
    ss << "N9 , \\field Coefficient 2 of Fuel Use Function of Part Load Ratio Curve\n";
    ss << "N10, \\field Coefficient 3 of Fuel Use Function of Part Load Ratio Curve\n";
    ss << "A4 , \\field Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5 , \\field Steam Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N11; \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::OS_Boiler_Steam);
    OptionalIddObject oObj = IddObject::load("OS:Boiler:Steam",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Boiler_Steam);
  return object;
}

IddObject createOS_HeatPump_WaterToWater_EquationFit_HeatingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:HeatPump:WaterToWater:EquationFit:Heating,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,  \\field Source Side Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4,  \\field Source Side Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5,  \\field Load Side Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6,  \\field Load Side Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1,  \\field Rated Load Side Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "N2,  \\field Rated Source Side Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "N3,  \\field Rated Heating Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W\n";
    ss << "N4,  \\field Rated Heating Power Consumption\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W\n";
    ss << "N5,  \\field Heating Capacity Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N6,  \\field Heating Capacity Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N7,  \\field Heating Capacity Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N8,  \\field Heating Capacity Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N9,  \\field Heating Capacity Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N10, \\field Heating Compressor Power Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N11, \\field Heating Compressor Power Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N12, \\field Heating Compressor Power Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N13, \\field Heating Compressor Power Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N14; \\field Heating Compressor Power Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::OS_HeatPump_WaterToWater_EquationFit_Heating);
    OptionalIddObject oObj = IddObject::load("OS:HeatPump:WaterToWater:EquationFit:Heating",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_HeatPump_WaterToWater_EquationFit_Heating);
  return object;
}

IddObject createOS_HeatPump_WaterToWater_EquationFit_CoolingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:HeatPump:WaterToWater:EquationFit:Cooling,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,  \\field Source Side Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4,  \\field Source Side Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5,  \\field Load Side Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6,  \\field Load Side Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1,  \\field Rated Load Side Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "N2,  \\field Rated Source Side Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "N3,  \\field Rated Cooling Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W\n";
    ss << "N4,  \\field Rated Cooling Power Consumption\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W\n";
    ss << "N5,  \\field Cooling Capacity Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N6,  \\field Cooling Capacity Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N7,  \\field Cooling Capacity Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N8,  \\field Cooling Capacity Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N9,  \\field Cooling Capacity Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N10, \\field Cooling Compressor Power Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N11, \\field Cooling Compressor Power Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N12, \\field Cooling Compressor Power Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N13, \\field Cooling Compressor Power Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N14; \\field Cooling Compressor Power Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::OS_HeatPump_WaterToWater_EquationFit_Cooling);
    OptionalIddObject oObj = IddObject::load("OS:HeatPump:WaterToWater:EquationFit:Cooling",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_HeatPump_WaterToWater_EquationFit_Cooling);
  return object;
}

IddObject createOS_Chiller_Electric_EIRIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Chiller:Electric:EIR,\n";
    ss << "\\memo This chiller model is the empirical model from the DOE-2 building Energy\n";
    ss << "\\memo simulation program. Chiller performance at off-reference conditions is modeled\n";
    ss << "\\memo using three polynomial equations. Three curves objects are required.\n";
    ss << "\\min-fields 24\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "N1, \\field Reference Capacity\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "N2, \\field Reference COP\n";
    ss << "\\note Efficiency of the chiller compressor (cooling output/compressor energy input).\n";
    ss << "\\note Condenser fan power should not be included here.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0\n";
    ss << "N3, \\field Reference Leaving Chilled Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 6.67\n";
    ss << "N4, \\field Reference Entering Condenser Fluid Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 29.4\n";
    ss << "N5, \\field Reference Chilled Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0\n";
    ss << "\\default autosize\n";
    ss << "N6, \\field Reference Condenser Fluid Flow Rate\n";
    ss << "\\note This field is only used for Condenser Type = AirCooled or EvaporativelyCooled\n";
    ss << "\\note when Heat Recovery is specified\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0\n";
    ss << "\\default autosize\n";
    ss << "A3, \\field Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\note Cooling capacity as a function of CW supply temp and entering condenser temp\n";
    ss << "\\note curve = a + b*CWS + c*CWS**2 + d*ECT + e*ECT**2 + f*CWS*ECT\n";
    ss << "\\note CWS = supply (leaving) chilled water temperature(C)\n";
    ss << "\\note ECT = entering condenser fluid temperature(C)\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A4, \\field Electric Input to Cooling Output Ratio Function of Temperature Curve Name\n";
    ss << "\\note Electric Input Ratio (EIR) as a function of temperature\n";
    ss << "\\note EIR = 1/COP\n";
    ss << "\\note curve = a + b*CWS + c*CWS**2 + d*ECT + e*ECT**2 + f*CWS*ECT\n";
    ss << "\\note CWS = supply (leaving) chilled water temperature(C)\n";
    ss << "\\note ECT = entering condenser fluid temperature(C)\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A5, \\field Electric Input to Cooling Output Ratio Function of Part Load Ratio Curve Name\n";
    ss << "\\note Electric Input Ratio (EIR) as a function of Part Load Ratio (PLR)\n";
    ss << "\\note EIR = 1/COP\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note PLR = part load ratio (cooling load/steady state capacity)\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "N7, \\field Minimum Part Load Ratio\n";
    ss << "\\note Part load ratio below which the chiller starts cycling on/off to meet the load.\n";
    ss << "\\note Must be less than or equal to Maximum Part Load Ratio.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.1\n";
    ss << "N8, \\field Maximum Part Load Ratio\n";
    ss << "\\note Maximum allowable part load ratio. Must be greater than or equal to Minimum Part Load Ratio.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1.0\n";
    ss << "N9, \\field Optimum Part Load Ratio\n";
    ss << "\\note Optimum part load ratio where the chiller is most efficient.\n";
    ss << "\\note Must be greater than or equal to the Minimum Part Load Ratio\n";
    ss << "\\note and less than or equal to the Maximum Part Load Ratio.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1.0\n";
    ss << "N10, \\field Minimum Unloading Ratio\n";
    ss << "\\note Part load ratio where the chiller can no longer unload and false loading begins.\n";
    ss << "\\note Minimum unloading ratio must be greater than or equal to the Minimum Part Load Ratio\n";
    ss << "\\note and less than or equal to the Maximum Part Load Ratio.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.2\n";
    ss << "A6, \\field Chilled Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A7, \\field Chilled Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A8, \\field Condenser Inlet Node Name\n";
    ss << "\\note Not required if air-cooled or evaporativly-cooled\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A9, \\field Condenser Outlet Node Name\n";
    ss << "\\note Not required if air-cooled or evaporatively-cooled\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A10, \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\default AirCooled\n";
    ss << "\\key AirCooled\n";
    ss << "\\key WaterCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "N11, \\field Condenser Fan Power Ratio\n";
    ss << "\\note Use for air-cooled or evaporatively-cooled condensers.\n";
    ss << "\\note Ratio of condenser fan power to reference chiller capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N12, \\field Compressor Motor Efficiency\n";
    ss << "\\note Fraction of compressor electrical energy that must be rejected by the condenser.\n";
    ss << "\\note Enter 1.0 or leave this field blank for a hermetic compressor.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 1.0\n";
    ss << "N13, \\field Leaving Chilled Water Lower Temperature Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 2.0\n";
    ss << "A11, \\field Chiller Flow Mode\n";
    ss << "\\note Sets chilled water flow rate to either constant or variable.\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\key LeavingSetpointModulated\n";
    ss << "\\key NotModulated\n";
    ss << "\\default NotModulated\n";
    ss << "N14, \\field Design Heat Recovery Water Flow Rate\n";
    ss << "\\note If non-zero, then the heat recovery inlet and outlet node names must be entered.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "A12, \\field Heat Recovery Inlet Node Name\n";
    ss << "\\type alpha\n";
    ss << "A13, \\field Heat Recovery Outlet Node Name\n";
    ss << "\\type alpha\n";
    ss << "N15, \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1.0\n";
    ss << "N16, \\field Basin Heater Capacity\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled and for periods\n";
    ss << "\\note when the basin heater is available (field Basin Heater Operating Schedule Name).\n";
    ss << "\\note For this situation, the heater maintains the basin water temperature at the basin heater\n";
    ss << "\\note setpoint temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when the chiller is not operating.\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N17, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2\n";
    ss << "\\default 2.0\n";
    ss << "A14; \\field Basin Heater Operating Schedule Name\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_Chiller_Electric_EIR);
    OptionalIddObject oObj = IddObject::load("OS:Chiller:Electric:EIR",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Chiller_Electric_EIR);
  return object;
}

IddObject createOS_CentralHeatPumpSystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:CentralHeatPumpSystem,\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObjecta\n";
    ss << "\\required-field\n";
    ss << "A3,  \\field Control Method\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key SmartMixing\n";
    ss << "A3,  \\field Cooling Loop Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4,  \\field Cooling Loop Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5,  \\field Source Loop Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6,  \\field Source Loop Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A7,  \\field Heating Loop Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A8,  \\field Heating Loop Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1,  \\field Ancillary Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "A9,  \\field Ancillary Operation Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This value from this schedule is multiplied times the Ancillary Power\n";
    ss << "A10; \\field Chiller Heater Module List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";

    IddObjectType objType(IddObjectType::OS_CentralHeatPumpSystem);
    OptionalIddObject oObj = IddObject::load("OS:CentralHeatPumpSystem",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_CentralHeatPumpSystem);
  return object;
}

IddObject createOS_CentralHeatPumpSystem_ModuleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:CentralHeatPumpSystem:Module,\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\reference  CentralHeatPumpSystemModule\n";
    ss << "\\required-field\n";
    ss << "A3 , \\field Chiller Heater Modules Performance Component Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ChillerHeaterEIRNames\n";
    ss << "A4 , \\field Chiller Heater Modules Control Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\required-field\n";
    ss << "N1 ; \\field Number of Chiller Heater Modules\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_CentralHeatPumpSystem_Module);
    OptionalIddObject oObj = IddObject::load("OS:CentralHeatPumpSystem:Module",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_CentralHeatPumpSystem_Module);
  return object;
}

IddObject createOS_ChillerHeaterPerformance_Electric_EIRIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ChillerHeaterPerformance:Electric:EIR,\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ChillerHeaterEIRNames\n";
    ss << "N1 , \\field Reference Cooling Mode Evaporator Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Reference Cooling Mode COP\n";
    ss << "\\note Efficiency of the chiller compressor (cooling output/compressor energy input).\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3 , \\field Reference Cooling Mode Leaving Chilled Water Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N4 , \\field Reference Cooling Mode Entering Condenser Fluid Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N5 , \\field Reference Cooling Mode Leaving Condenser Water Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N6 , \\field Reference Heating Mode Cooling Capacity Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N7 , \\field Reference Heating Mode Cooling Power Input Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N8 , \\field Reference Heating Mode Leaving Chilled Water Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N9 , \\field Reference Heating Mode Leaving Condenser Water Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N10, \\field Reference Heating Mode Entering Condenser Fluid Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N11, \\field Heating Mode Entering Chilled Water Temperature Low Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "A3 , \\field Chilled Water Flow Mode Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\key VariableFlow\n";
    ss << "N12, \\field Design Chilled Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N13, \\field Design Condenser Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N14, \\field Design Hot Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N15, \\field Compressor Motor Efficiency\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A4 , \\field Condenser Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key WaterCooled\n";
    ss << "A5 , \\field Cooling Mode Temperature Curve Condenser Water Independent Variable\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key EnteringCondenser\n";
    ss << "\\key LeavingCondenser\n";
    ss << "A6 , \\field Cooling Mode Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A7 , \\field Cooling Mode Electric Input to Cooling Output Ratio Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A8 , \\field Cooling Mode Electric Input to Cooling Output Ratio Function of Part Load Ratio Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BicubicCurves\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "N16, \\field Cooling Mode Cooling Capacity Optimum Part Load Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "A9 , \\field Heating Mode Temperature Curve Condenser Water Independent Variable\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key EnteringCondenser\n";
    ss << "\\key LeavingCondenser\n";
    ss << "A10, \\field Heating Mode Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A11, \\field Heating Mode Electric Input to Cooling Output Ratio Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A12, \\field Heating Mode Electric Input to Cooling Output Ratio Function of Part Load Ratio Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BicubicCurves\n";
    ss << "\\object-list QuadraticCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "N17, \\field Heating Mode Cooling Capacity Optimum Part Load Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N18; \\field Sizing Factor\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";

    IddObjectType objType(IddObjectType::OS_ChillerHeaterPerformance_Electric_EIR);
    OptionalIddObject oObj = IddObject::load("OS:ChillerHeaterPerformance:Electric:EIR",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ChillerHeaterPerformance_Electric_EIR);
  return object;
}

IddObject createOS_Chiller_Absorption_IndirectIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Chiller:Absorption:Indirect,\n";
    ss << "\\memo This indirect absorption chiller model is an enhanced model from the\n";
    ss << "\\memo Building Loads and System Thermodynamics (BLAST) program.  Chiller\n";
    ss << "\\memo performance curves are generated by fitting catalog data to third order\n";
    ss << "\\memo polynomial equations. The chiller capacity is a function of condenser,\n";
    ss << "\\memo chilled water, and generator temperatures. The heat input is a function\n";
    ss << "\\memo of part-load ratio, condenser temperature, and chilled water temperature.\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "N1 , \\field Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "N2 , \\field Nominal Pumping Power\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "A3 , \\field Chilled Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4 , \\field Chilled Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5 , \\field Condenser Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6 , \\field Condenser Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N3 , \\field Minimum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "N4 , \\field Maximum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "N5 , \\field Optimum Part Load Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "N6 , \\field Design Condenser Inlet Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "\\note Used only when condenser flow rate is autosized.\n";
    ss << "N7 , \\field Condenser Inlet Temperature Lower Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "\\note Provides warnings when entering condenser temperature is below minimum.\n";
    ss << "\\note Capacity is not adjusted when entering condenser temperature is below minimum.\n";
    ss << "N8 , \\field Chilled Water Outlet Temperature Lower Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "\\note Capacity is adjusted when leaving chilled water temperature is below minimum.\n";
    ss << "N9 , \\field Design Chilled Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\note For variable flow this is the max flow & for constant flow this is the flow.\n";
    ss << "N10, \\field Design Condenser Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "A7 , \\field Chiller Flow Mode\n";
    ss << "\\note Select operating mode for fluid flow through the chiller. \"NotModulated\" is for\n";
    ss << "\\note either variable or constant pumping with flow controlled by the external plant system.\n";
    ss << "\\note \"ConstantFlow\" is for constant pumping with flow controlled by chiller to operate at\n";
    ss << "\\note full design flow rate.  \"LeavingSetpointModulated\" is for variable pumping with flow\n";
    ss << "\\note controlled by chiller to vary flow to target a leaving temperature setpoint.\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\key LeavingSetpointModulated\n";
    ss << "\\key NotModulated\n";
    ss << "\\required-field\n";
    ss << "A8,  \\field Generator Heat Input Function of Part Load Ratio Curve\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A9,  \\field Pump Electric Input Function of Part Load Ratio Curve\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A10 , \\field Generator Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note Enter the generator inlet node name which connects this chiller to a\n";
    ss << "\\note steam or hot water plant, otherwise leave this field blank.\n";
    ss << "\\note Generator nodes are used to model heat input to the chiller.\n";
    ss << "A11, \\field Generator Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note Enter the generator outlet node name which connects this chiller to a\n";
    ss << "\\note steam or hot water plant, otherwise leave this field blank.\n";
    ss << "\\note Generator nodes are used to model heat input to the chiller.\n";
    ss << "A12, \\field Capacity Correction Function of Condenser Temperature Curve\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Curve which shows the change in normalized capacity to changes in condenser temperature.\n";
    ss << "A13, \\field Capacity Correction Function of Chilled Water Temperature Curve\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Curve which shows the change in normalized capacity to changes in leaving chilled water temperature.\n";
    ss << "A14, \\field Capacity Correction Function of Generator Temperature Curve\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Used when generator fluid type is hot water\n";
    ss << "\\note Curve which shows the change in normalized capacity to changes in generator temperature.\n";
    ss << "A15, \\field Generator Heat Input Correction Function of Condenser Temperature Curve\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Curve which shows the change in normalized heat input to changes in condenser temperature.\n";
    ss << "A16, \\field Generator Heat Input Correction Function of Chilled Water Temperature Curve\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Curve which shows the change in normalized heat input to changes in leaving chilled water temperature.\n";
    ss << "A17, \\field Generator Heat Source Type\n";
    ss << "\\type choice\n";
    ss << "\\key HotWater\n";
    ss << "\\key Steam\n";
    ss << "\\required-field\n";
    ss << "\\note The Generator side of the chiller can be connected to a hot water or steam plant where the\n";
    ss << "\\note generator inlet and outlet nodes are connected to a plant loop. If the generator is not\n";
    ss << "\\note connected to a plant loop, and the generator inlet/outlet nodes are not used, this field should be\n";
    ss << "\\note specified as steam or left blank. When a plant is not used, the model assumes steam as the heat source.\n";
    ss << "N11, \\field Design Generator Fluid Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\note  For variable flow this is the max flow and for constant flow this is the flow.\n";
    ss << "N12, \\field Temperature Lower Limit Generator Inlet\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "\\note Provides warnings when entering generator temperature is below minimum.\n";
    ss << "\\note Capacity is not adjusted when entering generator temperature is below minimum.\n";
    ss << "N13, \\field Degree of Subcooling in Steam Generator\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 20.0\n";
    ss << "\\required-field\n";
    ss << "\\note This field is not used when the generator inlet/outlet nodes are not specified or\n";
    ss << "\\note the generator is connected to a hot water loop.\n";
    ss << "N14, \\field Degree of Subcooling in Steam Condensate Loop\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "\\note This field is not used when the generator inlet/outlet nodes are not specified or\n";
    ss << "\\note the generator is connected to a hot water loop.\n";
    ss << "N15; \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_Chiller_Absorption_Indirect);
    OptionalIddObject oObj = IddObject::load("OS:Chiller:Absorption:Indirect",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Chiller_Absorption_Indirect);
  return object;
}

IddObject createOS_Chiller_AbsorptionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Chiller:Absorption,\n";
    ss << "\\memo This indirect absorption chiller model is the empirical model from the\n";
    ss << "\\memo Building Loads and System Thermodynamics (BLAST) program.  Chiller\n";
    ss << "\\memo performance curves are generated by fitting catalog data to third order\n";
    ss << "\\memo polynomial equations.  Two sets of coefficients are required.\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "N1 , \\field Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Nominal Pumping Power\n";
    ss << "\\units W\n";
    ss << "\\required-field\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "A3 , \\field Chilled Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4 , \\field Chilled Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5 , \\field Condenser Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6 , \\field Condenser Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N3 , \\field Minimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "N4 , \\field Maximum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "N5 , \\field Optimum Part Load Ratio\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "N6 , \\field Design Condenser Inlet Temperature\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "N7 , \\field Design Chilled Water Flow Rate\n";
    ss << "\\note  For variable volume this is the max flow & for constant flow this is the flow.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\ip-units gal/min\n";
    ss << "N8 , \\field Design Condenser Water Flow Rate\n";
    ss << "\\note  The steam use coefficients below specify the\n";
    ss << "\\note  steam use as a fraction of chiller operating capacity\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\required-field\n";
    ss << "N9 , \\field Coefficient 1 of the Hot Water or Steam Use Part Load Ratio Curve\n";
    ss << "\\required-field\n";
    ss << "N10, \\field Coefficient 2 of the Hot Water or Steam Use Part Load Ratio Curve\n";
    ss << "\\required-field\n";
    ss << "N11, \\field Coefficient 3 of the Hot Water or Steam Use Part Load Ratio Curve\n";
    ss << "\\required-field\n";
    ss << "N12, \\field Coefficient 1 of the Pump Electric Use Part Load Ratio Curve\n";
    ss << "\\required-field\n";
    ss << "\\note  The pump electric use coefficients specify the\n";
    ss << "\\note  pumping power as a Fraction of Nominal pumping power\n";
    ss << "N13, \\field Coefficient 2 of the Pump Electric Use Part Load Ratio Curve\n";
    ss << "\\required-field\n";
    ss << "N14, \\field Coefficient 3 of the Pump Electric Use Part Load Ratio Curve\n";
    ss << "\\required-field\n";
    ss << "N15, \\field Chilled Water Outlet Temperature Lower Limit\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "A7 , \\field Generator Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A8 , \\field Generator Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A9 , \\field Chiller Flow Mode\n";
    ss << "\\note Select operating mode for fluid flow through the chiller. \"NotModulated\" is for\n";
    ss << "\\note either variable or constant pumping with flow controlled by the external plant system.\n";
    ss << "\\note \"ConstantFlow\" is for constant pumping with flow controlled by chiller to operate at\n";
    ss << "\\note full design flow rate.  \"LeavingSetpointModulated\" is for variable pumping with flow\n";
    ss << "\\note controlled by chiller to vary flow to target a leaving temperature setpoint.\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantFlow\n";
    ss << "\\key LeavingSetpointModulated\n";
    ss << "\\key NotModulated\n";
    ss << "\\required-field\n";
    ss << "A10 , \\field Generator Heat Source Type\n";
    ss << "\\type choice\n";
    ss << "\\key Steam\n";
    ss << "\\key HotWater\n";
    ss << "\\required-field\n";
    ss << "\\note The Generator side of the chiller can be connected to a hot water or steam plant where the\n";
    ss << "\\note generator inlet and outlet nodes are connected to a plant loop. If the generator is not\n";
    ss << "\\note connected to a plant loop, and the generator inlet/outlet nodes are not used, this field should be\n";
    ss << "\\note specified as steam or left blank. When a plant is not used, the model assumes steam as the heat source.\n";
    ss << "N16, \\field Design Generator Fluid Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\required-field\n";
    ss << "N17, \\field Degree of Subcooling in Steam Generator\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "\\note This field is not used when the generator inlet/outlet nodes are not specified or\n";
    ss << "\\note the generator is connected to a hot water loop.\n";
    ss << "N18; \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_Chiller_Absorption);
    OptionalIddObject oObj = IddObject::load("OS:Chiller:Absorption",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Chiller_Absorption);
  return object;
}

IddObject createOS_CoolingTower_SingleSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:CoolingTower:SingleSpeed,\n";
    ss << "\\min-fields 10\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note Tower Name\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4 , \\field Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 , \\field Design Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Leave field blank if tower performance input method is NominalCapacity\n";
    ss << "\\ip-units gal/min\n";
    ss << "N2 , \\field Design Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N3 , \\field Fan Power at Design Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "N4 , \\field U-Factor Times Area Value at Design Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 2100000.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Leave field blank if tower performance input method is NominalCapacity\n";
    ss << "N5 , \\field Air Flow Rate in Free Convection Regime\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autosizable\n";
    ss << "N6 , \\field U-Factor Times Area Value at Free Convection Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 300000.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autosizable\n";
    ss << "A5 , \\field Performance Input Method\n";
    ss << "\\type Choice\n";
    ss << "\\key UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\key NominalCapacity\n";
    ss << "\\default NominalCapacity\n";
    ss << "\\note User can define tower thermal performance by specifying the tower UA,\n";
    ss << "\\note the Design Air Flow Rate and the Design Water Flow Rate,\n";
    ss << "\\note or by specifying the tower nominal capacity\n";
    ss << "N7, \\field Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Nominal tower capacity with entering water at 35C (95F), leaving water at\n";
    ss << "\\note 29.44C (85F), entering air at 25.56C (78F) wet-bulb temperature and 35C (95F)\n";
    ss << "\\note dry-bulb temperature. Design water flow rate assumed to be 5.382E-8 m3/s per watt\n";
    ss << "\\note (3 gpm/ton). Nominal tower capacity times (1.25) gives the actual tower\n";
    ss << "\\note heat rejection at these operating conditions.\n";
    ss << "N8 , \\field Free Convection Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Tower capacity in free convection regime with entering water at 35C (95F),\n";
    ss << "\\note leaving water at 29.44C (85F), entering air at 25.56C (78F) wet-bulb temperature\n";
    ss << "\\note and 35C (95F) dry-bulb temperature. Design water flow rate assumed to be\n";
    ss << "\\note 5.382E-8 m3/s per watt of nominal tower capacity (3 gpm/ton). Tower free\n";
    ss << "\\note convection capacity times (1.25) gives the actual tower heat rejection at these\n";
    ss << "\\note operating conditions.\n";
    ss << "N9 , \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This heater maintains the basin water temperature at the basin heater setpoint\n";
    ss << "\\note temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when water is not flowing through the tower.\n";
    ss << "N10, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on\n";
    ss << "A6 , \\field Basin Heater Operating Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";
    ss << "A7 , \\field Evaporation Loss Mode\n";
    ss << "\\type choice\n";
    ss << "\\key LossFactor\n";
    ss << "\\key SaturatedExit\n";
    ss << "N11 , \\field Evaporation Loss Factor\n";
    ss << "\\type real\n";
    ss << "\\units percent/K\n";
    ss << "\\note Rate of water evaporation from the cooling tower and lost to the outdoor air [%/K]\n";
    ss << "\\note Evaporation loss is calculated as percentage of the circulating condenser water rate\n";
    ss << "\\note Value entered here is percent-per-degree K of temperature drop in the condenser water\n";
    ss << "\\note Typical values are from 0.15 to 0.27 [%/K].\n";
    ss << "\\default 0.2\n";
    ss << "N12, \\field Drift Loss Percent\n";
    ss << "\\type real\n";
    ss << "\\default 0.008\n";
    ss << "\\units percent\n";
    ss << "\\note Rate of drift loss as a percentage of circulating condenser water flow rate\n";
    ss << "\\note Typical values are between 0.002 and 0.2% The default value is 0.008%\n";
    ss << "A8 , \\field Blowdown Calculation Mode\n";
    ss << "\\type choice\n";
    ss << "\\key ConcentrationRatio\n";
    ss << "\\key ScheduledRate\n";
    ss << "N13, \\field Blowdown Concentration Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 3.0\n";
    ss << "\\note Characterizes the rate of blowdown in the cooling tower.\n";
    ss << "\\note Blowdown is water intentionally drained from the tower in order to offset the build up\n";
    ss << "\\note of solids in the water that would otherwise occur because of evaporation.\n";
    ss << "\\note Ratio of solids in the blowdown water to solids in the make up water.\n";
    ss << "\\note Typical values for tower operation are 3 to 5.  The default value is 3.\n";
    ss << "A9 , \\field Blowdown Makeup Water Usage Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Makeup water usage due to blowdown results from occasionally draining a small amount\n";
    ss << "\\note of water in the tower basin to purge scale or other contaminants to reduce their\n";
    ss << "\\note concentration in order to maintain an acceptable level of water quality.\n";
    ss << "\\note Schedule values should reflect water usage in m3/s.\n";
    ss << "A10 , \\field Outdoor Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A11, \\field Capacity Control\n";
    ss << "\\type choice\n";
    ss << "\\key FanCycling\n";
    ss << "\\key FluidBypass\n";
    ss << "\\default FanCycling\n";
    ss << "N14, \\field Number of Cells\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";
    ss << "A12, \\field Cell Control\n";
    ss << "\\type Choice\n";
    ss << "\\key MinimalCell\n";
    ss << "\\key MaximalCell\n";
    ss << "\\default MinimalCell\n";
    ss << "N15, \\field Cell Minimum  Water Flow Rate Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.33\n";
    ss << "\\note The allowable mininal fraction of the nominal flow rate per cell\n";
    ss << "N16, \\field Cell Maximum Water Flow Rate Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 1\n";
    ss << "\\default 2.5\n";
    ss << "\\note The allowable maximal fraction of the nominal flow rate per cell\n";
    ss << "N17; \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::OS_CoolingTower_SingleSpeed);
    OptionalIddObject oObj = IddObject::load("OS:CoolingTower:SingleSpeed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_CoolingTower_SingleSpeed);
  return object;
}

IddObject createOS_CoolingTower_TwoSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:CoolingTower:TwoSpeed,\n";
    ss << "\\min-fields 25\n";
    ss << "\\memo This tower model is based on Merkel's theory, which is also the basis\n";
    ss << "\\memo for the tower model in ASHRAE's HVAC1 Toolkit. The closed-circuit cooling tower\n";
    ss << "\\memo is modeled as a counter flow heat exchanger with a two-speed fan drawing air\n";
    ss << "\\memo through the tower (induced-draft configuration).\n";
    ss << "\\memo For a multi-cell tower, the capacity and air/water flow rate inputs are for the entire tower.\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingTowers\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4 , \\field Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 , \\field Design Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Leave field blank if Tower Performance Input Method is NominalCapacity\n";
    ss << "\\ip-units gal/min\n";
    ss << "N2 , \\field High Fan Speed Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N3 , \\field High Fan Speed Fan Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\note This is the fan motor electric input power at high speed\n";
    ss << "N4 , \\field High Fan Speed U-Factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 2100000.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Leave field blank if Tower Performance Input Method is NominalCapacity\n";
    ss << "N5 , \\field Low Fan Speed Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Low speed air flow rate must be less than high speed air flow rate\n";
    ss << "\\note Low speed air flow rate must be greater than free convection air flow rate\n";
    ss << "N6 , \\field Low Fan Speed Air Flow Rate Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate.\n";
    ss << "N7 , \\field Low Fan Speed Fan Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\note This is the fan motor electric input power at low speed\n";
    ss << "N8 , \\field Low Fan Speed Fan Power Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.16\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate.\n";
    ss << "N9 , \\field Low Fan Speed U-Factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 300000.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Leave field blank if tower Performance Input Method is NominalCapacity\n";
    ss << "\\note Low speed tower UA must be less than high speed tower UA\n";
    ss << "\\note Low speed tower UA must be greater than free convection tower UA\n";
    ss << "N10, \\field Low Fan Speed U-Factor Times Area Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.6\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate and\n";
    ss << "\\note the Performance Input Method is UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "N11, \\field Free Convection Regime Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autosizable\n";
    ss << "N12, \\field Free Convection Regime Air Flow Rate Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.1\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate.\n";
    ss << "N13, \\field Free Convection Regime U-Factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 300000.0\n";
    ss << "\\default 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Leave field blank if Tower Performance Input Method is NominalCapacity\n";
    ss << "N14, \\field Free Convection U-Factor Times Area Value Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.1\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate and\n";
    ss << "\\note the Performance Input Method is UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "A5 , \\field Performance Input Method\n";
    ss << "\\type choice\n";
    ss << "\\key UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\key NominalCapacity\n";
    ss << "\\default UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\note User can define tower thermal performance by specifying the tower UA,\n";
    ss << "\\note the Design Air Flow Rate and the Design Water Flow Rate,\n";
    ss << "\\note or by specifying the tower nominal capacity\n";
    ss << "N15, \\field Heat Rejection Capacity and Nominal Capacity Sizing Ratio\n";
    ss << "\\type real\n";
    ss << "\\default 1.25\n";
    ss << "N16, \\field High Speed Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Nominal tower capacity with entering water at 35C (95F), leaving water at\n";
    ss << "\\note 29.44C (85F), entering air at 25.56C (78F) wet-bulb temperature and 35C (95F)\n";
    ss << "\\note dry-bulb temperature, with the tower fan operating at high speed. Design water\n";
    ss << "\\note flow rate assumed to be 5.382E-8 m3/s per watt(3 gpm/ton). Nominal tower capacity\n";
    ss << "\\note times the Heat Rejection Capacity and Nominal Capacity Sizing Ratio (e.g. 1.25)\n";
    ss << "\\note gives the actual tower heat rejection at these operating conditions.\n";
    ss << "N17, \\field Low Speed Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Nominal tower capacity with entering water at 35C (95F), leaving water at\n";
    ss << "\\note 29.44C (85F), entering air at 25.56C (78F) wet-bulb temperature and 35C (95F)\n";
    ss << "\\note dry-bulb temperature, with the tower fan operating at low speed. Design water flow\n";
    ss << "\\note rate assumed to be 5.382E-8 m3/s per watt of tower high-speed nominal capacity\n";
    ss << "\\note (3 gpm/ton). Nominal tower capacity times the Heat Rejection Capacity and Nominal\n";
    ss << "\\note Capacity Sizing Ratio (e.g. 1.25) gives the actual tower heat\n";
    ss << "\\note rejection at these operating conditions.\n";
    ss << "N18, \\field Low Speed Nominal Capacity Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.5\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate\n";
    ss << "N19, \\field Free Convection Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Tower capacity in free convection regime with entering water at 35C (95F),\n";
    ss << "\\note leaving water at 29.44C (85F), entering air at 25.56C (78F) wet-bulb temperature\n";
    ss << "\\note and 35C (95F) dry-bulb temperature. Design water flow rate assumed to be\n";
    ss << "\\note 5.382E-8 m3/s per watt of tower high-speed nominal capacity (3 gpm/ton). Tower\n";
    ss << "\\note free convection capacity times the Heat Rejection Capacity and Nominal Capacity Sizing Ratio\n";
    ss << "\\note (e.g. 1.25)  gives the actual tower heat rejection at these operating conditions\n";
    ss << "N20, \\field Free Convection Nominal Capacity Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\default 0.1\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate\n";
    ss << "N21, \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note This heater maintains the basin water temperature at the basin heater setpoint\n";
    ss << "\\note temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when water is not flowing through the tower.\n";
    ss << "N22, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 2.0\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on\n";
    ss << "A6 , \\field Basin Heater Operating Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";
    ss << "A7 , \\field Evaporation Loss Mode\n";
    ss << "\\type choice\n";
    ss << "\\key LossFactor\n";
    ss << "\\key SaturatedExit\n";
    ss << "N23, \\field Evaporation Loss Factor\n";
    ss << "\\type real\n";
    ss << "\\units percent/K\n";
    ss << "\\note Rate of water evaporated from the cooling tower and lost to the outdoor air [%/K]\n";
    ss << "\\note Evaporation loss is calculated as percentage of the circulating condenser water rate\n";
    ss << "\\note Value entered here is percent-per-degree K of temperature drop in the condenser water\n";
    ss << "\\note Typical values are from 0.15 to 0.27 [%/K].\n";
    ss << "\\default 0.2\n";
    ss << "N24, \\field Drift Loss Percent\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\default 0.008\n";
    ss << "\\note Rate of drift loss as a percentage of circulating condenser water flow rate\n";
    ss << "\\note Typical values are between 0.002 and 0.2% The default value is 0.008%\n";
    ss << "A8 , \\field Blowdown Calculation Mode\n";
    ss << "\\type choice\n";
    ss << "\\key ConcentrationRatio\n";
    ss << "\\key ScheduledRate\n";
    ss << "N25, \\field Blowdown Concentration Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 3.0\n";
    ss << "\\note Characterizes the rate of blowdown in the cooling tower.\n";
    ss << "\\note Blowdown is water intentionally drained from the tower in order to offset the build up\n";
    ss << "\\note of solids in the water that would otherwise occur because of evaporation.\n";
    ss << "\\note Ratio of solids in the blowdown water to solids in the make up water.\n";
    ss << "\\note Typical values for tower operation are 3 to 5.  The default value is 3.\n";
    ss << "A9 , \\field Blowdown Makeup Water Usage Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Makeup water usage due to blowdown results from occasionally draining some amount\n";
    ss << "\\note of water in the tower basin to purge scale or other contaminants to reduce their\n";
    ss << "\\note concentration in order to maintain an acceptable level of water quality.\n";
    ss << "\\note Schedule values should reflect water usage in m3/s.\n";
    ss << "A10, \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A11, \\field Outdoor Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N26, \\field Number of Cells\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";
    ss << "A12, \\field Cell Control\n";
    ss << "\\type choice\n";
    ss << "\\key MinimalCell\n";
    ss << "\\key MaximalCell\n";
    ss << "\\default MinimalCell\n";
    ss << "N27, \\field Cell Minimum  Water Flow Rate Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.33\n";
    ss << "\\note The allowable mininal fraction of the nominal flow rate per cell\n";
    ss << "N28, \\field Cell Maximum Water Flow Rate Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 1\n";
    ss << "\\default 2.5\n";
    ss << "\\note The allowable maximal fraction of the nominal flow rate per cell\n";
    ss << "N29; \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::OS_CoolingTower_TwoSpeed);
    OptionalIddObject oObj = IddObject::load("OS:CoolingTower:TwoSpeed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_CoolingTower_TwoSpeed);
  return object;
}

IddObject createOS_CoolingTower_VariableSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:CoolingTower:VariableSpeed,\n";
    ss << "\\min-fields 16\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingTowers\n";
    ss << "\\note Tower Name\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Water Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4 , \\field Water Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5 , \\field Model Type\n";
    ss << "\\type choice\n";
    ss << "\\key CoolToolsCrossFlow\n";
    ss << "\\key CoolToolsUserDefined\n";
    ss << "\\key YorkCalc\n";
    ss << "\\key YorkCalcUserDefined\n";
    ss << "A6 , \\field Model Coefficient\n";
    ss << "\\type object-list\n";
    ss << "\\object-list VariableSpeedTowerCoefficient\n";
    ss << "\\note Name of the tower model coefficient object.\n";
    ss << "\\note Used only when tower Model Type is either CoolToolsUserDefined or YorkCalcUserDefined.\n";
    ss << "N1 , \\field Design Inlet Air Wet-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 20.0\n";
    ss << "\\note Enter the tower's design inlet air wet-bulb temperature\n";
    ss << "N2 , \\field Design Approach Temperature\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the approach temperature corresponding to the design inlet air\n";
    ss << "\\note wet-bulb temperature and design range temperature.\n";
    ss << "\\note Design approach temp = outlet water temperature minus inlet air wet-bulb temperature\n";
    ss << "\\note at design conditions.\n";
    ss << "N3 , \\field Design Range Temperature\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Enter the range temperature corresponding to the design inlet air\n";
    ss << "\\note wet-bulb temperature and design approach temperature.\n";
    ss << "\\note Design range = inlet water temperature minus outlet water temperature\n";
    ss << "\\note at design conditions.\n";
    ss << "N4 , \\field Design Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\note Water flow rate through the tower at design conditions\n";
    ss << "N5 , \\field Design Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Design (maximum) air flow rate through the tower\n";
    ss << "N6 , \\field Design Fan Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\note Enter the fan motor electric input power at design (max) air flow through the tower\n";
    ss << "\\note Standard conversion for horsepower is 1 HP = 745.7 W\n";
    ss << "A7 , \\field Fan Power Ratio Function of Air Flow Rate Ratio Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CubicCurves\n";
    ss << "\\note FPR = a + b*AFR + c*AFR**2 + d*AFR**3\n";
    ss << "\\note FPR = fraction of the design fan power\n";
    ss << "\\note AFR = fraction of the design air flow rate\n";
    ss << "\\note If left blank, then fan power is assumed to be proportional to\n";
    ss << "\\note (air flow rate ratio)^3\n";
    ss << "N7 , \\field Minimum Air Flow Rate Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.2\n";
    ss << "\\maximum 0.5\n";
    ss << "\\note Enter the minimum air flow rate ratio. This is typically determined by the variable\n";
    ss << "\\note speed drive that controls the fan motor speed. Valid entries are from 0.2 to 0.5.\n";
    ss << "N8 , \\field Fraction of Tower Capacity in Free Convection Regime\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.2\n";
    ss << "\\note Enter the fraction of tower capacity in the free convection regime. This is the\n";
    ss << "\\note fraction of the tower capacity, at the current inlet air wet-bulb temperature,\n";
    ss << "\\note that is available when the tower fan is off. Manufacturers typically estimate the\n";
    ss << "\\note free convection capacity at approximately 10-15%. Values are entered as a fraction\n";
    ss << "\\note and can range from 0 to 0.2.\n";
    ss << "N9 , \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note This heater maintains the basin water temperature at the basin heater setpoint\n";
    ss << "\\note temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when water is not flowing through the tower.\n";
    ss << "N10, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on\n";
    ss << "A8 , \\field Basin Heater Operating Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";
    ss << "A9 , \\field Evaporation Loss Mode\n";
    ss << "\\type choice\n";
    ss << "\\key LossFactor\n";
    ss << "\\key SaturatedExit\n";
    ss << "N11, \\field Evaporation Loss Factor\n";
    ss << "\\type real\n";
    ss << "\\units percent/K\n";
    ss << "\\note Rate of water evaporated from the cooling tower and lost to the outdoor air [%/K]\n";
    ss << "\\note Evaporation loss is calculated as percentage of the circulating condenser water rate\n";
    ss << "\\note Value entered here is percent-per-degree K of temperature drop in the condenser water\n";
    ss << "\\note Typical values are from 0.15 to 0.27 [percent/K].\n";
    ss << "\\default 0.2\n";
    ss << "N12, \\field Drift Loss Percent\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\note Rate of drift loss as a percentage of circulating condenser water flow rate\n";
    ss << "\\note Typical values are between 0.002 and 0.2% The default value is 0.008%\n";
    ss << "A10 , \\field Blowdown Calculation Mode\n";
    ss << "\\type choice\n";
    ss << "\\key ConcentrationRatio\n";
    ss << "\\key ScheduledRate\n";
    ss << "N13, \\field Blowdown Concentration Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 2.0\n";
    ss << "\\note Characterizes the rate of blowdown in the cooling tower.\n";
    ss << "\\note Blowdown is water intentionally drained from the tower in order to offset the build up\n";
    ss << "\\note of solids in the water that would otherwise occur because of evaporation.\n";
    ss << "\\note Ratio of solids in the blowdown water to solids in the make up water.\n";
    ss << "\\note Typical values for tower operation are 3 to 5.  The default value is 3.\n";
    ss << "A11, \\field Blowdown Makeup Water Usage Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Makeup water usage due to blowdown results from occasionally draining a small amount\n";
    ss << "\\note of water in the tower basin to purge scale or other contaminants to reduce their\n";
    ss << "\\note concentration in order to maintain an acceptable level of water quality.\n";
    ss << "\\note Schedule values should reflect water usage in m3/s.\n";
    ss << "A12, \\field Supply Water Storage Tank\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A13, \\field Outdoor Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N14, \\field Number of Cells\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "A13, \\field Cell Control\n";
    ss << "\\type Choice\n";
    ss << "\\key MinimalCell\n";
    ss << "\\key MaximalCell\n";
    ss << "N15, \\field Cell Minimum  Water Flow Rate Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note The allowable mininal fraction of the nominal flow rate per cell\n";
    ss << "N16, \\field Cell Maximum Water Flow Rate Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 1\n";
    ss << "\\note The allowable maximal fraction of the nominal flow rate per cell\n";
    ss << "N17; \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";

    IddObjectType objType(IddObjectType::OS_CoolingTower_VariableSpeed);
    OptionalIddObject oObj = IddObject::load("OS:CoolingTower:VariableSpeed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_CoolingTower_VariableSpeed);
  return object;
}

IddObject createOS_CoolingTowerPerformance_CoolToolsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:CoolingTowerPerformance:CoolTools,\n";
    ss << "\\min-fields 45\n";
    ss << "\\memo This object is used to define coefficients for the approach temperature\n";
    ss << "\\memo correlation for a variable speed cooling tower when tower Model Type is\n";
    ss << "\\memo specified as CoolToolsUserDefined in the object CoolingTower:VariableSpeed.\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference VariableSpeedTowerCoefficient\n";
    ss << "N1 , \\field Minimum Inlet Air Wet-Bulb Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Minimum valid inlet air wet-bulb temperature for this approach\n";
    ss << "\\note temperature correlation.\n";
    ss << "N2 , \\field Maximum Inlet Air Wet-Bulb Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Maximum valid inlet air wet-bulb temperature for this approach\n";
    ss << "\\note temperature correlation.\n";
    ss << "N3 , \\field Minimum Range Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Minimum valid range temperature for this approach temperature\n";
    ss << "\\note correlation.\n";
    ss << "N4 , \\field Maximum Range Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Maximum valid range temperature for this approach temperature\n";
    ss << "\\note correlation.\n";
    ss << "N5 , \\field Minimum Approach Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Minimum valid approach temperature for this correlation.\n";
    ss << "N6 , \\field Maximum Approach Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Maximum valid approach temperature for this correlation.\n";
    ss << "N7 , \\field Minimum Water Flow Rate Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note Minimum valid water flow rate ratio for this approach\n";
    ss << "\\note temperature correlation.\n";
    ss << "N8 , \\field Maximum Water Flow Rate Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note Maximum valid water flow rate ratio for this approach\n";
    ss << "\\note temperature correlation.\n";
    ss << "N9 , \\field Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N10, \\field Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N11, \\field Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N12, \\field Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N13, \\field Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N14, \\field Coefficient 6\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N15, \\field Coefficient 7\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N16, \\field Coefficient 8\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N17, \\field Coefficient 9\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N18, \\field Coefficient 10\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N19, \\field Coefficient 11\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N20, \\field Coefficient 12\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N21, \\field Coefficient 13\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N22, \\field Coefficient 14\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N23, \\field Coefficient 15\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N24, \\field Coefficient 16\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N25, \\field Coefficient 17\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N26, \\field Coefficient 18\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N27, \\field Coefficient 19\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N28, \\field Coefficient 20\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N29, \\field Coefficient 21\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N30, \\field Coefficient 22\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N31, \\field Coefficient 23\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N32, \\field Coefficient 24\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N33, \\field Coefficient 25\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N34, \\field Coefficient 26\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N35, \\field Coefficient 27\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N36, \\field Coefficient 28\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N37, \\field Coefficient 29\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N38, \\field Coefficient 30\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N39, \\field Coefficient 31\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N40, \\field Coefficient 32\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N41, \\field Coefficient 33\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N42, \\field Coefficient 34\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N43; \\field Coefficient 35\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::OS_CoolingTowerPerformance_CoolTools);
    OptionalIddObject oObj = IddObject::load("OS:CoolingTowerPerformance:CoolTools",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_CoolingTowerPerformance_CoolTools);
  return object;
}

IddObject createOS_CoolingTowerPerformance_YorkCalcIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:CoolingTowerPerformance:YorkCalc,\n";
    ss << "\\min-fields 38\n";
    ss << "\\memo This object is used to define coefficients for the approach temperature\n";
    ss << "\\memo correlation for a variable speed cooling tower when tower Model Type is\n";
    ss << "\\memo specified as YorkCalcUserDefined in the object CoolingTower:VariableSpeed.\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference VariableSpeedTowerCoefficient\n";
    ss << "N1 , \\field Minimum Inlet Air Wet-Bulb Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Minimum valid inlet air wet-bulb temperature for this approach\n";
    ss << "\\note temperature correlation.\n";
    ss << "N2 , \\field Maximum Inlet Air Wet-Bulb Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Maximum valid inlet air wet-bulb temperature for this approach\n";
    ss << "\\note temperature correlation.\n";
    ss << "N3 , \\field Minimum Range Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Minimum valid range temperature for this approach temperature\n";
    ss << "\\note correlation.\n";
    ss << "N4 , \\field Maximum Range Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Maximum valid range temperature for this approach temperature\n";
    ss << "\\note correlation.\n";
    ss << "N5 , \\field Minimum Approach Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Minimum valid approach temperature for this correlation.\n";
    ss << "N6 , \\field Maximum Approach Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\note Maximum valid approach temperature for this correlation.\n";
    ss << "N7 , \\field Minimum Water Flow Rate Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note Minimum valid water flow rate ratio for this approach\n";
    ss << "\\note temperature correlation.\n";
    ss << "N8 , \\field Maximum Water Flow Rate Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note Maximum valid water flow rate ratio for this approach\n";
    ss << "\\note temperature correlation.\n";
    ss << "N9 , \\field Maximum Liquid to Gas Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note Maximum liquid (water) to gas (air) ratio for this approach\n";
    ss << "\\note temperature correlation.\n";
    ss << "N10, \\field Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N11, \\field Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N12, \\field Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N13, \\field Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N14, \\field Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N15, \\field Coefficient 6\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N16, \\field Coefficient 7\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N17, \\field Coefficient 8\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N18, \\field Coefficient 9\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N19, \\field Coefficient 10\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N20, \\field Coefficient 11\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N21, \\field Coefficient 12\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N22, \\field Coefficient 13\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N23, \\field Coefficient 14\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N24, \\field Coefficient 15\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N25, \\field Coefficient 16\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N26, \\field Coefficient 17\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N27, \\field Coefficient 18\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N28, \\field Coefficient 19\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N29, \\field Coefficient 20\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N30, \\field Coefficient 21\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N31, \\field Coefficient 22\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N32, \\field Coefficient 23\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N33, \\field Coefficient 24\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N34, \\field Coefficient 25\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N35, \\field Coefficient 26\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N36; \\field Coefficient 27\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::OS_CoolingTowerPerformance_YorkCalc);
    OptionalIddObject oObj = IddObject::load("OS:CoolingTowerPerformance:YorkCalc",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_CoolingTowerPerformance_YorkCalc);
  return object;
}

IddObject createOS_DistrictCoolingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:DistrictCooling,\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Chilled Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4 , \\field Chilled Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 ; \\field Nominal Capacity\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_DistrictCooling);
    OptionalIddObject oObj = IddObject::load("OS:DistrictCooling",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_DistrictCooling);
  return object;
}

IddObject createOS_DistrictHeatingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:DistrictHeating,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Hot Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4 , \\field Hot Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 ; \\field Nominal Capacity\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_DistrictHeating);
    OptionalIddObject oObj = IddObject::load("OS:DistrictHeating",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_DistrictHeating);
  return object;
}

IddObject createOS_GroundHeatExchanger_VerticalIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:GroundHeatExchanger:Vertical,\n";
    ss << "\\extensible:2\n";
    ss << "\\min-fields 21\n";
    ss << "\\max-fields 219\n";
    ss << "\\memo Variable short time step vertical ground heat exchanger model based on\n";
    ss << "\\memo Yavuztruk, C., J.D.Spitler. 1999. A Short Time Step response Factor Model for\n";
    ss << "\\memo Vertical Ground Loop Heat Exchangers\n";
    ss << "\\memo The Fluid Type in the associated condenser loop must be same for which the\n";
    ss << "\\memo g-functions below are calculated.\n";
    ss << "A1,   \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,   \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,   \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4,   \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1,   \\field Maximum Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N2,   \\field Number of Bore Holes\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3,   \\field Bore Hole Length\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "N4,   \\field Bore Hole Radius\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "N5,   \\field Ground Thermal Conductivity\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\ip-units Btu-in/hr-ft2-R\n";
    ss << "\\minimum> 0.0\n";
    ss << "N6,   \\field Ground Thermal Heat Capacity\n";
    ss << "\\type real\n";
    ss << "\\units J/m3-K\n";
    ss << "\\minimum> 0.0\n";
    ss << "N7,   \\field Ground Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "N8,   \\field Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N9,   \\field Grout Thermal Conductivity\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\ip-units Btu-in/hr-ft2-R\n";
    ss << "\\minimum> 0.0\n";
    ss << "N10,  \\field Pipe Thermal Conductivity\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\ip-units Btu-in/hr-ft2-R\n";
    ss << "\\minimum> 0.0\n";
    ss << "N11,  \\field Pipe Out Diameter\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units in\n";
    ss << "N12,  \\field U-Tube Distance\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "N13,  \\field Pipe Thickness\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units in\n";
    ss << "N14,  \\field Maximum Length of Simulation\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N15,  \\field G-Function Reference Ratio\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.0005\n";
    ss << "N16,  \\field G-Function Ln(T/Ts) Value\n";
    ss << "\\type real\n";
    ss << "\\begin-extensible\n";
    ss << "N17;  \\field G-Function G Value\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::OS_GroundHeatExchanger_Vertical);
    OptionalIddObject oObj = IddObject::load("OS:GroundHeatExchanger:Vertical",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_GroundHeatExchanger_Vertical);
  return object;
}

IddObject createOS_GroundHeatExchanger_HorizontalTrenchIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:GroundHeatExchanger:HorizontalTrench,\n";
    ss << "\\memo This models a horizontal heat exchanger placed in a series of trenches\n";
    ss << "\\memo The model uses the PipingSystem:Underground underlying algorithms,\n";
    ss << "\\memo but provides a more usable input interface.\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4 , \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 , \\field Design Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "N2 , \\field Trench Length in Pipe Axial Direction\n";
    ss << "\\note This is the total pipe axial length of the heat exchanger\n";
    ss << "\\note If all pipe trenches are parallel, this is the length of a\n";
    ss << "\\note single trench.  If a single, long run of pipe is used with one\n";
    ss << "\\note trench, this is the full length of the pipe run.\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units ft\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field Number of Trenches\n";
    ss << "\\note This is the number of horizontal legs that will be used\n";
    ss << "\\note in the entire heat exchanger, one pipe per trench\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\required-field\n";
    ss << "N4 , \\field Horizontal Spacing Between Pipes\n";
    ss << "\\note This represents the average horizontal spacing between any two\n";
    ss << "\\note trenches for heat exchangers that have multiple trenches\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "N5 , \\field Pipe Inner Diameter\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units in\n";
    ss << "\\required-field\n";
    ss << "N6 , \\field Pipe Outer Diameter\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units in\n";
    ss << "\\required-field\n";
    ss << "N7 , \\field Burial Depth\n";
    ss << "\\note This is the burial depth of the pipes, or the trenches\n";
    ss << "\\note containing the pipes\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units ft\n";
    ss << "\\required-field\n";
    ss << "N8 , \\field Soil Thermal Conductivity\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "N9 , \\field Soil Density\n";
    ss << "\\type real\n";
    ss << "\\units kg/m3\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "N10, \\field Soil Specific Heat\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units J/kg-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "N11, \\field Pipe Thermal Conductivity\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "N12, \\field Pipe Density\n";
    ss << "\\type real\n";
    ss << "\\units kg/m3\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "N13, \\field Pipe Specific Heat\n";
    ss << "\\type real\n";
    ss << "\\units J/kg-K\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "N14, \\field Soil Moisture Content Percent\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 100\n";
    ss << "\\required-field\n";
    ss << "N15, \\field Soil Moisture Content Percent at Saturation\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 100\n";
    ss << "\\required-field\n";
    ss << "A5, \\field Ground Temperature Model\n";
    ss << "\\type choice\n";
    ss << "\\key SiteGroundTemperature\n";
    ss << "\\key KusudaAchenbach\n";
    ss << "N16, \\field Kusuda-Achenbach Average Surface Temperature\n";
    ss << "\\note This is the parameter for average annual surface temperature\n";
    ss << "\\note This is an optional input in that if it is missing, a\n";
    ss << "\\note Site:GroundTemperature:Shallow object must be found in the input\n";
    ss << "\\note The undisturbed ground temperature will be approximated from this object\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "N17, \\field Kusuda-Achenbach Average Amplitude of Surface Temperature\n";
    ss << "\\note This is the parameter for annual average amplitude from average surface temperature\n";
    ss << "\\note This is an optional input in that if it is missing, a\n";
    ss << "\\note Site:GroundTemperature:Shallow object must be found in the input\n";
    ss << "\\note The undisturbed ground temperature will be approximated from this object\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\required-field\n";
    ss << "N18, \\field Kusuda-Achenbach Phase Shift of Minimum Surface Temperature\n";
    ss << "\\note This is the parameter for phase shift from minimum surface temperature\n";
    ss << "\\note This is an optional input in that if it is missing, a\n";
    ss << "\\note Site:GroundTemperature:Shallow object must be found in the input\n";
    ss << "\\note The undisturbed ground temperature will be approximated from this object\n";
    ss << "\\type real\n";
    ss << "\\units days\n";
    ss << "\\required-field\n";
    ss << "N19; \\field Evapotranspiration Ground Cover Parameter\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.5\n";
    ss << "\\required-field\n";
    ss << "\\note This specifies the ground cover effects during evapotranspiration\n";
    ss << "\\note  calculations.  The value roughly represents the following cases:\n";
    ss << "\\note  = 0   : concrete or other solid, non-permeable ground surface material\n";
    ss << "\\note  = 0.5 : short grass, much like a manicured lawn\n";
    ss << "\\note  = 1   : standard reference state (12 cm grass)\n";
    ss << "\\note  = 1.5 : wild growth\n";

    IddObjectType objType(IddObjectType::OS_GroundHeatExchanger_HorizontalTrench);
    OptionalIddObject oObj = IddObject::load("OS:GroundHeatExchanger:HorizontalTrench",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_GroundHeatExchanger_HorizontalTrench);
  return object;
}

IddObject createOS_Coil_Cooling_CooledBeamIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Cooling:CooledBeam,\n";
    ss << "\\min-fields 13\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference CoolingCoilCooledBeam\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 ,\\field Chilled Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4 ,\\field Chilled Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1, \\field Coil Surface Area per Coil Length\n";
    ss << "\\type real\n";
    ss << "\\units m2/m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 5.422\n";
    ss << "N2 ,\\field Model Parameter a\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 15.3\n";
    ss << "N3 , \\field Model Parameter n1\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N4, \\field Model Parameter n2\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.84\n";
    ss << "N5, \\field Model Parameter n3\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.12\n";
    ss << "N6, \\field Model Parameter a0\n";
    ss << "\\note Free area of the coil in plan view per unit beam length\n";
    ss << "\\type real\n";
    ss << "\\units m2/m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.171\n";
    ss << "N7, \\field Model Parameter K1\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0057\n";
    ss << "N8, \\field Model Parameter n\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.4\n";
    ss << "N9; \\field Leaving Pipe Inside Diameter\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.0145\n";

    IddObjectType objType(IddObjectType::OS_Coil_Cooling_CooledBeam);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Cooling:CooledBeam",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Cooling_CooledBeam);
  return object;
}

IddObject createOS_Coil_Cooling_DX_SingleSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Cooling:DX:SingleSpeed,\n";
    ss << "\\min-fields 15\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference CoolingCoilsDX\n";
    ss << "\\reference CoolingCoilsDXSingleSpeed\n";
    ss << "\\reference CoolingCoilsDXMultiModeOrSingleSpeed\n";
    ss << "\\reference CoolingCoilsDXBypassFactorEmpirical\n";
    ss << "\\reference DesuperHeatingCoilSources\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Rated Total Cooling Capacity\n";
    ss << "\\note gross capacity excluding supply air fan heat\n";
    ss << "\\note rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "N2, \\field Rated Sensible Heat Ratio\n";
    ss << "\\note Rated sensible heat ratio (gross sensible capacity/gross total capacity)\n";
    ss << "\\note sensible and total capacities do not include supply fan heat\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1\n";
    ss << "N3, \\field Rated COP\n";
    ss << "\\note Gross cooling capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply fan heat or supply fan electrical energy input\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 3.0\n";
    ss << "N4, \\field Rated Air Flow Rate\n";
    ss << "\\note Flow rate corresponding to rated total cooling capacity, Rated SHR and Rated COP\n";
    ss << "\\note should be between 0.00004027 m3/s and .00006041 m3/s per watt of rated total cooling capacity\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "N5, \\field Rated Evaporator Fan Power Per Volume Flow Rate\n";
    ss << "\\note Enter the evaporator fan power per air volume flow rate at the rated test conditions.\n";
    ss << "\\note The test conditions vary external static pressure based on total cooling capacity.\n";
    ss << "\\note This value is only used to calculate Seasonal Energy Efficiency Ratio (SEER), Energy\n";
    ss << "\\note Efficiency Ratio (EER), Integrated Energy Efficiency Ratio (IEER), and the Standard Rating\n";
    ss << "\\note (Net) Cooling Capacity which will be outputs in the EnergyPlus eio file.  This value is not\n";
    ss << "\\note used for modeling the evaporator fan during simulations.\n";
    ss << "\\type real\n";
    ss << "\\units W/(m3/s)\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1250\n";
    ss << "\\default 773.3\n";
    ss << "A4, \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6, \\field Total Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*edb + e*edb**2 + f*wb*edb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note edb = dry-bulb temperature seen by the condenser (C)\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A7, \\field Total Cooling Capacity Function of Flow Fraction Curve Name\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = Fraction of the full load flow\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A8, \\field Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*edb + e*edb**2 + f*wb*edb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note edb = dry-bulb temperature seen by the condenser (C)\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A9, \\field Energy Input Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = Fraction of the full load flow\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A10, \\field Part Load Fraction Correlation Curve Name\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLR = part load ratio (cooling load/steady state capacity)\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "N6, \\field Nominal Time for Condensate Removal to Begin\n";
    ss << "\\note The nominal time for condensate to begin leaving the coil's condensate\n";
    ss << "\\note drain line at the coil's rated air flow rate and temperature conditions.\n";
    ss << "\\note Nominal time is equal to the ratio of the energy of the coil's maximum\n";
    ss << "\\note condensate holding capacity (J) to the coil's steady state latent capacity (W).\n";
    ss << "\\note Suggested value is 1000; zero value means latent degradation model is disabled.\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 3000\n";
    ss << "\\default 0.0\n";
    ss << "N7, \\field Ratio of Initial Moisture Evaporation Rate and Steady State Latent Capacity\n";
    ss << "\\note Ratio of the initial moisture evaporation rate from the cooling coil (when\n";
    ss << "\\note the compressor first turns off) and the coil's steady state latent capacity\n";
    ss << "\\note at rated air flow rate and temperature conditions. Suggested value is 1.5; zero value\n";
    ss << "\\note means latent degradation model is disabled.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 5\n";
    ss << "\\default 0.0\n";
    ss << "N8, \\field Maximum Cycling Rate\n";
    ss << "\\note The maximum on-off cycling Rate for the compressor, which occurs at 50% run time\n";
    ss << "\\note fraction. Suggested value is 3; zero value means latent degradation model is disabled.\n";
    ss << "\\type real\n";
    ss << "\\units cycles/hr\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 5\n";
    ss << "\\default 0.0\n";
    ss << "N9, \\field Latent Capacity Time Constant\n";
    ss << "\\note Time constant for the cooling coil's latent capacity to reach steady state after\n";
    ss << "\\note startup. Suggested value is 45; zero value means latent degradation model is disabled.\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 500\n";
    ss << "\\default 0.0\n";
    ss << "A11, \\field Condenser Air Inlet Node Name\n";
    ss << "\\note Enter the name of an outdoor air node. This node name is also specified in\n";
    ss << "\\note an OutdoorAir:Node or OutdoorAir:NodeList object.\n";
    ss << "\\type alpha\n";
    ss << "A12, \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\default AirCooled\n";
    ss << "\\key AirCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "N10, \\field Evaporative Condenser Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.9\n";
    ss << "N11, \\field Evaporative Condenser Air Flow Rate\n";
    ss << "\\note Used to calculate evaporative condenser water use\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "N12, \\field Evaporative Condenser Pump Rated Power Consumption\n";
    ss << "\\note Rated power consumed by the evaporative condenser's water pump\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N13, \\field Crankcase Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\ip-units Btu/h\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N14, \\field Maximum Outdoor Dry-Bulb Temperature for Crankcase Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0\n";
    ss << "\\default 10.0\n";
    ss << "A13, \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A14, \\field Condensate Collection Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "N15, \\field Basin Heater Capacity\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled and for periods\n";
    ss << "\\note when the basin heater is available (field Basin Heater Operating Schedule Name).\n";
    ss << "\\note For this situation, the heater maintains the basin water temperature at the basin heater\n";
    ss << "\\note setpoint temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when the DX coil is off.\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N16, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2\n";
    ss << "\\default 2.0\n";
    ss << "A15; \\field Basin Heater Operating Schedule Name\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_Coil_Cooling_DX_SingleSpeed);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Cooling:DX:SingleSpeed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Cooling_DX_SingleSpeed);
  return object;
}

IddObject createOS_Coil_Cooling_DX_TwoStageWithHumidityControlModeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Cooling:DX:TwoStageWithHumidityControlMode,\n";
    ss << "\\memo Direct expansion (DX) cooling coil and condensing unit (includes electric compressor\n";
    ss << "\\memo and condenser fan), two-stage with humidity control mode (e.g. sub-cool or hot gas\n";
    ss << "\\memo reheat). Optional inputs for moisture evaporation from wet coil when compressor\n";
    ss << "\\memo cycles off with continuous fan operation. Requires two to four sets of performance\n";
    ss << "\\memo data, see CoilPerformance:DX:Cooling. Stages are modeled as a face-split coil.\n";
    ss << "\\min-fields 18\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingCoilsDX\n";
    ss << "\\reference CoolingCoilsDXMultiModeOrSingleSpeed\n";
    ss << "\\reference DesuperHeatingCoilSources\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5 , \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 , \\field Crankcase Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\required-field\n";
    ss << "N2 , \\field Maximum Outdoor Dry-Bulb Temperature for Crankcase Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field Number of Capacity Stages\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 2\n";
    ss << "\\required-field\n";
    ss << "N4 , \\field Number of Enhanced Dehumidification Modes\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\required-field\n";
    ss << "A6 , \\field Normal Mode Stage 1 Coil Performance\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoilPerformanceDX\n";
    ss << "A7 , \\field Normal Mode Stage 1 Plus 2 Coil Performance\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoilPerformanceDX\n";
    ss << "A8, \\field Dehumidification Mode 1 Stage 1 Coil Performance\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoilPerformanceDX\n";
    ss << "A9, \\field Dehumidification Mode 1 Stage 1 Plus 2 Coil Performance\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoilPerformanceDX\n";
    ss << "A10, \\field Supply Water Storage Tank\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A11, \\field Condensate Collection Water Storage Tank\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "N5,  \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled and for periods\n";
    ss << "\\note when the basin heater is available (field Basin Heater Operating Schedule Name).\n";
    ss << "\\note For this situation, the heater maintains the basin water temperature at the basin heater\n";
    ss << "\\note setpoint temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when the DX coil is off.\n";
    ss << "N6,  \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\required-field\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on.\n";
    ss << "A12; \\field Basin Heater Operating Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";

    IddObjectType objType(IddObjectType::OS_Coil_Cooling_DX_TwoStageWithHumidityControlMode);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Cooling:DX:TwoStageWithHumidityControlMode",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Cooling_DX_TwoStageWithHumidityControlMode);
  return object;
}

IddObject createOS_CoilPerformance_DX_CoolingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:CoilPerformance:DX:Cooling,\n";
    ss << "\\min-fields 23\n";
    ss << "\\memo Used to specify DX cooling coil performance for one mode of operation for a\n";
    ss << "\\memo Coil:Cooling:DX:TwoStageWithHumidityControlMode object which may reference one to four\n";
    ss << "\\memo CoilPerformance:DX:Cooling objects depending on the specified number of stages and\n";
    ss << "\\memo dehumidification modes. In nearly all cases, the Rated Air Flow Rate will be the same\n";
    ss << "\\memo for all performance objects associated with a given coil. If bypass is specified,\n";
    ss << "\\memo the Rated Air Flow Rate includes both the bypassed flow and the flow through the\n";
    ss << "\\memo active part of the coil.\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoilPerformanceDX\n";
    ss << "N1 , \\field Gross Rated Total Cooling Capacity\n";
    ss << "\\note Total cooling capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\note gross capacity excluding supply air fan heat\n";
    ss << "\\note rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "N2 , \\field Gross Rated Sensible Heat Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\note Rated sensible heat ratio (gross sensible capacity/gross total capacity)\n";
    ss << "\\note sensible and total capacities do not include supply fan heat\n";
    ss << "N3 , \\field Gross Rated Cooling COP\n";
    ss << "\\note Gross cooling capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply fan heat or supply fan electrical energy input\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\required-field\n";
    ss << "N4 , \\field Rated Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\note Flow rate corresponding to Rated total Cooling capacity, Rated SHR and Rated COP\n";
    ss << "N5 , \\field Fraction of Air Flow Bypassed Around Coil\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\required-field\n";
    ss << "\\note Fraction of Rated Air Flow Rate which bypasses the cooling coil\n";
    ss << "\\note in this performance mode.  The remaining portion of the flow\n";
    ss << "\\note should be between 0.00004027 m3/s and .00006041 m3/s per watt of rated total cooling capacity.\n";
    ss << "\\note This is used to model face-split coils on multi-stage units or bypass dampers.\n";
    ss << "\\note If total flow rate varies during simulation, the same fraction is bypassed.\n";
    ss << "A3 , \\field Total Cooling Capacity Function of Temperature Curve\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*edb + e*edb**2 + f*wb*edb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note edb = dry-bulb temperature seen by the condenser (C)\n";
    ss << "A4 , \\field Total Cooling Capacity Function of Flow Fraction Curve\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";
    ss << "A5 , \\field Energy Input Ratio Function of Temperature Curve\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*edb + e*edb**2 + f*wb*edb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note edb = dry-bulb temperature seen by the condenser (C)\n";
    ss << "A6 , \\field Energy Input Ratio Function of Flow Fraction Curve\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";
    ss << "A7 , \\field Part Load Fraction Correlation Curve\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLR = part load ratio (cooling load/steady state capacity)\n";
    ss << "N6 , \\field Nominal Time for Condensate Removal to Begin\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 3000.0\n";
    ss << "\\required-field\n";
    ss << "\\note The nominal time for condensate to begin leaving the coil's condensate\n";
    ss << "\\note drain line at the coil's rated air flow rate and temperature conditions.\n";
    ss << "\\note Nominal time is equal to the ratio of the energy of the coil's maximum\n";
    ss << "\\note condensate holding capacity (J) to the coil's steady state latent capacity (W).\n";
    ss << "\\note Suggested value is 1000; zero value means latent degradation model is disabled.\n";
    ss << "N7 , \\field Ratio of Initial Moisture Evaporation Rate and Steady State Latent Capacity\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 5.0\n";
    ss << "\\maximum 3000.0\n";
    ss << "\\required-field\n";
    ss << "\\note Ratio of the initial moisture evaporation rate from the cooling coil (when\n";
    ss << "\\note the compressor first turns off) and the coil's steady state latent capacity\n";
    ss << "\\note at rated air flow rate and temperature conditions. Suggested value is 1.5; zero value\n";
    ss << "\\note means latent degradation model is disabled.\n";
    ss << "N8 , \\field Maximum Cycling Rate\n";
    ss << "\\type real\n";
    ss << "\\units cycles/hr\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 5.0\n";
    ss << "\\required-field\n";
    ss << "\\note The maximum on-off cycling rate for the compressor, which occurs at 50% run time\n";
    ss << "\\note fraction. Suggested value is 3; zero value means latent degradation model is disabled.\n";
    ss << "N9 , \\field Latent Capacity Time Constant\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 500.0\n";
    ss << "\\required-field\n";
    ss << "\\note Time constant for the cooling coil's latent capacity to reach steady state after\n";
    ss << "\\note startup. Suggested value is 45; zero value means latent degradation model is disabled.\n";
    ss << "A8 , \\field Condenser Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "\\note Enter the name of an outdoor air node. This node name is also specified in\n";
    ss << "\\note an OutdoorAir:Node or OutdoorAir:NodeList object.\n";
    ss << "A9 , \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "\\required-field\n";
    ss << "N10 , \\field Evaporative Condenser Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\required-field\n";
    ss << "N11, \\field Evaporative Condenser Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\note Used to calculate evaporative condenser water use\n";
    ss << "N12, \\field Evaporative Condenser Pump Rated Power Consumption\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\note Rated power consumed by the evaporative condenser's water pump\n";
    ss << "A10,  \\field Sensible Heat Ratio Function of Temperature Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*db + e*db**2 + f*wb*db\n";
    ss << "\\note wb = entering wet-bulb temperature seen by the DX cooling coil (C)\n";
    ss << "\\note db = entering dry-bulb temperature seen by the DX cooling coil (C)\n";
    ss << "\\note entering temperature can be outside air or pretreated air.\n";
    ss << "A11; \\field Sensible Heat Ratio Function of Flow Fraction Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";

    IddObjectType objType(IddObjectType::OS_CoilPerformance_DX_Cooling);
    OptionalIddObject oObj = IddObject::load("OS:CoilPerformance:DX:Cooling",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_CoilPerformance_DX_Cooling);
  return object;
}

IddObject createOS_Coil_Cooling_DX_MultiSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Cooling:DX:MultiSpeed,\n";
    ss << "\\extensible:1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingCoilsDXMultiSpeed\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5 , \\field Air Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6 , \\field Condenser Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "A7 , \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "\\required-field\n";
    ss << "A8 , \\field Supply Water Storage Tank\n";
    ss << "A9 , \\field Condensate Collection Water Storage Tank\n";
    ss << "A10 , \\field Apply Part Load Fraction to Speeds Greater than 1\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\required-field\n";
    ss << "A11, \\field Apply Latent Degradation to Speeds Greater than 1\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\default No\n";
    ss << "N1 , \\field Crankcase Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\required-field\n";
    ss << "N2 , \\field Maximum Outdoor Dry-Bulb Temperature for Crankcase Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "N3,  \\field Basin Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "N4,  \\field Basin Heater Setpoint Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "\\required-field\n";
    ss << "A12, \\field Basin Heater Operating Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A13, \\field Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\required-field\n";
    ss << "A14; \\field Stage 1\n";
    ss << "\\begin-extensible\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoilCoolingDXMultiSpeedStageData\n";

    IddObjectType objType(IddObjectType::OS_Coil_Cooling_DX_MultiSpeed);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Cooling:DX:MultiSpeed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Cooling_DX_MultiSpeed);
  return object;
}

IddObject createOS_Coil_Cooling_DX_MultiSpeed_StageDataIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Cooling:DX:MultiSpeed:StageData,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoilCoolingDXMultiSpeedStageData\n";
    ss << "N1 , \\field Gross Rated Total Cooling Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Gross Rated Sensible Heat Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1.0\n";
    ss << "\\autosizable\n";
    ss << "N3 , \\field Gross Rated Cooling COP\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\required-field\n";
    ss << "N4 , \\field Rated Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N5, \\field Rated Evaporator Fan Power Per Volume Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units W/(m3/s)\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1250.0\n";
    ss << "\\required-field\n";
    ss << "A3, \\field Total Cooling Capacity Function of Temperature Curve\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A4, \\field Total Cooling Capacity Function of Flow Fraction Curve\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A5, \\field Energy Input Ratio Function of Temperature Curve\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A6, \\field Energy Input Ratio Function of Flow Fraction Curve\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A7, \\field Part Load Fraction Correlation Curve\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "N6, \\field Nominal Time for Condensate Removal to Begin\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 3000.0\n";
    ss << "\\required-field\n";
    ss << "N7, \\field Ratio of Initial Moisture Evaporation Rate and Steady State Latent Capacity\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 5.0\n";
    ss << "\\required-field\n";
    ss << "N8, \\field Maximum Cycling Rate\n";
    ss << "\\type real\n";
    ss << "\\units cycles/hr\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 5.0\n";
    ss << "\\required-field\n";
    ss << "N9, \\field Latent Capacity Time Constant\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 500.0\n";
    ss << "\\required-field\n";
    ss << "N10, \\field Rated Waste Heat Fraction of Power Input\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A8, \\field Waste Heat Function of Temperature Curve\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "N11, \\field Evaporative Condenser Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\required-field\n";
    ss << "N12, \\field Evaporative Condenser Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "N13; \\field Rated Evaporative Condenser Pump Power Consumption\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_Coil_Cooling_DX_MultiSpeed_StageData);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Cooling:DX:MultiSpeed:StageData",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Cooling_DX_MultiSpeed_StageData);
  return object;
}

IddObject createOS_Coil_Cooling_DX_TwoSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Cooling:DX:TwoSpeed,\n";
    ss << "\\min-fields 20\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference CoolingCoilsDX\n";
    ss << "\\reference DesuperHeatingCoilSources\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Rated High Speed Total Cooling Capacity\n";
    ss << "\\note gross capacity excluding supply air fan heat\n";
    ss << "\\note rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "N2, \\field Rated High Speed Sensible Heat Ratio\n";
    ss << "\\note Rated sensible heat ratio (gross sensible capacity/gross total capacity)\n";
    ss << "\\note sensible and total capacities do not include supply fan heat\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1\n";
    ss << "N3, \\field Rated High Speed COP\n";
    ss << "\\note Gross cooling capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply fan heat or supply fan electrical energy input\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 3.0\n";
    ss << "N4, \\field Rated High Speed Air Flow Rate\n";
    ss << "\\note Flow rate corresponding to rated total cooling capacity, Rated SHR\n";
    ss << "\\note and Rated COP. Should be between 0.00004027 m3/s and .00006041 m3/s per watt\n";
    ss << "\\note of rated total cooling capacity.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "A4, \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6, \\field Total Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*edb + e*edb**2 + f*wb*edb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note edb = dry-bulb temperature seen by the condenser (C)\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A7, \\field Total Cooling Capacity Function of Flow Fraction Curve Name\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A8, \\field Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*edb + e*edb**2 + f*wb*edb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note edb = dry-bulb temperature seen by the condenser (C)\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A9, \\field Energy Input Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A10, \\field Part Load Fraction Correlation Curve Name\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLR = part load ratio (cooling load/steady state capacity)\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "N5, \\field Rated Low Speed Total Cooling Capacity\n";
    ss << "\\note gross capacity excluding supply air fan heat\n";
    ss << "\\note rating point: air entering the cooling coil at 26.7 C dry-bulb/19.4 C wet-bulb, and\n";
    ss << "\\note air entering the outdoor condenser coil at 35 C dry-bulb/23.9 C wet-bulb\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "N6, \\field Rated Low Speed Sensible Heat Ratio\n";
    ss << "\\note Rated sensible heat ratio (gross sensible capacity/gross total capacity)\n";
    ss << "\\note sensible and total capacities do not include supply fan heat\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1\n";
    ss << "N7, \\field Rated Low Speed COP\n";
    ss << "\\note Gross cooling capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply fan heat or supply fan electrical energy input\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 3.0\n";
    ss << "N8, \\field Rated Low Speed Air Flow Rate\n";
    ss << "\\note Flow rate corresponding to rated total cooling capacity, Rated SHR\n";
    ss << "\\note and Rated COP. Should be between 0.00004027 m3/s and .00006041 m3/s per watt\n";
    ss << "\\note of rated total cooling capacity.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "A11, \\field Low Speed Total Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*edb + e*edb**2 + f*wb*edb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note edb = dry-bulb temperature seen by the condenser (C)\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A12, \\field Low Speed Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\note curve = a + b*wb + c*wb**2 + d*edb + e*edb**2 + f*wb*edb\n";
    ss << "\\note wb = entering wet-bulb temperature (C)\n";
    ss << "\\note edb = dry-bulb temperature seen by the condenser (C)\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A13, \\field Condenser Air Inlet Node Name\n";
    ss << "\\note Enter the name of an outdoor air node. This node name is also specified in\n";
    ss << "\\note an OutdoorAir:Node or OutdoorAir:NodeList object.\n";
    ss << "\\type alpha\n";
    ss << "A14, \\field Condenser Type\n";
    ss << "\\type choice\n";
    ss << "\\default AirCooled\n";
    ss << "\\key AirCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "N9, \\field High Speed Evaporative Condenser Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.9\n";
    ss << "N10, \\field High Speed Evaporative Condenser Air Flow Rate\n";
    ss << "\\note Used to calculate evaporative condenser water use\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "N11, \\field High Speed Evaporative Condenser Pump Rated Power Consumption\n";
    ss << "\\note Rated power consumed by the evaporative condenser's water pump at high speed\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "N12, \\field Low Speed Evaporative Condenser Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.9\n";
    ss << "N13, \\field Low Speed Evaporative Condenser Air Flow Rate\n";
    ss << "\\note Used to calculate evaporative condenser water use\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "N14, \\field Low Speed Evaporative Condenser Pump Rated Power Consumption\n";
    ss << "\\note Rated power consumed by the evaporative condenser's water pump at low speed\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "A15, \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A16, \\field Condensate Collection Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "N15, \\field Basin Heater Capacity\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled and for periods\n";
    ss << "\\note when the basin heater is available (field Basin Heater Operating Schedule Name).\n";
    ss << "\\note For this situation, the heater maintains the basin water temperature at the basin heater\n";
    ss << "\\note setpoint temperature when the outdoor air temperature falls below the setpoint temperature.\n";
    ss << "\\note The basin heater only operates when the DX coil is off.\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N16, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Enter the outdoor dry-bulb temperature when the basin heater turns on.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2\n";
    ss << "\\default 2.0\n";
    ss << "A17; \\field Basin Heater Operating Schedule Name\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled.\n";
    ss << "\\note Schedule values greater than 0 allow the basin heater to operate whenever the outdoor\n";
    ss << "\\note air dry-bulb temperature is below the basin heater setpoint temperature.\n";
    ss << "\\note If a schedule name is not entered, the basin heater is allowed to operate\n";
    ss << "\\note throughout the entire simulation.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_Coil_Cooling_DX_TwoSpeed);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Cooling:DX:TwoSpeed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Cooling_DX_TwoSpeed);
  return object;
}

IddObject createOS_CoilSystem_Cooling_Water_HeatExchangerAssistedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:CoilSystem:Cooling:Water:HeatExchangerAssisted,\n";
    ss << "\\memo Virtual component consisting of a chilled-water cooling coil and an air-to-air heat\n";
    ss << "\\memo exchanger. The air-to-air heat exchanger precools the air entering the cooling coil\n";
    ss << "\\memo and reuses this energy to reheat the supply air leaving the cooling coil. This heat\n";
    ss << "\\memo exchange process improves the latent removal performance of the cooling coil (lower\n";
    ss << "\\memo sensible heat ratio).\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CoolingCoilsWater\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4, \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5 , \\field Heat Exchanger\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionObject\n";
    ss << "A6 ; \\field Cooling Coil\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsWaterNoHX\n";

    IddObjectType objType(IddObjectType::OS_CoilSystem_Cooling_Water_HeatExchangerAssisted);
    OptionalIddObject oObj = IddObject::load("OS:CoilSystem:Cooling:Water:HeatExchangerAssisted",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_CoilSystem_Cooling_Water_HeatExchangerAssisted);
  return object;
}

IddObject createOS_CoilSystem_Cooling_DX_HeatExchangerAssistedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:CoilSystem:Cooling:DX:HeatExchangerAssisted,\n";
    ss << "\\memo Virtual component consisting of a direct expansion (DX) cooling coil and an\n";
    ss << "\\memo air-to-air heat exchanger. The air-to-air heat exchanger precools the air entering the\n";
    ss << "\\memo cooling coil and reuses this energy to reheat the supply air leaving the cooling\n";
    ss << "\\memo coil. This heat exchange process improves the latent removal performance of the\n";
    ss << "\\memo cooling coil (lower sensible heat ratio).\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CoolingCoilsDX\n";
    ss << "\\reference CoolingCoilsDXSingleSpeed\n";
    ss << "\\reference CoolingCoilsDXMultiModeOrSingleSpeed\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4, \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5 , \\field Heat Exchanger\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HXAirToAirNames\n";
    ss << "A6 ; \\field Cooling Coil\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsDXBypassFactorEmpirical\n";

    IddObjectType objType(IddObjectType::OS_CoilSystem_Cooling_DX_HeatExchangerAssisted);
    OptionalIddObject oObj = IddObject::load("OS:CoilSystem:Cooling:DX:HeatExchangerAssisted",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_CoilSystem_Cooling_DX_HeatExchangerAssisted);
  return object;
}

IddObject createOS_Coil_Cooling_DX_VariableRefrigerantFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Cooling:DX:VariableRefrigerantFlow,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingCoilsDXVarRefrigFlow\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field Rated Total Cooling Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Cooling capacity excluding supply air fan heat\n";
    ss << "N2 , \\field Rated Sensible Heat Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N3 , \\field Rated Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "A4 , \\field Cooling Capacity Ratio Modifier Function of Temperature Curve\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A5 , \\field Cooling Capacity Modifier Curve Function of Flow Fraction\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A6 , \\field Coil Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A7 ; \\field Coil Air Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";

    IddObjectType objType(IddObjectType::OS_Coil_Cooling_DX_VariableRefrigerantFlow);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Cooling:DX:VariableRefrigerantFlow",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Cooling_DX_VariableRefrigerantFlow);
  return object;
}

IddObject createOS_Coil_Cooling_LowTemperatureRadiant_ConstantFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Cooling:LowTemperatureRadiant:ConstantFlow,\n";
    ss << "\\min-fields 10\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CoilCoolingLowTempRadiantConstantFlow\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Cooling Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4, \\field Cooling Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Cooling High Water Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6, \\field Cooling Low Water Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A7, \\field Cooling High Control Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A8, \\field Cooling Low Control Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A9, \\field Condensation Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Off\n";
    ss << "\\key SimpleOff\n";
    ss << "\\key VariableOff\n";
    ss << "\\default SimpleOff\n";
    ss << "N1 ; \\field Condensation Control Dewpoint Offset\n";
    ss << "\\units C\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::OS_Coil_Cooling_LowTemperatureRadiant_ConstantFlow);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Cooling:LowTemperatureRadiant:ConstantFlow",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Cooling_LowTemperatureRadiant_ConstantFlow);
  return object;
}

IddObject createOS_Coil_Cooling_LowTemperatureRadiant_VariableFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Cooling:LowTemperatureRadiant:VariableFlow,\n";
    ss << "\\min-fields 7\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CoilCoolingLowTempRadiantVariableFlow\n";
    ss << "\\reference ConnectionObject\n";
    ss << "N1 , \\field Maximum Cold Water Flow\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\default autosize\n";
    ss << "A3 , \\field Cooling Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4, \\field Cooling Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N2 , \\field Cooling Control Throttling Range\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.5\n";
    ss << "\\default 0.5\n";
    ss << "A5, \\field Cooling Control Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6, \\field Condensation Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Off\n";
    ss << "\\key SimpleOff\n";
    ss << "\\key VariableOff\n";
    ss << "\\default SimpleOff\n";
    ss << "N3 ; \\field Condensation Control Dewpoint Offset\n";
    ss << "\\units C\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::OS_Coil_Cooling_LowTemperatureRadiant_VariableFlow);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Cooling:LowTemperatureRadiant:VariableFlow",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Cooling_LowTemperatureRadiant_VariableFlow);
  return object;
}

IddObject createOS_Coil_Cooling_WaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Cooling:Water,\n";
    ss << "\\min-fields 16\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference CoolingCoilName\n";
    ss << "\\reference CoolingCoilsWater\n";
    ss << "\\reference CoolingCoilsWaterNoHX\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Design Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0\n";
    ss << "\\default autosize\n";
    ss << "N2, \\field Design Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\default autosize\n";
    ss << "N3, \\field Design Inlet Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0\n";
    ss << "\\default autosize\n";
    ss << "N4, \\field Design Inlet Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0\n";
    ss << "\\default autosize\n";
    ss << "N5, \\field Design Outlet Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0\n";
    ss << "\\default autosize\n";
    ss << "N6, \\field Design Inlet Air Humidity Ratio\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units kg-H2O/kg-air\n";
    ss << "\\minimum 0\n";
    ss << "\\default autosize\n";
    ss << "N7, \\field Design Outlet Air Humidity Ratio\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units kg-H2O/kg-air\n";
    ss << "\\minimum 0\n";
    ss << "\\default autosize\n";
    ss << "A4, \\field Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6, \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A7, \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A8, \\field Type of Analysis\n";
    ss << "\\type choice\n";
    ss << "\\default SimpleAnalysis\n";
    ss << "\\key SimpleAnalysis\n";
    ss << "\\key DetailedAnalysis\n";
    ss << "A9; \\field Heat Exchanger Configuration\n";
    ss << "\\type choice\n";
    ss << "\\default CrossFlow\n";
    ss << "\\key CrossFlow\n";
    ss << "\\key CounterFlow\n";

    IddObjectType objType(IddObjectType::OS_Coil_Cooling_Water);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Cooling:Water",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Cooling_Water);
  return object;
}

IddObject createOS_Coil_Cooling_WaterToAirHeatPump_EquationFitIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Cooling:WaterToAirHeatPump:EquationFit,\n";
    ss << "\\Min-fields 29\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference CoolingCoilsWaterToAirHP\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,  \\field Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4,  \\field Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5,  \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6,  \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1,  \\field Rated Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\default Autosize\n";
    ss << "N2,  \\field Rated Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\autosizable\n";
    ss << "\\default Autosize\n";
    ss << "N3,  \\field Rated Total Cooling Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "\\default Autosize\n";
    ss << "N4,  \\field Rated Sensible Cooling Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "\\default Autosize\n";
    ss << "N5,  \\field Rated Cooling Coefficient of Performance\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 3.0\n";
    ss << "N6,  \\field Total Cooling Capacity Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N7,  \\field Total Cooling Capacity Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N8,  \\field Total Cooling Capacity Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N9,  \\field Total Cooling Capacity Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N10, \\field Total Cooling Capacity Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N11, \\field Sensible Cooling Capacity Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N12, \\field Sensible Cooling Capacity Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N13, \\field Sensible Cooling Capacity Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N14, \\field Sensible Cooling Capacity Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N15, \\field Sensible Cooling Capacity Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N16, \\field Sensible Cooling Capacity Coefficient 6\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N17, \\field Cooling Power Consumption Coefficient 1\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N18, \\field Cooling Power Consumption Coefficient 2\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N19, \\field Cooling Power Consumption Coefficient 3\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N20, \\field Cooling Power Consumption Coefficient 4\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N21, \\field Cooling Power Consumption Coefficient 5\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N22, \\field Nominal Time for Condensate Removal to Begin\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 3000.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note The nominal time for condensate to begin leaving the coil's condensate\n";
    ss << "\\note drain line at the coil's rated air flow and temperature conditions.\n";
    ss << "\\note Nominal time is equal to the ratio of the energy of the coil's maximum\n";
    ss << "\\note condensate holding capacity (J) to the coil's steady state latent capacity (W).\n";
    ss << "\\note Suggested value is 1000; zero value means latent degradation model is disabled.\n";
    ss << "N23; \\field Ratio of Initial Moisture Evaporation Rate and Steady State Latent Capacity\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 5.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note Ratio of the initial moisture evaporation rate from the cooling coil (when\n";
    ss << "\\note the compressor first turns off) and the coil's steady state latent capacity\n";
    ss << "\\note at rated air flow rate and temperature conditions. Suggested value is 1.5; zero value\n";
    ss << "\\note means latent degradation model is disabled.\n";

    IddObjectType objType(IddObjectType::OS_Coil_Cooling_WaterToAirHeatPump_EquationFit);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Cooling:WaterToAirHeatPump:EquationFit",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Cooling_WaterToAirHeatPump_EquationFit);
  return object;
}

IddObject createOS_Coil_Heating_DX_SingleSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Heating:DX:SingleSpeed,\n";
    ss << "\\min-fields 22\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference HeatingCoilsDX\n";
    ss << "\\reference HeatingCoilsGasElecDXSS\n";
    ss << "\\reference HeatingCoilsDXSingleSpeed\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Rated Total Heating Capacity\n";
    ss << "\\note capacity excluding supply air fan heat\n";
    ss << "\\note rating point outdoor dry-bulb temp 8.33 C, outdoor wet-bulb temp 6.11 C\n";
    ss << "\\note rating point heating coil entering air dry-bulb 21.11 C, coil entering wet-bulb 15.55 C\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "N2, \\field Rated COP\n";
    ss << "\\note Rated heating capacity divided by power input to the compressor and outdoor fan,\n";
    ss << "\\note does not include supply air fan heat or supply air fan electrical energy\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0\n";
    ss << "N3, \\field Rated Air Flow Rate\n";
    ss << "\\note Flow rate corresponding to rated total capacity\n";
    ss << "\\note should be between 0.00004027 m3/s and .00006041 m3/s per watt of rated total heating capacity\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "A4, \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6, \\field Total Heating Capacity Function of Temperature Curve Name\n";
    ss << "\\note quadratic curve = a + b*oat + c*oat**2\n";
    ss << "\\note cubic curve = a + b*oat + c*oat**2 + d*oat**3\n";
    ss << "\\note biquadratic curve = a + b*iat + c*iat**2 + d*oat + e*oat**2 + f*iat*oat\n";
    ss << "\\note oat = outdoor air dry-bulb temperature (C)\n";
    ss << "\\note iat = indoor air dry-bulb temperature (C)\n";
    ss << "\\note Biquadratic curve is recommended if sufficient manufacturer data is\n";
    ss << "\\note available for the heating capacity to be sensitive to both iat and oat.\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list BiquadraticQuadraticCubicCurves\n";
    ss << "A7, \\field Total Heating Capacity Function of Flow Fraction Curve Name\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A8, \\field Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\note quadratic curve = a + b*oat + c*oat**2\n";
    ss << "\\note cubic curve = a + b*oat + c*oat**2 + d*oat**3\n";
    ss << "\\note biquadratic curve = a + b*iat + c*iat**2 + d*oat + e*oat**2 + f*iat*oat\n";
    ss << "\\note oat = outdoor air dry-bulb temperature (C)\n";
    ss << "\\note iat = indoor air dry-bulb temperature (C)\n";
    ss << "\\note biquadratic curve is recommended if sufficient manufacturer data is\n";
    ss << "\\note available for the energy input ratio to be sensitive to both iat and oat.\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list BiquadraticQuadraticCubicCurves\n";
    ss << "A9, \\field Energy Input Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A10, \\field Part Load Fraction Correlation Curve Name\n";
    ss << "\\note quadratic curve = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLR = part load ratio (sensible heating load/steady state heating capacity)\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A11, \\field Defrost Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\note biquadratic curve = a + b*wb + c*wb**2 + d*oat + e*oat**2 + f*wb*oat\n";
    ss << "\\note wb = wet-bulb temperature (C) of air entering the indoor coil\n";
    ss << "\\note oat = outdoor air dry-bulb temperature (C)\n";
    ss << "\\note only required if ReverseCycle defrost strategy is specified\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "N4, \\field Minimum Outdoor Dry-Bulb Temperature for Compressor Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -20\n";
    ss << "\\default -8.0\n";
    ss << "N5, \\field Maximum Outdoor Dry-Bulb Temperature for Defrost Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 7.22\n";
    ss << "\\default 5.0\n";
    ss << "N6, \\field Crankcase Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\ip-units Btu/h\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N7, \\field Maximum Outdoor Dry-Bulb Temperature for Crankcase Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0\n";
    ss << "\\default 10.0\n";
    ss << "A12, \\field Defrost Strategy\n";
    ss << "\\type choice\n";
    ss << "\\default ReverseCycle\n";
    ss << "\\key ReverseCycle\n";
    ss << "\\key Resistive\n";
    ss << "A13, \\field Defrost Control\n";
    ss << "\\type choice\n";
    ss << "\\default Timed\n";
    ss << "\\key Timed\n";
    ss << "\\key OnDemand\n";
    ss << "N8, \\field Defrost Time Period Fraction\n";
    ss << "\\note Fraction of time in defrost mode\n";
    ss << "\\note only applicable if timed defrost control is specified\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.058333\n";
    ss << "N9; \\field Resistive Defrost Heater Capacity\n";
    ss << "\\note only applicable if resistive defrost strategy is specified\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";

    IddObjectType objType(IddObjectType::OS_Coil_Heating_DX_SingleSpeed);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Heating:DX:SingleSpeed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Heating_DX_SingleSpeed);
  return object;
}

IddObject createOS_Coil_Heating_DX_VariableRefrigerantFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Heating:DX:VariableRefrigerantFlow,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatingCoilsDX\n";
    ss << "\\reference HeatingCoilsDXSingleSpeed\n";
    ss << "\\reference HeatingCoilsDXVarRefrigFlow\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field Rated Total Heating Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Rated Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "A4 , \\field Coil Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5 , \\field Coil Air Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6 , \\field Heating Capacity Ratio Modifier Function of Temperature Curve\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "A7 ; \\field Heating Capacity Modifier Function of Flow Fraction Curve\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list LinearCurves\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\note quadratic curve = a + b*ff + c*ff**2\n";
    ss << "\\note cubic curve = a + b*ff + c*ff**2 + d*ff**3\n";
    ss << "\\note ff = fraction of the full load flow\n";

    IddObjectType objType(IddObjectType::OS_Coil_Heating_DX_VariableRefrigerantFlow);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Heating:DX:VariableRefrigerantFlow",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Heating_DX_VariableRefrigerantFlow);
  return object;
}

IddObject createOS_Coil_Heating_ElectricIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Heating:Electric,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatingCoilName\n";
    ss << "\\reference HeatingCoilsGasElec\n";
    ss << "\\reference HeatingCoilsGasElecDXSS\n";
    ss << "\\reference HeatingCoilsGasElecDesup\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 1.0\n";
    ss << "N2, \\field Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\default Autosize\n";
    ss << "A4, \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6; \\field Temperature Setpoint Node Name\n";
    ss << "\\note needed if coil is temperature controlled and not load-base controlled\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";

    IddObjectType objType(IddObjectType::OS_Coil_Heating_Electric);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Heating:Electric",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Heating_Electric);
  return object;
}

IddObject createOS_Coil_Heating_GasIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Heating:Gas,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference HeatingCoilName\n";
    ss << "\\reference HeatingCoilsGasElec\n";
    ss << "\\reference HeatingCoilsGasElecDXSS\n";
    ss << "\\reference HeatingCoilsGasElecDesup\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Gas Burner Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.8\n";
    ss << "N2, \\field Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\default Autosize\n";
    ss << "A4, \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6, \\field Temperature Setpoint Node Name\n";
    ss << "\\note optional, used if coil is temperature control and not load-base controlled\n";
    ss << "\\type alpha\n";
    ss << "N3, \\field Parasitic Electric Load\n";
    ss << "\\note parasitic electric load associated with the gas coil operation\n";
    ss << "\\note such as an inducer fan, etc..  This will be modified by the part load ratio to reflect\n";
    ss << "\\note the time of operation in a timestep.\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "A7, \\field Part Load Fraction Correlation Curve Name\n";
    ss << "\\note quadratic curve, PLF = a + b*PLR + c*PLR**2\n";
    ss << "\\note cubic curve, PLF = a + b*PLR + c*PLR**2 + d*PLR**3\n";
    ss << "\\note PLF = part load fraction\n";
    ss << "\\note PLR = part load ratio (sensible heating load/steady state heating capacity)\n";
    ss << "\\note Coil runtime fraction = Part Load Ratio / PLF\n";
    ss << "\\note This part load degradation is for coil performance & will\n";
    ss << "\\note increase the gas consumption of the coil due to transient coil operation.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "N4; \\field Parasitic Gas Load\n";
    ss << "\\note parasitic gas load associated with the gas coil operation (i.e., standing pilot)\n";
    ss << "\\type real\n";
    ss << "\\units W\n";

    IddObjectType objType(IddObjectType::OS_Coil_Heating_Gas);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Heating:Gas",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Heating_Gas);
  return object;
}

IddObject createOS_Coil_Heating_Gas_MultiStageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Heating:Gas:MultiStage,\n";
    ss << "\\extensible:1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference HeatingCoilsGasMultiStage\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4, \\field Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Air Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6, \\field Part Load Fraction Correlation Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "N1, \\field Parasitic Gas Load\n";
    ss << "\\units W\n";
    ss << "A7; \\field Stage 1\n";
    ss << "\\begin-extensible\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoilHeatingGasMultiStageStageData\n";

    IddObjectType objType(IddObjectType::OS_Coil_Heating_Gas_MultiStage);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Heating:Gas:MultiStage",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Heating_Gas_MultiStage);
  return object;
}

IddObject createOS_Coil_Heating_Gas_MultiStage_StageDataIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Heating:Gas:MultiStage:StageData,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CoilHeatingGasMultiStageStageData\n";
    ss << "\\type alpha\n";
    ss << "N1, \\field Gas Burner Efficiency\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2, \\field Nominal Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N3; \\field Parasitic Electric Load\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";

    IddObjectType objType(IddObjectType::OS_Coil_Heating_Gas_MultiStage_StageData);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Heating:Gas:MultiStage:StageData",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Heating_Gas_MultiStage_StageData);
  return object;
}

IddObject createOS_Coil_Heating_DesuperheaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Heating:Desuperheater,\n";
    ss << "\\memo Desuperheater air heating coil. The heating energy provided by this coil is reclaimed\n";
    ss << "\\memo from the superheated refrigerant gas leaving a compressor and does not impact the\n";
    ss << "\\memo performance of the compressor.\n";
    ss << "\\min-fields 7\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatingCoilsGasElecDesup\n";
    ss << "\\reference HeatingCoilsDesuperheater\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1,  \\field Heat Reclaim Recovery Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "A4,  \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5,  \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6,  \\field Heating Source Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesuperHeatingCoilSources\n";
    ss << "N2;  \\field Parasitic Electric Load\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\note parasitic electric load associated with the desuperheater coil operation\n";
    ss << "\\note such as solenoid valves, etc.\n";
    ss << "\\ip-units W\n";

    IddObjectType objType(IddObjectType::OS_Coil_Heating_Desuperheater);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Heating:Desuperheater",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Heating_Desuperheater);
  return object;
}

IddObject createOS_Coil_WaterHeating_DesuperheaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:WaterHeating:Desuperheater,\n";
    ss << "\\memo Desuperheater air heating coil. The heating energy provided by this coil is reclaimed\n";
    ss << "\\memo from the superheated refrigerant gas leaving a compressor and does not impact the\n";
    ss << "\\memo performance of the compressor. This coil must be used with a water heater tank, see\n";
    ss << "\\memo Water Heater:Mixed.\n";
    ss << "\\min-fields 16\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WaterHeatingCoilsDesuperheater\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,  \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values of 0 denote the desuperheater heating coil is off and the parasitic electric\n";
    ss << "\\note energy is also off.\n";
    ss << "A4,  \\field Setpoint Temperature Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defines the cut-out temperature where the desuperheater water heating coil turns off.\n";
    ss << "\\note The desuperheater heating coil setpoint temperature should always be greater\n";
    ss << "\\note than the water tank's heater (element or burner) setpoint temperature. Temperature\n";
    ss << "\\note schedule values should be in degrees C.\n";
    ss << "N1,  \\field Dead Band Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 20\n";
    ss << "\\default 5\n";
    ss << "\\note Setpoint temperature minus the dead band temperature difference defines\n";
    ss << "\\note the cut-in temperature where the desuperheater water heating coil turns on.\n";
    ss << "\\note The water tank's heater (element or burner) setpoint temperature\n";
    ss << "\\note should always be less than the desuperheater heating coil cut-in temperature.\n";
    ss << "N2,  \\field Rated Heat Reclaim Recovery Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Enter the fraction of waste heat reclaimed by the desuperheater water heating coil.\n";
    ss << "N3,  \\field Rated Inlet Water Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note The inlet water temperature corresponding to the rated heat reclaim recovery efficiency.\n";
    ss << "N4,  \\field Rated Outdoor Air Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note The outdoor air dry-bulb temperature corresponding to the\n";
    ss << "\\note rated heat reclaim recovery efficiency.\n";
    ss << "N5,  \\field Maximum Inlet Water Temperature for Heat Reclaim\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note The desuperheater water heating coil is off when the inlet water temperature is above\n";
    ss << "\\note the maximum inlet water temperature for heat reclaim.\n";
    ss << "A5,  \\field Heat Reclaim Efficiency Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\note A biquadratic curve defining the performance of the desuperheater heating coil.\n";
    ss << "\\note Performance can be specified as a function of inlet water temperature, outdoor air\n";
    ss << "\\note dry-bulb temperature, or both.\n";
    ss << "\\note Curve = a + b*Tw + c*Tw**2 + d*odb + e*odb**2 + f*Tw*odb.\n";
    ss << "\\note Tw = desuperheater heating coil entering water temperature (C).\n";
    ss << "\\note Odb = outdoor dry-bulb temperature at DX system condenser (C).\n";
    ss << "A6,  \\field Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note The node from which the desuperheater heating coil draws its inlet water.\n";
    ss << "\\note This name should match the source side outlet node name in the associated\n";
    ss << "\\note water heater tank object.\n";
    ss << "A7,  \\field Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note The node to which the desuperheater heating coil sends its outlet water.\n";
    ss << "\\note This name should match the source side inlet node name in the associated\n";
    ss << "\\note water heater tank object.\n";
    ss << "A8,  \\field Heating Source Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesuperHeatingCoilSources\n";
    ss << "\\note The name of the DX system used for heat reclaim.\n";
    ss << "N6,  \\field Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\note The operating water flow rate.\n";
    ss << "N7,  \\field Water Pump Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\note The water circulation pump electric power.\n";
    ss << "N8,  \\field Fraction of Pump Heat to Water\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.2\n";
    ss << "\\note The fraction of pump heat transferred to the water. The pump is assumed to be downstream of\n";
    ss << "\\note the desuperheater water heating coil.\n";
    ss << "N9,  \\field On-Cycle Parasitic Electric Load\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note Parasitic electric power consumed when the desuperheater water heating coil operates.\n";
    ss << "\\note Parasitic electric load does not contribute to water heating or the zone air heat balance.\n";
    ss << "\\ip-units W\n";
    ss << "N10; \\field Off-Cycle Parasitic Electric Load\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\note Parasitic electric load consumed when the desuperheater water heating coil is off.\n";
    ss << "\\note Parasitic electric load does not contribute to water heating or the zone air heat balance.\n";
    ss << "\\note Off-cycle parasitic power is 0 when the availability schedule is 0.\n";
    ss << "\\ip-units W\n";

    IddObjectType objType(IddObjectType::OS_Coil_WaterHeating_Desuperheater);
    OptionalIddObject oObj = IddObject::load("OS:Coil:WaterHeating:Desuperheater",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_WaterHeating_Desuperheater);
  return object;
}

IddObject createOS_Coil_Heating_LowTemperatureRadiant_ConstantFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Heating:LowTemperatureRadiant:ConstantFlow,\n";
    ss << "\\min-fields 8\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CoilHeatingLowTempRadiantConstantFlow\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Heating Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4 , \\field Heating Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5 , \\field Heating High Water Temperature Schedule Name\n";
    ss << "\\note Water and control temperatures for heating work together to provide\n";
    ss << "\\note a linear function that determines the water temperature sent to the\n";
    ss << "\\note radiant system.  The current control temperature (see Temperature Control Type above) is\n";
    ss << "\\note compared to the high and low control temperatures at the current time.\n";
    ss << "\\note If the control temperature is above the high temperature, then the\n";
    ss << "\\note inlet water temperature is set to the low water temperature.  If the\n";
    ss << "\\note control temperature is below the low temperature, then the inlet\n";
    ss << "\\note water temperature is set to the high water temperature.  If the control\n";
    ss << "\\note temperature is between the high and low value, then the inlet water\n";
    ss << "\\note temperature is linearly interpolated between the low and high water\n";
    ss << "\\note temperature values.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6 , \\field Heating Low Water Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A7 , \\field Heating High Control Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A8 ; \\field Heating Low Control Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_Coil_Heating_LowTemperatureRadiant_ConstantFlow);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Heating:LowTemperatureRadiant:ConstantFlow",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Heating_LowTemperatureRadiant_ConstantFlow);
  return object;
}

IddObject createOS_Coil_Heating_LowTemperatureRadiant_VariableFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Heating:LowTemperatureRadiant:VariableFlow,\n";
    ss << "\\min-fields 7\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference CoilHeatingLowTempRadiantVariableFlow\n";
    ss << "\\reference ConnectionObject\n";
    ss << "N1 , \\field Maximum Hot Water Flow\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\default autosize\n";
    ss << "A3 , \\field Heating Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4 , \\field Heating Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N2 , \\field Heating Control Throttling Range\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.5\n";
    ss << "\\default 0.5\n";
    ss << "A5 ; \\field Heating Control Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_Coil_Heating_LowTemperatureRadiant_VariableFlow);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Heating:LowTemperatureRadiant:VariableFlow",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Heating_LowTemperatureRadiant_VariableFlow);
  return object;
}

IddObject createOS_Coil_Heating_WaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Heating:Water,\n";
    ss << "\\min-fields 16\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference HeatingCoilName\n";
    ss << "\\reference HeatingCoilsWater\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field U-Factor Times Area Value\n";
    ss << "\\note UA value under rating conditions\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units W/K\n";
    ss << "\\default autosize\n";
    ss << "N2, \\field Maximum Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\default Autosize\n";
    ss << "A4, \\field Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6, \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A7, \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A8, \\field Performance Input Method\n";
    ss << "\\type choice\n";
    ss << "\\default UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\key UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\key NominalCapacity\n";
    ss << "N3, \\field Rated Capacity\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\default autosize\n";
    ss << "N4, \\field Rated Inlet Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 82.2\n";
    ss << "N5, \\field Rated Inlet Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 16.6\n";
    ss << "N6, \\field Rated Outlet Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 71.1\n";
    ss << "N7, \\field Rated Outlet Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 32.2\n";
    ss << "N8; \\field Rated Ratio for Air and Water Convection\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.5\n";

    IddObjectType objType(IddObjectType::OS_Coil_Heating_Water);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Heating:Water",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Heating_Water);
  return object;
}

IddObject createOS_Coil_Heating_Water_BaseboardIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Heating:Water:Baseboard,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference BaseboardHeatingCoil\n";
    ss << "\\reference ConnectionObject\n";
    ss << "N1, \\field U-Factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units W/K\n";
    ss << "\\default autosize\n";
    ss << "N2, \\field Maximum Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\default Autosize\n";
    ss << "N3, \\field Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "A3, \\field Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4; \\field Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";

    IddObjectType objType(IddObjectType::OS_Coil_Heating_Water_Baseboard);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Heating:Water:Baseboard",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Heating_Water_Baseboard);
  return object;
}

IddObject createOS_Coil_Heating_Water_Baseboard_RadiantIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Heating:Water:Baseboard:Radiant,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference RadiantBaseboardHeatingCoil\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4, \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1, \\field Rated Average Water Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\maximum 150.0\n";
    ss << "\\minimum 20.0\n";
    ss << "\\units C\n";
    ss << "N2, \\field Rated Water Mass Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\maximum 10.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units kg/s\n";
    ss << "A5, \\field Heating Design Capacity Method\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key HeatingDesignCapacity\n";
    ss << "\\key CapacityPerFloorArea\n";
    ss << "\\key FractionOfAutosizedHeatingCapacity\n";
    ss << "N3, \\field Heating Design Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "N4, \\field Heating Design Capacity Per Floor Area\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "N5, \\field Fraction of Autosized Heating Design Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "N6, \\field Maximum Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "N7; \\field Convergence Tolerance\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";

    IddObjectType objType(IddObjectType::OS_Coil_Heating_Water_Baseboard_Radiant);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Heating:Water:Baseboard:Radiant",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Heating_Water_Baseboard_Radiant);
  return object;
}

IddObject createOS_Coil_Heating_WaterToAirHeatPump_EquationFitIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Heating:WaterToAirHeatPump:EquationFit,\n";
    ss << "\\Min-fields 20\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference HeatingCoilsWaterToAirHP\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,  \\field Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4,  \\field Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5,  \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6,  \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1,  \\field Rated Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\default Autosize\n";
    ss << "N2,  \\field Rated Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\autosizable\n";
    ss << "\\default Autosize\n";
    ss << "N3,  \\field Rated Heating Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "\\default Autosize\n";
    ss << "N4,  \\field Rated Heating Coefficient of Performance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units W/W\n";
    ss << "\\default 3.0\n";
    ss << "N5,  \\field Heating Capacity Coefficient 1\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N6,  \\field Heating Capacity Coefficient 2\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N7,  \\field Heating Capacity Coefficient 3\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N8,  \\field Heating Capacity Coefficient 4\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N9,  \\field Heating Capacity Coefficient 5\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N10, \\field Heating Power Consumption Coefficient 1\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N11, \\field Heating Power Consumption Coefficient 2\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N12, \\field Heating Power Consumption Coefficient 3\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N13, \\field Heating Power Consumption Coefficient 4\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N14; \\field Heating Power Consumption Coefficient 5\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_Coil_Heating_WaterToAirHeatPump_EquationFit);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Heating:WaterToAirHeatPump:EquationFit",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Heating_WaterToAirHeatPump_EquationFit);
  return object;
}

IddObject createOS_Coil_Heating_DX_MultiSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Heating:DX:MultiSpeed,\n";
    ss << "\\min-fields 19\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatingCoilsDXMultiSpeed\n";
    ss << "\\reference AFNCoilNames\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5 , \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 , \\field Minimum Outdoor Dry-Bulb Temperature for Compressor Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N2 , \\field Outdoor Dry-Bulb Temperature to Turn On Compressor\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N3 , \\field Crankcase Heater Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "N4 , \\field Maximum Outdoor Dry-Bulb Temperature for Crankcase Heater Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units C\n";
    ss << "A6 , \\field Defrost Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "N5 , \\field Maximum Outdoor Dry-Bulb Temperature for Defrost Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 7.22\n";
    ss << "\\units C\n";
    ss << "A7 , \\field Defrost Strategy\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key ReverseCycle\n";
    ss << "\\key Resistive\n";
    ss << "A8 , \\field Defrost Control\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Timed\n";
    ss << "\\key OnDemand\n";
    ss << "N6 , \\field Defrost Time Period Fraction\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "N7 , \\field Resistive Defrost Heater Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "A9 , \\field Apply Part Load Fraction to Speeds Greater than 1\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A10, \\field Fuel Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "N8,  \\field Region number for Calculating HSPF\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 6\n";
    ss << "A11; \\field Stage Data List\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";

    IddObjectType objType(IddObjectType::OS_Coil_Heating_DX_MultiSpeed);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Heating:DX:MultiSpeed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Heating_DX_MultiSpeed);
  return object;
}

IddObject createOS_Coil_Heating_DX_MultiSpeed_StageDataIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Heating:DX:MultiSpeed:StageData,\n";
    ss << "\\min-fields 12\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field Gross Rated Heating Capacity\n";
    ss << "\\note Heating capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Gross Rated Heating COP\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3 , \\field Rated Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N4 , \\field Rated Supply Air Fan Power Per Volume Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/(m3/s)\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1250.0\n";
    ss << "A2 , \\field Heating Capacity Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticQuadraticCubicCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A3 , \\field Heating Capacity Function of Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A4 , \\field Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticQuadraticCubicCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A5 , \\field Energy Input Ratio Function of Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A6 , \\field Part Load Fraction Correlation Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "N5 , \\field Rated Waste Heat Fraction of Power Input\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A7 ; \\field Waste Heat Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";

    IddObjectType objType(IddObjectType::OS_Coil_Heating_DX_MultiSpeed_StageData);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Heating:DX:MultiSpeed:StageData",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Heating_DX_MultiSpeed_StageData);
  return object;
}

IddObject createOS_Coil_Heating_DX_VariableSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Heating:DX:VariableSpeed,\n";
    ss << "\\min-fields 19\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatingCoilsDXVariableSpeed\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,  \\field Indoor Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4,  \\field Indoor Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1,  \\field Nominal Speed Level\n";
    ss << "\\units dimensionless\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\note must be lower than or equal to the highest speed number\n";
    ss << "N2,  \\field Rated Heating Capacity At Selected Nominal Speed Level\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "N3,  \\field Rated Air Flow Rate At Selected Nominal Speed Level\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "A5,  \\field Energy Part Load Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A6,  \\field Defrost Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "N4,  \\field Minimum Outdoor Dry-Bulb Temperature for Compressor Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum -50.0\n";
    ss << "\\units C\n";
    ss << "N5,  \\field Outdoor Dry-Bulb Temperature to Turn On Compressor\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N6,  \\field Maximum Outdoor Dry-Bulb Temperature for Defrost Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 7.22\n";
    ss << "\\units C\n";
    ss << "N7,  \\field Crankcase Heater Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "N8,  \\field Maximum Outdoor Dry-Bulb Temperature for Crankcase Heater Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units C\n";
    ss << "A7,  \\field Defrost Strategy\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key ReverseCycle\n";
    ss << "\\key Resistive\n";
    ss << "A8,  \\field Defrost Control\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Timed\n";
    ss << "\\key OnDemand\n";
    ss << "N9,  \\field Defrost Time Period Fraction\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "N10, \\field Resistive Defrost Heater Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "A9;  \\field Speed Data List\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";

    IddObjectType objType(IddObjectType::OS_Coil_Heating_DX_VariableSpeed);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Heating:DX:VariableSpeed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Heating_DX_VariableSpeed);
  return object;
}

IddObject createOS_Coil_Heating_DX_VariableSpeed_SpeedDataIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Heating:DX:VariableSpeed:SpeedData,\n";
    ss << "\\min-fields 9\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoilHeatingDXVariableSpeedSpeedData\n";
    ss << "N1,  \\field Reference Unit Gross Rated Heating Capacity\n";
    ss << "\\note Heating capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N2,  \\field Reference Unit Gross Rated Heating COP\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N3,  \\field Reference Unit Rated Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "A3,  \\field Heating Capacity Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A4,  \\field Total  Heating Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A5,  \\field Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A6;  \\field Energy Input Ratio Function of Air Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";

    IddObjectType objType(IddObjectType::OS_Coil_Heating_DX_VariableSpeed_SpeedData);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Heating:DX:VariableSpeed:SpeedData",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Heating_DX_VariableSpeed_SpeedData);
  return object;
}

IddObject createOS_Coil_Cooling_DX_VariableSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Cooling:DX:VariableSpeed,\n";
    ss << "\\min-fields 21\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingCoilsDXVariableSpeed\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,  \\field Indoor Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4,  \\field Indoor Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1,  \\field Nominal Speed Level\n";
    ss << "\\units dimensionless\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\note must be lower than or equal to the highest speed number\n";
    ss << "N2,  \\field Gross Rated Total Cooling Capacity At Selected Nominal Speed Level\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "N3,  \\field Rated Air Flow Rate At Selected Nominal Speed Level\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "N4,  \\field Nominal Time for Condensate to Begin Leaving the Coil\n";
    ss << "\\units s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N5,  \\field Initial Moisture Evaporation Rate Divided by Steady-State AC Latent Capacity\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "A5,  \\field Energy Part Load Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A6,  \\field Condenser Air Inlet Node Name\n";
    ss << "\\type alpha\n";
    ss << "A7,  \\field Condenser Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key AirCooled\n";
    ss << "\\key EvaporativelyCooled\n";
    ss << "N6,  \\field Evaporative Condenser Pump Rated Power Consumption\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N7,  \\field Crankcase Heater Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "N8,  \\field Maximum Outdoor Dry-Bulb Temperature for Crankcase Heater Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units C\n";
    ss << "A8,  \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A9,  \\field Condensate Collection Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "N9,  \\field Basin Heater Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "N10, \\field Basin Heater Setpoint Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 2.0\n";
    ss << "A10, \\field Basin Heater Operating Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A11; \\field Speed Data List\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";

    IddObjectType objType(IddObjectType::OS_Coil_Cooling_DX_VariableSpeed);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Cooling:DX:VariableSpeed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Cooling_DX_VariableSpeed);
  return object;
}

IddObject createOS_Coil_Cooling_DX_VariableSpeed_SpeedDataIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Cooling:DX:VariableSpeed:SpeedData,\n";
    ss << "\\min-fields 12\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoilCoolingDXVariableSpeedSpeedData\n";
    ss << "N1,  \\field Reference Unit Gross Rated Total Cooling Capacity\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N2,  \\field Reference Unit Gross Rated Sensible Heat Ratio\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\required-field\n";
    ss << "N3,  \\field Reference Unit Gross Rated Cooling COP\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N4,  \\field Reference Unit Rated Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N5,  \\field Reference Unit Rated Condenser Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled\n";
    ss << "N6,  \\field Reference Unit Rated Pad Effectiveness of Evap Precooling\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note This field is only used for Condenser Type = EvaporativelyCooled\n";
    ss << "A3,  \\field Total Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A4,  \\field Total Cooling Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A5,  \\field Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A6;  \\field Energy Input Ratio Function of Air Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";

    IddObjectType objType(IddObjectType::OS_Coil_Cooling_DX_VariableSpeed_SpeedData);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Cooling:DX:VariableSpeed:SpeedData",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Cooling_DX_VariableSpeed_SpeedData);
  return object;
}

IddObject createOS_Coil_Heating_WaterToAirHeatPump_VariableSpeedEquationFitIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Heating:WaterToAirHeatPump:VariableSpeedEquationFit,\n";
    ss << "\\min-fields 12\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatingCoilsWaterToAirVSHP\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,  \\field Water-to-Refrigerant HX Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4,  \\field Water-to-Refrigerant HX Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5,  \\field Indoor Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6,  \\field Indoor Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1,  \\field Nominal Speed Level\n";
    ss << "\\units dimensionless\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\note must be lower than or equal to the highest speed number\n";
    ss << "N2,  \\field Rated Heating Capacity At Selected Nominal Speed Level\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "N3,  \\field Rated Air Flow Rate At Selected Nominal Speed Level\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "N4,  \\field Rated Water Flow Rate At Selected Nominal Speed Level\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "A7,  \\field Energy Part Load Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A8;  \\field Speed Data List\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";

    IddObjectType objType(IddObjectType::OS_Coil_Heating_WaterToAirHeatPump_VariableSpeedEquationFit);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Heating:WaterToAirHeatPump:VariableSpeedEquationFit",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Heating_WaterToAirHeatPump_VariableSpeedEquationFit);
  return object;
}

IddObject createOS_Coil_Heating_WaterToAirHeatPump_VariableSpeedEquationFit_SpeedDataIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Heating:WaterToAirHeatPump:VariableSpeedEquationFit:SpeedData,\n";
    ss << "\\min-fields 14\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoilHeatingWaterToAirHeatPumpVariableSpeedEquationFitSpeedData\n";
    ss << "N1,  \\field Reference Unit Gross Rated Heating Capacity\n";
    ss << "\\note Heating capacity not accounting for the effect of supply air fan heat\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N2,  \\field Reference Unit Gross Rated Heating COP\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N3,  \\field Reference Unit Rated Air Flow\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N4,  \\field Reference Unit Rated Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "A3,  \\field Heating Capacity Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A4,  \\field Total Heating Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A5,  \\field Heating Capacity Function of Water Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A6,  \\field Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A7,  \\field Energy Input Ratio Function of Air Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A8,  \\field Energy Input Ratio Function of Water Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "N5,  \\field Reference Unit Waste Heat Fraction of Input Power At Rated Conditions\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "A9;  \\field Waste Heat Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";

    IddObjectType objType(IddObjectType::OS_Coil_Heating_WaterToAirHeatPump_VariableSpeedEquationFit_SpeedData);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Heating:WaterToAirHeatPump:VariableSpeedEquationFit:SpeedData",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Heating_WaterToAirHeatPump_VariableSpeedEquationFit_SpeedData);
  return object;
}

IddObject createOS_Coil_Cooling_WaterToAirHeatPump_VariableSpeedEquationFitIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Cooling:WaterToAirHeatPump:VariableSpeedEquationFit,\n";
    ss << "\\min-fields 15\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoolingCoilsWaterToAirVSHP\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,  \\field Water-to-Refrigerant HX Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4,  \\field Water-to-Refrigerant HX Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5,  \\field Indoor Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6,  \\field Indoor Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1,  \\field Nominal Speed Level\n";
    ss << "\\units dimensionless\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\note must be lower than or equal to the highest speed number\n";
    ss << "N2,  \\field Gross Rated Total Cooling Capacity At Selected Nominal Speed Level\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "N3,  \\field Rated Air Flow Rate At Selected Nominal Speed Level\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "N4,  \\field Rated Water Flow Rate At Selected Nominal Speed Level\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "N5,  \\field Nominal Time for Condensate to Begin Leaving the Coil\n";
    ss << "\\units s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N6,  \\field Initial Moisture Evaporation Rate Divided by Steady-State AC Latent Capacity\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N7,  \\field Use Hot Gas Reheat\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\required-field\n";
    ss << "A7,  \\field Energy Part Load Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A8;  \\field Speed Data List\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";

    IddObjectType objType(IddObjectType::OS_Coil_Cooling_WaterToAirHeatPump_VariableSpeedEquationFit);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Cooling:WaterToAirHeatPump:VariableSpeedEquationFit",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Cooling_WaterToAirHeatPump_VariableSpeedEquationFit);
  return object;
}

IddObject createOS_Coil_Cooling_WaterToAirHeatPump_VariableSpeedEquationFit_SpeedDataIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:Cooling:WaterToAirHeatPump:VariableSpeedEquationFit:SpeedData,\n";
    ss << "\\min-fields 15\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CoilCoolingWaterToAirHeatPumpVariableSpeedEquationFitSpeedData\n";
    ss << "N1,  \\field Reference Unit Gross Rated Total Cooling Capacity\n";
    ss << "\\units W\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N2,  \\field Reference Unit Gross Rated Sensible Heat Ratio\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\Maximum 1.0\n";
    ss << "\\required-field\n";
    ss << "N3,  \\field Reference Unit Gross Rated Cooling COP\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N4,  \\field Reference Unit Rated Air Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N5,  \\field Reference Unit Rated Water Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "A3,  \\field Total Cooling Capacity Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A4,  \\field Total Cooling Capacity Function of Air Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A5,  \\field Total Cooling Capacity Function of Water Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A6,  \\field Energy Input Ratio Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A7,  \\field Energy Input Ratio Function of Air Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A8,  \\field Energy Input Ratio Function of Water Flow Fraction Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "N6,  \\field Reference Unit Waste Heat Fraction of Input Power At Rated Conditions\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "A9;  \\field Waste Heat Function of Temperature Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";

    IddObjectType objType(IddObjectType::OS_Coil_Cooling_WaterToAirHeatPump_VariableSpeedEquationFit_SpeedData);
    OptionalIddObject oObj = IddObject::load("OS:Coil:Cooling:WaterToAirHeatPump:VariableSpeedEquationFit:SpeedData",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_Cooling_WaterToAirHeatPump_VariableSpeedEquationFit_SpeedData);
  return object;
}

IddObject createOS_ConnectionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Connection,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionNames\n";
    ss << "A3, \\field Source Object\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionObject\n";
    ss << "N1, \\field Outlet Port\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";
    ss << "A4, \\field Target Object\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionObject\n";
    ss << "N2; \\field Inlet Port\n";
    ss << "\\type integer\n";
    ss << "\\minimum 0\n";

    IddObjectType objType(IddObjectType::OS_Connection);
    OptionalIddObject oObj = IddObject::load("OS:Connection",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Connection);
  return object;
}

IddObject createOS_Connector_MixerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Connector:Mixer,\n";
    ss << "\\memo Mix N inlet air/water streams into one.  Branch names cannot be duplicated within\n";
    ss << "\\memo a single mixer list.\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 4\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Outlet Branch Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4; \\field Inlet Branch Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\object-list ConnectionNames\n";

    IddObjectType objType(IddObjectType::OS_Connector_Mixer);
    OptionalIddObject oObj = IddObject::load("OS:Connector:Mixer",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Connector_Mixer);
  return object;
}

IddObject createOS_Connector_SplitterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Connector:Splitter,\n";
    ss << "\\memo Split one air/water stream into N outlet streams.  Branch names cannot be duplicated\n";
    ss << "\\memo within a single Splitter list.\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 4\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Inlet Branch Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4; \\field Outlet Branch Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\object-list ConnectionNames\n";

    IddObjectType objType(IddObjectType::OS_Connector_Splitter);
    OptionalIddObject oObj = IddObject::load("OS:Connector:Splitter",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Connector_Splitter);
  return object;
}

IddObject createOS_Controller_MechanicalVentilationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Controller:MechanicalVentilation,\n";
    ss << "\\extensible:3\n";
    ss << "\\min-fields 5\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ControllerMechanicalVentilationNames\n";
    ss << "A3, \\field Availability Schedule\n";
    ss << "\\note Schedule values greater than 0 indicate mechanical ventilation is enabled\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4, \\field Demand Controlled Ventilation\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A5, \\field System Outdoor Air Method\n";
    ss << "\\type choice\n";
    ss << "\\default VentilationRateProcedure\n";
    ss << "\\key ZoneSum\n";
    ss << "\\key VentilationRateProcedure\n";
    ss << "\\key IndoorAirQualityProcedure\n";
    ss << "\\key ProportionalControl\n";
    ss << "\\key ProportionalControlBasedonOccupancySchedule\n";
    ss << "\\key ProportionalControlBasedOnDesignOccupancy\n";
    ss << "A6, \\field Thermal Zone\n";
    ss << "\\note A zone name or a zone list name may be used here\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A7, \\field Design Specification Outdoor Air Object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "A8;  \\field Design Specification Zone Air Distribution Object\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneAirDistributionNames\n";

    IddObjectType objType(IddObjectType::OS_Controller_MechanicalVentilation);
    OptionalIddObject oObj = IddObject::load("OS:Controller:MechanicalVentilation",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Controller_MechanicalVentilation);
  return object;
}

IddObject createOS_ZoneControl_ContaminantControllerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneControl:ContaminantController,\n";
    ss << "\\min-fields 8\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A3 , \\field Controlled Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A4 , \\field Carbon Dioxide Control Availability Schedule Name\n";
    ss << "\\note Availability schedule name for CO2 controller. Schedule value > 0 means the CO2\n";
    ss << "\\note controller is enabled. If this field is blank, then CO2  controller is always enabled.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5 , \\field Carbon Dioxide Setpoint Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values should be carbon dioxide concentration in parts per million (ppm)\n";
    ss << "A6 , \\field Minimum Carbon Dioxide Concentration Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values should be carbon dioxide concentration in parts per\n";
    ss << "\\note million (ppm)\n";
    ss << "\\note This field is used when the field System Outdoor Air Method =\n";
    ss << "\\note ProportionalControlBasedonOccupancySchedule or ProportionalControlBasedOnDesignOccupancy\n";
    ss << "\\note in Controller:MechanicalVentilation\n";
    ss << "A7 , \\field Generic Contaminant Control Availability Schedule Name\n";
    ss << "\\note Availability schedule name for generic contaminant controller. Schedule value > 0 means\n";
    ss << "\\note the generic contaminant controller is enabled. If this field is blank, then generic\n";
    ss << "\\note contaminant controller is always enabled.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A8 ; \\field Generic Contaminant Setpoint Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values should be generic contaminant concentration in parts per\n";
    ss << "\\note million (ppm)\n";
    ss << "\\note This field is used when the field System Outdoor Air Method =\n";
    ss << "\\note IndoorAirQualityProcedureGenericContaminant in Controller:MechanicalVentilation\n";

    IddObjectType objType(IddObjectType::OS_ZoneControl_ContaminantController);
    OptionalIddObject oObj = IddObject::load("OS:ZoneControl:ContaminantController",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneControl_ContaminantController);
  return object;
}

IddObject createOS_Controller_OutdoorAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Controller:OutdoorAir,\n";
    ss << "\\min-fields 17\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference OutdoorAirController\n";
    ss << "A3, \\field Relief Air Outlet Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A4, \\field Return Air Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A5, \\field Mixed Air Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A6, \\field Actuator Node Name\n";
    ss << "\\note Outdoor air inlet node entering the first pre-treat component if any\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "N1, \\field Minimum Outdoor Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "N2, \\field Maximum Outdoor Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "A7, \\field Economizer Control Type\n";
    ss << "\\type choice\n";
    ss << "\\default NoEconomizer\n";
    ss << "\\key FixedDryBulb\n";
    ss << "\\key FixedEnthalpy\n";
    ss << "\\key DifferentialDryBulb\n";
    ss << "\\key DifferentialEnthalpy\n";
    ss << "\\key FixedDewPointAndDryBulb\n";
    ss << "\\key ElectronicEnthalpy\n";
    ss << "\\key DifferentialDryBulbAndEnthalpy\n";
    ss << "\\key NoEconomizer\n";
    ss << "A8, \\field Economizer Control Action Type\n";
    ss << "\\type choice\n";
    ss << "\\default ModulateFlow\n";
    ss << "\\key ModulateFlow\n";
    ss << "\\key MinimumFlowWithBypass\n";
    ss << "N3, \\field Economizer Maximum Limit Dry-Bulb Temperature\n";
    ss << "\\note Enter the maximum outdoor dry-bulb temperature limit for FixedDryBulb\n";
    ss << "\\note economizer control type. No input or blank input means this limit is\n";
    ss << "\\note not operative. Limit is applied regardless of economizer control type.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N4, \\field Economizer Maximum Limit Enthalpy\n";
    ss << "\\note Enter the maximum outdoor enthalpy limit for FixedEnthalpy economizer control type.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "\\type real\n";
    ss << "\\units J/kg\n";
    ss << "\\ip-units Btu/lb_m\n";
    ss << "N5, \\field Economizer Maximum Limit Dewpoint Temperature\n";
    ss << "\\note Enter the maximum outdoor dewpoint temperature limit for FixedDewPointAndDryBulb\n";
    ss << "\\note economizer control type. No input or blank input means this limit is not operative.\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "A9, \\field Electronic Enthalpy Limit Curve Name\n";
    ss << "\\note Enter the name of a quadratic or cubic curve which defines the maximum outdoor\n";
    ss << "\\note humidity ratio (function of outdoor dry-bulb temperature) for ElectronicEnthalpy\n";
    ss << "\\note economizer control type. No input or blank input means this limit is not operative\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "N6, \\field Economizer Minimum Limit Dry-Bulb Temperature\n";
    ss << "\\note Enter the minimum outdoor dry-bulb temperature limit for economizer control.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "\\note Limit is applied regardless of economizer control type.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "A10, \\field Lockout Type\n";
    ss << "\\type choice\n";
    ss << "\\default NoLockout\n";
    ss << "\\key NoLockout\n";
    ss << "\\key LockoutWithHeating\n";
    ss << "\\key LockoutWithCompressor\n";
    ss << "A11, \\field Minimum Limit Type\n";
    ss << "\\type choice\n";
    ss << "\\default ProportionalMinimum\n";
    ss << "\\key FixedMinimum\n";
    ss << "\\key ProportionalMinimum\n";
    ss << "A12, \\field Minimum Outdoor Air Schedule Name\n";
    ss << "\\note Schedule values multiply the minimum outdoor air flow rate\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A13, \\field Minimum Fraction of Outdoor Air Schedule Name\n";
    ss << "\\note schedule values multiply the design/mixed air flow rate\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A14, \\field Maximum Fraction of Outdoor Air Schedule Name\n";
    ss << "\\note schedule values multiply the design/mixed air flow rate\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A15, \\field Controller Mechanical Ventilation\n";
    ss << "\\note Enter the name of a Controller:MechanicalVentilation object.\n";
    ss << "\\note Optional field for defining outdoor ventilation air based on flow rate per unit floor\n";
    ss << "\\note area and flow rate per person. Simplified method of demand-controlled ventilation.\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ControllerMechanicalVentilationNames\n";
    ss << "A16, \\field Time of Day Economizer Control Schedule Name\n";
    ss << "\\note Optional schedule to simulate \"push-button\" type economizer control.\n";
    ss << "\\note Schedule values greater than 0 indicate time-of-day economizer control is enabled.\n";
    ss << "\\note Economizer control may be used with or without the high humidity control option.\n";
    ss << "\\note When used together, high humidity control has priority over economizer control.\n";
    ss << "\\note If the field Economizer Control Type = NoEconomizer, then this option is disabled.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A17, \\field High Humidity Control\n";
    ss << "\\note Optional field to enable modified outdoor air flow rates based on zone relative humidity.\n";
    ss << "\\note Select Yes to modify outdoor air flow rate based on a zone humidistat.\n";
    ss << "\\note Select No to disable this feature.\n";
    ss << "\\note If the field Economizer Control Type = NoEconomizer, then this option is disabled.\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A18, \\field Humidistat Control Zone Name\n";
    ss << "\\note Enter the name of the zone where the humidistat is located.\n";
    ss << "\\note This field is only used when the field High Humidity Control = Yes.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "N7, \\field High Humidity Outdoor Air Flow Ratio\n";
    ss << "\\note Enter the ratio of outdoor air to the maximum outdoor air flow rate when modified air\n";
    ss << "\\note flow rates are active based on high indoor humidity.\n";
    ss << "\\note The minimum value must be greater than 0.\n";
    ss << "\\note This field is only used when the field High Humidity Control = Yes.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1.0\n";
    ss << "A19, \\field Control High Indoor Humidity Based on Outdoor Humidity Ratio\n";
    ss << "\\note If No is selected, the outdoor air flow rate is modified any time indoor relative\n";
    ss << "\\note humidity is above the humidistat setpoint. If Yes is selected, the outdoor air\n";
    ss << "\\note flow rate is modified any time the indoor relative humidity is above the humidistat\n";
    ss << "\\note setpoint and the outdoor humidity ratio is less than the indoor humidity ratio.\n";
    ss << "\\note This field is only used when the field High Humidity Control = Yes.\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A20; \\field Heat Recovery Bypass Control Type\n";
    ss << "\\note BypassWhenWithinEconomizerLimits specifies that heat recovery\n";
    ss << "\\note is active only when the economizer is off because conditions\n";
    ss << "\\note are outside the economizer control limits\n";
    ss << "\\note BypassWhenOAFlowGreaterThanMinimum specifies enhanced economizer\n";
    ss << "\\note controls to allow heat recovery when economizer is active\n";
    ss << "\\note (within limits) but the outdoor air flow rate is at the minimum.\n";
    ss << "\\type choice\n";
    ss << "\\default BypassWhenWithinEconomizerLimits\n";
    ss << "\\key BypassWhenWithinEconomizerLimits\n";
    ss << "\\key BypassWhenOAFlowGreaterThanMinimum\n";

    IddObjectType objType(IddObjectType::OS_Controller_OutdoorAir);
    OptionalIddObject oObj = IddObject::load("OS:Controller:OutdoorAir",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Controller_OutdoorAir);
  return object;
}

IddObject createOS_Controller_WaterCoilIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Controller:WaterCoil,\n";
    ss << "\\min-fields 10\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference AirLoopControllers\n";
    ss << "A3,  \\field Water Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionObject\n";
    ss << "A4, \\field Control Variable\n";
    ss << "\\note keys HumidityRatio or TemperatureAndHumidityRatio\n";
    ss << "\\note requires a ZoneControl:Humidistat object along\n";
    ss << "\\note with SetpointManager:SingleZone:Humidity:Maximum,\n";
    ss << "\\note SetpointManager:MultiZone:MaximumHumidity:Average, or\n";
    ss << "\\note SetpointManager:Multizone:Humidity:Maximum object\n";
    ss << "\\type choice\n";
    ss << "\\default Temperature\n";
    ss << "\\key Temperature\n";
    ss << "\\key HumidityRatio\n";
    ss << "\\key TemperatureAndHumidityRatio\n";
    ss << "A5, \\field Action\n";
    ss << "\\note Leave blank to have this automatically selected from coil type.\n";
    ss << "\\note Chilled water coils should be reverse action\n";
    ss << "\\note Hot water coils should be normal action\n";
    ss << "\\type choice\n";
    ss << "\\key Normal\n";
    ss << "\\key Reverse\n";
    ss << "A6, \\field Actuator Variable\n";
    ss << "\\type choice\n";
    ss << "\\default Flow\n";
    ss << "\\key Flow\n";
    ss << "A7, \\field Sensor Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "A8, \\field Actuator Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "N1, \\field Controller Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units deltaC\n";
    ss << "\\default Autosize\n";
    ss << "N2, \\field Maximum Actuated Flow\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\default Autosize\n";
    ss << "N3; \\field Minimum Actuated Flow\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\default 0.0000001\n";

    IddObjectType objType(IddObjectType::OS_Controller_WaterCoil);
    OptionalIddObject oObj = IddObject::load("OS:Controller:WaterCoil",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Controller_WaterCoil);
  return object;
}

IddObject createOS_Curve_LinearIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Curve:Linear,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note curve = C1 + C2*x\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference LinearCurves\n";
    ss << "\\reference LinearOrQuadraticCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1, \\field Coefficient1 Constant\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Coefficient2 x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N3, \\field Minimum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N4, \\field Maximum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N5, \\field Minimum Curve Output\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "N6, \\field Maximum Curve Output\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "A3, \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key Pressure\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "A4; \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";

    IddObjectType objType(IddObjectType::OS_Curve_Linear);
    OptionalIddObject oObj = IddObject::load("OS:Curve:Linear",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Curve_Linear);
  return object;
}

IddObject createOS_Curve_QuadraticIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Curve:Quadratic,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note curve = C1 + C2*x + C3*x**2\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference QuadraticCurves\n";
    ss << "\\reference LinearOrQuadraticCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "\\reference QuadraticCubicCurves\n";
    ss << "\\reference BiquadraticQuadraticCubicCurves\n";
    ss << "N1, \\field Coefficient1 Constant\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Coefficient2 x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N3, \\field Coefficient3 x**2\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N4, \\field Minimum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N5, \\field Maximum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N6, \\field Minimum Curve Output\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "N7, \\field Maximum Curve Output\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "A3, \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "A4; \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";

    IddObjectType objType(IddObjectType::OS_Curve_Quadratic);
    OptionalIddObject oObj = IddObject::load("OS:Curve:Quadratic",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Curve_Quadratic);
  return object;
}

IddObject createOS_Curve_CubicIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Curve:Cubic,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note curve = C1 + C2*x + C3*x**2 + C4*x**3\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference CubicCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "\\reference QuadraticCubicCurves\n";
    ss << "\\reference BiquadraticCubicCurves\n";
    ss << "\\reference BiquadraticQuadraticCubicCurves\n";
    ss << "N1, \\field Coefficient1 Constant\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Coefficient2 x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N3, \\field Coefficient3 x**2\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N4, \\field Coefficient4 x**3\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N5, \\field Minimum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N6, \\field Maximum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N7, \\field Minimum Curve Output\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "N8, \\field Maximum Curve Output\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "A3, \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "A4; \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";

    IddObjectType objType(IddObjectType::OS_Curve_Cubic);
    OptionalIddObject oObj = IddObject::load("OS:Curve:Cubic",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Curve_Cubic);
  return object;
}

IddObject createOS_Curve_QuarticIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Curve:Quartic,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note curve = C1 + C2*x + C3*x**2 + C4*x**3 + C5*x**4\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference QuarticCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1, \\field Coefficient1 Constant\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Coefficient2 x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N3, \\field Coefficient3 x**2\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N4, \\field Coefficient4 x**3\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N5, \\field Coefficient5 x**4\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N6, \\field Minimum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N7, \\field Maximum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N8, \\field Minimum Curve Output\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "N9, \\field Maximum Curve Output\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "A3, \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "A4; \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";

    IddObjectType objType(IddObjectType::OS_Curve_Quartic);
    OptionalIddObject oObj = IddObject::load("OS:Curve:Quartic",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Curve_Quartic);
  return object;
}

IddObject createOS_Curve_ExponentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Curve:Exponent,\n";
    ss << "\\min-fields 7\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note curve = C1 + C2*x**C3\n";
    ss << "\\note The independent variable x is raised to the C3 power, multiplied by C2, and C1 is added to the result.\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ExponentCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1, \\field Coefficient1 Constant\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Coefficient2 Constant\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N3, \\field Coefficient3 Constant\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N4, \\field Minimum Value of x\n";
    ss << "\\note Specify the minimum value of the independent variable x allowed\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N5, \\field Maximum Value of x\n";
    ss << "\\note Specify the maximum value of the independent variable x allowed\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N6, \\field Minimum Curve Output\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "N7, \\field Maximum Curve Output\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "A3, \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "A4; \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";

    IddObjectType objType(IddObjectType::OS_Curve_Exponent);
    OptionalIddObject oObj = IddObject::load("OS:Curve:Exponent",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Curve_Exponent);
  return object;
}

IddObject createOS_Curve_BicubicIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Curve:Bicubic,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note curve = C1 + C2*x + C3*x**2 + C4*y + C5*y**2 + C6*x*y + C7*x**3 + C8*y**3 + C9*x**2*y\n";
    ss << "\\note + C10*x*y**2\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference AllCurves\n";
    ss << "\\reference BicubicCurves\n";
    ss << "\\reference BicubicBiquadraticCurves\n";
    ss << "N1, \\field Coefficient1 Constant\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Coefficient2 x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N3, \\field Coefficient3 x**2\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N4, \\field Coefficient4 y\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N5, \\field Coefficient5 y**2\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N6, \\field Coefficient6 x*y\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N7, \\field Coefficient7 x**3\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N8, \\field Coefficient8 y**3\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N9, \\field Coefficient9 x**2*y\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N10, \\field Coefficient10 x*y**2\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N11, \\field Minimum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N12, \\field Maximum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N13, \\field Minimum Value of y\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N14, \\field Maximum Value of y\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N15, \\field Minimum Curve Output\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "N16, \\field Maximum Curve Output\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "A3, \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "A4, \\field Input Unit Type for Y\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "A5; \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";

    IddObjectType objType(IddObjectType::OS_Curve_Bicubic);
    OptionalIddObject oObj = IddObject::load("OS:Curve:Bicubic",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Curve_Bicubic);
  return object;
}

IddObject createOS_Curve_BiquadraticIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Curve:Biquadratic,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note curve = C1 + C2*x + C3*x**2 + C4*y + C5*y**2 + C6*x*y\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference BiquadraticCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "\\reference BiquadraticCubicCurves\n";
    ss << "\\reference BiquadraticQuadraticCubicCurves\n";
    ss << "\\reference BicubicBiquadraticCurves\n";
    ss << "N1, \\field Coefficient1 Constant\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Coefficient2 x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N3, \\field Coefficient3 x**2\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N4, \\field Coefficient4 y\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N5, \\field Coefficient5 y**2\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N6, \\field Coefficient6 x*y\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N7, \\field Minimum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N8, \\field Maximum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N9, \\field Minimum Value of y\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N10, \\field Maximum Value of y\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N11, \\field Minimum Curve Output\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "N12, \\field Maximum Curve Output\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "A3, \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "A4, \\field Input Unit Type for Y\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "A5; \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";

    IddObjectType objType(IddObjectType::OS_Curve_Biquadratic);
    OptionalIddObject oObj = IddObject::load("OS:Curve:Biquadratic",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Curve_Biquadratic);
  return object;
}

IddObject createOS_Curve_QuadraticLinearIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Curve:QuadraticLinear,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note curve = (C1 + C2*x + C3*x**2) + (C4 + C5*x + C6*x**2)*y\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference QuadraticLinearCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1, \\field Coefficient1 Constant\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Coefficient2 x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N3, \\field Coefficient3 x**2\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N4, \\field Coefficient4 y\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N5, \\field Coefficient5 x*y\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N6, \\field Coefficient6 x**2*y\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N7, \\field Minimum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N8, \\field Maximum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N9, \\field Minimum Value of y\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N10, \\field Maximum Value of y\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N11, \\field Minimum Curve Output\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "N12, \\field Maximum Curve Output\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "A3, \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "A4, \\field Input Unit Type for Y\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "A5; \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";

    IddObjectType objType(IddObjectType::OS_Curve_QuadraticLinear);
    OptionalIddObject oObj = IddObject::load("OS:Curve:QuadraticLinear",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Curve_QuadraticLinear);
  return object;
}

IddObject createOS_Curve_TriquadraticIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Curve:Triquadratic,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note 2nd order polynomial in three variable polynomial (all terms)\n";
    ss << "\\note curve = a0 + a1*x**2 + a2*x + a3*y**2 + a4*y\n";
    ss << "\\note + a5*z**2 + a6*z + a7*x**2*y**2 + a8*x*y\n";
    ss << "\\note + a9*x*y**2 + a10*x**2*y + a11*x**2*z**2\n";
    ss << "\\note + a12*x*z + a13*x*z**2 + a14*x**2*z + a15*y**2*z**2\n";
    ss << "\\note + a16*y*z + a17*y*z**2 + a18*y**2*z + a19*x**2*y**2*z**2\n";
    ss << "\\note + a20*x**2*y**2*z + a21*x**2*y*z**2 + a22*x*y**2*z**2\n";
    ss << "\\note + a23*x**2*y*z + a24*x*y**2*z + a25*x*y*z**2 +a26*x*y*z\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference TriQuadraticCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1, \\field Coefficient1 Constant\n";
    ss << "\\type real\n";
    ss << "N2, \\field Coefficient2 x**2\n";
    ss << "\\type real\n";
    ss << "N3, \\field Coefficient3 x\n";
    ss << "\\type real\n";
    ss << "N4, \\field Coefficient4 y**2\n";
    ss << "\\type real\n";
    ss << "N5, \\field Coefficient5 y\n";
    ss << "\\type real\n";
    ss << "N6, \\field Coefficient6 z**2\n";
    ss << "\\type real\n";
    ss << "N7, \\field Coefficient7 z\n";
    ss << "\\type real\n";
    ss << "N8, \\field Coefficient8 x**2*y**2\n";
    ss << "\\type real\n";
    ss << "N9, \\field Coefficient9 x*y\n";
    ss << "\\type real\n";
    ss << "N10, \\field Coefficient10 x*y**2\n";
    ss << "\\type real\n";
    ss << "N11, \\field Coefficient11 x**2*y\n";
    ss << "\\type real\n";
    ss << "N12, \\field Coefficient12 x**2*z**2\n";
    ss << "\\type real\n";
    ss << "N13, \\field Coefficient13 x*z\n";
    ss << "\\type real\n";
    ss << "N14, \\field Coefficient14 x*z**2\n";
    ss << "\\type real\n";
    ss << "N15, \\field Coefficient15 x**2*z\n";
    ss << "\\type real\n";
    ss << "N16, \\field Coefficient16 y**2*z**2\n";
    ss << "\\type real\n";
    ss << "N17, \\field Coefficient17 y*z\n";
    ss << "\\type real\n";
    ss << "N18, \\field Coefficient18 y*z**2\n";
    ss << "\\type real\n";
    ss << "N19, \\field Coefficient19 y**2*z\n";
    ss << "\\type real\n";
    ss << "N20, \\field Coefficient20 x**2*y**2*z**2\n";
    ss << "\\type real\n";
    ss << "N21, \\field Coefficient21 x**2*y**2*z\n";
    ss << "\\type real\n";
    ss << "N22, \\field Coefficient22 x**2*y*z**2\n";
    ss << "\\type real\n";
    ss << "N23, \\field Coefficient23 x*y**2*z**2\n";
    ss << "\\type real\n";
    ss << "N24, \\field Coefficient24 x**2*y*z\n";
    ss << "\\type real\n";
    ss << "N25, \\field Coefficient25 x*y**2*z\n";
    ss << "\\type real\n";
    ss << "N26, \\field Coefficient26 x*y*z**2\n";
    ss << "\\type real\n";
    ss << "N27, \\field Coefficient27 x*y*z\n";
    ss << "\\type real\n";
    ss << "N28, \\field Minimum Value of x\n";
    ss << "\\type real\n";
    ss << "N29, \\field Maximum Value of x\n";
    ss << "\\type real\n";
    ss << "N30, \\field Minimum Value of y\n";
    ss << "\\type real\n";
    ss << "N31, \\field Maximum Value of y\n";
    ss << "\\type real\n";
    ss << "N32, \\field Minimum Value of z\n";
    ss << "\\type real\n";
    ss << "N33, \\field Maximum Value of z\n";
    ss << "\\type real\n";
    ss << "N34, \\field Minimum Curve Output\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "N35, \\field Maximum Curve Output\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "A3, \\field Input Unit Type for X\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "A4, \\field Input Unit Type for Y\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "A5, \\field Input Unit Type for Z\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "A6; \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";

    IddObjectType objType(IddObjectType::OS_Curve_Triquadratic);
    OptionalIddObject oObj = IddObject::load("OS:Curve:Triquadratic",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Curve_Triquadratic);
  return object;
}

IddObject createOS_Curve_Functional_PressureDropIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Curve:Functional:PressureDrop,\n";
    ss << "\\memo Sets up curve information for minor loss and/or friction\n";
    ss << "\\memo calculations in plant pressure simulations\n";
    ss << "\\memo Expression: DeltaP = {K + f*(L/D)} * (rho * V^2) / 2\n";
    ss << "\\min-fields 6\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference AllCurves\n";
    ss << "\\reference PressureDropCurves\n";
    ss << "N1, \\field Diameter\n";
    ss << "\\note \"D\" in above expression, used to also calculate local velocity\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2, \\field Minor Loss Coefficient\n";
    ss << "\\note \"K\" in above expression\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3, \\field Length\n";
    ss << "\\note \"L\" in above expression\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "N4, \\field Roughness\n";
    ss << "\\note This will be used to calculate \"f\" from Moody-chart approximations\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "N5; \\field Fixed Friction Factor\n";
    ss << "\\note Optional way to set a constant value for \"f\", instead of using\n";
    ss << "\\note internal Moody-chart approximations\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";

    IddObjectType objType(IddObjectType::OS_Curve_Functional_PressureDrop);
    OptionalIddObject oObj = IddObject::load("OS:Curve:Functional:PressureDrop",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Curve_Functional_PressureDrop);
  return object;
}

IddObject createOS_Curve_FanPressureRiseIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Curve:FanPressureRise,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note curve = C1*Qfan**2+C2*Qfan+C3*Qfan*(Psm-Po)**0.5+C4*(Psm-Po)\n";
    ss << "\\note Po assumed to be zero\n";
    ss << "\\note See InputOut Reference for curve details\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference FanPressureRiseCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1, \\field Coefficient1 C1\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Coefficient2 C2\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N3, \\field Coefficient3 C3\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N4, \\field Coefficient4 C4\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N5, \\field Minimum Value of Qfan\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "N6, \\field Maximum Value of Qfan\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "N7, \\field Minimum Value of Psm\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units Pa\n";
    ss << "N8, \\field Maximum Value of Psm\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units Pa\n";
    ss << "N9, \\field Minimum Curve Output\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units Pa\n";
    ss << "N10; \\field Maximum Curve Output\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units Pa\n";

    IddObjectType objType(IddObjectType::OS_Curve_FanPressureRise);
    OptionalIddObject oObj = IddObject::load("OS:Curve:FanPressureRise",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Curve_FanPressureRise);
  return object;
}

IddObject createOS_Curve_ExponentialSkewNormalIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Curve:ExponentialSkewNormal,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note See InputOut Reference for curve description\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ExponentialSkewNormalCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1, \\field Coefficient1 C1\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Coefficient2 C2\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N3, \\field Coefficient3 C3\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N4, \\field Coefficient4 C4\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N5, \\field Minimum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N6, \\field Maximum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N7, \\field Minimum Curve Output\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "N8, \\field Maximum Curve Output\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "A3, \\field Input Unit Type for x\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "A4; \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";

    IddObjectType objType(IddObjectType::OS_Curve_ExponentialSkewNormal);
    OptionalIddObject oObj = IddObject::load("OS:Curve:ExponentialSkewNormal",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Curve_ExponentialSkewNormal);
  return object;
}

IddObject createOS_Curve_SigmoidIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Curve:Sigmoid,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note See InputOut Reference for curve description\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference SigmoidCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1, \\field Coefficient1 C1\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Coefficient2 C2\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N3, \\field Coefficient3 C3\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N4, \\field Coefficient4 C4\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N5, \\field Coefficient5 C5\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N6, \\field Minimum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N7, \\field Maximum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N8, \\field Minimum Curve Output\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "N9, \\field Maximum Curve Output\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "A3, \\field Input Unit Type for x\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "A4; \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";

    IddObjectType objType(IddObjectType::OS_Curve_Sigmoid);
    OptionalIddObject oObj = IddObject::load("OS:Curve:Sigmoid",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Curve_Sigmoid);
  return object;
}

IddObject createOS_Curve_RectangularHyperbola1IddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Curve:RectangularHyperbola1,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note curve = ((C1*x)/(C2+x))+C3\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference RectangularHyperbola1Curves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1, \\field Coefficient1 C1\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Coefficient2 C2\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N3, \\field Coefficient3 C3\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N4, \\field Minimum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N5, \\field Maximum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N6, \\field Minimum Curve Output\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "N7, \\field Maximum Curve Output\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "A3, \\field Input Unit Type for x\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "A4; \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";

    IddObjectType objType(IddObjectType::OS_Curve_RectangularHyperbola1);
    OptionalIddObject oObj = IddObject::load("OS:Curve:RectangularHyperbola1",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Curve_RectangularHyperbola1);
  return object;
}

IddObject createOS_Curve_RectangularHyperbola2IddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Curve:RectangularHyperbola2,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note curve = ((C1*x)/(C2+x))+(C3*x)\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference RectangularHyperbola2Curves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1, \\field Coefficient1 C1\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Coefficient2 C2\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N3, \\field Coefficient3 C3\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N4, \\field Minimum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N5, \\field Maximum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N6, \\field Minimum Curve Output\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "N7, \\field Maximum Curve Output\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "A3, \\field Input Unit Type for x\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "A4; \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";

    IddObjectType objType(IddObjectType::OS_Curve_RectangularHyperbola2);
    OptionalIddObject oObj = IddObject::load("OS:Curve:RectangularHyperbola2",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Curve_RectangularHyperbola2);
  return object;
}

IddObject createOS_Curve_ExponentialDecayIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Curve:ExponentialDecay,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note curve = C1+C2*exp(C3*x)\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ExponentialDecayCurves\n";
    ss << "\\reference AllCurves\n";
    ss << "N1, \\field Coefficient1 C1\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Coefficient2 C2\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N3, \\field Coefficient3 C3\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N4, \\field Minimum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N5, \\field Maximum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N6, \\field Minimum Curve Output\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "N7, \\field Maximum Curve Output\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "A3, \\field Input Unit Type for x\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "A4; \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";

    IddObjectType objType(IddObjectType::OS_Curve_ExponentialDecay);
    OptionalIddObject oObj = IddObject::load("OS:Curve:ExponentialDecay",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Curve_ExponentialDecay);
  return object;
}

IddObject createOS_Curve_DoubleExponentialDecayIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Curve:DoubleExponentialDecay,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference DoubleExponentialDecayCurves\n";
    ss << "N1, \\field Coefficient1 C1\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Coefficient2 C2\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N3, \\field Coefficient3 C3\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N4, \\field Coefficient3 C4\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N5, \\field Coefficient3 C5\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N6, \\field Minimum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N7, \\field Maximum Value of x\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N8, \\field Minimum Curve Output\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "N9, \\field Maximum Curve Output\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "\\type real\n";
    ss << "A3, \\field Input Unit Type for x\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";
    ss << "A4; \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\default Dimensionless\n";
    ss << "\\key Dimensionless\n";

    IddObjectType objType(IddObjectType::OS_Curve_DoubleExponentialDecay);
    OptionalIddObject oObj = IddObject::load("OS:Curve:DoubleExponentialDecay",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Curve_DoubleExponentialDecay);
  return object;
}

IddObject createOS_Table_MultiVariableLookupIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Table:MultiVariableLookup,\n";
    ss << "\\memo The multi-variable lookup table can represent from 1 to 5 independent variables and\n";
    ss << "\\memo can interpolate these independent variables up to a 4th order polynomial. The\n";
    ss << "\\memo polynomial order is assumed to be the number of interpolation points (n) minus 1.\n";
    ss << "\\memo When any independent variable value is outside the table limits, linear extrapolation\n";
    ss << "\\memo is used to predict the table result and is based on the two nearest data points in the\n";
    ss << "\\memo table for that particularindependent variable.\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 29\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference TableMultiVariableLookup\n";
    ss << "\\reference AllCurves\n";
    ss << "\\reference LinearCurves\n";
    ss << "\\reference LinearOrQuadraticCurves\n";
    ss << "\\reference QuadraticCurves\n";
    ss << "\\reference QuadraticCubicCurves\n";
    ss << "\\reference BiquadraticQuadraticCubicCurves\n";
    ss << "\\reference CubicCurves\n";
    ss << "\\reference QuarticCurves\n";
    ss << "\\reference BicubicCurves\n";
    ss << "\\reference BicubicBiquadraticCurves\n";
    ss << "\\reference BiquadraticCurves\n";
    ss << "\\reference QuadraticLinearCurves\n";
    ss << "\\reference TriQuadraticCurves\n";
    ss << "\\reference BiquadraticCubicCurves\n";
    ss << "\\reference BiVariateTables\n";
    ss << "\\reference UniVariateTables\n";
    ss << "A3 , \\field Interpolation Method\n";
    ss << "\\type choice\n";
    ss << "\\key LinearInterpolationOfTable\n";
    ss << "\\key EvaluateCurveToLimits\n";
    ss << "\\key LagrangeInterpolationLinearExtrapolation\n";
    ss << "\\default LagrangeInterpolationLinearExtrapolation\n";
    ss << "N1 , \\field Number of Interpolation Points\n";
    ss << "\\type integer\n";
    ss << "\\minimum> 1\n";
    ss << "\\maximum 4\n";
    ss << "\\default 3\n";
    ss << "A4 , \\field Curve Type\n";
    ss << "\\type choice\n";
    ss << "\\key Linear\n";
    ss << "\\key Quadratic\n";
    ss << "\\key Cubic\n";
    ss << "\\key Quartic\n";
    ss << "\\key Exponent\n";
    ss << "\\key BiQuadratic\n";
    ss << "\\key QuadraticLinear\n";
    ss << "\\key BiCubic\n";
    ss << "\\key TriQuadratic\n";
    ss << "\\key Other\n";
    ss << "\\note The curve types BiCubic and TriQuadratic may not\n";
    ss << "\\note be used with Interpolation Method = EvaluateCurveToLimits\n";
    ss << "A5 , \\field Table Data Format\n";
    ss << "\\type choice\n";
    ss << "\\key SingleLineIndependentVariableWithMatrix\n";
    ss << "\\default SingleLineIndependentVariableWithMatrix\n";
    ss << "A6 , \\field External File Name\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "A7 , \\field X1 Sort Order\n";
    ss << "\\type choice\n";
    ss << "\\key Ascending\n";
    ss << "\\key Descending\n";
    ss << "\\default Ascending\n";
    ss << "A8 , \\field X2 Sort Order\n";
    ss << "\\type choice\n";
    ss << "\\key Ascending\n";
    ss << "\\key Descending\n";
    ss << "\\default Ascending\n";
    ss << "N2 , \\field Normalization Reference\n";
    ss << "\\type real\n";
    ss << "\\note This field is used to normalize the table output data.\n";
    ss << "\\note The minimum and maximum table output fields are also normalized.\n";
    ss << "\\note If this field is blank or 1, the table data will be directly used.\n";
    ss << "\\note This field is not allowed to be set equal to 0.\n";
    ss << "N3 , \\field Minimum Value of X1\n";
    ss << "\\type real\n";
    ss << "N4 , \\field Maximum Value of X1\n";
    ss << "\\type real\n";
    ss << "N5 , \\field Minimum Value of X2\n";
    ss << "\\type real\n";
    ss << "N6 , \\field Maximum Value of X2\n";
    ss << "\\type real\n";
    ss << "N7 , \\field Minimum Value of X3\n";
    ss << "\\type real\n";
    ss << "N8 , \\field Maximum Value of X3\n";
    ss << "\\type real\n";
    ss << "N9 , \\field Minimum Value of X4\n";
    ss << "\\type real\n";
    ss << "N10, \\field Maximum Value of X4\n";
    ss << "\\type real\n";
    ss << "N11, \\field Minimum Value of X5\n";
    ss << "\\type real\n";
    ss << "N12, \\field Maximum Value of X5\n";
    ss << "\\type real\n";
    ss << "N13, \\field Minimum Table Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the minimum value calculated by this curve object\n";
    ss << "N14, \\field Maximum Table Output\n";
    ss << "\\type real\n";
    ss << "\\note Specify the maximum value calculated by this curve object\n";
    ss << "A9 , \\field Input Unit Type for X1\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A10 , \\field Input Unit Type for X2\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A11, \\field Input Unit Type for X3\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A12, \\field Input Unit Type for X4\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A13, \\field Input Unit Type for X5\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Temperature\n";
    ss << "\\key VolumetricFlow\n";
    ss << "\\key MassFlow\n";
    ss << "\\key Power\n";
    ss << "\\key Distance\n";
    ss << "\\default Dimensionless\n";
    ss << "A14, \\field Output Unit Type\n";
    ss << "\\type choice\n";
    ss << "\\key Dimensionless\n";
    ss << "\\key Capacity\n";
    ss << "\\key Power\n";
    ss << "\\default Dimensionless\n";
    ss << "N15, \\field Number of Independent Variables\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 5\n";
    ss << "\\required-field\n";
    ss << "N16; \\field Data\n";
    ss << "\\type real\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::OS_Table_MultiVariableLookup);
    OptionalIddObject oObj = IddObject::load("OS:Table:MultiVariableLookup",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Table_MultiVariableLookup);
  return object;
}

IddObject createOS_DesignSpecification_OutdoorAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:DesignSpecification:OutdoorAir,\n";
    ss << "\\memo This object is used to describe general outdoor air requirements which\n";
    ss << "\\memo are referenced by other objects.\n";
    ss << "\\min-fields 8\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note Enter a unique name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference DesignSpecificationOutdoorAirNames\n";
    ss << "A3, \\field Outdoor Air Method\n";
    ss << "\\type choice\n";
    ss << "\\default Sum\n";
    ss << "\\key Sum\n";
    ss << "\\key Maximum\n";
    ss << "N1, \\field Outdoor Air Flow per Person\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-person\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N2, \\field Outdoor Air Flow per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N3, \\field Outdoor Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N4, \\field Outdoor Air Flow Air Changes per Hour\n";
    ss << "\\units 1/hr\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "A4; \\field Outdoor Air Flow Rate Fraction Schedule Name\n";
    ss << "\\note Schedule values are multiplied by the Outdoor Air Flow rate calculated using\n";
    ss << "\\note the previous four inputs. Schedule values are limited to 0 to 1.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_DesignSpecification_OutdoorAir);
    OptionalIddObject oObj = IddObject::load("OS:DesignSpecification:OutdoorAir",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_DesignSpecification_OutdoorAir);
  return object;
}

IddObject createOS_DesignSpecification_ZoneAirDistributionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:DesignSpecification:ZoneAirDistribution,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference DesignSpecificationZoneAirDistributionNames\n";
    ss << "N1,  \\field Zone Air Distribution Effectiveness in Cooling Mode\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units dimensionless\n";
    ss << "N2,  \\field Zone Air Distribution Effectiveness in Heating Mode\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units dimensionless\n";
    ss << "A3,  \\field Zone Air Distribution Effectiveness Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note optionally used to replace Zone Air Distribution Effectiveness in Cooling and\n";
    ss << "\\note Heating Mode\n";
    ss << "N3;  \\field Zone Secondary Recirculation Fraction\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "\\minimum 0.0\n";
    ss << "\\units dimensionless\n";

    IddObjectType objType(IddObjectType::OS_DesignSpecification_ZoneAirDistribution);
    OptionalIddObject oObj = IddObject::load("OS:DesignSpecification:ZoneAirDistribution",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_DesignSpecification_ZoneAirDistribution);
  return object;
}

IddObject createOS_Humidifier_Steam_ElectricIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Humidifier:Steam:Electric,\n";
    ss << "\\memo Electrically heated steam humidifier with fan.\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Rated Capacity\n";
    ss << "\\note Capacity is m3/s of water at 5.05 C\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Rated Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units W\n";
    ss << "\\autosizable\n";
    ss << "\\note if autosized the rated power is calculated from the rated capacity\n";
    ss << "\\note and enthalpy rise of water from 20.0C to 100.0C steam and assumes\n";
    ss << "\\note electric to thermal energy conversion efficiency of 100.0%\n";
    ss << "N3, \\field Rated Fan Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units W\n";
    ss << "N4, \\field Standby Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units W\n";
    ss << "A4, \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6; \\field Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";

    IddObjectType objType(IddObjectType::OS_Humidifier_Steam_Electric);
    OptionalIddObject oObj = IddObject::load("OS:Humidifier:Steam:Electric",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Humidifier_Steam_Electric);
  return object;
}

IddObject createOS_EvaporativeCooler_Indirect_ResearchSpecialIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:EvaporativeCooler:Indirect:ResearchSpecial,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Cooler Maximum Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 2.0\n";
    ss << "\\required-field\n";
    ss << "N2 , \\field Cooler Flow Ratio\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Recirculating Water Pump Power Consumption\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "N4 , \\field Secondary Fan Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N5 , \\field Secondary Fan Total Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\required-field\n";
    ss << "N6 , \\field Secondary Fan Delta Pressure\n";
    ss << "\\units Pa\n";
    ss << "\\minimum 0.0\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\required-field\n";
    ss << "A4 , \\field Primary Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5 , \\field Primary Air Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6 , \\Field Control Type\n";
    ss << "N7 , \\field Dewpoint Effectiveness Factor\n";
    ss << "\\required-field\n";
    ss << "A7 , \\Field Secondary Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "A8 , \\Field Sensor Node Name\n";
    ss << "\\object-list Node\n";
    ss << "A9 , \\Field Relief Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "A10, \\Field Water Supply Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "N8 , \\field Drift Loss Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Rate of drift loss as a fraction of evaporated water flow rate\n";
    ss << "N9 , \\field Blowdown Concentration Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 2.0\n";
    ss << "\\note Characterizes the rate of blowdown in the evaporative cooler.\n";
    ss << "\\note Blowdown is water intentionally drained from the cooler in order to offset the build up\n";
    ss << "\\note of solids in the water that would otherwise occur because of evaporation.\n";
    ss << "\\note Ratio of solids in the blowdown water to solids in the make up water.\n";
    ss << "\\note A typical value is 3.  If left blank then there is no blowdown.\n";
    ss << "A11 , \\field Wetbulb Effectiveness Flow Ratio Modifier Curve Name\n";
    ss << "\\note this curve modifies the wetbulb effectiveness in the previous field (eff_wb_design)\n";
    ss << "\\note by multiplying the value by the result of this curve, eff_wb = eff_wb_design * func(HXFlowRatio)\n";
    ss << "\\note x = HXFlowRatio = sum of the primary and secondary flow rates divided by the sum of the design flow rates\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllCurves\n";
    ss << "\\note Any curve or table with one independent variable can be used:\n";
    ss << "\\note Curve:Linear, Curve:Quadratic, Curve:Cubic, Curve:Quartic, Curve:Exponent,\n";
    ss << "\\note Curve:ExponentialSkewNormal, Curve:Sigmoid, Curve:RectuangularHyperbola1,\n";
    ss << "\\note Curve:RectangularHyperbola2, Curve:ExponentialDecay, Curve:DoubleExponentialDecay,\n";
    ss << "\\note Table:OneIndependentVariable\n";
    ss << "N10 , \\field Cooler Drybulb Design Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\note dry operation effectiveness with respect to drybulb temperature difference\n";
    ss << "\\note this is the nominal design dryblub effectiveness at design air flow rates, no evaporation water active\n";
    ss << "\\minimum 0.0\n";
    ss << "A12 , \\field Drybulb Effectiveness Flow Ratio Modifier Curve Name\n";
    ss << "\\note this curve modifies the drybulb effectiveness in the previous field (eff_db_design)\n";
    ss << "\\note by multiplying the value by the result of this curve, eff_db = eff_db_design * f(HXFlowRatio)\n";
    ss << "\\note x = HXFlowRatio = sum of the primary and secondary flow rates divided by the sum of the design flow rates\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllCurves\n";
    ss << "\\note Any curve or table with one independent variable can be used:\n";
    ss << "\\note Curve:Linear, Curve:Quadratic, Curve:Cubic, Curve:Quartic, Curve:Exponent,\n";
    ss << "\\note Curve:ExponentialSkewNormal, Curve:Sigmoid, Curve:RectuangularHyperbola1,\n";
    ss << "\\note Curve:RectangularHyperbola2, Curve:ExponentialDecay, Curve:DoubleExponentialDecay,\n";
    ss << "\\note Table:OneIndependentVariable\n";
    ss << "N11 , \\field Water Pump Power Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W/(m3/s)\n";
    ss << "\\note this field is used when the previous field is set to autosize. The pump power is scaled with Secondary Design Air Flow Rate\n";
    ss << "A13 , \\field Water Pump Power Modifier Curve Name\n";
    ss << "\\note this curve modifies the pump power in the previous field by multiplying the design power by the result of this curve.\n";
    ss << "\\note x = ff = flow fraction on the secondary side, secondary air flow rate during operation divided by Secondary Design Air Flow Rate\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllCurves\n";
    ss << "\\note Any curve or table with one independent variable can be used:\n";
    ss << "\\note Curve:Linear, Curve:Quadratic, Curve:Cubic, Curve:Quartic, Curve:Exponent,\n";
    ss << "\\note Curve:ExponentialSkewNormal, Curve:Sigmoid, Curve:RectuangularHyperbola1,\n";
    ss << "\\note Curve:RectangularHyperbola2, Curve:ExponentialDecay, Curve:DoubleExponentialDecay,\n";
    ss << "\\note Table:OneIndependentVariable\n";
    ss << "N12 , \\field Secondary Air Flow Scaling Factor\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units dimensionless\n";
    ss << "\\note This field is used when the previous field is set to autoize.  The Primary Design Air Flow Rate is scaled using this factor\n";
    ss << "\\note to calculate the secondary design air flow rate.\n";
    ss << "N13 , \\field Secondary Air Fan Design Power\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\note This is the fan power at Secondary Design Air Flow Rate\n";
    ss << "\\note this is the nominal design power at full speed.\n";
    ss << "\\autosizable\n";
    ss << "A14 , \\field Secondary Air Fan Power Modifier Curve Name\n";
    ss << "\\note this curve modifies the design fan power in the previous field by multiplying the value by the result\n";
    ss << "\\note of this curve.  It should have a value of 1.0 at a x = 1.0.\n";
    ss << "\\note x = ff = flow fraction on the secondary side, secondary air flow rate during operation divided by Secondary Design Air Flow Rate\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllCurves\n";
    ss << "\\note Any curve or table with one independent variable can be used:\n";
    ss << "\\note Curve:Linear, Curve:Quadratic, Curve:Cubic, Curve:Quartic, Curve:Exponent,\n";
    ss << "\\note Curve:ExponentialSkewNormal, Curve:Sigmoid, Curve:RectuangularHyperbola1,\n";
    ss << "\\note Curve:RectangularHyperbola2, Curve:ExponentialDecay, Curve:DoubleExponentialDecay,\n";
    ss << "\\note Table:OneIndependentVariable\n";
    ss << "N14 ; \\field Primary Design Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";

    IddObjectType objType(IddObjectType::OS_EvaporativeCooler_Indirect_ResearchSpecial);
    OptionalIddObject oObj = IddObject::load("OS:EvaporativeCooler:Indirect:ResearchSpecial",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_EvaporativeCooler_Indirect_ResearchSpecial);
  return object;
}

IddObject createOS_EvaporativeCooler_Direct_ResearchSpecialIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:EvaporativeCooler:Direct:ResearchSpecial,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Cooler Effectiveness\n";
    ss << "\\note effectiveness with respect to wetbulb depression\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "N2, \\field Recirculating Water Pump Power Consumption\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "N3 , \\field Primary Air Design Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "A4, \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6, \\field Sensor Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "N4, \\field Drift Loss Fraction\n";
    ss << "\\note Rate of drift loss as a fraction of evaporated water flow rate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0\n";
    ss << "N5, \\field Blowdown Concentration Ratio\n";
    ss << "\\note Characterizes the rate of blowdown in the evaporative cooler.\n";
    ss << "\\note Blowdown is water intentionally drained from the cooler in order to offset the build up\n";
    ss << "\\note of solids in the water that would otherwise occur because of evaporation.\n";
    ss << "\\note Ratio of solids in the blowdown water to solids in the make up water.\n";
    ss << "\\note A typical value is 3. If left blank then there is no blowdown.\n";
    ss << "\\note In OpenStudio a value less than 2  gets translated into a blank field by the EnergyPlus translator\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0\n";
    ss << "A7,  \\field Effectiveness Flow Ratio Modifier Curve Name\n";
    ss << "\\note this curve modifies the design effectiveness in the previous field\n";
    ss << "\\note by multiplying the value by the result of this curve.  The effectiveness flow modifier curve\n";
    ss << "\\note is a function of flow fraction. Flow fraction is the ratio of current primary air flow rate to\n";
    ss << "\\note the primary air design flow rate. If this input field is left blank then, the effectiveness\n";
    ss << "\\note is assumed to be constant.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllCurves\n";
    ss << "\\note Any curve or table with one independent variable can be used:\n";
    ss << "\\note Curve:Linear, Curve:Quadratic, Curve:Cubic, Curve:Quartic, Curve:Exponent,\n";
    ss << "\\note Curve:ExponentialSkewNormal, Curve:Sigmoid, Curve:RectuangularHyperbola1,\n";
    ss << "\\note Curve:RectangularHyperbola2, Curve:ExponentialDecay, Curve:DoubleExponentialDecay,\n";
    ss << "\\note Table:OneIndependentVariable\n";
    ss << "N6,  \\field Water Pump Power Sizing Factor\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W/(m3/s)\n";
    ss << "\\note this field is used when the previous field is set to autosize. The pump power is scaled with Primary Air Design Air Flow Rate\n";
    ss << "A8;  \\field Water Pump Power Modifier Curve Name\n";
    ss << "\\note this curve modifies the pump power in the previous field by multiplying the design power by the result of this curve.\n";
    ss << "\\note x = ff = flow fraction on the primary air.  The flow fraction is the secondary air flow rate during current operation divided\n";
    ss << "\\note by Primary Air Design Flow Rate\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllCurves\n";
    ss << "\\note Any curve or table with one independent variable can be used:\n";
    ss << "\\note Curve:Linear, Curve:Quadratic, Curve:Cubic, Curve:Quartic, Curve:Exponent,\n";
    ss << "\\note Curve:ExponentialSkewNormal, Curve:Sigmoid, Curve:RectuangularHyperbola1,\n";
    ss << "\\note Curve:RectangularHyperbola2, Curve:ExponentialDecay, Curve:DoubleExponentialDecay,\n";
    ss << "\\note Table:OneIndependentVariable\n";

    IddObjectType objType(IddObjectType::OS_EvaporativeCooler_Direct_ResearchSpecial);
    OptionalIddObject oObj = IddObject::load("OS:EvaporativeCooler:Direct:ResearchSpecial",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_EvaporativeCooler_Direct_ResearchSpecial);
  return object;
}

IddObject createOS_EvaporativeFluidCooler_SingleSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:EvaporativeFluidCooler:SingleSpeed,\n";
    ss << "\\min-fields 10\n";
    ss << "\\memo This model is based on Merkel's theory, which is also the basis\n";
    ss << "\\memo for the cooling tower model in EnergyPlus. The Evaporative fluid cooler\n";
    ss << "\\memo is modeled as a counter flow heat exchanger.\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "\\note Fluid Cooler Name\n";
    ss << "A3 , \\field Water Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note Name of Fluid Cooler water inlet node\n";
    ss << "A4 , \\field Water Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note Name of Fluid Cooler water outlet node\n";
    ss << "N1 , \\field Design Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field Fan Power at Design Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\note This is the fan motor electric input power\n";
    ss << "N3 , \\field Design Spray Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "A5 , \\field Performance Input Method\n";
    ss << "\\type Choice\n";
    ss << "\\key UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\key StandardDesignCapacity\n";
    ss << "\\key UserSpecifiedDesignCapacity\n";
    ss << "\\note User can define fluid cooler thermal performance by specifying the fluid cooler UA\n";
    ss << "\\note and the Design Water Flow Rate, or by specifying the fluid cooler Standard Design\n";
    ss << "\\note Capacity or by specifying Design Capacity for Non standard conditions.\n";
    ss << "A6 , \\field Outdoor Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note Enter the name of an outdoor air node\n";
    ss << "N4 , \\field Standard Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Standard design capacity with entering water at 35C (95F), leaving water at\n";
    ss << "\\note 29.44C (85F), entering air at 25.56C (78F) wet-bulb temperature and 35C (95F)\n";
    ss << "\\note dry-bulb temperature. Design water flow rate assumed to be 5.382E-8 m3/s per watt\n";
    ss << "\\note (3 gpm/ton). Standard design capacity times (1.25) gives the actual fluid cooler\n";
    ss << "\\note heat rejection at these operating conditions.\n";
    ss << "\\note Only used for Performance Input Method = StandardDesignCapacity;\n";
    ss << "\\note for other input methods, this field is ignored.\n";
    ss << "\\note The standard conditions mentioned above for Standard design capacity are already\n";
    ss << "\\note specified in the EnergyPlus. So the input fields such as design entering water\n";
    ss << "\\note temp., design entering air wet-bulb and dry-bulb temp. and design water flow rate, if\n";
    ss << "\\note provided in the input, will be ignored for the StandardDesignCapacity performance input\n";
    ss << "\\note method. Also, the standard conditions are for water as a fluid type so this performance input\n";
    ss << "\\note method can only be used with water as a fluid type (as specified in CondenserLoop object).\n";
    ss << "N5 , \\field U-factor Times Area Value at Design Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 2100000.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Only used for Performance Input Method = UFactorTimesAreaAndDesignWaterFlowRate;\n";
    ss << "\\note for other Performance Input Methods, this field is ignored.\n";
    ss << "N6 , \\field Design Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\note Input value is ignored if fluid cooler Performance Input Method= StandardDesignCapacity.\n";
    ss << "N7 , \\field User Specified Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Only used for Performance Input Method = UserSpecifiedDesignCapacity;\n";
    ss << "\\note for other Performance Input Methods, this field is ignored.\n";
    ss << "N8 , \\field Design Entering Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Only used for Performance Input Method = UserSpecifiedDesignCapacity;\n";
    ss << "\\note for other Performance Input Methods, this field is ignored.\n";
    ss << "\\note Design Entering Water Temperature must be greater than Design Entering Air Temperature.\n";
    ss << "N9 , \\field Design Entering Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Only used for Performance Input Method = UserSpecifiedDesignCapacity;\n";
    ss << "\\note for other Performance Input Methods, this field is ignored.\n";
    ss << "\\note Design Entering Air Temperature must be greater than Design Entering Air Wet-bulb\n";
    ss << "\\note Temperature.\n";
    ss << "N10, \\field Design Entering Air Wet-bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Only used for Performance Input Method = UserSpecifiedDesignCapacity;\n";
    ss << "\\note for other Performance Input Methods, this field is ignored.\n";
    ss << "\\note Design Entering Air Wet-bulb Temperature must be less than Design Entering Air\n";
    ss << "\\note Temperature.\n";
    ss << "A7 , \\field Capacity Control\n";
    ss << "\\type choice\n";
    ss << "\\key FanCycling\n";
    ss << "\\key FluidBypass\n";
    ss << "\\default FanCycling\n";
    ss << "N11, \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized capacity and flow rates\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "A8 , \\field Evaporation Loss Mode\n";
    ss << "\\type choice\n";
    ss << "\\key LossFactor\n";
    ss << "\\key SaturatedExit\n";
    ss << "\\default SaturatedExit\n";
    ss << "N12, \\field Evaporation Loss Factor\n";
    ss << "\\type real\n";
    ss << "\\units percent/K\n";
    ss << "\\note Rate of water evaporation from the Fluid Cooler and lost to the outdoor air [%/K]\n";
    ss << "\\note Empirical correlation is used to calculate default loss factor if it not explicitly provided.\n";
    ss << "N13, \\field Drift Loss Percent\n";
    ss << "\\type real\n";
    ss << "\\default 0.008\n";
    ss << "\\units percent\n";
    ss << "\\note Rate of drift loss as a percentage of circulating spray water flow rate\n";
    ss << "\\note Default value for this field in under investigation. For now Cooling tower's drift loss\n";
    ss << "\\note percent default value is taken here.\n";
    ss << "A9 , \\field Blowdown Calculation Mode\n";
    ss << "\\type choice\n";
    ss << "\\key ConcentrationRatio\n";
    ss << "\\key ScheduledRate\n";
    ss << "\\default ConcentrationRatio\n";
    ss << "N14, \\field Blowdown Concentration Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 2.0\n";
    ss << "\\default 3.0\n";
    ss << "\\note Characterizes the rate of blowdown in the Evaporative Fluid Cooler.\n";
    ss << "\\note Blowdown is water intentionally drained from the basin in order to offset the build\n";
    ss << "\\note up of solids in the water that would otherwise occur because of evaporation.\n";
    ss << "\\note Ratio of solids in the blowdown water to solids in the make up water.\n";
    ss << "\\note Default value for this field in under investigation. For now Cooling tower's\n";
    ss << "\\note Blowdown Concentration Ratio percent default value is taken here.\n";
    ss << "A10, \\field Blowdown Makeup Water Usage Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Makeup water usage due to blowdown results from occasionally draining a small\n";
    ss << "\\note amount of water in the Fluid Cooler basin to purge scale or other contaminants to\n";
    ss << "\\note reduce their concentration in order to maintain an acceptable level of water quality.\n";
    ss << "\\note Schedule values should reflect water usage in m3/s.\n";
    ss << "A11; \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";

    IddObjectType objType(IddObjectType::OS_EvaporativeFluidCooler_SingleSpeed);
    OptionalIddObject oObj = IddObject::load("OS:EvaporativeFluidCooler:SingleSpeed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_EvaporativeFluidCooler_SingleSpeed);
  return object;
}

IddObject createOS_EvaporativeFluidCooler_TwoSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:EvaporativeFluidCooler:TwoSpeed,\n";
    ss << "\\min-fields 34\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Water Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4 , \\field Water Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 , \\field High Fan Speed Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 , \\field High Fan Speed Fan Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\note This is the fan motor electric input power at high speed\n";
    ss << "N3 , \\field Low Fan Speed Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Low speed air flow rate must be less than high speed air flow rate\n";
    ss << "N4 , \\field Low Fan Speed Air Flow Rate Sizing Factor\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate\n";
    ss << "N5 , \\field Low Fan Speed Fan Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\note This is the fan motor electric input power at low speed\n";
    ss << "N6 , \\field Low Fan Speed Fan Power Sizing Factor\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate.\n";
    ss << "N7 , \\field Design Spray Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units gal/min\n";
    ss << "A5 , \\field Performance Input Method\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\key StandardDesignCapacity\n";
    ss << "\\key UserSpecifiedDesignCapacity\n";
    ss << "\\note User can define fluid cooler thermal performance by specifying the fluid cooler UA\n";
    ss << "\\note and the Design Water Flow Rate, or by specifying the fluid cooler Standard Design\n";
    ss << "\\note Capacity or by specifying Design Capacity for Non standard conditions.\n";
    ss << "A6 , \\field Outdoor Air Inlet Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\note Enter the name of an outdoor air node\n";
    ss << "N8 , \\field Heat Rejection Capacity and Nominal Capacity Sizing Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "N9 , \\field High Speed Standard Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "N10, \\field Low Speed Standard Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N11, \\field Low Speed Standard Capacity Sizing Factor\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate\n";
    ss << "N12, \\field High Fan Speed U-factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 2100000.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Only used for Performance Input Method = UFactorTimesAreaAndDesignWaterFlowRate;\n";
    ss << "\\note for other Performance Input Methods, this field is ignored.\n";
    ss << "N13, \\field Low Fan Speed U-factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 300000.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Only used for Performance Input Method = UFactorTimesAreaAndDesignWaterFlowRate;\n";
    ss << "\\note for other input methods, this field is ignored.\n";
    ss << "\\note Low speed fluid cooler UA must be less than high speed fluid cooler UA\n";
    ss << "N14, \\field Low Fan Speed U-Factor Times Area Sizing Factor\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate and\n";
    ss << "\\note the Performance Input Method is UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "N15, \\field Design Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\note Input value is ignored if fluid cooler Performance Input Method= StandardDesignCapacity\n";
    ss << "N16, \\field High Speed User Specified Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Only used for Performance Input Method = UserSpecifiedDesignCapacity;\n";
    ss << "\\note for other Performance Input Methods, this field is ignored.\n";
    ss << "N17, \\field Low Speed User Specified Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Only used for Performance Input Method = UserSpecifiedDesignCapacity;\n";
    ss << "\\note for other Performance Input Methods, this field is ignored.\n";
    ss << "N18, \\field Low Speed User Specified Design Capacity Sizing Factor\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note This field is only used if the previous field is set to autocalculate\n";
    ss << "N19, \\field Design Entering Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "N20, \\field Design Entering Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "N21, \\field Design Entering Air Wet-bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Temperature.\n";
    ss << "N22, \\field High Speed Sizing Factor\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "A7 , \\field Evaporation Loss Mode\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key LossFactor\n";
    ss << "\\key SaturatedExit\n";
    ss << "N23, \\field Evaporation Loss Factor\n";
    ss << "\\type real\n";
    ss << "\\units percent/K\n";
    ss << "N24, \\field Drift Loss Percent\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "A8 , \\field Blowdown Calculation Mode\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key ConcentrationRatio\n";
    ss << "\\key ScheduledRate\n";
    ss << "N25, \\field Blowdown Concentration Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 2.0\n";
    ss << "A9 , \\field Blowdown Makeup Water Usage Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A10; \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";

    IddObjectType objType(IddObjectType::OS_EvaporativeFluidCooler_TwoSpeed);
    OptionalIddObject oObj = IddObject::load("OS:EvaporativeFluidCooler:TwoSpeed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_EvaporativeFluidCooler_TwoSpeed);
  return object;
}

IddObject createOS_Fan_ConstantVolumeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Fan:ConstantVolume,\n";
    ss << "\\min-fields 10\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference Fans\n";
    ss << "\\reference FansCV\n";
    ss << "\\reference FansCVandOnOff\n";
    ss << "\\reference FansCVandVAV\n";
    ss << "\\reference FansCVandOnOffandVAV\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Fan Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.7\n";
    ss << "N2, \\field Pressure Rise\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\default 250.0\n";
    ss << "N3, \\field Maximum Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "N4, \\field Motor Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.9\n";
    ss << "N5, \\field Motor In Airstream Fraction\n";
    ss << "\\note 0.0 means fan motor outside of air stream, 1.0 means motor inside of air stream\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 1.0\n";
    ss << "A4, \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::OS_Fan_ConstantVolume);
    OptionalIddObject oObj = IddObject::load("OS:Fan:ConstantVolume",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Fan_ConstantVolume);
  return object;
}

IddObject createOS_Fan_VariableVolumeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Fan:VariableVolume,\n";
    ss << "\\min-fields 18\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference Fans\n";
    ss << "\\reference FansVAV\n";
    ss << "\\reference FansCVandVAV\n";
    ss << "\\reference FansOnOffandVAV\n";
    ss << "\\reference FansCVandOnOffandVAV\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Fan Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.7\n";
    ss << "N2, \\field Pressure Rise\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "N3, \\field Maximum Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "A4, \\field Fan Power Minimum Flow Rate Input Method\n";
    ss << "\\type choice\n";
    ss << "\\default Fraction\n";
    ss << "\\key Fraction\n";
    ss << "\\key FixedFlowRate\n";
    ss << "N4, \\field Fan Power Minimum Flow Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.25\n";
    ss << "N5, \\field Fan Power Minimum Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "N6, \\field Motor Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.9\n";
    ss << "N7, \\field Motor In Airstream Fraction\n";
    ss << "\\note 0.0 means fan motor outside of air stream, 1.0 means motor inside of air stream\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 1.0\n";
    ss << "N8, \\field Fan Power Coefficient 1\n";
    ss << "\\note all Fan Power Coefficients should not be 0.0 or no fan power will be consumed.\n";
    ss << "\\note Fan Power Coefficents are specified as function of full flow rate/power\n";
    ss << "\\note Equation:\n";
    ss << "\\type real\n";
    ss << "N9, \\field Fan Power Coefficient 2\n";
    ss << "\\type real\n";
    ss << "N10, \\field Fan Power Coefficient 3\n";
    ss << "\\type real\n";
    ss << "N11, \\field Fan Power Coefficient 4\n";
    ss << "\\type real\n";
    ss << "N12, \\field Fan Power Coefficient 5\n";
    ss << "\\type real\n";
    ss << "A4, \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::OS_Fan_VariableVolume);
    OptionalIddObject oObj = IddObject::load("OS:Fan:VariableVolume",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Fan_VariableVolume);
  return object;
}

IddObject createOS_Fan_OnOffIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Fan:OnOff,\n";
    ss << "\\min-fields 13\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference Fans\n";
    ss << "\\reference FansOnOff\n";
    ss << "\\reference FansCV\n";
    ss << "\\reference FansCVandOnOff\n";
    ss << "\\reference FansCVandVAV\n";
    ss << "\\reference FansCVandOnOffandVAV\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Fan Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.6\n";
    ss << "N2, \\field Pressure Rise\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\default 250.0\n";
    ss << "N3, \\field Maximum Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "N4, \\field Motor Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.8\n";
    ss << "N5, \\field Motor In Airstream Fraction\n";
    ss << "\\note 0.0 means fan motor outside of air stream, 1.0 means motor inside of air stream\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 1.0\n";
    ss << "A4, \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6, \\field Fan Power Ratio Function of Speed Ratio Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ExponentCurves\n";
    ss << "\\object-list CubicCurves\n";
    ss << "A7, \\field Fan Efficiency Ratio Function of Speed Ratio Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "A8; \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";

    IddObjectType objType(IddObjectType::OS_Fan_OnOff);
    OptionalIddObject oObj = IddObject::load("OS:Fan:OnOff",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Fan_OnOff);
  return object;
}

IddObject createOS_Fan_ZoneExhaustIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Fan:ZoneExhaust,\n";
    ss << "\\memo Models a fan that exhausts air from a zone.\n";
    ss << "\\min-fields 10\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference FansZoneExhaust\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Fan Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\required-field\n";
    ss << "N2, \\field Pressure Rise\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units inH2O\n";
    ss << "\\required-field\n";
    ss << "N3, \\field Maximum Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "A4, \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6, \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\required-field\n";
    ss << "A7, \\field Flow Fraction Schedule Name\n";
    ss << "\\note If field is used, then when fan runs the exhausted air flow rate is controlled to be the scheduled fraction times the Maximum Flow Rate\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A8, \\field System Availability Manager Coupling Mode\n";
    ss << "\\note Control if fan is to be interlocked with HVAC system Availability Managers or not.\n";
    ss << "\\type choice\n";
    ss << "\\key Coupled\n";
    ss << "\\key Decoupled\n";
    ss << "\\required-field\n";
    ss << "A9, \\field Minimum Zone Temperature Limit Schedule Name\n";
    ss << "\\note If field is used, the exhaust fan will not run if the zone temperature is lower than this limit\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A10; \\field Balanced Exhaust Fraction Schedule Name\n";
    ss << "\\note Used to control fan's impact on flow at the return air node. Enter the portion of the exhaust that is balanced by simple airflows.\n";
    ss << "\\note\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_Fan_ZoneExhaust);
    OptionalIddObject oObj = IddObject::load("OS:Fan:ZoneExhaust",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Fan_ZoneExhaust);
  return object;
}

IddObject createOS_HeatExchanger_AirToAir_SensibleAndLatentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:HeatExchanger:AirToAir:SensibleAndLatent,\n";
    ss << "\\min-fields 24\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HXAirToAirNames\n";
    ss << "\\reference HXAirToAirSensibleAndLatentNames\n";
    ss << "\\reference AFNHeatExchangerNames\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1, \\field Nominal Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "N2, \\field Sensible Effectiveness at 100% Heating Air Flow\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N3, \\field Latent Effectiveness at 100% Heating Air Flow\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N4, \\field Sensible Effectiveness at 75% Heating Air Flow\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N5, \\field Latent Effectiveness at 75% Heating Air Flow\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N6, \\field Sensible Effectiveness at 100% Cooling Air Flow\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N7, \\field Latent Effectiveness at 100% Cooling Air Flow\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N8, \\field Sensible Effectiveness at 75% Cooling Air Flow\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N9, \\field Latent Effectiveness at 75% Cooling Air Flow\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A4, \\field Supply Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Supply Air Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6, \\field Exhaust Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A7, \\field Exhaust Air Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N10,\\field Nominal Electric Power\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\minimum 0.0\n";
    ss << "A8, \\field Supply Air Outlet Temperature Control\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A9, \\field Heat Exchanger Type\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Plate\n";
    ss << "\\key Rotary\n";
    ss << "A10, \\field Frost Control Type\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key None\n";
    ss << "\\key ExhaustAirRecirculation\n";
    ss << "\\key ExhaustOnly\n";
    ss << "\\key MinimumExhaustTemperature\n";
    ss << "N11,\\field Threshold Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 1.7\n";
    ss << "\\note Supply (outdoor) air inlet temp threshold for exhaust air recirculation and\n";
    ss << "\\note exhaust only frost control types. Exhaust air outlet threshold Temperature for\n";
    ss << "\\note minimum exhaust temperature frost control type.\n";
    ss << "N12,\\field Initial Defrost Time Fraction\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note Fraction of the time when frost control will be invoked at the threshold temperature.\n";
    ss << "\\note This field only used for exhaust air recirc and exhaust-only frost control types.\n";
    ss << "N13,\\field Rate of Defrost Time Fraction Increase\n";
    ss << "\\type real\n";
    ss << "\\units 1/K\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Rate of increase in defrost time fraction as actual temp falls below threshold temperature.\n";
    ss << "\\note This field only used for exhaust air recirc and exhaust-only frost control types.\n";
    ss << "A11;\\field Economizer Lockout\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\note Yes means that the heat exchanger will be locked out (off)\n";
    ss << "\\note when the economizer is operating or high humidity control is active\n";

    IddObjectType objType(IddObjectType::OS_HeatExchanger_AirToAir_SensibleAndLatent);
    OptionalIddObject oObj = IddObject::load("OS:HeatExchanger:AirToAir:SensibleAndLatent",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_HeatExchanger_AirToAir_SensibleAndLatent);
  return object;
}

IddObject createOS_HeatExchanger_FluidToFluidIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:HeatExchanger:FluidToFluid,\n";
    ss << "\\min-fields 15\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\note default is that heat exchanger is on\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Loop Demand Side Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5 , \\field Loop Demand Side Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 , \\field Loop Demand Side Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\autosizable\n";
    ss << "A6 , \\field Loop Supply Side Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A7 , \\field Loop Supply Side Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N2 , \\field Loop Supply Side Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\autosizable\n";
    ss << "A8 , \\field Heat Exchange Model Type\n";
    ss << "\\type choice\n";
    ss << "\\key CrossFlowBothUnMixed\n";
    ss << "\\key CrossFlowBothMixed\n";
    ss << "\\key CrossFlowSupplyMixedDemandUnMixed\n";
    ss << "\\key CrossFlowSupplyUnMixedDemandMixed\n";
    ss << "\\key ParallelFlow\n";
    ss << "\\key CounterFlow\n";
    ss << "\\key Ideal\n";
    ss << "\\default Ideal\n";
    ss << "N3 , \\field Heat Exchanger U-Factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "A9 , \\field Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key UncontrolledOn\n";
    ss << "\\key OperationSchemeModulated\n";
    ss << "\\key OperationSchemeOnOff\n";
    ss << "\\key HeatingSetpointModulated\n";
    ss << "\\key HeatingSetpointOnOff\n";
    ss << "\\key CoolingSetpointModulated\n";
    ss << "\\key CoolingSetpointOnOff\n";
    ss << "\\key DualDeadbandSetpointModulated\n";
    ss << "\\key DualDeadbandSetpointOnOff\n";
    ss << "\\key CoolingDifferentialOnOff\n";
    ss << "\\key CoolingSetpointOnOffWithComponentOverride\n";
    ss << "\\default UncontrolledOn\n";
    ss << "A10 , \\field Heat Exchanger Setpoint Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "N4 , \\field Minimum Temperature Difference to Activate Heat Exchanger\n";
    ss << "\\note Tolerance between control temperatures used to determine if heat exchanger should run.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 50\n";
    ss << "\\default 0.01\n";
    ss << "\\units deltaC\n";
    ss << "A11, \\field Heat Transfer Metering End Use Type\n";
    ss << "\\note This feild controls end use reporting for heat transfer meters\n";
    ss << "\\type choice\n";
    ss << "\\key FreeCooling\n";
    ss << "\\key HeatRecovery\n";
    ss << "\\key HeatRejection\n";
    ss << "\\key HeatRecoveryForCooling\n";
    ss << "\\key HeatRecoveryForHeating\n";
    ss << "\\key LoopToLoop\n";
    ss << "\\default LoopToLoop\n";
    ss << "A12, \\field Component Override Loop Supply Side Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "A13, \\field Component Override Loop Demand Side Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "A14, \\field Component Override Cooling Control Temperature Mode\n";
    ss << "\\type choice\n";
    ss << "\\key WetBulbTemperature\n";
    ss << "\\key DryBulbTemperature\n";
    ss << "\\key Loop\n";
    ss << "\\default Loop\n";
    ss << "\\note This field is only used if Control Type is set to CoolingSetpointOnOffWithComponentOverride\n";
    ss << "N5 , \\field Sizing Factor\n";
    ss << "\\note Multiplies the autosized flow rates for this device\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";
    ss << "N6 , \\field Operation Minimum Temperature Limit\n";
    ss << "\\note Lower limit on inlet temperatures, heat exchanger will not operate if either inlet is below this limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N7 ; \\field Operation Maximum Temperature Limit\n";
    ss << "\\note Upper limit on inlet temperatures, heat exchanger will not operate if either inlet is above this limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";

    IddObjectType objType(IddObjectType::OS_HeatExchanger_FluidToFluid);
    OptionalIddObject oObj = IddObject::load("OS:HeatExchanger:FluidToFluid",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_HeatExchanger_FluidToFluid);
  return object;
}

IddObject createOS_HVACComponentListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:HVACComponentList,\n";
    ss << "\\extensible:1 - repeat last field, remembering to remove ; from \"inner\" fields.\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\reference HVACComponentList\n";
    ss << "A2; \\field HVACComponent 1\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllObjects\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::OS_HVACComponentList);
    OptionalIddObject oObj = IddObject::load("OS:HVACComponentList",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_HVACComponentList);
  return object;
}

IddObject createOS_NodeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Node,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "\\reference Node\n";
    ss << "N1, \\field Inlet Port\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N2; \\field Outlet Port\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";

    IddObjectType objType(IddObjectType::OS_Node);
    OptionalIddObject oObj = IddObject::load("OS:Node",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Node);
  return object;
}

IddObject createOS_PortListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:PortList,\n";
    ss << "\\min-fields 1\n";
    ss << "\\extensible:1 Just duplicate last field and comments (changing numbering, please)\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type Handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "\\reference PortLists\n";
    ss << "A3, \\field HVAC Component\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionObject\n";
    ss << "A4; \\field Port 1\n";
    ss << "\\begin-extensible\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";

    IddObjectType objType(IddObjectType::OS_PortList);
    OptionalIddObject oObj = IddObject::load("OS:PortList",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_PortList);
  return object;
}

IddObject createOS_Pipe_AdiabaticIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Pipe:Adiabatic,\n";
    ss << "\\memo Passes Inlet Node state variables to Outlet Node state variables\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4; \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";

    IddObjectType objType(IddObjectType::OS_Pipe_Adiabatic);
    OptionalIddObject oObj = IddObject::load("OS:Pipe:Adiabatic",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Pipe_Adiabatic);
  return object;
}

IddObject createOS_PlantLoopIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:PlantLoop,\n";
    ss << "\\min-fields 25\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference PlantLoops\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Fluid Type\n";
    ss << "\\type choice\n";
    ss << "\\default Water\n";
    ss << "\\key Water\n";
    ss << "\\key Steam\n";
    ss << "\\key UserDefinedFluidType\n";
    ss << "A4, \\field User Defined Fluid Type\n";
    ss << "\\note This field is only required when Fluid Type is UserDefinedFluidType\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FluidAndGlycolNames\n";
    ss << "A5, \\field Plant Equipment Operation Heating Load\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ControlSchemeList\n";
    ss << "A6, \\field Plant Equipment Operation Cooling Load\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ControlSchemeList\n";
    ss << "A7, \\field Primary Plant Equipment Operation Scheme\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ControlSchemeList\n";
    ss << "A8, \\field Loop Temperature Setpoint Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list Node\n";
    ss << "N1, \\field Maximum Loop Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 100.0\n";
    ss << "N2, \\field Minimum Loop Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\default 0.0\n";
    ss << "N3, \\field Maximum Loop Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0\n";
    ss << "\\default autosize\n";
    ss << "N4, \\field Minimum Loop Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\default 0.0\n";
    ss << "N5, \\field Plant Loop Volume\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\units m3\n";
    ss << "\\ip-units gal\n";
    ss << "\\minimum 0\n";
    ss << "\\default autocalculate\n";
    ss << "A8, \\field Plant Side Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A9, \\field Plant Side Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A10, \\field Plant Side Branch List Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list BranchLists\n";
    ss << "A11, \\field Demand Side Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A12, \\field Demand Side Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A13, \\field Demand Side Branch List Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list BranchLists\n";
    ss << "A14, \\field Demand Side Connector List Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectorLists\n";
    ss << "A15, \\field Load Distribution Scheme\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Optimal\n";
    ss << "\\key SequentialLoad\n";
    ss << "\\key UniformLoad\n";
    ss << "\\key UniformPLR\n";
    ss << "\\key SequentialUniformPLR\n";
    ss << "A16, \\field Availability Manager List Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";
    ss << "A17, \\field Plant Loop Demand Calculation Scheme\n";
    ss << "\\type choice\n";
    ss << "\\default SingleSetpoint\n";
    ss << "\\key SingleSetpoint\n";
    ss << "\\key DualSetpointDeadband\n";
    ss << "A18, \\field Common Pipe Simulation\n";
    ss << "\\note Specifies a primary-secondary loop configuration. The plant side is the\n";
    ss << "\\note primary loop, and the demand side is the secondary loop.\n";
    ss << "\\note A secondary supply pump is required on the demand side.\n";
    ss << "\\note None = Primary-only, no secondary simulation\n";
    ss << "\\note CommonPipe = Primary-secondary with no temperature control at primary-secondary interface\n";
    ss << "\\note TwoWayCommonPipe = Primary-secondary with control of secondary supply temperature or\n";
    ss << "\\note primary return temperature (requires a setpoint be placed on the\n";
    ss << "\\note plant side or demand side inlet node).\n";
    ss << "\\type choice\n";
    ss << "\\default None\n";
    ss << "\\key CommonPipe\n";
    ss << "\\key TwoWayCommonPipe\n";
    ss << "\\key None\n";
    ss << "A19, \\field Pressure Simulation Type\n";
    ss << "\\type choice\n";
    ss << "\\default None\n";
    ss << "\\key PumpPowerCorrection\n";
    ss << "\\key LoopFlowCorrection\n";
    ss << "\\key None\n";
    ss << "A20, \\field Plant Equipment Operation Heating Load Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A21, \\field Plant Equipment Operation Cooling Load Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A22, \\field Primary Plant Equipment Operation Scheme Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A23; \\field Component Setpoint Operation Scheme Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_PlantLoop);
    OptionalIddObject oObj = IddObject::load("OS:PlantLoop",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_PlantLoop);
  return object;
}

IddObject createOS_PlantEquipmentOperation_CoolingLoadIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:PlantEquipmentOperation:CoolingLoad,\n";
    ss << "\\extensible:3\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "N1 ,\\field Load Range 1 Lower Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\begin-extensible\n";
    ss << "N2 ,\\field Load Range 1 Upper Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "A3 ;\\field Range 1 Equipment List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";

    IddObjectType objType(IddObjectType::OS_PlantEquipmentOperation_CoolingLoad);
    OptionalIddObject oObj = IddObject::load("OS:PlantEquipmentOperation:CoolingLoad",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_PlantEquipmentOperation_CoolingLoad);
  return object;
}

IddObject createOS_PlantEquipmentOperation_HeatingLoadIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:PlantEquipmentOperation:HeatingLoad,\n";
    ss << "\\extensible:3\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "N1 ,\\field Load Range 1 Lower Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\begin-extensible\n";
    ss << "N2 ,\\field Load Range 1 Upper Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "A3 ;\\field Range 1 Equipment List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";

    IddObjectType objType(IddObjectType::OS_PlantEquipmentOperation_HeatingLoad);
    OptionalIddObject oObj = IddObject::load("OS:PlantEquipmentOperation:HeatingLoad",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_PlantEquipmentOperation_HeatingLoad);
  return object;
}

IddObject createOS_PlantEquipmentOperation_OutdoorDryBulbIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:PlantEquipmentOperation:OutdoorDryBulb,\n";
    ss << "\\extensible:3\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "N1 ,\\field Dry-Bulb Temperature Range 1 Lower Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -70\n";
    ss << "\\maximum 70\n";
    ss << "\\begin-extensible\n";
    ss << "N2 ,\\field Dry-Bulb Temperature Range 1 Upper Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -70\n";
    ss << "\\maximum 70\n";
    ss << "A3 ;\\field Range 1 Equipment List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";

    IddObjectType objType(IddObjectType::OS_PlantEquipmentOperation_OutdoorDryBulb);
    OptionalIddObject oObj = IddObject::load("OS:PlantEquipmentOperation:OutdoorDryBulb",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_PlantEquipmentOperation_OutdoorDryBulb);
  return object;
}

IddObject createOS_PlantEquipmentOperation_OutdoorWetBulbIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:PlantEquipmentOperation:OutdoorWetBulb,\n";
    ss << "\\extensible:3\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "N1 ,\\field Dry-Bulb Temperature Range 1 Lower Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -70\n";
    ss << "\\maximum 70\n";
    ss << "\\begin-extensible\n";
    ss << "N2 ,\\field Dry-Bulb Temperature Range 1 Upper Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -70\n";
    ss << "\\maximum 70\n";
    ss << "A3 ;\\field Range 1 Equipment List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";

    IddObjectType objType(IddObjectType::OS_PlantEquipmentOperation_OutdoorWetBulb);
    OptionalIddObject oObj = IddObject::load("OS:PlantEquipmentOperation:OutdoorWetBulb",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_PlantEquipmentOperation_OutdoorWetBulb);
  return object;
}

IddObject createOS_PlantEquipmentOperation_OutdoorRelativeHumidityIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:PlantEquipmentOperation:OutdoorRelativeHumidity,\n";
    ss << "\\extensible:3\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "N1 ,\\field Relative Humidity Range 1 Lower Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\begin-extensible\n";
    ss << "N2 ,\\field Relative Humidity Range 1 Upper Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units percent\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 100.0\n";
    ss << "A3 ;\\field Range 1 Equipment List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";

    IddObjectType objType(IddObjectType::OS_PlantEquipmentOperation_OutdoorRelativeHumidity);
    OptionalIddObject oObj = IddObject::load("OS:PlantEquipmentOperation:OutdoorRelativeHumidity",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_PlantEquipmentOperation_OutdoorRelativeHumidity);
  return object;
}

IddObject createOS_PlantEquipmentOperation_OutdoorDewpointIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:PlantEquipmentOperation:OutdoorDewpoint,\n";
    ss << "\\extensible:3\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "N1 ,\\field Dewpoint Temperature Range 1 Lower Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -70\n";
    ss << "\\maximum 70\n";
    ss << "\\begin-extensible\n";
    ss << "N2 ,\\field Dewpoint Temperature Range 1 Upper Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -70\n";
    ss << "\\maximum 70\n";
    ss << "A3 ;\\field Range 1 Equipment List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";

    IddObjectType objType(IddObjectType::OS_PlantEquipmentOperation_OutdoorDewpoint);
    OptionalIddObject oObj = IddObject::load("OS:PlantEquipmentOperation:OutdoorDewpoint",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_PlantEquipmentOperation_OutdoorDewpoint);
  return object;
}

IddObject createOS_PlantEquipmentOperation_OutdoorDryBulbDifferenceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:PlantEquipmentOperation:OutdoorDryBulbDifference,\n";
    ss << "\\extensible:3\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "A3 ,\\field Reference Temperature Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "N1,\\field Dry-Bulb Temperature Difference Range 1 Lower Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum -50.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\begin-extensible\n";
    ss << "N2,\\field Dry-Bulb Temperature Difference Range 1 Upper Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum -50.0\n";
    ss << "\\maximum 100.0\n";
    ss << "A4; \\field Range 1 Equipment List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";

    IddObjectType objType(IddObjectType::OS_PlantEquipmentOperation_OutdoorDryBulbDifference);
    OptionalIddObject oObj = IddObject::load("OS:PlantEquipmentOperation:OutdoorDryBulbDifference",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_PlantEquipmentOperation_OutdoorDryBulbDifference);
  return object;
}

IddObject createOS_PlantEquipmentOperation_OutdoorDewpointDifferenceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:PlantEquipmentOperation:OutdoorDewpointDifference,\n";
    ss << "\\extensible:3\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "A3 ,\\field Reference Temperature Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "N1,\\field Dry-Bulb Temperature Difference Range 1 Lower Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum -50.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\begin-extensible\n";
    ss << "N2,\\field Dry-Bulb Temperature Difference Range 1 Upper Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum -50.0\n";
    ss << "\\maximum 100.0\n";
    ss << "A4; \\field Range 1 Equipment List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";

    IddObjectType objType(IddObjectType::OS_PlantEquipmentOperation_OutdoorDewpointDifference);
    OptionalIddObject oObj = IddObject::load("OS:PlantEquipmentOperation:OutdoorDewpointDifference",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_PlantEquipmentOperation_OutdoorDewpointDifference);
  return object;
}

IddObject createOS_PlantEquipmentOperation_OutdoorWetBulbDifferenceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:PlantEquipmentOperation:OutdoorWetBulbDifference,\n";
    ss << "\\extensible:3\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 ,\\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ControlSchemeList\n";
    ss << "A3 ,\\field Reference Temperature Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "N1,\\field Dry-Bulb Temperature Difference Range 1 Lower Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum -50.0\n";
    ss << "\\maximum 100.0\n";
    ss << "\\begin-extensible\n";
    ss << "N2,\\field Dry-Bulb Temperature Difference Range 1 Upper Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum -50.0\n";
    ss << "\\maximum 100.0\n";
    ss << "A4; \\field Range 1 Equipment List Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ModelObjectLists\n";

    IddObjectType objType(IddObjectType::OS_PlantEquipmentOperation_OutdoorWetBulbDifference);
    OptionalIddObject oObj = IddObject::load("OS:PlantEquipmentOperation:OutdoorWetBulbDifference",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_PlantEquipmentOperation_OutdoorWetBulbDifference);
  return object;
}

IddObject createOS_PlantComponent_TemperatureSourceIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:PlantComponent:TemperatureSource,\n";
    ss << "\\min-fields 8\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Inlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4 , \\field Outlet Node\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 , \\field Design Volume Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "A5 , \\field Temperature Specification Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Constant\n";
    ss << "\\key Scheduled\n";
    ss << "N2 , \\field Source Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Used if Temperature Specification Type = Constant\n";
    ss << "A6 ; \\field Source Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\units C\n";
    ss << "\\note Used if Temperature Specification Type = Scheduled\n";

    IddObjectType objType(IddObjectType::OS_PlantComponent_TemperatureSource);
    OptionalIddObject oObj = IddObject::load("OS:PlantComponent:TemperatureSource",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_PlantComponent_TemperatureSource);
  return object;
}

IddObject createOS_LoadProfile_PlantIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:LoadProfile:Plant,\n";
    ss << "\\min-fields 7\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4 , \\field Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5 , \\field Load Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Peak Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "A6 ; \\field Flow Rate Fraction Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_LoadProfile_Plant);
    OptionalIddObject oObj = IddObject::load("OS:LoadProfile:Plant",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_LoadProfile_Plant);
  return object;
}

IddObject createOS_Pump_ConstantSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Pump:ConstantSpeed,\n";
    ss << "\\memo This pump model is described in the ASHRAE secondary HVAC toolkit.\n";
    ss << "\\min-fields 10\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4 , \\field Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 , \\field Rated Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0\n";
    ss << "N2 , \\field Rated Pump Head\n";
    ss << "\\units Pa\n";
    ss << "\\default 179352\n";
    ss << "\\note default head is 60 feet\n";
    ss << "\\ip-units ftH2O\n";
    ss << "N3 , \\field Rated Power Consumption\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "N4 , \\field Motor Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N5 , \\field Fraction of Motor Inefficiencies to Fluid Stream\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "A5 , \\field Pump Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Continuous\n";
    ss << "\\key Intermittent\n";
    ss << "\\default Continuous\n";
    ss << "A6 , \\field Pump Flow Rate Schedule\n";
    ss << "\\note Modifies the rated flow rate of the pump on a time basis. Default is\n";
    ss << "\\note that the pump is on and runs according to its other operational requirements\n";
    ss << "\\note specified above.  The schedule is for special pump operations.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A7 , \\field Pump Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllCurves\n";
    ss << "\\note This references any single independent variable polynomial curve in order to\n";
    ss << "\\note  do pressure vs. flow calculations for this pump.  The available types are then:\n";
    ss << "\\note  Linear, Quadratic, Cubic, and Quartic\n";
    ss << "\\note The non-dimensional pump pressure relationship is of the following form:\n";
    ss << "\\note  (psi = C4*phi^4 + C3*phi^3 + C2*phi^2 + C1*phi + C0)\n";
    ss << "\\note Where the nondimensional variables are defined as:\n";
    ss << "\\note  delP = rho * ((N/60)^2) * (D^2) * psi\n";
    ss << "\\note  mdot = rho * (N/60) * (D^3) * phi\n";
    ss << "N6 , \\field Impeller Diameter\n";
    ss << "\\units m\n";
    ss << "\\type real\n";
    ss << "\\note \"D\" in above expression in field A6\n";
    ss << "N7 , \\field Rotational Speed\n";
    ss << "\\units rev/min\n";
    ss << "\\type real\n";
    ss << "\\note \"N\" in above expression in field A6\n";
    ss << "A8,   \\field Zone\n";
    ss << "\\note optional, if used pump losses transfered to zone as internal gains\n";
    ss << "\\type Object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "N8;   \\field Skin Loss Radiative Fraction\n";
    ss << "\\note optional. If zone identified in previous field then this determines\n";
    ss << "\\note the split between convection and radiation for the skin losses\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";

    IddObjectType objType(IddObjectType::OS_Pump_ConstantSpeed);
    OptionalIddObject oObj = IddObject::load("OS:Pump:ConstantSpeed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Pump_ConstantSpeed);
  return object;
}

IddObject createOS_Pump_VariableSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Pump:VariableSpeed,\n";
    ss << "\\memo This pump model is described in the ASHRAE secondary HVAC toolkit.\n";
    ss << "\\min-fields 15\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4, \\field Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1, \\field Rated Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\default autosize\n";
    ss << "\\minimum> 0\n";
    ss << "N2, \\field Rated Pump Head\n";
    ss << "\\note default head is 60 feet\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units ftH2O\n";
    ss << "\\default 179352\n";
    ss << "N3, \\field Rated Power Consumption\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units W\n";
    ss << "\\ip-units W\n";
    ss << "\\default autosize\n";
    ss << "N4, \\field Motor Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.9\n";
    ss << "N5, \\field Fraction of Motor Inefficiencies to Fluid Stream\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "N6, \\field Coefficient 1 of the Part Load Performance Curve\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "N7, \\field Coefficient 2 of the Part Load Performance Curve\n";
    ss << "\\type real\n";
    ss << "\\default 1.0\n";
    ss << "N8, \\field Coefficient 3 of the Part Load Performance Curve\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "N9, \\field Coefficient 4 of the Part Load Performance Curve\n";
    ss << "\\type real\n";
    ss << "\\default 0.0\n";
    ss << "N10, \\field Minimum Flow Rate\n";
    ss << "\\note This value can be zero and will be defaulted to that if not specified.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\default 0.0\n";
    ss << "A5, \\field Pump Control Type\n";
    ss << "\\type choice\n";
    ss << "\\default Continuous\n";
    ss << "\\key Continuous\n";
    ss << "\\key Intermittent\n";
    ss << "A6, \\field Pump Flow Rate Schedule Name\n";
    ss << "\\note Modifies the rated flow rate of the pump on a time basis. Default is\n";
    ss << "\\note that the pump is on and runs according to its other operational requirements\n";
    ss << "\\note specified above.  The schedule is for special pump operations.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A7, \\field Pump Curve Name\n";
    ss << "\\note This references any single independent variable polynomial curve in order to\n";
    ss << "\\note do pressure vs. flow calculations for this pump.  The available types are then:\n";
    ss << "\\note Linear, Quadratic, Cubic, and Quartic\n";
    ss << "\\note The non-dimensional pump pressure relationship is of the following form:\n";
    ss << "\\note (psi = C4*phi^4 + C3*phi^3 + C2*phi^2 + C1*phi + C0)\n";
    ss << "\\note Where the nondimensional variables are defined as:\n";
    ss << "\\note delP = rho * ((N/60)^2) * (D^2) * psi\n";
    ss << "\\note mdot = rho * (N/60) * (D^3) * phi\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllCurves\n";
    ss << "N11, \\field Impeller Diameter\n";
    ss << "\\note \"D\" in above expression in field A6\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "A8, \\field VFD Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key ManualControl\n";
    ss << "\\key PressureSetpointControl\n";
    ss << "A9, \\field Pump rpm Schedule Name\n";
    ss << "\\note Modifies the rpm of the pump on a time basis. Default is\n";
    ss << "\\note that the pump is on and runs according to its other operational requirements\n";
    ss << "\\note specified above.  The schedule is for special pump operations.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A10, \\field Minimum Pressure Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\units Pa\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A11, \\field Maximum Pressure Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\units Pa\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A12, \\field Minimum RPM Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\units Rotations Per Minute\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A13; \\field Maximum RPM Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\units Rotations Per Minute\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_Pump_VariableSpeed);
    OptionalIddObject oObj = IddObject::load("OS:Pump:VariableSpeed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Pump_VariableSpeed);
  return object;
}

IddObject createOS_HeaderedPumps_ConstantSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:HeaderedPumps:ConstantSpeed,\n";
    ss << "\\memo This Headered pump object describes a pump bank with more than 1 pump in parallel\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4 , \\field Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 , \\field Total Rated Flow Rate\n";
    ss << "\\note If the field is not autosized set to the flow rate to\n";
    ss << "\\note the total flow when all pumps are running at full load\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "N2 , \\field Number of Pumps in Bank\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "A5 , \\field Flow Sequencing Control Scheme\n";
    ss << "\\type choice\n";
    ss << "\\key Sequential\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field Rated Pump Head\n";
    ss << "\\units Pa\n";
    ss << "\\ip-units ftH2O\n";
    ss << "\\required-field\n";
    ss << "N4 , \\field Rated Power Consumption\n";
    ss << "\\note If the field is not autosized set to the power consumed by the pump bank\n";
    ss << "\\note when all the pumps are running at nominal flow\n";
    ss << "\\note If this field is autosized, an impeller efficiency of 0.78 is assumed.\n";
    ss << "\\note autosized Rated Power Consumption = Total Rated Flow Rate * Rated Pump Head / (0.78 * Motor Efficiency)\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\ip-units W\n";
    ss << "N5 , \\field Motor Efficiency\n";
    ss << "\\note This is the motor efficiency only. When the Rated Power Consumption if autosized,\n";
    ss << "\\note an impeller efficiency of 0.78 is assumed in addition to the motor efficiency.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\required-field\n";
    ss << "N6 , \\field Fraction of Motor Inefficiencies to Fluid Stream\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\required-field\n";
    ss << "A6 , \\field Pump Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Continuous\n";
    ss << "\\key Intermittent\n";
    ss << "\\required-field\n";
    ss << "A7 , \\field Pump Flow Rate Schedule\n";
    ss << "\\note Modifies the rated flow rate of the pump on a time basis. Default is\n";
    ss << "\\note that the pump is on and runs according to its other operational requirements\n";
    ss << "\\note specified above.  The schedule is for special pump operations.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A8 ,  \\field Thermal Zone\n";
    ss << "\\note optional, if used pump losses transfered to zone as internal gains\n";
    ss << "\\type Object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "N7 ;  \\field Skin Loss Radiative Fraction\n";
    ss << "\\note optional. If zone identified in previous field then this determines\n";
    ss << "\\note the split between convection and radiation for the skin losses\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_HeaderedPumps_ConstantSpeed);
    OptionalIddObject oObj = IddObject::load("OS:HeaderedPumps:ConstantSpeed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_HeaderedPumps_ConstantSpeed);
  return object;
}

IddObject createOS_HeaderedPumps_VariableSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:HeaderedPumps:VariableSpeed,\n";
    ss << "\\memo This Headered pump object describes a pump bank with more than 1 pump in parallel\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4 , \\field Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 , \\field Total Rated Flow Rate\n";
    ss << "\\note If the field is not autosized set to the flow rate to\n";
    ss << "\\note the total flow when all pumps are running at full load\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "N2 , \\field Number of Pumps in Bank\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "A5 , \\field Flow Sequencing Control Scheme\n";
    ss << "\\type choice\n";
    ss << "\\key Sequential\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field Rated Pump Head\n";
    ss << "\\units Pa\n";
    ss << "\\note default head is 60 feet\n";
    ss << "\\ip-units ftH2O\n";
    ss << "\\required-field\n";
    ss << "N4 , \\field Rated Power Consumption\n";
    ss << "\\note If the field is not autosized set to the power consumed by the pump bank\n";
    ss << "\\note when all the pumps are running at nominal flow\n";
    ss << "\\note If this field is autosized, an impeller efficiency of 0.78 is assumed.\n";
    ss << "\\note autosized Rated Power Consumption = Total Rated Flow Rate * Rated Pump Head / (0.78 * Motor Efficiency)\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\required-field\n";
    ss << "N5 , \\field Motor Efficiency\n";
    ss << "\\note This is the motor efficiency only. When the Rated Power Consumption if autosized,\n";
    ss << "\\note an impeller efficiency of 0.78 is assumed in addition to the motor efficiency.\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\required-field\n";
    ss << "N6 , \\field Fraction of Motor Inefficiencies to Fluid Stream\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\required-field\n";
    ss << "N7 , \\field Coefficient 1 of the Part Load Performance Curve\n";
    ss << "\\required-field\n";
    ss << "N8 , \\field Coefficient 2 of the Part Load Performance Curve\n";
    ss << "\\required-field\n";
    ss << "N9 , \\field Coefficient 3 of the Part Load Performance Curve\n";
    ss << "\\required-field\n";
    ss << "N10, \\field Coefficient 4 of the Part Load Performance Curve\n";
    ss << "\\required-field\n";
    ss << "N11, \\field Minimum Flow Rate Fraction\n";
    ss << "\\note This value can be zero and will be defaulted to that if not specified.\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\required-field\n";
    ss << "A6 , \\field Pump Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Continuous\n";
    ss << "\\key Intermittent\n";
    ss << "\\required-field\n";
    ss << "A7 , \\field Pump Flow Rate Schedule\n";
    ss << "\\note Modifies the rated flow rate of the pump on a time basis. Default is\n";
    ss << "\\note that the pump is on and runs according to its other operational requirements\n";
    ss << "\\note specified above.  The schedule is for special pump operations.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A8 ,  \\field Thermal Zone\n";
    ss << "\\note optional, if used pump losses transfered to zone as internal gains\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "N12;  \\field Skin Loss Radiative Fraction\n";
    ss << "\\note optional. If zone identified in previous field then this determines\n";
    ss << "\\note the split between convection and radiation for the skin losses\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_HeaderedPumps_VariableSpeed);
    OptionalIddObject oObj = IddObject::load("OS:HeaderedPumps:VariableSpeed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_HeaderedPumps_VariableSpeed);
  return object;
}

IddObject createOS_TemperingValveIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:TemperingValve,\n";
    ss << "\\memo Temperature-controlled diversion valve used to divert flow around one or more plant\n";
    ss << "\\memo components such as a hot water heater. It can only be used on one of two branches\n";
    ss << "\\memo between a Splitter and a Mixer.\n";
    ss << "\\min-fields 7\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4, \\field Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Stream 2 Source Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "A6, \\field Temperature Setpoint Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "A7; \\field Pump Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";

    IddObjectType objType(IddObjectType::OS_TemperingValve);
    OptionalIddObject oObj = IddObject::load("OS:TemperingValve",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_TemperingValve);
  return object;
}

IddObject createOS_SetpointManager_FollowOutdoorAirTemperatureIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:FollowOutdoorAirTemperature,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "A3 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\key MinimumTemperature\n";
    ss << "\\key MaximumTemperature\n";
    ss << "\\default Temperature\n";
    ss << "A4 , \\field Reference Temperature Type\n";
    ss << "\\type choice\n";
    ss << "\\key OutdoorAirWetBulb\n";
    ss << "\\key OutdoorAirDryBulb\n";
    ss << "\\default OutdoorAirWetBulb\n";
    ss << "N1 , \\field Offset Temperature Difference\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Maximum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Minimum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "A5 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\note Node(s) at which the temperature will be set\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list Node\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_FollowOutdoorAirTemperature);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:FollowOutdoorAirTemperature",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_FollowOutdoorAirTemperature);
  return object;
}

IddObject createOS_SetpointManager_MixedAirIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:MixedAir,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "A3, \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\default Temperature\n";
    ss << "\\key Temperature\n";
    ss << "A4, \\field Reference Setpoint Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list Node\n";
    ss << "A5, \\field Fan Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list Node\n";
    ss << "A6, \\field Fan Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list Node\n";
    ss << "A7; \\field Setpoint Node or NodeList Name\n";
    ss << "\\note Node(s) at which the temperature will be set\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list Node\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_MixedAir);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:MixedAir",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_MixedAir);
  return object;
}

IddObject createOS_SetpointManager_OutdoorAirResetIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:OutdoorAirReset,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\reference SetpointManagers\n";
    ss << "A3 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\default Temperature\n";
    ss << "N1 , \\field Setpoint at Outdoor Low Temperature\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "N2 , \\field Outdoor Low Temperature\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field Setpoint at Outdoor High Temperature\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "N4 , \\field Outdoor High Temperature\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "A4 , \\field Setpoint Node or NodeList Name\n";
    ss << "\\note Node(s) at which temperature will be set\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "A5 , \\field Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Optional input.\n";
    ss << "\\note Schedule allows scheduling of the outdoor air reset rule - a schedule value\n";
    ss << "\\note of 1 means use the first rule; a value of 2 means use the second rule.\n";
    ss << "N5 , \\field Setpoint at Outdoor Low Temperature 2\n";
    ss << "\\note 2nd outdoor air temperature reset rule\n";
    ss << "\\units C\n";
    ss << "N6 , \\field Outdoor Low Temperature 2\n";
    ss << "\\note 2nd outdoor air temperature reset rule\n";
    ss << "\\units C\n";
    ss << "N7 , \\field Setpoint at Outdoor High Temperature 2\n";
    ss << "\\note 2nd outdoor air temperature reset rule\n";
    ss << "\\units C\n";
    ss << "N8 ; \\field Outdoor High Temperature 2\n";
    ss << "\\note 2nd outdoor air temperature reset rule\n";
    ss << "\\units C\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_OutdoorAirReset);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:OutdoorAirReset",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_OutdoorAirReset);
  return object;
}

IddObject createOS_SetpointManager_OutdoorAirPretreatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:OutdoorAirPretreat,\n";
    ss << "\\min-fields 12\n";
    ss << "\\memo This setpoint manager determines the required\n";
    ss << "\\memo conditions at the outdoor air stream node which will\n";
    ss << "\\memo produce the reference setpoint condition at the\n";
    ss << "\\memo mixed air node when mixed with the return air stream\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "A3,  \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\key HumidityRatio\n";
    ss << "\\key MaximumHumidityRatio\n";
    ss << "\\key MinimumHumidityRatio\n";
    ss << "\\default Temperature\n";
    ss << "N1,  \\field Minimum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\default -99\n";
    ss << "\\note Applicable only if Control variable is Temperature\n";
    ss << "N2,  \\field Maximum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\default 99\n";
    ss << "\\note Applicable only if Control variable is Temperature\n";
    ss << "N3,  \\field Minimum Setpoint Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.00001\n";
    ss << "\\note Applicable only if Control variable is\n";
    ss << "\\note MaximumHumidityRatio, MinimumHumidityRatio, or HumidityRatio - then minimum is 0.00001\n";
    ss << "N4,  \\field Maximum Setpoint Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "\\note Applicable only if Control variable is\n";
    ss << "\\note MaximumHumidityRatio, MinimumHumidityRatio, or HumidityRatio - then minimum is 0.00001\n";
    ss << "A4,  \\field Reference Setpoint Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "\\note The current setpoint at this node is the\n";
    ss << "\\note desired condition for the Mixed Air Node\n";
    ss << "\\note This node must have a valid setpoint\n";
    ss << "\\note which has been set by another setpoint manager\n";
    ss << "A5,  \\field Mixed Air Stream Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "\\note Name of Mixed Air Node\n";
    ss << "\\required-field\n";
    ss << "A6,  \\field Outdoor Air Stream Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "\\note Name of Outdoor Air Stream Node\n";
    ss << "\\required-field\n";
    ss << "A7,  \\field Return Air Stream Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "\\note Name of Return Air Stream Node\n";
    ss << "\\required-field\n";
    ss << "A8;  \\field Setpoint Node or NodeList Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "\\required-field\n";
    ss << "\\note Node(s) at which the temperature or humidity\n";
    ss << "\\note ratio will be set\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_OutdoorAirPretreat);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:OutdoorAirPretreat",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_OutdoorAirPretreat);
  return object;
}

IddObject createOS_SetpointManager_SingleZone_ReheatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:SingleZone:Reheat,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "N1, \\field Minimum Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N2, \\field Maximum Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "A3, \\field Control Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A4, \\field Setpoint Node or NodeList Name\n";
    ss << "\\note Node(s) at which the temperature will be set\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list Node\n";
    ss << "A5; \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\default Temperature\n";
    ss << "\\key Temperature\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_SingleZone_Reheat);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:SingleZone:Reheat",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_SingleZone_Reheat);
  return object;
}

IddObject createOS_SetpointManager_SingleZone_Humidity_MinimumIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:SingleZone:Humidity:Minimum,\n";
    ss << "\\memo The Single Zone Minimum Humidity Setpoint Manager allows the\n";
    ss << "\\memo control of a single zone minimum humidity level.\n";
    ss << "\\memo This setpoint manager can be used in conjunction with\n";
    ss << "\\memo object ZoneControl:Humidistat to detect humidity levels.\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "A3,  \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\default MinimumHumidityRatio\n";
    ss << "\\key MinimumHumidityRatio\n";
    ss << "A4,  \\field Setpoint Node or NodeList Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list Node\n";
    ss << "A5;  \\field Control Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ThermalZoneNames\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_SingleZone_Humidity_Minimum);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:SingleZone:Humidity:Minimum",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_SingleZone_Humidity_Minimum);
  return object;
}

IddObject createOS_SetpointManager_MultiZone_MinimumHumidity_AverageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:MultiZone:MinimumHumidity:Average,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo This setpoint manager sets the average supply air minimum humidity ratio based on moisture\n";
    ss << "\\memo load requirements of all controlled zones in an air loop served by a central air-conditioner.\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "N1,  \\field Minimum Setpoint Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.005\n";
    ss << "N2,  \\field Maximum Setpoint Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.012\n";
    ss << "A3,  \\field Setpoint Node or NodeList Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list Node\n";
    ss << "A4;  \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\default MinimumHumidityRatio\n";
    ss << "\\key MinimumHumidityRatio\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_MultiZone_MinimumHumidity_Average);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:MultiZone:MinimumHumidity:Average",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_MultiZone_MinimumHumidity_Average);
  return object;
}

IddObject createOS_SetpointManager_MultiZone_Humidity_MinimumIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:MultiZone:Humidity:Minimum,\n";
    ss << "\\min-fields 5\n";
    ss << "\\memo This setpoint manager sets the minimum supply air humidity ratio based on humidification\n";
    ss << "\\memo requirements of a controlled zone with critical humidity ratio setpoint (i.e., a zone with\n";
    ss << "\\memo the highest humidity ratio setpoint) in an air loop served by a central air-conditioner.\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "N1,  \\field Minimum Setpoint Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.005\n";
    ss << "N2,  \\field Maximum Setpoint Humidity Ratio\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.012\n";
    ss << "A3,  \\field Setpoint Node or NodeList Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list Node\n";
    ss << "A4;  \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\default MinimumHumidityRatio\n";
    ss << "\\key MinimumHumidityRatio\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_MultiZone_Humidity_Minimum);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:MultiZone:Humidity:Minimum",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_MultiZone_Humidity_Minimum);
  return object;
}

IddObject createOS_SetpointManager_ScheduledIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:Scheduled,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "A3, \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Temperature\n";
    ss << "\\key MaximumTemperature\n";
    ss << "\\key MinimumTemperature\n";
    ss << "\\key HumidityRatio\n";
    ss << "\\key MaximumHumidityRatio\n";
    ss << "\\key MinimumHumidityRatio\n";
    ss << "\\key MassFlowRate\n";
    ss << "\\key MaximumMassFlowRate\n";
    ss << "\\key MinimumMassFlowRate\n";
    ss << "A4, \\field Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5; \\field Setpoint Node or NodeList Name\n";
    ss << "\\note Node(s) at which control variable will be set\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list Node\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_Scheduled);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:Scheduled",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_Scheduled);
  return object;
}

IddObject createOS_SetpointManager_Scheduled_DualSetpointIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:Scheduled:DualSetpoint,\n";
    ss << "\\memo This setpoint manager places a high and low schedule value\n";
    ss << "\\memo on one or more nodes.\n";
    ss << "\\min-fields 6\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "A3,  \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\default Temperature\n";
    ss << "A4,  \\field High Setpoint Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\required-field\n";
    ss << "A5,  \\field Low Setpoint Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\required-field\n";
    ss << "A6;  \\field Setpoint Node or NodeList Name\n";
    ss << "\\note Node(s) at which temperature will be set\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_Scheduled_DualSetpoint);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:Scheduled:DualSetpoint",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_Scheduled_DualSetpoint);
  return object;
}

IddObject createOS_SetpointManager_WarmestIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:Warmest,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "A3 , \\field Control Variable\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Temperature\n";
    ss << "N1 , \\field Minimum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\required-field\n";
    ss << "N2 , \\field Maximum Setpoint Temperature\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\required-field\n";
    ss << "A4 , \\field Strategy\n";
    ss << "\\type choice\n";
    ss << "\\key MaximumTemperature\n";
    ss << "\\required-field\n";
    ss << "A5 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list Node\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_Warmest);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:Warmest",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_Warmest);
  return object;
}

IddObject createOS_SetpointManager_WarmestTemperatureFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:WarmestTemperatureFlow,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "A3 , \\field Control Variable\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "N1 , \\field Minimum Setpoint Temperature\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2 , \\field Maximum Setpoint Temperature\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "A4 , \\field Strategy\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key TemperatureFirst\n";
    ss << "\\key FlowFirst\n";
    ss << "A5 , \\field Setpoint Node or NodeList Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list Node\n";
    ss << "N3 ; \\field Minimum Turndown Ratio\n";
    ss << "\\required-field\n";
    ss << "\\units dimensionless\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_WarmestTemperatureFlow);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:WarmestTemperatureFlow",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_WarmestTemperatureFlow);
  return object;
}

IddObject createOS_SetpointManager_ColdestIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:Coldest,\n";
    ss << "\\memo This SetpointManager is used in dual duct systems to reset\n";
    ss << "\\memo the setpoint temperature of the air in the heating supply duct.\n";
    ss << "\\memo Usually it is used in conjunction with a SetpointManager:Warmest\n";
    ss << "\\memo resetting the temperature of the air in the cooling supply duct.\n";
    ss << "\\min-fields 7\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "A3 , \\field Control Variable\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "N1 , \\field Minimum Setpoint Temperature\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2 , \\field Maximum Setpoint Temperature\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "A4 , \\field Strategy\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key MinimumTemperature\n";
    ss << "A5 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_Coldest);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:Coldest",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_Coldest);
  return object;
}

IddObject createOS_SetpointManager_FollowGroundTemperatureIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:FollowGroundTemperature,\n";
    ss << "\\memo This setpoint manager is used to place a temperature setpoint on a\n";
    ss << "\\memo system node that is derived from a current ground temperature.\n";
    ss << "\\memo The ground temperatures are specified in different\n";
    ss << "\\memo Site:GroundTemperature:* objects and used during the simulation.\n";
    ss << "\\memo This setpoint manager is primarily intended for condenser or plant loops\n";
    ss << "\\memo using some type of ground heat exchanger.\n";
    ss << "\\min-fields 7\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "A3 , \\field Control Variable\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\key MinimumTemperature\n";
    ss << "\\key MaximumTemperature\n";
    ss << "N1 , \\field Offset Temperature Difference\n";
    ss << "\\required-field\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Maximum Setpoint Temperature\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Minimum Setpoint Temperature\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "A4 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_FollowGroundTemperature);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:FollowGroundTemperature",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_FollowGroundTemperature);
  return object;
}

IddObject createOS_SetpointManager_FollowSystemNodeTemperatureIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:FollowSystemNodeTemperature,\n";
    ss << "\\memo This setpoint manager is used to place a temperature setpoint on a\n";
    ss << "\\memo system node that is derived from the current temperatures at a separate\n";
    ss << "\\memo system node.  The current value of the temperature at a reference node\n";
    ss << "\\memo is obtained and used to generate setpoint on a second system node.\n";
    ss << "\\memo If the reference node is also designated to be an outdoor air (intake) node,\n";
    ss << "\\memo then this setpoint manager can be used to follow outdoor air conditions\n";
    ss << "\\memo that are adjusted for altitude.\n";
    ss << "\\min-fields 9\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "A3 , \\field Control Variable\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "\\key MinimumTemperature\n";
    ss << "\\key MaximumTemperature\n";
    ss << "A4,  \\field Reference Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "A5 , \\field Reference Temperature Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key NodeWetBulb\n";
    ss << "\\key NodeDryBulb\n";
    ss << "N1 , \\field Offset Temperature Difference\n";
    ss << "\\required-field\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "N2 , \\field Maximum Limit Setpoint Temperature\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "N3 , \\field Minimum Limit Setpoint Temperature\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "A6 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_FollowSystemNodeTemperature);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:FollowSystemNodeTemperature",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_FollowSystemNodeTemperature);
  return object;
}

IddObject createOS_SetpointManager_MultiZone_Cooling_AverageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:MultiZone:Cooling:Average,\n";
    ss << "\\min-fields 6\n";
    ss << "\\memo This setpoint manager sets the average supply air temperature based on the cooling load\n";
    ss << "\\memo requirements of all controlled zones in an air loop served by a central air-conditioner.\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "A3 , \\field Control Variable\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "N1 , \\field Minimum Setpoint Temperature\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2 , \\field Maximum Setpoint Temperature\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "A4 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_MultiZone_Cooling_Average);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:MultiZone:Cooling:Average",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_MultiZone_Cooling_Average);
  return object;
}

IddObject createOS_SetpointManager_MultiZone_Heating_AverageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:MultiZone:Heating:Average,\n";
    ss << "\\min-fields 6\n";
    ss << "\\memo This setpoint manager sets the average supply air temperature based on the heating load\n";
    ss << "\\memo requirements of all controlled zones in an air loop served by a central air-conditioner.\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "A3 , \\field Control Variable\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "N1 , \\field Minimum Setpoint Temperature\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2 , \\field Maximum Setpoint Temperature\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "A4 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_MultiZone_Heating_Average);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:MultiZone:Heating:Average",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_MultiZone_Heating_Average);
  return object;
}

IddObject createOS_SetpointManager_MultiZone_Humidity_MaximumIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:MultiZone:Humidity:Maximum,\n";
    ss << "\\min-fields 6\n";
    ss << "\\memo This setpoint manager sets the maximum supply air humidity ratio based on dehumidification\n";
    ss << "\\memo requirements of a controlled zone with critical humidity ratio setpoint (i.e., a zone with\n";
    ss << "\\memo the lowest humidity ratio setpoint) in an air loop served by a central air-conditioner.\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "A3 , \\field Control Variable\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key MaximumHumidityRatio\n";
    ss << "N1 , \\field Minimum Setpoint Humidity Ratio\n";
    ss << "\\required-field\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2 , \\field Maximum Setpoint Humidity Ratio\n";
    ss << "\\required-field\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "A4 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_MultiZone_Humidity_Maximum);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:MultiZone:Humidity:Maximum",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_MultiZone_Humidity_Maximum);
  return object;
}

IddObject createOS_SetpointManager_MultiZone_MaximumHumidity_AverageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:MultiZone:MaximumHumidity:Average,\n";
    ss << "\\min-fields 6\n";
    ss << "\\memo This setpoint manager sets the average supply air maximum humidity ratio based on moisture\n";
    ss << "\\memo load requirements of all controlled zones in an air loop served by a central air-conditioner.\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "A3 , \\field Control Variable\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key MaximumHumidityRatio\n";
    ss << "N1 , \\field Minimum Setpoint Humidity Ratio\n";
    ss << "\\required-field\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2 , \\field Maximum Setpoint Humidity Ratio\n";
    ss << "\\required-field\n";
    ss << "\\units kgWater/kgDryAir\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "A4 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_MultiZone_MaximumHumidity_Average);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:MultiZone:MaximumHumidity:Average",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_MultiZone_MaximumHumidity_Average);
  return object;
}

IddObject createOS_SetpointManager_SingleZone_OneStageCoolingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:SingleZone:OneStageCooling,\n";
    ss << "\\memo This object can be used with CoilSystem:Cooling:DX to model on/off cycling control\n";
    ss << "\\memo of single stage air systems. Setpoints are modulated to run coil full on or full off\n";
    ss << "\\memo depending on zone conditions. Intended for use with ZoneControl:Thermostat:StagedDualSetpoint\n";
    ss << "\\min-fields 7\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "A3 , \\field Control Variable\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "N1 , \\field Cooling Stage On Supply Air Setpoint Temperature\n";
    ss << "\\note This is the setpoint value applied when cooling device is to cycle ON\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "N2 , \\field Cooling Stage Off Supply Air Setpoint Temperature\n";
    ss << "\\note This is the setpoint value applied when cooling device is to cycle OFF\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "A4 , \\field Control Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A5 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_SingleZone_OneStageCooling);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:SingleZone:OneStageCooling",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_SingleZone_OneStageCooling);
  return object;
}

IddObject createOS_SetpointManager_SingleZone_OneStageHeatingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:SingleZone:OneStageHeating,\n";
    ss << "\\memo This object can be used with CoilSystem:Heating:DX, Coil:Heating:Gas,\n";
    ss << "\\memo Coil:Heating:Electric to model on/off cycling control of single stage air systems.\n";
    ss << "\\memo Setpoints are modulated to run coil full on or full off depending on zone conditions.\n";
    ss << "\\memo Intended for use with ZoneControl:Thermostat:StagedDualSetpoint.\n";
    ss << "\\min-fields 7\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "A3 , \\field Control Variable\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Temperature\n";
    ss << "N1 , \\field Heating Stage On Supply Air Setpoint Temperature\n";
    ss << "\\note This is the setpoint value applied when heating device is to cycle ON\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "N2 , \\field Heating Stage Off Supply Air Setpoint Temperature\n";
    ss << "\\note This is the setpoint value applied when heating device is to cycle OFF\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "A4 , \\field Control Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A5 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_SingleZone_OneStageHeating);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:SingleZone:OneStageHeating",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_SingleZone_OneStageHeating);
  return object;
}

IddObject createOS_SetpointManager_SingleZone_Humidity_MaximumIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SetpointManager:SingleZone:Humidity:Maximum,\n";
    ss << "\\memo The Single Zone Maximum Humidity Setpoint Manager allows the\n";
    ss << "\\memo control of a single zone maximum humidity level.\n";
    ss << "\\memo This setpoint manager can be used in conjunction with\n";
    ss << "\\memo object ZoneControl:Humidistat to detect humidity levels.\n";
    ss << "\\min-fields 5\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference SetpointManagers\n";
    ss << "A3 , \\field Control Variable\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key MaximumHumidityRatio\n";
    ss << "A4 , \\field Control Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A5 ; \\field Setpoint Node or NodeList Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";

    IddObjectType objType(IddObjectType::OS_SetpointManager_SingleZone_Humidity_Maximum);
    OptionalIddObject oObj = IddObject::load("OS:SetpointManager:SingleZone:Humidity:Maximum",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SetpointManager_SingleZone_Humidity_Maximum);
  return object;
}

IddObject createOS_Sizing_PlantIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Sizing:Plant,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Plant or Condenser Loop Name\n";
    ss << "\\note Enter the name of a PlantLoop or a CondenserLoop object\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PlantLoops\n";
    ss << "A3, \\field Loop Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Heating\n";
    ss << "\\key Cooling\n";
    ss << "\\key Condenser\n";
    ss << "\\key Steam\n";
    ss << "N1, \\field Design Loop Exit Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N2, \\field Loop Design Temperature Difference\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum> 0.0\n";
    ss << "A4, \\field Sizing Option\n";
    ss << "\\note if Coincident is chosen, then sizing is based on HVAC Sizing Simulations and\n";
    ss << "\\note the input field called Do HVAC Sizing Simulation for Sizing Periods in SimulationControl must be set to Yes\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Coincident\n";
    ss << "\\key NonCoincident\n";
    ss << "N3, \\field Zone Timesteps in Averaging Window\n";
    ss << "\\required-field\n";
    ss << "\\note this is used in the coincident sizing algorithm to apply a running average to peak flow rates\n";
    ss << "\\note that occur during HVAC Sizing Simulations\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "A5; \\field Coincident Sizing Factor Mode\n";
    ss << "\\note this is used to adjust the result for coincident sizing by applying a sizing factor\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key GlobalHeatingSizingFactor\n";
    ss << "\\key GlobalCoolingSizingFactor\n";
    ss << "\\key LoopComponentSizingFactor\n";

    IddObjectType objType(IddObjectType::OS_Sizing_Plant);
    OptionalIddObject oObj = IddObject::load("OS:Sizing:Plant",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Sizing_Plant);
  return object;
}

IddObject createOS_Sizing_SystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Sizing:System,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field AirLoop Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list AirPrimaryLoops\n";
    ss << "A3, \\field Type of Load to Size On\n";
    ss << "\\note Specifies the basis for sizing the system supply air flow rate\n";
    ss << "\\note Sensible and VentilationRequirement are the only available options\n";
    ss << "\\note Sensible uses the zone design air flow rates\n";
    ss << "\\note VentilationRequirement uses the system ventilation requirement\n";
    ss << "\\type choice\n";
    ss << "\\default Sensible\n";
    ss << "\\key Sensible\n";
    ss << "\\key VentilationRequirement\n";
    ss << "\\key Latent\n";
    ss << "\\key Total\n";
    ss << "N1, \\field Design Outdoor Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\default autosize\n";
    ss << "N2, \\field Minimum System Air Flow Ratio\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "N3, \\field Preheat Design Temperature\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "N4, \\field Preheat Design Humidity Ratio\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units kg-H2O/kg-Air\n";
    ss << "N5, \\field Precool Design Temperature\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "N6, \\field Precool Design Humidity Ratio\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units kg-H2O/kg-Air\n";
    ss << "N7, \\field Central Cooling Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "N8, \\field Central Heating Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "A4, \\field Sizing Option\n";
    ss << "\\type choice\n";
    ss << "\\default NonCoincident\n";
    ss << "\\key Coincident\n";
    ss << "\\key NonCoincident\n";
    ss << "A5, \\field 100% Outdoor Air in Cooling\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A6, \\field 100% Outdoor Air in Heating\n";
    ss << "\\type choice\n";
    ss << "\\default No\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "N9, \\field Central Cooling Design Supply Air Humidity Ratio\n";
    ss << "\\type real\n";
    ss << "\\units kg-H2O/kg-Air\n";
    ss << "\\default 0.008\n";
    ss << "N10, \\field Central Heating Design Supply Air Humidity Ratio\n";
    ss << "\\type real\n";
    ss << "\\units kg-H2O/kg-Air\n";
    ss << "\\default 0.008\n";
    ss << "A7, \\field Cooling Design Air Flow Method\n";
    ss << "\\type choice\n";
    ss << "\\default DesignDay\n";
    ss << "\\key Flow/System\n";
    ss << "\\key DesignDay\n";
    ss << "\\key FlowPerFloorArea\n";
    ss << "\\key FractionOfAutosizedCoolingAirflow\n";
    ss << "\\key FlowPerCoolingCapacity\n";
    ss << "N11, \\field Cooling Design Air Flow Rate\n";
    ss << "\\note This input is used if Cooling Design Air Flow Method is Flow/System\n";
    ss << "\\note This value will *not* be multiplied by any sizing factor or by zone multipliers.\n";
    ss << "\\note If using zone multipliers, this value must be large enough to serve the multiplied zones.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "A8, \\field Heating Design Air Flow Method\n";
    ss << "\\type choice\n";
    ss << "\\default DesignDay\n";
    ss << "\\key Flow/System\n";
    ss << "\\key DesignDay\n";
    ss << "\\key FlowPerFloorArea\n";
    ss << "\\key FractionOfAutosizedHeatingAirflow\n";
    ss << "\\key FractionOfAutosizedCoolingAirflow\n";
    ss << "\\key FlowPerCoolingCapacity\n";
    ss << "N12, \\field Heating Design Air Flow Rate\n";
    ss << "\\note This input is used if Heating Design Air Flow Method is Flow/System\n";
    ss << "\\note This value will *not* be multiplied by any sizing factor or by zone multipliers.\n";
    ss << "\\note If using zone multipliers, this value must be large enough to serve the multiplied zones.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "A9, \\field System Outdoor Air Method\n";
    ss << "\\type choice\n";
    ss << "\\default ZoneSum\n";
    ss << "\\key ZoneSum\n";
    ss << "\\key VentilationRateProcedure\n";
    ss << "N13, \\field Zone Maximum Outdoor Air Fraction\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units dimensionless\n";
    ss << "\\required-field\n";
    ss << "N14, \\field Cooling Supply Air Flow Rate Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the cooling supply air volume flow rate per total conditioned floor area.\n";
    ss << "\\note Required field when Cooling Supply Air Flow Rate Method is FlowPerFloorArea.\n";
    ss << "N15, \\field Cooling Fraction of Autosized Cooling Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the cooling supply air flow rate.\n";
    ss << "\\note Required field when Cooling Supply Air Flow Rate Method is\n";
    ss << "\\note FractionOfAutosizedCoolingAirflow.\n";
    ss << "N16, \\field Cooling Supply Air Flow Rate Per Unit Cooling Capacity\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the supply air volume flow rate per unit cooling capacity.\n";
    ss << "\\note Required field when Cooling Supply Air Flow Rate Method is\n";
    ss << "\\note FlowPerCoolingCapacity.\n";
    ss << "N17, \\field Heating Supply Air Flow Rate Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the heating supply air volume flow rate per total conditioned floor area.\n";
    ss << "\\note Required field when Heating Supply Air Flow Rate Method is FlowPerFloorArea.\n";
    ss << "N18, \\field Heating Fraction of Autosized Heating Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the heating supply air flow rate.\n";
    ss << "\\note Required field when Heating Supply Air Flow Rate Method is\n";
    ss << "\\note FractionOfAutosizedHeatingAirflow.\n";
    ss << "N19, \\field Heating Fraction of Autosized Cooling Supply Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the supply air volume flow rate as a fraction of the cooling supply air flow rate.\n";
    ss << "\\note Required field when Heating Supply Air Flow Rate Method is\n";
    ss << "\\note FractionOfAutosizedCoolingAirflow.\n";
    ss << "N20, \\field Heating Supply Air Flow Rate Per Unit Heating Capacity\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the heating supply air volume flow rate per unit heating capacity.\n";
    ss << "\\note Required field when Heating Supply Air Flow Rate Method is\n";
    ss << "\\note FlowPerHeatingCapacity.\n";
    ss << "A10, \\field Cooling Design Capacity Method\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key CoolingDesignCapacity\n";
    ss << "\\key CapacityPerFloorArea\n";
    ss << "\\key FractionOfAutosizedCoolingCapacity\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the method used to determine the system cooling design capacity for scalable sizing.\n";
    ss << "\\note None is used when a cooling coils is not included in an airloop or this field may be blank.\n";
    ss << "\\note If this input field is left blank, then the design cooling capacity is set to zero.\n";
    ss << "\\note CoolingDesignCapacity => selected when the design cooling capacity value is specified or\n";
    ss << "\\note auto-sized. CapacityPerFloorArea => selected when the design cooling capacity is determined\n";
    ss << "\\note from user specified cooling capacity per floor area and total floor area of cooled zones\n";
    ss << "\\note served by an airloop. FractionOfAutosizedCoolingCapacity => is selected when the design\n";
    ss << "\\note cooling capacity is determined from a user specified fraction and the auto-sized design\n";
    ss << "\\note cooling capacity of the system.\n";
    ss << "N21, \\field Cooling Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the design cooling capacity.\n";
    ss << "N22, \\field Cooling Design Capacity Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the cooling design capacity per total floor area of cooled zones served by an airloop.\n";
    ss << "\\note Required field when the cooling design capacity method field is CapacityPerFloorArea.\n";
    ss << "N23, \\field Fraction of Autosized Cooling Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the fraction of auto-sized cooling design capacity. Required field when the cooling\n";
    ss << "\\note design capacity method field is FractionOfAutosizedCoolingCapacity.\n";
    ss << "A11, \\field Heating Design Capacity Method\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key HeatingDesignCapacity\n";
    ss << "\\key CapacityPerFloorArea\n";
    ss << "\\key FractionOfAutosizedHeatingCapacity\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the method used to determine the heating design capacity for scalable sizing.\n";
    ss << "\\note None is used when a heating coil not included in an airloop or this field may be blank.\n";
    ss << "\\note If this input field is left blank, then the design heating capacity is set to zero.\n";
    ss << "\\note HeatingDesignCapacity => selected when the design heating capacity value is specified or\n";
    ss << "\\note auto-sized. CapacityPerFloorArea => selected when the design heating capacity is determined\n";
    ss << "\\note from user specified heating capacity per flow area and total floor area of heated zones\n";
    ss << "\\note served by an airloop. FractionOfAutosizedHeatingCapacity => is selected when the design\n";
    ss << "\\note heating capacity is determined from a user specified fraction and the auto-sized design\n";
    ss << "\\note heating capacity of the system.\n";
    ss << "N24, \\field Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Enter the design heating capacity.\n";
    ss << "\\required-field\n";
    ss << "N25, \\field Heating Design Capacity Per Floor Area\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the heating design capacity per zone floor area. Required field when the heating design\n";
    ss << "\\note capacity method field is CapacityPerFloorArea.\n";
    ss << "N26, \\field Fraction of Autosized Heating Design Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "\\note Enter the fraction of auto-sized heating design capacity. Required field when capacity the\n";
    ss << "\\note heating design capacity method field is FractionOfAutosizedHeatingCapacity.\n";
    ss << "A12; \\field Central Cooling Capacity Control Method\n";
    ss << "\\note Method used to control the coil's output\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key VAV\n";
    ss << "\\key Bypass\n";
    ss << "\\key VT\n";
    ss << "\\key OnOff\n";

    IddObjectType objType(IddObjectType::OS_Sizing_System);
    OptionalIddObject oObj = IddObject::load("OS:Sizing:System",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Sizing_System);
  return object;
}

IddObject createOS_Sizing_ZoneIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Sizing:Zone,\n";
    ss << "\\min-fields 20\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Zone or ZoneList Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A3, \\field Zone Cooling Design Supply Air Temperature Input Method\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "N1, \\field Zone Cooling Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "N2, \\field Zone Cooling Design Supply Air Temperature Difference\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "A4, \\field Zone Heating Design Supply Air Temperature Input Method\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key SupplyAirTemperature\n";
    ss << "\\key TemperatureDifference\n";
    ss << "N3, \\field Zone Heating Design Supply Air Temperature\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "N4, \\field Zone Heating Design Supply Air Temperature Difference\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "N5, \\field Zone Cooling Design Supply Air Humidity Ratio\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units kg-H2O/kg-air\n";
    ss << "\\minimum 0\n";
    ss << "N6, \\field Zone Heating Design Supply Air Humidity Ratio\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units kg-H2O/kg-air\n";
    ss << "\\minimum 0\n";
    ss << "N7, \\field Zone Heating Sizing Factor\n";
    ss << "\\note if blank or zero, global heating sizing factor from Sizing:Parameters is used.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N8, \\field Zone Cooling Sizing Factor\n";
    ss << "\\note if blank or zero, global cooling sizing factor from Sizing:Parameters is used.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "A5, \\field Cooling Design Air Flow Method\n";
    ss << "\\type choice\n";
    ss << "\\default DesignDay\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key DesignDay\n";
    ss << "\\key DesignDayWithLimit\n";
    ss << "N9, \\field Cooling Design Air Flow Rate\n";
    ss << "\\note This input is used if Cooling Design Air Flow Method is Flow/Zone\n";
    ss << "\\note This value will be multiplied by the global or zone sizing factor and\n";
    ss << "\\note by zone multipliers.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N10, \\field Cooling Minimum Air Flow per Zone Floor Area\n";
    ss << "\\note default is .15 cfm/ft2\n";
    ss << "\\note This input is used if Cooling Design Air Flow Method is design day with limit\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.000762\n";
    ss << "N11, \\field Cooling Minimum Air Flow\n";
    ss << "\\note This input is used if Cooling Design Air Flow Method is design day with limit\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N12, \\field Cooling Minimum Air Flow Fraction\n";
    ss << "\\note fraction of the Cooling design Air Flow Rate\n";
    ss << "\\note This input is currently used in sizing the Fan minimum Flow Rate.\n";
    ss << "\\note It does not currently affect other component autosizing.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "A6, \\field Heating Design Air Flow Method\n";
    ss << "\\type choice\n";
    ss << "\\default DesignDay\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key DesignDay\n";
    ss << "\\key DesignDayWithLimit\n";
    ss << "N13, \\field Heating Design Air Flow Rate\n";
    ss << "\\note This input is used if Heating Design Air Flow Method is Flow/Zone.\n";
    ss << "\\note This value will be multiplied by the global or zone sizing factor and\n";
    ss << "\\note by zone multipliers.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.0\n";
    ss << "N14, \\field Heating Maximum Air Flow per Zone Floor Area\n";
    ss << "\\note default is .40 cfm/ft2\n";
    ss << "\\note This input is not currently used for autosizing any of the components.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.002032\n";
    ss << "N15, \\field Heating Maximum Air Flow\n";
    ss << "\\note default is 300 cfm\n";
    ss << "\\note This input is not currently used for autosizing any of the components.\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.1415762\n";
    ss << "N16, \\field Heating Maximum Air Flow Fraction\n";
    ss << "\\note fraction of the Heating Design Air Flow Rate\n";
    ss << "\\note This input is not currently used for autosizing any of the components.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0.3\n";
    ss << "N17, \\field Design Zone Air Distribution Effectiveness in Cooling Mode\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1.0\n";
    ss << "N18, \\field Design Zone Air Distribution Effectiveness in Heating Mode\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 1.0\n";
    ss << "A6, \\field Account for Dedicated Outdoor Air System\n";
    ss << "\\note account for effect of dedicated outdoor air system supplying air directly to the zone\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\required-field\n";
    ss << "A7, \\field Dedicated Outdoor Air System Control Strategy\n";
    ss << "\\note 1)supply neutral ventilation air; 2)supply neutral dehumidified and reheated\n";
    ss << "\\note ventilation air; 3)supply cold ventilation air\n";
    ss << "\\type choice\n";
    ss << "\\key NeutralSupplyAir\n";
    ss << "\\key NeutralDehumidifiedSupplyAir\n";
    ss << "\\key ColdSupplyAir\n";
    ss << "\\required-field\n";
    ss << "N19,\\field Dedicated Outdoor Air Low Setpoint Temperature for Design\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "N20;\\field Dedicated Outdoor Air High Setpoint Temperature for Design\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_Sizing_Zone);
    OptionalIddObject oObj = IddObject::load("OS:Sizing:Zone",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Sizing_Zone);
  return object;
}

IddObject createOS_SplitterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Splitter,\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Inlet Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A4; \\field Outlet Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::OS_Splitter);
    OptionalIddObject oObj = IddObject::load("OS:Splitter",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Splitter);
  return object;
}

IddObject createOS_ThermalZoneIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ThermalZone,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ThermalZoneNames\n";
    ss << "\\reference ConnectionObject\n";
    ss << "N1, \\field Multiplier\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";
    ss << "N2, \\field Ceiling Height\n";
    ss << "\\note If this field is 0.0, negative or autocalculate, then the average height\n";
    ss << "\\note of the zone is automatically calculated and used in subsequent calculations.\n";
    ss << "\\note If this field is positive, then the number entered here will be used.\n";
    ss << "\\note Note that the Zone Ceiling Height is the distance from the Floor to\n";
    ss << "\\note the Ceiling in the Zone, not an absolute height from the ground.\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\units m\n";
    ss << "\\default autocalculate\n";
    ss << "N3, \\field Volume\n";
    ss << "\\note If this field is 0.0, negative or autocalculate, then the volume of the zone\n";
    ss << "\\note is automatically calculated and used in subsequent calculations.\n";
    ss << "\\note If this field is positive, then the number entered here will be used.\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\units m3\n";
    ss << "\\default autocalculate\n";
    ss << "N4, \\field Floor Area\n";
    ss << "\\note If this field is 0.0, negative or autocalculate, then the floor area of the zone\n";
    ss << "\\note is automatically calculated and used in subsequent calculations.\n";
    ss << "\\note If this field is positive, then the number entered here will be used.\n";
    ss << "\\type real\n";
    ss << "\\autocalculatable\n";
    ss << "\\units m2\n";
    ss << "\\default autocalculate\n";
    ss << "A3, \\field Zone Inside Convection Algorithm\n";
    ss << "\\note Will default to same value as SurfaceConvectionAlgorithm:Inside object\n";
    ss << "\\note setting this field overrides the default SurfaceConvectionAlgorithm:Inside for this zone\n";
    ss << "\\note Simple = constant natural convection (ASHRAE)\n";
    ss << "\\note TARP = variable natural convection based on temperature difference (ASHRAE)\n";
    ss << "\\note CeilingDiffuser = ACH based forced and mixed convection correlations\n";
    ss << "\\note for ceiling diffuser configuration with simple natural convection limit\n";
    ss << "\\note AdaptiveConvectionAlgorithm = dynamic selection of convection models based on conditions\n";
    ss << "\\note TrombeWall = variable natural convection in an enclosed rectangular cavity\n";
    ss << "\\type choice\n";
    ss << "\\key Simple\n";
    ss << "\\key TARP\n";
    ss << "\\key CeilingDiffuser\n";
    ss << "\\key AdaptiveConvectionAlgorithm\n";
    ss << "\\key TrombeWall\n";
    ss << "A4, \\field Zone Outside Convection Algorithm\n";
    ss << "\\note Will default to same value as SurfaceConvectionAlgorithm:Outside object\n";
    ss << "\\note setting this field overrides the default SurfaceConvectionAlgorithm:Outside for this zone\n";
    ss << "\\note SimpleCombined = Combined radiation and convection coefficient using simple ASHRAE model\n";
    ss << "\\note TARP = correlation from models developed by ASHRAE, Walton, and Sparrow et. al.\n";
    ss << "\\note MoWiTT = correlation from measurements by Klems and Yazdanian for smooth surfaces\n";
    ss << "\\note DOE-2 = correlation from measurements by Klems and Yazdanian for rough surfaces\n";
    ss << "\\note AdaptiveConvectionAlgorithm = dynamic selection of correlations based on conditions\n";
    ss << "\\type choice\n";
    ss << "\\key SimpleCombined\n";
    ss << "\\key TARP\n";
    ss << "\\key DOE-2\n";
    ss << "\\key MoWiTT\n";
    ss << "\\key AdaptiveConvectionAlgorithm\n";
    ss << "A5, \\field Zone Conditioning Equipment List Name\n";
    ss << "\\note Enter the name of a ZoneHVAC:EquipmentList object.\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A6, \\field Zone Air Inlet Port List\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list PortLists\n";
    ss << "A7, \\field Zone Air Exhaust Port List\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list PortLists\n";
    ss << "A8, \\field Zone Air Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A9, \\field Zone Return Air Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A10, \\field Primary Daylighting Control Name\n";
    ss << "\\note For export to EnergyPlus\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DaylightingControlNames\n";
    ss << "N5, \\field Fraction of Zone Controlled by Primary Daylighting Control\n";
    ss << "\\note For export to EnergyPlus\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 1.0\n";
    ss << "A11, \\field Secondary Daylighting Control Name\n";
    ss << "\\note For export to EnergyPlus\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DaylightingControlNames\n";
    ss << "N6, \\field Fraction of Zone Controlled by Secondary Daylighting Control\n";
    ss << "\\note For export to EnergyPlus\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\default 0.0\n";
    ss << "A12, \\field Illuminance Map Name\n";
    ss << "\\note For export to EnergyPlus\n";
    ss << "\\type object-list\n";
    ss << "\\object-list IlluminanceMapNames\n";
    ss << "A13, \\field Group Rendering Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list GroupRenderingNames\n";
    ss << "A14, \\field Thermostat Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermostatNames\n";
    ss << "A15, \\field Use Ideal Air Loads\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A16; \\field Humidistat Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HumidistatNames\n";

    IddObjectType objType(IddObjectType::OS_ThermalZone);
    OptionalIddObject oObj = IddObject::load("OS:ThermalZone",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ThermalZone);
  return object;
}

IddObject createOS_ZoneControl_HumidistatIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneControl:Humidistat,\n";
    ss << "\\memo Specifies zone relative humidity setpoint schedules for humidifying and dehumidifying.\n";
    ss << "\\min-fields 3\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference HumidistatNames\n";
    ss << "A3,  \\field Humidifying Relative Humidity Setpoint Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\note hourly schedule values should be in Relative Humidity (percent)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4;  \\field Dehumidifying Relative Humidity Setpoint Schedule Name\n";
    ss << "\\note hourly schedule values should be in Relative Humidity (percent)\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_ZoneControl_Humidistat);
    OptionalIddObject oObj = IddObject::load("OS:ZoneControl:Humidistat",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneControl_Humidistat);
  return object;
}

IddObject createOS_ThermostatSetpoint_DualSetpointIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ThermostatSetpoint:DualSetpoint,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ThermostatNames\n";
    ss << "A3, \\field Heating Setpoint Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4; \\field Cooling Setpoint Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_ThermostatSetpoint_DualSetpoint);
    OptionalIddObject oObj = IddObject::load("OS:ThermostatSetpoint:DualSetpoint",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ThermostatSetpoint_DualSetpoint);
  return object;
}

IddObject createOS_ZoneControl_Thermostat_StagedDualSetpointIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneControl:Thermostat:StagedDualSetpoint,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ThermostatNames\n";
    ss << "N1 , \\field Number of Heating Stages\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 4\n";
    ss << "A3 , \\field Heating Temperature Setpoint Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N2 , \\field Heating Throttling Temperature Range\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field Stage 1 Heating Temperature Offset\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\maximum 0.0\n";
    ss << "\\required-field\n";
    ss << "N4 , \\field Stage 2 Heating Temperature Offset\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\maximum 0.0\n";
    ss << "\\required-field\n";
    ss << "N5 , \\field Stage 3 Heating Temperature Offset\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\maximum 0.0\n";
    ss << "\\required-field\n";
    ss << "N6 , \\field Stage 4 Heating Temperature Offset\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\maximum 0.0\n";
    ss << "\\required-field\n";
    ss << "N7 , \\field Number of Cooling Stages\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 4\n";
    ss << "\\required-field\n";
    ss << "A4 , \\field Cooling Temperature Setpoint Base Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N8 , \\field Cooling Throttling Temperature Range\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "N9 , \\field Stage 1 Cooling Temperature Offset\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "N10, \\field Stage 2 Cooling Temperature Offset\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "N11, \\field Stage 3 Cooling Temperature Offset\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "N12; \\field Stage 4 Cooling Temperature Offset\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_ZoneControl_Thermostat_StagedDualSetpoint);
    OptionalIddObject oObj = IddObject::load("OS:ZoneControl:Thermostat:StagedDualSetpoint",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneControl_Thermostat_StagedDualSetpoint);
  return object;
}

IddObject createOS_ZoneHVAC_EquipmentListIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:EquipmentList,\n";
    ss << "\\min-fields 1\n";
    ss << "\\extensible:3 Duplicate the three fields Zone Equipment Object Type through Heating Priority\n";
    ss << "\\memo List equipment in simulation order.  Note that an ZoneHVAC:AirDistributionUnit or\n";
    ss << "\\memo AirTerminal:SingleDuct:Uncontrolled object must be listed in this statement if there is a forced\n";
    ss << "\\memo air system serving the zone from the air loop.\n";
    ss << "\\memo Equipment is simulated in the order specified by Zone Equipment Cooling Sequence and\n";
    ss << "\\memo Zone Equipment Heating or No-Load Sequence, depending on the thermostat request.\n";
    ss << "\\memo For equipment of similar type, assign sequence 1 to the first system intended to\n";
    ss << "\\memo serve that type of load.  For situations where one or more equipment types has limited capacity or\n";
    ss << "\\memo limited control, order the sequence so that the most controllable piece of equipment runs last.\n";
    ss << "\\memo For example, with a dedicated outdoor air system (DOAS), the air terminal for the DOAS\n";
    ss << "\\memo should be assigned Heating Sequence = 1 and Cooling Sequence = 1.  Any other equipment should\n";
    ss << "\\memo be assigned sequence 2 or higher so that it will see the net load after the DOAS air is added\n";
    ss << "\\memo to the zone.\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ZoneEquipmentLists\n";
    ss << "A3 , \\field Thermal Zone\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllObjects\n";
    ss << "A4 , \\field Zone Equipment 1\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllObjects\n";
    ss << "\\begin-extensible\n";
    ss << "N1 , \\field Zone Equipment 1 Cooling Sequence\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\note Specifies the zone equipment simulation order\n";
    ss << "\\note when the zone thermostat requests cooling\n";
    ss << "N2 ; \\field Zone Equipment 1 Heating or No-Load Sequence\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\note Specifies the zone equipment simulation order\n";
    ss << "\\note when the zone thermostat requests heating or no load\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_EquipmentList);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:EquipmentList",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_EquipmentList);
  return object;
}

IddObject createOS_ZoneVentilation_DesignFlowRateIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneVentilation:DesignFlowRate,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference VentilationNames\n";
    ss << "A3 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Design Flow Rate Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum amount of ventilation\n";
    ss << "\\note for this set of attributes\n";
    ss << "\\note Choices: Flow/Zone => Design Flow Rate -- simply enter Design Flow Rate\n";
    ss << "\\note Flow/Area => Flow Rate per Zone Floor Area - Value * Floor Area (zone) = Design Flow Rate\n";
    ss << "\\note Flow/Person => Flow Rate per Person - Value * #people = Design Flow Rate\n";
    ss << "\\note AirChanges/Hour => Air Changes per Hour - Value * Floor Volume (zone) adjusted for m3/s = Design Volume Flow Rate\n";
    ss << "\\note  \"Vdesign\" in Equation is the result.\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Flow/Person\n";
    ss << "\\key AirChanges/Hour\n";
    ss << "\\required-field\n";
    ss << "N1 , \\field Design Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N2 , \\field Flow Rate per Zone Floor Area\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field Flow Rate per Person\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units m3/s-person\n";
    ss << "\\required-field\n";
    ss << "N4 , \\field Air Changes per Hour\n";
    ss << "\\units 1/hr\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "A5 , \\field Ventilation Type\n";
    ss << "\\type choice\n";
    ss << "\\key Natural\n";
    ss << "\\key Intake\n";
    ss << "\\key Exhaust\n";
    ss << "\\key Balanced\n";
    ss << "\\required-field\n";
    ss << "N5 , \\field Fan Pressure Rise\n";
    ss << "\\note pressure rise across the fan\n";
    ss << "\\type real\n";
    ss << "\\units Pa\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "N6 , \\field Fan Total Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "N7 , \\field Constant Term Coefficient\n";
    ss << "\\note  \"A\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N8 , \\field Temperature Term Coefficient\n";
    ss << "\\note  \"B\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N9 , \\field Velocity Term Coefficient\n";
    ss << "\\note  \"C\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N10, \\field Velocity Squared Term Coefficient\n";
    ss << "\\note  \"D\" in Equation\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "N11, \\field Minimum Indoor Temperature\n";
    ss << "\\note this is the indoor temperature below which ventilation is shutoff\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\required-field\n";
    ss << "A6 , \\field Minimum Indoor Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the indoor temperature versus time below which\n";
    ss << "\\note ventilation is shutoff.\n";
    ss << "N12, \\field Maximum Indoor Temperature\n";
    ss << "\\note this is the indoor temperature above which ventilation is shutoff\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\required-field\n";
    ss << "A7 , \\field Maximum Indoor Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the indoor temperature versus time above which\n";
    ss << "\\note ventilation is shutoff.\n";
    ss << "N13, \\field Delta Temperature\n";
    ss << "\\note This is the temperature differential between indoor and outdoor below which ventilation is shutoff.\n";
    ss << "\\note If ((IndoorTemp - OutdoorTemp) < DeltaTemperature) then ventilation is not allowed.\n";
    ss << "\\note For example, if delta temperature is 2C, ventilation is assumed to be available if the outside air temperature\n";
    ss << "\\note is at least 2C cooler than the zone air temperature. The values for this field can include negative numbers.\n";
    ss << "\\note This allows ventilation to occur even if the outdoor temperature is above the indoor temperature.\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\required-field\n";
    ss << "A8 , \\field Delta Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the temperature differential between indoor and outdoor\n";
    ss << "\\note versus time below which ventilation is shutoff.\n";
    ss << "N14, \\field Minimum Outdoor Temperature\n";
    ss << "\\note this is the outdoor temperature below which ventilation is shutoff\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\required-field\n";
    ss << "A9 , \\field Minimum Outdoor Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the outdoor temperature versus time below which\n";
    ss << "\\note ventilation is shutoff.\n";
    ss << "N15, \\field Maximum Outdoor Temperature\n";
    ss << "\\note this is the outdoor temperature above which ventilation is shutoff\n";
    ss << "\\units C\n";
    ss << "\\type real\n";
    ss << "\\minimum -100\n";
    ss << "\\maximum 100\n";
    ss << "\\required-field\n";
    ss << "A10, \\field Maximum Outdoor Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the outdoor temperature versus time above which\n";
    ss << "\\note ventilation is shutoff.\n";
    ss << "N16; \\field Maximum Wind Speed\n";
    ss << "\\note this is the outdoor wind speed above which ventilation is shutoff\n";
    ss << "\\units m/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 40\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_ZoneVentilation_DesignFlowRate);
    OptionalIddObject oObj = IddObject::load("OS:ZoneVentilation:DesignFlowRate",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneVentilation_DesignFlowRate);
  return object;
}

IddObject createOS_ZoneHVAC_Baseboard_Convective_ElectricIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:Baseboard:Convective:Electric,\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Nominal Capacity\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "N2 ; \\field Efficiency\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 1.0\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_Baseboard_Convective_Electric);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:Baseboard:Convective:Electric",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_Baseboard_Convective_Electric);
  return object;
}

IddObject createOS_ZoneHVAC_Baseboard_Convective_WaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:Baseboard:Convective:Water,\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4;  \\field Heating Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list BaseboardHeatingCoil\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_Baseboard_Convective_Water);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:Baseboard:Convective:Water",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_Baseboard_Convective_Water);
  return object;
}

IddObject createOS_ZoneHVAC_HighTemperatureRadiantIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:HighTemperatureRadiant,\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "A3 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Maximum Power Input\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "A4 , \\field Fuel Type\n";
    ss << "\\note Natural gas or electricity\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key Electricity\n";
    ss << "N2 , \\field Combustion Efficiency\n";
    ss << "\\note Not used for non-gas radiant heaters\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field Fraction of Input Converted to Radiant Energy\n";
    ss << "\\note Radiant+latent+lost fractions must sum to 1 or less, remainder is considered convective heat\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\required-field\n";
    ss << "N4 , \\field Fraction of Input Converted to Latent Energy\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\required-field\n";
    ss << "N5 , \\field Fraction of Input that Is Lost\n";
    ss << "\\note Fraction of input vented to outdoor environment\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\required-field\n";
    ss << "A5 , \\field Temperature Control Type\n";
    ss << "\\note Temperature type used to control unit\n";
    ss << "\\type choice\n";
    ss << "\\key MeanAirTemperature\n";
    ss << "\\key MeanRadiantTemperature\n";
    ss << "\\key OperativeTemperature\n";
    ss << "\\key MeanAirTemperatureSetpoint\n";
    ss << "\\key MeanRadiantTemperatureSetpoint\n";
    ss << "\\key OperativeTemperatureSetpoint\n";
    ss << "\\required-field\n";
    ss << "N6 , \\field Heating Throttling Range\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "A6 , \\field Heating Setpoint Temperature Schedule Name\n";
    ss << "\\note This setpoint is an \"operative temperature\" setpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N7,  \\field Fraction of Radiant Energy Incident on People\n";
    ss << "\\note This will affect thermal comfort but from an energy balance standpoint this value\n";
    ss << "\\note gets added to the convective gains from the radiant heater\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\required-field\n";
    ss << "A7;  \\field Radiant Surface Type\n";
    ss << "\\note Identifies they types of surfaces that radiant system is embedded in\n";
    ss << "\\type choice\n";
    ss << "\\key Ceilings\n";
    ss << "\\key Floors\n";
    ss << "\\key CeilingsAndFloors\n";
    ss << "\\key AllSurfaces\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_HighTemperatureRadiant);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:HighTemperatureRadiant",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_HighTemperatureRadiant);
  return object;
}

IddObject createOS_ZoneHVAC_LowTemperatureRadiant_ElectricIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:LowTemperatureRadiant:Electric,\n";
    ss << "\\min-fields 8\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A3 , \\field Availability Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Radiant Surface Type\n";
    ss << "\\note Identifies they types of surfaces that radiant system is embedded in\n";
    ss << "\\type choice\n";
    ss << "\\key Ceilings\n";
    ss << "\\key Floors\n";
    ss << "\\key CeilingsAndFloors\n";
    ss << "\\key AllSurfaces\n";
    ss << "\\default Ceilings\n";
    ss << "N1 , \\field Maximum Electrical Power to Panel\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\ip-units W\n";
    ss << "A5 , \\field Temperature Control Type\n";
    ss << "\\note Temperature used to control unit\n";
    ss << "\\type choice\n";
    ss << "\\key MeanAirTemperature\n";
    ss << "\\key MeanRadiantTemperature\n";
    ss << "\\key OperativeTemperature\n";
    ss << "\\key OutdoorDryBulbTemperature\n";
    ss << "\\key OutdoorWetBulbTemperature\n";
    ss << "\\default MeanAirTemperature\n";
    ss << "N2 , \\field Heating Throttling Range\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "A6 ; \\field Heating Setpoint Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_LowTemperatureRadiant_Electric);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:LowTemperatureRadiant:Electric",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_LowTemperatureRadiant_Electric);
  return object;
}

IddObject createOS_ZoneHVAC_IdealLoadsAirSystemIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:IdealLoadsAirSystem,\n";
    ss << "\\min-fields 26\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Zone Supply Air Node Name\n";
    ss << "\\note Should match a zone air inlet node name.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5 , \\field Zone Exhaust Air Node Name\n";
    ss << "\\note Should match a zone air exhaust node name.\n";
    ss << "\\note This field is optional, but is required if this\n";
    ss << "\\note this object is used with other forced air equipment.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 , \\field Maximum Heating Supply Air Temperature\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum< 100.0\n";
    ss << "\\default 50.0\n";
    ss << "N2 , \\field Minimum Cooling Supply Air Temperature\n";
    ss << "\\units C\n";
    ss << "\\minimum> -100.0\n";
    ss << "\\maximum< 50.0\n";
    ss << "\\default 13.0\n";
    ss << "N3 , \\field Maximum Heating Supply Air Humidity Ratio\n";
    ss << "\\units kg-H2O/kg-air\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.0156\n";
    ss << "N4 , \\field Minimum Cooling Supply Air Humidity Ratio\n";
    ss << "\\units kg-H2O/kg-air\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.0077\n";
    ss << "A6 , \\field Heating Limit\n";
    ss << "\\type choice\n";
    ss << "\\key NoLimit\n";
    ss << "\\key LimitFlowRate\n";
    ss << "\\key LimitCapacity\n";
    ss << "\\key LimitFlowRateAndCapacity\n";
    ss << "\\default NoLimit\n";
    ss << "N5 , \\field Maximum Heating Air Flow Rate\n";
    ss << "\\note This field is ignored if Heating Limit = NoLimit\n";
    ss << "\\note If this field is blank, there is no limit.\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N6 , \\field Maximum Sensible Heating Capacity\n";
    ss << "\\note This field is ignored if Heating Limit = NoLimit\n";
    ss << "\\note If this field is blank, there is no limit.\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "A7 , \\field Cooling Limit\n";
    ss << "\\type choice\n";
    ss << "\\key NoLimit\n";
    ss << "\\key LimitFlowRate\n";
    ss << "\\key LimitCapacity\n";
    ss << "\\key LimitFlowRateAndCapacity\n";
    ss << "\\default NoLimit\n";
    ss << "N7 , \\field Maximum Cooling Air Flow Rate\n";
    ss << "\\note This field is ignored if Cooling Limit = NoLimit\n";
    ss << "\\note This field is required if Outdoor Air Control Type\n";
    ss << "\\note is TemperatureEconomizer or EnthalpyEconomizer\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N8 , \\field Maximum Total Cooling Capacity\n";
    ss << "\\note This field is ignored if Cooling Limit = NoLimit\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "A8 , \\field Heating Availability Schedule Name\n";
    ss << "\\note If blank, heating is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A9 , \\field Cooling Availability Schedule Name\n";
    ss << "\\note If blank, cooling is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A10, \\field Dehumidification Control Type\n";
    ss << "\\note ConstantSensibleHeatRatio means that the ideal loads system\n";
    ss << "\\note will be controlled to meet the sensible cooling load, and the\n";
    ss << "\\note latent cooling rate will be computed using a constant\n";
    ss << "\\note sensible heat ratio (SHR)\n";
    ss << "\\note Humidistat means that there is a ZoneControl:Humidistat for this\n";
    ss << "\\note zone and the ideal loads system will attempt to satisfy the humidistat.\n";
    ss << "\\note None means that there is no dehumidification.\n";
    ss << "\\note ConstantSupplyHumidityRatio means that during cooling the supply air\n";
    ss << "\\note will always be at the Minimum Cooling Supply Humidity Ratio.\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantSensibleHeatRatio\n";
    ss << "\\key Humidistat\n";
    ss << "\\key None\n";
    ss << "\\key ConstantSupplyHumidityRatio\n";
    ss << "\\default ConstantSensibleHeatRatio\n";
    ss << "N9 , \\field Cooling Sensible Heat Ratio\n";
    ss << "\\note This field is applicable only when Dehumidification Control Type is ConstantSensibleHeatRatio\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.7\n";
    ss << "A11, \\field Humidification Control Type\n";
    ss << "\\note None means that there is no humidification.\n";
    ss << "\\note Humidistat means that there is a ZoneControl:Humidistat for this\n";
    ss << "\\note zone and the ideal loads system will attempt to satisfy the humidistat.\n";
    ss << "\\note ConstantSupplyHumidityRatio means that during heating the supply air\n";
    ss << "\\note will always be at the Maximum Heating Supply Humidity Ratio.\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Humidistat\n";
    ss << "\\key ConstantSupplyHumidityRatio\n";
    ss << "\\default None\n";
    ss << "A12, \\field Design Specification Outdoor Air Object Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationOutdoorAirNames\n";
    ss << "\\note When the name of a DesignSpecification:OutdoorAir object is entered, the minimum\n";
    ss << "\\note outdoor air flow rate will be computed using these specifications. The outdoor air\n";
    ss << "\\note flow rate will also be affected by the next two fields.\n";
    ss << "\\note If this field is blank, there will be no outdoor air and the remaining fields will\n";
    ss << "\\note be ignored.\n";
    ss << "A13, \\field Demand Controlled Ventilation Type\n";
    ss << "\\note This field controls how the minimum outdoor air flow rate is calculated.\n";
    ss << "\\note None means that design occupancy will be uased to compute the minimum outdoor air flow rate\n";
    ss << "\\note OccupancySchedule means that current occupancy level will be used.\n";
    ss << "\\note CO2Setpoint means that the design occupancy will be used to compute the minimum outdoor air flow\n";
    ss << "\\note reate and the outdoor air flow rate may be increased if necessary to maintain the indoor air carbon\n";
    ss << "\\note dioxide setpoint defined in a ZoneControl:ContaminantController object.\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key OccupancySchedule\n";
    ss << "\\key CO2Setpoint\n";
    ss << "\\default None\n";
    ss << "A14, \\field Outdoor Air Economizer Type\n";
    ss << "\\note DifferentialDryBulb and DifferentialEnthalpy will increase the outdoor air flow rate\n";
    ss << "\\note when there is a cooling load and the outdoor air temperature or enthalpy\n";
    ss << "\\note is below the zone exhaust air temperature or enthalpy.\n";
    ss << "\\type choice\n";
    ss << "\\key NoEconomizer\n";
    ss << "\\key DifferentialDryBulb\n";
    ss << "\\key DifferentialEnthalpy\n";
    ss << "\\default NoEconomizer\n";
    ss << "A15, \\field Heat Recovery Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Sensible\n";
    ss << "\\key Enthalpy\n";
    ss << "\\default None\n";
    ss << "N10, \\field Sensible Heat Recovery Effectiveness\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.70\n";
    ss << "N11; \\field Latent Heat Recovery Effectiveness\n";
    ss << "\\note Applicable only if Heat Recovery Type is Enthalpy.\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.65\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_IdealLoadsAirSystem);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:IdealLoadsAirSystem",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_IdealLoadsAirSystem);
  return object;
}

IddObject createOS_ZoneHVAC_FourPipeFanCoilIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:FourPipeFanCoil,\n";
    ss << "\\min-fields 24\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Capacity Control Method\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key ConstantFanVariableFlow\n";
    ss << "\\key CyclingFan\n";
    ss << "\\key VariableFanVariableFlow\n";
    ss << "\\key VariableFanConstantFlow\n";
    ss << "N1 , \\field Maximum Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "N2 , \\field Low Speed Supply Air Flow Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.33\n";
    ss << "N3 , \\field Medium Speed Supply Air Flow Ratio\n";
    ss << "\\note Medium Speed Supply Air Flow Ratio should be greater\n";
    ss << "\\note than Low Speed Supply Air Flow Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.66\n";
    ss << "N4 , \\field Maximum Outdoor Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "A5 , \\field Outdoor Air Schedule Name\n";
    ss << "\\note Value of schedule multiplies maximum outdoor air flow rate\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A7 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A8,  \\field Outdoor Air Mixer Object Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key OutdoorAir:Mixer\n";
    ss << "\\note currently only one type OutdoorAir:Mixer object is available.\n";
    ss << "A9 , \\field Outdoor Air Mixer Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutdoorAirMixers\n";
    ss << "A10, \\field Supply Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOffandVAV\n";
    ss << "A11, \\field Cooling Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsWater\n";
    ss << "N5 , \\field Maximum Cold Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N6 , \\field Minimum Cold Water Flow Rate\n";
    ss << "\\default 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N7 , \\field Cooling Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "A12, \\field Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilsWater\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N8 , \\field Maximum Hot Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N9 , \\field Minimum Hot Water Flow Rate\n";
    ss << "\\default 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "N10; \\field Heating Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_FourPipeFanCoil);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:FourPipeFanCoil",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_FourPipeFanCoil);
  return object;
}

IddObject createOS_ZoneHVAC_LowTemperatureRadiant_ConstantFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:LowTemperatureRadiant:ConstantFlow,\n";
    ss << "\\min-fields 15\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A3 , \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Radiant Surface Type\n";
    ss << "\\note Identifies they types of surfaces that radiant system is embedded in\n";
    ss << "\\type choice\n";
    ss << "\\key Ceilings\n";
    ss << "\\key Floors\n";
    ss << "\\key CeilingsAndFloors\n";
    ss << "\\key AllSurfaces\n";
    ss << "\\default Ceilings\n";
    ss << "N1 , \\field Hydronic Tubing Inside Diameter\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.013\n";
    ss << "N2 , \\field Hydronic Tubing Length\n";
    ss << "\\note Total length of pipe embedded in surface\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "A5 , \\field Temperature Control Type\n";
    ss << "\\note Temperature used to control system\n";
    ss << "\\type choice\n";
    ss << "\\key MeanAirTemperature\n";
    ss << "\\key MeanRadiantTemperature\n";
    ss << "\\key OperativeTemperature\n";
    ss << "\\key OutdoorDryBulbTemperature\n";
    ss << "\\key OutdoorWetBulbTemperature\n";
    ss << "\\default MeanAirTemperature\n";
    ss << "A6 , \\field Low Temp Radiant Constant Flow Heating Coil Name\n";
    ss << "\\type object-List\n";
    ss << "\\required-field\n";
    ss << "\\object-list CoilHeatingLowTempRadiantConstantFlow\n";
    ss << "A7 , \\field Low Temp Radiant Constant Flow Cooling Coil Name\n";
    ss << "\\type object-List\n";
    ss << "\\required-field\n";
    ss << "\\object-list CoilCoolingLowTempRadiantConstantFlow\n";
    ss << "N3 , \\field Rated Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "A8 , \\field Pump Flow Rate Schedule Name\n";
    ss << "\\note Modifies the Rated Flow Rate of the pump on a time basis\n";
    ss << "\\note the default is that the pump is ON and runs according to its other\n";
    ss << "\\note operational requirements specified above.  The schedule is for special\n";
    ss << "\\note pump operations. Values here are between 0 and 1 and are multipliers\n";
    ss << "\\note on the previous field (Rated Flow Rate).\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N4 , \\field Rated Pump Head\n";
    ss << "\\units Pa\n";
    ss << "\\default 179352\n";
    ss << "\\note default head is 60 feet\n";
    ss << "N5 , \\field Rated Power Consumption\n";
    ss << "\\units W\n";
    ss << "N6 , \\field Motor Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.9\n";
    ss << "N7 , \\field Fraction of Motor Inefficiencies to Fluid Stream\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "A9, \\field Number of Circuits\n";
    ss << "\\type choice\n";
    ss << "\\key OnePerSurface\n";
    ss << "\\key CalculateFromCircuitLength\n";
    ss << "\\default OnePerSurface\n";
    ss << "N8 ; \\field Circuit Length\n";
    ss << "\\units m\n";
    ss << "\\default 106.7\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_LowTemperatureRadiant_ConstantFlow);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:LowTemperatureRadiant:ConstantFlow",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_LowTemperatureRadiant_ConstantFlow);
  return object;
}

IddObject createOS_ZoneHVAC_LowTemperatureRadiant_VariableFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:LowTemperatureRadiant:VariableFlow,\n";
    ss << "\\min-fields 9\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A3 , \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Low Temp Radiant Variable Flow Heating Coil Name\n";
    ss << "\\type object-List\n";
    ss << "\\required-field\n";
    ss << "\\object-list CoilHeatingLowTempRadiantVariableFlow\n";
    ss << "A5 , \\field Low Temp Radiant Variable Flow Cooling Coil Name\n";
    ss << "\\type object-List\n";
    ss << "\\required-field\n";
    ss << "\\object-list CoilCoolingLowTempRadiantVariableFlow\n";
    ss << "A6 , \\field Radiant Surface Type\n";
    ss << "\\note Identifies they types of surfaces that radiant system is embedded in\n";
    ss << "\\type choice\n";
    ss << "\\key Ceilings\n";
    ss << "\\key Floors\n";
    ss << "\\key CeilingsAndFloors\n";
    ss << "\\key AllSurfaces\n";
    ss << "\\default Ceilings\n";
    ss << "N1 , \\field Hydronic Tubing Inside Diameter\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.013\n";
    ss << "\\ip-units in\n";
    ss << "N2 , \\field Hydronic Tubing Length\n";
    ss << "\\note (total length of pipe embedded in surface)\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "A7 , \\field Temperature Control Type\n";
    ss << "\\note (Temperature on which unit is controlled)\n";
    ss << "\\type choice\n";
    ss << "\\key MeanAirTemperature\n";
    ss << "\\key MeanRadiantTemperature\n";
    ss << "\\key OperativeTemperature\n";
    ss << "\\key OutdoorDryBulbTemperature\n";
    ss << "\\key OutdoorWetBulbTemperature\n";
    ss << "\\default MeanAirTemperature\n";
    ss << "A8 , \\field Number of Circuits\n";
    ss << "\\type choice\n";
    ss << "\\key OnePerSurface\n";
    ss << "\\key CalculateFromCircuitLength\n";
    ss << "\\default OnePerSurface\n";
    ss << "N3 ; \\field Circuit Length\n";
    ss << "\\units m\n";
    ss << "\\default 106.7\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_LowTemperatureRadiant_VariableFlow);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:LowTemperatureRadiant:VariableFlow",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_LowTemperatureRadiant_VariableFlow);
  return object;
}

IddObject createOS_ZoneHVAC_PackagedTerminalHeatPumpIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:PackagedTerminalHeatPump,\n";
    ss << "\\min-fields 24\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note Unique name or this packaged terminal heat pump object.\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\note Schedule values of 0 denote the unit is off.\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4, \\field Air Inlet Node Name\n";
    ss << "\\note Air inlet node for the PTHP must be a zone air exhaust node.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Air Outlet Node Name\n";
    ss << "\\note Air outlet node for the PTHP must be a zone air inlet node.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6, \\field Outdoor Air Mixer Object Type\n";
    ss << "\\note currently only one OutdoorAir:Mixer object type is available.\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key OutdoorAir:Mixer\n";
    ss << "A7, \\field Outdoor Air Mixer Name\n";
    ss << "\\note Needs to match name of outdoor air mixer object.\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "N1, \\field Supply Air Flow Rate During Cooling Operation\n";
    ss << "\\note Must be less than or equal to fan size.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "N2, \\field Supply Air Flow Rate During Heating Operation\n";
    ss << "\\note Must be less than or equal to fan size.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "N3, \\field Supply Air Flow Rate When No Cooling or Heating is Needed\n";
    ss << "\\note Must be less than or equal to fan size.\n";
    ss << "\\note Only used when heat pump fan operating mode is continuous. This air flow rate\n";
    ss << "\\note is used when no heating or cooling is required and the DX coil compressor is off.\n";
    ss << "\\note If this field is left blank or zero, the supply air flow rate from the previous on cycle\n";
    ss << "\\note (either cooling or heating) is used.\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "N4, \\field Outdoor Air Flow Rate During Cooling Operation\n";
    ss << "\\note Must be less than or equal to supply air flow rate during cooling operation.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "N5, \\field Outdoor Air Flow Rate During Heating Operation\n";
    ss << "\\note Must be less than or equal to supply air flow rate during heating operation.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "N6, \\field Outdoor Air Flow Rate When No Cooling or Heating is Needed\n";
    ss << "\\note Only used when heat pump Fan operating mode is continuous. This air flow rate\n";
    ss << "\\note is used when no heating or cooling is required and the DX coil compressor is off.\n";
    ss << "\\note If this field is left blank or zero, the outdoor air flow rate from the previous on cycle\n";
    ss << "\\note (either cooling or heating) is used.\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "A8, \\field Supply Air Fan Name\n";
    ss << "\\note Needs to match a fan object.\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list FansCVandOnOff\n";
    ss << "A9, \\field Heating Coil Name\n";
    ss << "\\note Needs to match in the DX Heating Coil object.\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list HeatingCoilsDXSingleSpeed\n";
    ss << "\\object-list HeatingCoilsDXVariableSpeed\n";
    ss << "N7, \\field Heating Convergence Tolerance\n";
    ss << "\\note Defines Heating convergence tolerence as a fraction of Heating load to be met.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.001\n";
    ss << "N8, \\field Minimum Outdoor Dry-Bulb Temperature for Compressor Operation\n";
    ss << "\\note Needs to match the corresponding minimum outdoor temperature defined\n";
    ss << "\\note in the DX Heating Coil object.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum -20\n";
    ss << "\\default -8.0\n";
    ss << "A10, \\field Cooling Coil Name\n";
    ss << "\\note Needs to match in the DX Cooling Coil object.\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list CoolingCoilsDXSingleSpeed\n";
    ss << "\\object-list CoolingCoilsDXVariableSpeed\n";
    ss << "N9, \\field Cooling Convergence Tolerance\n";
    ss << "\\note Defines Cooling convergence tolerence as a fraction of the Cooling load to be met.\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.001\n";
    ss << "A11, \\field Supplemental Heating Coil Name\n";
    ss << "\\note Needs to match in the supplemental heating coil object.\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N10, \\field Maximum Supply Air Temperature from Supplemental Heater\n";
    ss << "\\note Supply air temperature from the supplemental heater will not exceed this value.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units C\n";
    ss << "N11, \\field Maximum Outdoor Dry-Bulb Temperature for Supplemental Heater Operation\n";
    ss << "\\note Supplemental heater will not operate when outdoor temperature exceeds this value.\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\maximum 21\n";
    ss << "\\default 21.0\n";
    ss << "A12, \\field Fan Placement\n";
    ss << "\\note Select fan placement as either blow through or draw through.\n";
    ss << "\\type choice\n";
    ss << "\\default DrawThrough\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "A13; \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\note Enter the name of a schedule that controls fan operation. Schedule values of 0 denote\n";
    ss << "\\note cycling fan operation (fan cycles with cooling or heating coil). Schedule Name values greater\n";
    ss << "\\note than 0 denote constant fan operation (fan runs continually regardless of coil operation).\n";
    ss << "\\note The fan operating mode defaults to cycling fan operation if this field is left blank.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_PackagedTerminalHeatPump);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:PackagedTerminalHeatPump",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_PackagedTerminalHeatPump);
  return object;
}

IddObject createOS_ZoneHVAC_PackagedTerminalAirConditionerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:PackagedTerminalAirConditioner,\n";
    ss << "\\min-fields 16\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note Unique name for this packaged terminal air conditioner object.\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3, \\field Availability Schedule Name\n";
    ss << "\\note Schedule values of 0 denote the unit is off.\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4, \\field Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5, \\field Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6, \\field Outdoor Air Mixer Object Type\n";
    ss << "\\note currently only one OutdoorAir:Mixer object type is available.\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key OutdoorAir:Mixer\n";
    ss << "A7, \\field Outdoor Air Mixer Name\n";
    ss << "\\note Needs to match the name of the PTAC outdoor air mixer object.\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list OutdoorAirMixers\n";
    ss << "N1, \\field Supply Air Flow Rate During Cooling Operation\n";
    ss << "\\note Must be less than or equal to fan size.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "N2, \\field Supply Air Flow Rate During Heating Operation\n";
    ss << "\\note Must be less than or equal to fan size.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "N3, \\field Supply Air Flow Rate When No Cooling or Heating is Needed\n";
    ss << "\\note Must be less than or equal to fan size.\n";
    ss << "\\note Only used when supply air fan operating mode schedule values specify continuous fan\n";
    ss << "\\note (schedule values greater than 0 specify continuous fan operation).\n";
    ss << "\\note This air flow rate is used when no heating or cooling is required and the cooling or\n";
    ss << "\\note heating coil is off. If this field is left blank or zero, the supply air flow rate\n";
    ss << "\\note from the previous on cycle (either cooling or heating) is used.\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "N4, \\field Outdoor Air Flow Rate During Cooling Operation\n";
    ss << "\\note Must be less than or equal to supply air flow rate during cooling operation.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "N5, \\field Outdoor Air Flow Rate During Heating Operation\n";
    ss << "\\note Must be less than or equal to supply air flow rate during heating operation.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "N6, \\field Outdoor Air Flow Rate When No Cooling or Heating is Needed\n";
    ss << "\\note Only used when supply air fan operating mode schedule values specify continuous fan\n";
    ss << "\\note (schedule values greater than 0 specify continuous fan operation).\n";
    ss << "\\note This air flow rate is used when no heating or cooling is required and the cooling or\n";
    ss << "\\note heating coil is off. If this field is left blank or zero, the outdoor air flow rate\n";
    ss << "\\note from the previous on cycle (either cooling or heating) is used.\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "A8, \\field Supply Air Fan Name\n";
    ss << "\\note Needs to match in the fan object.\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list FansCVandOnOff\n";
    ss << "A9, \\field Heating Coil Name\n";
    ss << "\\note Needs to match in the heating coil object.\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "A10, \\field Cooling Coil Name\n";
    ss << "\\note Needs to match a DX cooling coil object.\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list CoolingCoilsDXSingleSpeed\n";
    ss << "\\object-list CoolingCoilsDXVariableSpeed\n";
    ss << "A11, \\field Fan Placement\n";
    ss << "\\note Select fan placement as either blow through or draw through.\n";
    ss << "\\type choice\n";
    ss << "\\default DrawThrough\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "A12; \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\note Enter the name of a schedule that controls fan operation. Schedule Name values of 0 denote\n";
    ss << "\\note cycling fan operation (fan cycles with cooling or heating coil). Schedule Name values greater\n";
    ss << "\\note than 0 denote constant fan operation (fan runs continually regardless of coil operation).\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_PackagedTerminalAirConditioner);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:PackagedTerminalAirConditioner",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_PackagedTerminalAirConditioner);
  return object;
}

IddObject createOS_ZoneHVAC_TerminalUnit_VariableRefrigerantFlowIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:TerminalUnit:VariableRefrigerantFlow,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 ,  \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\reference ZoneTerminalUnitNames\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 ,  \\field Terminal Unit Availability schedule\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 ,  \\field Terminal Unit Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5 ,  \\field Terminal Unit Air Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 ,  \\field Supply Air Flow Rate During Cooling Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2 ,  \\field Supply Air Flow Rate When No Cooling is Needed\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N3 ,  \\field Supply Air Flow Rate During Heating Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N4 ,  \\field Supply Air Flow Rate When No Heating is Needed\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N5 ,  \\field Outdoor Air Flow Rate During Cooling Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N6 ,  \\field Outdoor Air Flow Rate During Heating Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N7 ,  \\field Outdoor Air Flow Rate When No Cooling or Heating is Needed\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "A6 ,  \\field Supply Air Fan Operating Mode Schedule\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A7 ,  \\field Supply Air Fan placement\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\note Select fan placement as either blow through or draw through.\n";
    ss << "A8 ,  \\field Supply Air Fan\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOff\n";
    ss << "A9,  \\field Outside Air Mixer\n";
    ss << "\\type object-list\n";
    ss << "\\object-list OutdoorAirMixers\n";
    ss << "\\note If this field is blank, and outside air mixer is not used.\n";
    ss << "A10,  \\field Cooling Coil\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsDXVarRefrigFlow\n";
    ss << "\\note Cooling Coil Type must be Coil:Cooling:DX:VariableRefrigerantFlow\n";
    ss << "\\note This field may be left blank if heating-only mode is used\n";
    ss << "A11,  \\field Heating Coil\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilsDXVarRefrigFlow\n";
    ss << "\\note Heating Coil Type must be Coil:Heating:DX:VariableRefrigerantFlow\n";
    ss << "\\note This field may be left blank if cooling-only mode is used\n";
    ss << "N8 ,  \\field Zone Terminal Unit On Parasitic Electric Energy Use\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "N9 ,  \\field Zone Terminal Unit Off Parasitic Electric Energy Use\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "N10; \\field Rated Total Heating Capacity Sizing Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum 1.0\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_TerminalUnit_VariableRefrigerantFlow);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:TerminalUnit:VariableRefrigerantFlow",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_TerminalUnit_VariableRefrigerantFlow);
  return object;
}

IddObject createOS_ZoneHVAC_WaterToAirHeatPumpIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:WaterToAirHeatPump,\n";
    ss << "\\min-fields 25\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,  \\field Availability Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4,  \\field Air Inlet Node Name\n";
    ss << "\\note Air inlet node for the PTHP must be a zone air exhaust node.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5,  \\field Air Outlet Node Name\n";
    ss << "\\note Air outlet node for the PTHP must be a zone air inlet node.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6,  \\field Outdoor Air Mixer Name\n";
    ss << "\\note Needs to match name of outdoor air mixer object.\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list OutdoorAirMixers\n";
    ss << "N1,  \\field Supply Air Flow Rate During Cooling Operation\n";
    ss << "\\note Must be less than or equal to fan size.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N2,  \\field Supply Air Flow Rate During Heating Operation\n";
    ss << "\\note Must be less than or equal to fan size.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3,  \\field Supply Air Flow Rate When No Cooling or Heating is Needed\n";
    ss << "\\note Must be less than or equal to fan size.\n";
    ss << "\\note Only used when heat pump fan operating mode is continuous. This air flow rate\n";
    ss << "\\note is used when no heating or cooling is required and the DX coil compressor is off.\n";
    ss << "\\note If this field is left blank or zero, the supply air flow rate from the previous on cycle\n";
    ss << "\\note (either cooling or heating) is used.\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "N4,  \\field Outdoor Air Flow Rate During Cooling Operation\n";
    ss << "\\note Must be less than or equal to supply air flow rate during cooling operation.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "N5,  \\field Outdoor Air Flow Rate During Heating Operation\n";
    ss << "\\note Must be less than or equal to supply air flow rate during heating operation.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "N6, \\field Outdoor Air Flow Rate When No Cooling or Heating is Needed\n";
    ss << "\\note Only used when heat pump Fan operating mode is continuous. This air flow rate\n";
    ss << "\\note is used when no heating or cooling is required and the DX coil compressor is off.\n";
    ss << "\\note If this field is left blank or zero, the outdoor air flow rate from the previous on cycle\n";
    ss << "\\note (either cooling or heating) is used.\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "A7,  \\field Supply Air Fan Name\n";
    ss << "\\note Needs to match Fan:OnOff object\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOff\n";
    ss << "A8, \\field Heating Coil Name\n";
    ss << "\\note  Needs to match in the water-to-air heatpump heating coil object\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list HeatingCoilsWaterToAirHP\n";
    ss << "\\object-list HeatingCoilsWaterToAirVSHP\n";
    ss << "A9, \\field Cooling Coil Name\n";
    ss << "\\note Needs to match in the water-to-air heatpump cooling coil object\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list CoolingCoilsWaterToAirHP\n";
    ss << "\\object-list CoolingCoilsWaterToAirVSHP\n";
    ss << "N7,  \\field Maximum Cycling Rate\n";
    ss << "\\note The maximum on-off cycling rate for the compressor\n";
    ss << "\\note Suggested value is 2.5 for a typical heat pump\n";
    ss << "\\type real\n";
    ss << "\\units cycles/hr\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 5.0\n";
    ss << "\\default 2.5\n";
    ss << "N8,  \\field Heat Pump Time Constant\n";
    ss << "\\note Time constant for the cooling coil's capacity to reach steady state after startup\n";
    ss << "\\note Suggested value is 60 for a typical heat pump\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 500.0\n";
    ss << "\\default 60.0\n";
    ss << "N9,  \\field Fraction of On-Cycle Power Use\n";
    ss << "\\note The fraction of on-cycle power use to adjust the part load fraction based on\n";
    ss << "\\note the off-cycle power consumption due to crankcase heaters, controls, fans, and etc.\n";
    ss << "\\note Suggested value is 0.01 for a typical heat pump\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 0.05\n";
    ss << "\\default 0.01\n";
    ss << "N10, \\field Heat Pump Fan Delay Time\n";
    ss << "\\note Programmed time delay for heat pump fan to shut off after compressor cycle off.\n";
    ss << "\\note Only required when fan operating mode is cycling\n";
    ss << "\\note Enter 0 when fan operating mode is continuous\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 60\n";
    ss << "A10, \\field Supplemental Heating Coil Name\n";
    ss << "\\note  Needs to match in the supplemental heating coil object\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N11, \\field Maximum Supply Air Temperature from Supplemental Heater\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\autosizable\n";
    ss << "N12, \\field Maximum Outdoor Dry-Bulb Temperature for Supplemental Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\maximum 21.0\n";
    ss << "\\default 21.0\n";
    ss << "\\units C\n";
    ss << "A11, \\field Outdoor Dry-Bulb Temperature Sensor Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A12, \\field Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\default BlowThrough\n";
    ss << "A13, \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Enter the name of a schedule that controls fan operation. Schedule values of 0 denote\n";
    ss << "\\note cycling fan operation (fan cycles with cooling or heating coil). Schedule values greater\n";
    ss << "\\note than 0 denote constant fan operation (fan runs continually regardless of coil operation).\n";
    ss << "\\note The fan operating mode defaults to cycling fan operation if this field is left blank.\n";
    ss << "A14; \\field Availability Manager List Name\n";
    ss << "\\note Enter the name of an AvailabilityManagerAssignmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_WaterToAirHeatPump);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:WaterToAirHeatPump",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_WaterToAirHeatPump);
  return object;
}

IddObject createOS_ZoneHVAC_UnitHeaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:UnitHeater,\n";
    ss << "\\min-fields 10\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\note Unique name for this unit heater.\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule Name\n";
    ss << "\\note Schedule values of 0 denote the unit is off.\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6 , \\field Supply Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOffandVAV\n";
    ss << "\\note Allowable fan types are Fan:ConstantVolume, Fan:OnOff and\n";
    ss << "\\note Fan:VariableVolume\n";
    ss << "N1 , \\field Maximum Supply Air Flow Rate\n";
    ss << "\\note Must be less than or equal to fan size.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "A7 , \\field Fan Control Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key OnOff\n";
    ss << "\\key Continuous\n";
    ss << "A8 , \\field Heating Coil Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N2 , \\field Maximum Hot Water Flow Rate\n";
    ss << "\\note Not used when heating coil is gas or electric\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N3 , \\field Minimum Hot Water Flow Rate\n";
    ss << "\\note Not used when heating coil is gas or electric\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\ip-units gal/min\n";
    ss << "N4 , \\field Heating Convergence Tolerance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\default 0.001\n";
    ss << "A9 ; \\field Availability Manager List Name\n";
    ss << "\\note Enter the name of an AvailabilityManagerAssignmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_UnitHeater);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:UnitHeater",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_UnitHeater);
  return object;
}

IddObject createOS_ZoneHVAC_Dehumidifier_DXIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:Dehumidifier:DX,\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,  \\field Availability Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4,  \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5,  \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1,  \\field Rated Water Removal\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units L/day\n";
    ss << "\\minimum> 0.0\n";
    ss << "N2,  \\field Rated Energy Factor\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units L/kWh\n";
    ss << "\\minimum> 0.0\n";
    ss << "N3,  \\field Rated Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "A6,  \\field Water Removal Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A7,  \\field Energy Factor Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "A8,  \\field Part Load Fraction Correlation Curve Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "N4,  \\field Minimum Dry-Bulb Temperature for Dehumidifier Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N5,  \\field Maximum Dry-Bulb Temperature for Dehumidifier Operation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N6,  \\field Off-Cycle Parasitic Electric Load\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "A9;  \\field Condensate Collection Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_Dehumidifier_DX);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:Dehumidifier:DX",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_Dehumidifier_DX);
  return object;
}

IddObject createOS_ZoneHVAC_EnergyRecoveryVentilatorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:EnergyRecoveryVentilator,\n";
    ss << "A1 ,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 ,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 ,  \\field Availability Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 ,  \\field Heat Exchanger Name\n";
    ss << "\\required-field\n";
    ss << "\\note Heat exchanger type must be HeatExchanger:AirToAir:SensibleAndLatent\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HXAirToAirSensibleAndLatentNames\n";
    ss << "N1 ,  \\field Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\note This flow rate must match the supply fan's air flow rate.\n";
    ss << "N2 ,  \\field Exhaust Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\autosizable\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\units m3/s\n";
    ss << "\\note This flow rate must match the supply fan air flow rate.\n";
    ss << "A5 ,  \\field Supply Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\note Fan type must be Fan:OnOff\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansOnOff\n";
    ss << "A6 ,  \\field Exhaust Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\note Fan type must be Fan:OnOff\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansOnOff\n";
    ss << "A7 ,  \\field Controller Name\n";
    ss << "\\note Enter the name of a ZoneHVAC:EnergyRecoveryVentilator:Controller object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ControllerStandAloneEnergyRecoveryVentilator\n";
    ss << "N3 ,  \\field Ventilation Rate per Unit Floor Area\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-m2\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note 0.000508 m3/s-m2 corresponds to 0.1 ft3/min-ft2\n";
    ss << "\\note Used only when supply and exhaust air flow rates are autosized.\n";
    ss << "N4 ,  \\field Ventilation Rate per Occupant\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s-person\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note 0.00236 m3/s-person corresponds to 5 ft3/min-person\n";
    ss << "\\note Used only when supply and exhaust air flow rates are autosized.\n";
    ss << "A8 ,  \\field Availability Manager List Name\n";
    ss << "\\note Enter the name of an AvailabilityManagerAssignmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";
    ss << "A9 ,  \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A10;  \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_EnergyRecoveryVentilator);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:EnergyRecoveryVentilator",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_EnergyRecoveryVentilator);
  return object;
}

IddObject createOS_ZoneHVAC_EnergyRecoveryVentilator_ControllerIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:EnergyRecoveryVentilator:Controller,\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ControllerStandAloneEnergyRecoveryVentilator\n";
    ss << "N1 , \\field Temperature High Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the maximum outdoor dry-bulb temperature limit for economizer operation.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "N2 , \\field Temperature Low Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the minimum outdoor dry-bulb temperature limit for economizer operation.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "N3 , \\field Enthalpy High Limit\n";
    ss << "\\type real\n";
    ss << "\\units J/kg\n";
    ss << "\\note Enter the maximum outdoor enthalpy limit for economizer operation.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "N4 , \\field Dewpoint Temperature Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\note Enter the maximum outdoor dew point temperature limit for economizer operation.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "A3 , \\field Electronic Enthalpy Limit Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Enter the name of a quadratic or cubic curve which defines the maximum outdoor\n";
    ss << "\\note humidity ratio (function of outdoor dry-bulb temperature) for economizer operation.\n";
    ss << "\\note No input or blank input means this limit is not operative\n";
    ss << "A4 , \\field Exhaust Air Temperature Limit\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key ExhaustAirTemperatureLimit\n";
    ss << "\\key NoExhaustAirTemperatureLimit\n";
    ss << "A5 , \\field Exhaust Air Enthalpy Limit\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key ExhaustAirEnthalpyLimit\n";
    ss << "\\key NoExhaustAirEnthalpyLimit\n";
    ss << "A6 , \\field Time of Day Economizer Flow Control Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values greater than 0 indicate economizer operation is active. This\n";
    ss << "\\note schedule may be used with or without the High Humidity Control option.\n";
    ss << "\\note When used together, high humidity control has priority over economizer control.\n";
    ss << "A7 , \\field High Humidity Control Flag\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\note Select Yes to modify air flow rates based on a zone humidistat.\n";
    ss << "\\note Select No to disable this feature.\n";
    ss << "N5 , \\field High Humidity Outdoor Air Flow Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Enter the ratio of supply (outdoor) air to the maximum supply air flow rate when modified\n";
    ss << "\\note air flow rates are active based on high indoor humidity.\n";
    ss << "A8 ; \\field Control High Indoor Humidity Based on Outdoor Humidity Ratio\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\note If NO is selected, the air flow rate is modified any time indoor relative\n";
    ss << "\\note humidity is above humidistat setpoint. If YES is selected, outdoor air flow\n";
    ss << "\\note rate is modified any time indoor relative humidity is above the humidistat\n";
    ss << "\\note setpoint AND the outdoor humidity ratio is less than the indoor humidity ratio.\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_EnergyRecoveryVentilator_Controller);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:EnergyRecoveryVentilator:Controller",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_EnergyRecoveryVentilator_Controller);
  return object;
}

IddObject createOS_ZoneHVAC_UnitVentilatorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:UnitVentilator,\n";
    ss << "\\min-fields 19\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Maximum Supply Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "A4 , \\field Outdoor Air Control Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key FixedAmount\n";
    ss << "\\key VariablePercent\n";
    ss << "\\key FixedTemperature\n";
    ss << "N2 , \\field Minimum Outdoor Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";
    ss << "\\minimum 0.0\n";
    ss << "A5 , \\field Minimum Outdoor Air Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N3 , \\field Maximum Outdoor Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0\n";
    ss << "\\autosizable\n";
    ss << "A6 , \\field Maximum Outdoor Air Fraction or Temperature Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A7 , \\field Air Inlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A8 , \\field Air Outlet Node Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A9,  \\field Supply Air Fan Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansCVandOnOffandVAV\n";
    ss << "A10, \\field Supply Air Fan Operating Mode Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Enter the name of a schedule that controls fan operation. Schedule\n";
    ss << "\\note name values of 0 denote cycling fan operation (fan cycles with\n";
    ss << "\\note cooling/heating coil). Schedule values greater than 0 denote\n";
    ss << "\\note constant fan operation (fan runs continually regardless of coil\n";
    ss << "\\note operation). The fan operating mode defaults to cycling fan operation\n";
    ss << "\\note if this input field is left blank.\n";
    ss << "A11, \\field Heating Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatingCoilName\n";
    ss << "N4 , \\field Heating Convergence Tolerance\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "A12, \\field Cooling Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CoolingCoilsWater\n";
    ss << "N5 , \\field Cooling Convergence Tolerance\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "A13, \\field Availability Manager List Name\n";
    ss << "\\note Enter the name of an AvailabilityManagerAssignmentList object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SystemAvailabilityManagerLists\n";
    ss << "A14; \\field Design Specification ZoneHVAC Sizing Object Name\n";
    ss << "\\note Enter the name of a DesignSpecificationZoneHVACSizing object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list DesignSpecificationZoneHVACSizingName\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_UnitVentilator);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:UnitVentilator",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_UnitVentilator);
  return object;
}

IddObject createOS_ZoneHVAC_Baseboard_RadiantConvective_WaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:Baseboard:RadiantConvective:Water,\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,  \\field Availability Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4,  \\field Heating Coil Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list RadiantBaseboardHeatingCoil\n";
    ss << "N1,  \\field Fraction Radiant\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "N2;  \\field Fraction of Radiant Energy Incident on People\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_Baseboard_RadiantConvective_Water);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:Baseboard:RadiantConvective:Water",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_Baseboard_RadiantConvective_Water);
  return object;
}

IddObject createOS_ZoneHVAC_Baseboard_RadiantConvective_ElectricIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneHVAC:Baseboard:RadiantConvective:Electric,\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A3 , \\field Availability Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Heating Design Capacity Method\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key HeatingDesignCapacity\n";
    ss << "\\key CapacityPerFloorArea\n";
    ss << "\\key FractionOfAutosizedHeatingCapacity\n";
    ss << "N1 , \\field Heating Design Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "N2 , \\field Heating Design Capacity Per Floor Area\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "N3 , \\field Fraction of Autosized Heating Design Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "N4 , \\field Efficiency\n";
    ss << "\\required-field\n";
    ss << "\\maximum 1.0\n";
    ss << "\\minimum> 0.0\n";
    ss << "N5,  \\field Fraction Radiant\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "N6;  \\field Fraction of Radiant Energy Incident on People\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";

    IddObjectType objType(IddObjectType::OS_ZoneHVAC_Baseboard_RadiantConvective_Electric);
    OptionalIddObject oObj = IddObject::load("OS:ZoneHVAC:Baseboard:RadiantConvective:Electric",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneHVAC_Baseboard_RadiantConvective_Electric);
  return object;
}

IddObject createOS_ZoneMixingIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ZoneMixing,\n";
    ss << "\\memo ZoneMixing is a simple air exchange from one zone to another. Note that this statement\n";
    ss << "\\memo only affects the energy balance of the \"receiving\" zone and will not produce\n";
    ss << "\\memo any effect on the \"source\" zone. Mixing statements can be complementary and include\n";
    ss << "\\memo multiple zones, but the balancing of flows between zones is left to the user's\n";
    ss << "\\memo discretion.\n";
    ss << "\\min-fields 18\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "A3 , \\field Zone Name\n";
    ss << "\\note This is the receiving zone\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A4 , \\field Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A5 , \\field Design Flow Rate Calculation Method\n";
    ss << "\\note The entered calculation method is used to create the maximum amount of ventilation\n";
    ss << "\\note for this set of attributes\n";
    ss << "\\note Choices: Flow/Zone => Design Flow Rate -- simply enter Design Flow Rate\n";
    ss << "\\note Flow/Area => Flow Rate per Zone Floor Area - Value * Floor Area (zone) = Design Flow Rate\n";
    ss << "\\note Flow/Person => Flow Rate per Person - Value * #people = Design Flow Rate\n";
    ss << "\\note AirChanges/Hour => Air Changes per Hour - Value * Floor Volume (zone) adjusted for m3/s = Design Volume Flow Rate\n";
    ss << "\\note  \"Vdesign\" in Equation is the result.\n";
    ss << "\\type choice\n";
    ss << "\\key Flow/Zone\n";
    ss << "\\key Flow/Area\n";
    ss << "\\key Flow/Person\n";
    ss << "\\key AirChanges/Hour\n";
    ss << "\\default Flow/Zone\n";
    ss << "N1 , \\field Design Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "N2 , \\field Flow Rate per Zone Floor Area\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units m3/s-m2\n";
    ss << "N3 , \\field Flow Rate per Person\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\units m3/s-person\n";
    ss << "N4 , \\field Air Changes per Hour\n";
    ss << "\\units 1/hr\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "A6 , \\field Source Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "N5 , \\field Delta Temperature\n";
    ss << "\\units deltaC\n";
    ss << "\\type real\n";
    ss << "\\note This field contains the constant temperature differential between source and\n";
    ss << "\\note receiving zones below which mixing is shutoff.\n";
    ss << "A7 , \\field Delta Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the temperature differential between source and receiving\n";
    ss << "\\note zones versus time below which mixing is shutoff.\n";
    ss << "A8 , \\field Minimum Zone Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the zone dry-bulb temperature versus time below which\n";
    ss << "\\note mixing is shutoff.\n";
    ss << "A9 , \\field Maximum Zone Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the zone dry-bulb temperature versus time above which\n";
    ss << "\\note mixing is shutoff.\n";
    ss << "A10 , \\field Minimum Source Zone Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the source zone dry-bulb temperature versus time below\n";
    ss << "\\note which mixing is shutoff.\n";
    ss << "A11, \\field Maximum Source Zone Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the source zone dry-bulb temperature versus time above\n";
    ss << "\\note which mixing is shutoff.\n";
    ss << "A12, \\field Minimum Outdoor Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the outdoor temperature versus time below which\n";
    ss << "\\note mixing is shutoff.\n";
    ss << "A13; \\field Maximum Outdoor Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note This schedule contains the outdoor temperature versus time above which\n";
    ss << "\\note mixing is shutoff.\n";

    IddObjectType objType(IddObjectType::OS_ZoneMixing);
    OptionalIddObject oObj = IddObject::load("OS:ZoneMixing",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ZoneMixing);
  return object;
}

IddObject createOS_WaterHeater_MixedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:WaterHeater:Mixed,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WaterHeaterNames\n";
    ss << "\\reference ConnectionObject\n";
    ss << "N1 , \\field Tank Volume\n";
    ss << "\\autosizable\n";
    ss << "\\type real\n";
    ss << "\\units m3\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "\\ip-units gal\n";
    ss << "A3 , \\field Setpoint Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N2 , \\field Deadband Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N3 , \\field Maximum Temperature Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "A4 , \\field Heater Control Type\n";
    ss << "\\type choice\n";
    ss << "\\key Cycle\n";
    ss << "\\key Modulate\n";
    ss << "\\default Cycle\n";
    ss << "N4 , \\field Heater Maximum Capacity\n";
    ss << "\\autosizable\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "N5 , \\field Heater Minimum Capacity\n";
    ss << "\\note Only used when Heater Control Type is set to Modulate\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "N6 , \\field Heater Ignition Minimum Flow Rate\n";
    ss << "\\note Not yet implemented\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "N7 , \\field Heater Ignition Delay\n";
    ss << "\\note Not yet implemented\n";
    ss << "\\type real\n";
    ss << "\\units s\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "A5 , \\field Heater Fuel Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key Steam\n";
    ss << "\\key DistrictHeating\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "N8 , \\field Heater Thermal Efficiency\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A6 , \\field Part Load Factor Curve Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "N9 , \\field Off Cycle Parasitic Fuel Consumption Rate\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "A7 , \\field Off Cycle Parasitic Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key Steam\n";
    ss << "\\key DistrictHeating\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "N10, \\field Off Cycle Parasitic Heat Fraction to Tank\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "N11, \\field On Cycle Parasitic Fuel Consumption Rate\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\default 0.0\n";
    ss << "A8 , \\field On Cycle Parasitic Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key Steam\n";
    ss << "\\key DistrictHeating\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "N12, \\field On Cycle Parasitic Heat Fraction to Tank\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.0\n";
    ss << "A9 , \\field Ambient Temperature Indicator\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Schedule\n";
    ss << "\\key ThermalZone\n";
    ss << "\\key Outdoors\n";
    ss << "A10 , \\field Ambient Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A11, \\field Ambient Temperature Thermal Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A12, \\field Ambient Temperature Outdoor Air Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\note required for Ambient Temperature Indicator=Outdoors\n";
    ss << "N13, \\field Off Cycle Loss Coefficient to Ambient Temperature\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "N14, \\field Off Cycle Loss Fraction to Thermal Zone\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "N15, \\field On Cycle Loss Coefficient to Ambient Temperature\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "N16, \\field On Cycle Loss Fraction to Thermal Zone\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "N17, \\field Peak Use Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Only used if Use Side Node connections are blank\n";
    ss << "A13, \\field Use Flow Rate Fraction Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Only used if Use Side Node connections are blank\n";
    ss << "A14, \\field Cold Water Supply Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Only used if Use Side Node connections are blank\n";
    ss << "\\note Defaults to water temperatures calculated by Site:WaterMainsTemperature object\n";
    ss << "A15, \\field Use Side Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A16, \\field Use Side Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N18, \\field Use Side Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A17, \\field Source Side Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A18, \\field Source Side Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N19, \\field Source Side Effectiveness\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "N20, \\field Use Side Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "N21, \\field Source Side Design Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\default autosize\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "N22; \\field Indirect Water Heating Recovery Time\n";
    ss << "\\type real\n";
    ss << "\\default 1.5\n";
    ss << "\\note Parameter for autosizing design flow rates for indirectly heated water tanks\n";
    ss << "\\note Time required to raise temperature of entire tank from 14.4C to 57.2C\n";
    ss << "\\units hr\n";
    ss << "\\minimum> 0.0\n";

    IddObjectType objType(IddObjectType::OS_WaterHeater_Mixed);
    OptionalIddObject oObj = IddObject::load("OS:WaterHeater:Mixed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_WaterHeater_Mixed);
  return object;
}

IddObject createOS_WaterHeater_HeatPumpIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:WaterHeater:HeatPump,\n";
    ss << "\\min-fields 25\n";
    ss << "\\memo This object models an air-source heat pump for water heating.\n";
    ss << "\\memo WaterHeater:HeatPump is a compound object that references other component objects -\n";
    ss << "\\memo Coil:WaterHeating:AirToWaterHeatPump, Fan:OnOff, WaterHeater:Mixed\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\note Unique name for this instance of a heat pump water heater.\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Schedule values of 0 denote the heat pump compressor is off and the parasitic electric\n";
    ss << "\\note energy is also off.\n";
    ss << "A4,  \\field Compressor Setpoint Temperature Schedule\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defines the cut-out temperature where the heat pump compressor turns off.\n";
    ss << "\\note The heat pump compressor setpoint temperature should always be greater\n";
    ss << "\\note than the water tank's heater (element or burner) setpoint temperature.\n";
    ss << "N1 , \\field Dead Band Temperature Difference\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 20\n";
    ss << "\\required-field\n";
    ss << "\\note Setpoint temperature minus the dead band temperature difference defines\n";
    ss << "\\note the cut-in temperature where the heat pump compressor turns on.\n";
    ss << "\\note The water tank's heater (element or burner) setpoint temperature\n";
    ss << "\\note should always be less than the heat pump compressor cut-in temperature.\n";
    ss << "N2 , \\field Condenser Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "\\note Actual water flow rate through the heat pump's water coil (condenser).\n";
    ss << "\\note If autocalculated, the water flow rate is set equal to 4.487E-8 m3/s/W times\n";
    ss << "\\note the rated heating capacity of the heat pump's DX coil.\n";
    ss << "N3 , \\field Evaporator Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "\\note Actual air flow rate across the heat pump's air coil (evaporator).\n";
    ss << "\\note If autocalculated, the air flow rate is set equal to 5.035E-5 m3/s/W times\n";
    ss << "\\note the rated heating capacity of the heat pump's DX coil.\n";
    ss << "A5 , \\field Inlet Air Configuration\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Schedule\n";
    ss << "\\key ZoneAirOnly\n";
    ss << "\\key OutdoorAirOnly\n";
    ss << "\\key ZoneAndOutdoorAir\n";
    ss << "\\note Defines the configuration of the airflow path through the air coil and fan section.\n";
    ss << "A6 , \\field Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note Zone air exhaust node name if Inlet Air Configuration is ZoneAirOnly or\n";
    ss << "\\note ZoneAndOutdoorAir.\n";
    ss << "\\note Simply a unique Node Name if Inlet Air Configuration is Schedule.\n";
    ss << "\\note Otherwise, leave field blank.\n";
    ss << "A7 , \\field Air Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note Zone Air Inlet Node Name if Inlet Air Configuration is ZoneAirOnly or\n";
    ss << "\\note ZoneAndOutdoorAir.\n";
    ss << "\\note Simply a unique Node Name if Inlet Air Configuration is Schedule.\n";
    ss << "\\note Otherwise, leave field blank.\n";
    ss << "A8 , \\field Outdoor Air Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "\\note Outdoor air node name if inlet air configuration is ZoneAndOutdoorAir\n";
    ss << "\\note or OutdoorAirOnly, otherwise leave field blank.\n";
    ss << "A9, \\field Inlet Air Temperature Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Used only if Inlet Air Configuration is Schedule, otherwise leave blank.\n";
    ss << "\\note Schedule values should be degrees C.\n";
    ss << "A10, \\field Inlet Air Humidity Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Used only if Inlet Air Configuration is Schedule, otherwise leave blank.\n";
    ss << "\\note Schedule values are entered as a fraction (e.g. 0.5 is equal to 50%RH)\n";
    ss << "A11, \\field Tank\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterHeaterNames\n";
    ss << "\\note Needs to match the name used in the corresponding Water Heater object.\n";
    ss << "A12, \\field DX Coil\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list HeatPumpWaterHeaterDXCoils\n";
    ss << "\\note Must match the name used in the corresponding Coil:WaterHeating:AirToWaterHeatPump object.\n";
    ss << "N4 , \\field Minimum Inlet Air Temperature for Compressor Operation\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "\\minimum -5\n";
    ss << "\\note Heat pump compressor will not operate when the inlet air dry-bulb temperature\n";
    ss << "\\note is below this value.\n";
    ss << "A13, \\field Compressor Location\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Schedule\n";
    ss << "\\key Zone\n";
    ss << "\\key Outdoors\n";
    ss << "\\note If Zone is selected, Inlet Air Configuration must be ZoneAirOnly or\n";
    ss << "\\note ZoneAndOutdoorAir. If Schedule is selected, then you must provide a\n";
    ss << "\\note Compressor Ambient Temperature Schedule Name below.\n";
    ss << "A14, \\field Compressor Ambient Temperature Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Used only if Compressor Location is Schedule, otherwise leave field blank.\n";
    ss << "A15, \\field Fan\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FansOnOff\n";
    ss << "\\note Needs to match the name used in the corresponding Fan:OnOff object.\n";
    ss << "A16, \\field Fan Placement\n";
    ss << "\\type choice\n";
    ss << "\\key BlowThrough\n";
    ss << "\\key DrawThrough\n";
    ss << "\\required-field\n";
    ss << "\\note BlowThrough means the fan is located before the air coil (upstream).\n";
    ss << "\\note DrawThrough means the fan is located after the air coil (downstream).\n";
    ss << "N5 , \\field On Cycle Parasitic Electric Load\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "\\note Parasitic electric power consumed when the heat pump compressor operates.\n";
    ss << "\\note Does not contribute to water heating but can impact the zone air heat balance.\n";
    ss << "N6 , \\field Off Cycle Parasitic Electric Load\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\required-field\n";
    ss << "\\note Parasitic electric power consumed when the heat pump compressor is off.\n";
    ss << "\\note Does not contribute to water heating but can impact the zone air heat balance.\n";
    ss << "\\note Off-cycle parasitic power is 0 when the availability schedule is 0.\n";
    ss << "A17, \\field Parasitic Heat Rejection Location\n";
    ss << "\\type choice\n";
    ss << "\\key Zone\n";
    ss << "\\key Outdoors\n";
    ss << "\\required-field\n";
    ss << "\\note This field determines if the parasitic electric load impacts the zone air\n";
    ss << "\\note heat balance. If Zone is selected, Inlet Air Configuration must be\n";
    ss << "\\note ZoneAirOnly or ZoneAndOutdoorAir.\n";
    ss << "A18, \\field Inlet Air Mixer Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\required-field\n";
    ss << "\\note Required only if Inlet Air Configuration is ZoneAndOutdoorAir, otherwise\n";
    ss << "\\note leave field blank. Schedule values define whether the heat pump draws its\n";
    ss << "\\note inlet air from the zone, outdoors or a combination of zone and outdoor air.\n";
    ss << "\\note A schedule value of 0 denotes inlet air is drawn only from the zone.\n";
    ss << "\\note A schedule value of 1 denotes inlet air is drawn only from outdoors.\n";
    ss << "\\note Schedule values between 0 and 1 denote a mixture of zone and outdoor air\n";
    ss << "\\note proportional to the schedule value.\n";
    ss << "A19; \\field Control Sensor Location In Stratified Tank\n";
    ss << "\\note Used to indicate height of control sensor if Tank Object Type is WaterHeater:Stratified\n";
    ss << "\\type choice\n";
    ss << "\\key Heater1\n";
    ss << "\\key Heater2\n";
    ss << "\\key SourceInlet\n";
    ss << "\\key SourceOutlet\n";
    ss << "\\key UseInlet\n";
    ss << "\\key UseOutlet\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_WaterHeater_HeatPump);
    OptionalIddObject oObj = IddObject::load("OS:WaterHeater:HeatPump",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_WaterHeater_HeatPump);
  return object;
}

IddObject createOS_Coil_WaterHeating_AirToWaterHeatPumpIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Coil:WaterHeating:AirToWaterHeatPump,\n";
    ss << "\\memo Heat pump water heater (HPWH) heating coil, air-to-water direct-expansion (DX)\n";
    ss << "\\memo system which includes a water heating coil, evaporator air coil, evaporator\n";
    ss << "\\memo fan, electric compressor, and water pump. Part of a WaterHeater:HeatPump system.\n";
    ss << "\\min-fields 29\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference HeatPumpWaterHeaterDXCoils\n";
    ss << "\\reference ConnectionObject\n";
    ss << "\\note Unique name for this instance of a heat pump water heater DX coil.\n";
    ss << "N1 , \\field Rated Heating Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0\n";
    ss << "\\note Heating capacity at the rated inlet air temperatures, rated condenser inlet\n";
    ss << "\\note water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump heat.\n";
    ss << "N2 , \\field Rated COP\n";
    ss << "\\type real\n";
    ss << "\\units W/W\n";
    ss << "\\minimum> 0\n";
    ss << "\\required-field\n";
    ss << "\\note Heating coefficient of performance at the rated inlet air temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Can optionally include condenser pump power and evaporator fan power (see fields below).\n";
    ss << "N3 , \\field Rated Sensible Heat Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.5\n";
    ss << "\\maximum 1\n";
    ss << "\\required-field\n";
    ss << "\\note Gross air-side sensible heat ratio at the rated inlet air temperatures,\n";
    ss << "\\note rated condenser inlet water temperature, rated air flow rate, and rated water flow rate.\n";
    ss << "\\note Sensible heat ratio equals gross sensible cooling capacity divided by gross total cooling\n";
    ss << "\\note capacity. Rated SHR (gross) should not include evaporator fan heat, only sensible cooling\n";
    ss << "\\note and dehumidification by the coil alone.\n";
    ss << "N4 , \\field Rated Evaporator Inlet Air Dry-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 5\n";
    ss << "\\required-field\n";
    ss << "\\note Evaporator inlet air dry-bulb temperature corresponding to rated coil performance\n";
    ss << "\\note (heating capacity, COP and SHR).\n";
    ss << "N5 , \\field Rated Evaporator Inlet Air Wet-Bulb Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 5\n";
    ss << "\\required-field\n";
    ss << "\\note Evaporator inlet air wet-bulb temperature corresponding to rated coil performance\n";
    ss << "\\note (heating capacity, COP and SHR).\n";
    ss << "N6 , \\field Rated Condenser Inlet Water Temperature\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 25\n";
    ss << "\\required-field\n";
    ss << "\\note Condenser inlet water temperature corresponding to rated coil performance\n";
    ss << "\\note (heating capacity, COP and SHR).\n";
    ss << "N7 , \\field Rated Evaporator Air Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\note Evaporator air flow rate corresponding to rated coil performance\n";
    ss << "\\note (heating capacity, COP and SHR).\n";
    ss << "\\note Default is 5.035E-5 m3/s/W (31.25 cfm/MBH) of rated heating capacity when autocalculated.\n";
    ss << "N8 , \\field Rated Condenser Water Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\note Condenser water flow rate corresponding to rated coil performance\n";
    ss << "\\note (heating capacity, COP and SHR).\n";
    ss << "\\note Default is 4.487E-8 m3/s/W (0.208 gpm/MBH) of rated heating capacity when autocalculated.\n";
    ss << "\\note A warning message will be issued if the ratio of Rated Condenser Water Flow Rate\n";
    ss << "\\note to Heating Capacity is less than 1.79405E-8 m3/s/W (0.083 gpm/MBH)\n";
    ss << "\\note or greater than 8.97024E-8 m3/s/W (0.417 gpm/MBH), but the simulation will continue.\n";
    ss << "A3 , \\field Evaporator Fan Power Included in Rated COP\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\required-field\n";
    ss << "\\note Select Yes if the evaporator fan power is included in the rated COP. This choice field\n";
    ss << "\\note impacts the calculation of compressor electric power.\n";
    ss << "A4 , \\field Condenser Pump Power Included in Rated COP\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\required-field\n";
    ss << "\\note Select Yes if the condenser pump power is included in the rated COP. This choice field\n";
    ss << "\\note impacts the calculation of compressor electric power.\n";
    ss << "A5 , \\field Condenser Pump Heat Included in Rated Heating Capacity and Rated COP\n";
    ss << "\\type choice\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "\\required-field\n";
    ss << "\\note Select Yes if the condenser pump heat is included in the rated heating capacity and\n";
    ss << "\\note rated COP. This choice field impacts the calculation of water heating capacity.\n";
    ss << "N9 , \\field Condenser Water Pump Power\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "\\note A warning message will be issued if the ratio of Condenser Water Pump Power to Rated\n";
    ss << "\\note Heating Capacity exceeds 0.1422 W/W (41.67 Watts/MBH), but the simulation will continue.\n";
    ss << "N10, \\field Fraction of Condenser Pump Heat to Water\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1\n";
    ss << "\\required-field\n";
    ss << "\\note Fraction of pump heat transferred to the condenser water. The pump is assumed\n";
    ss << "\\note to be located downstream of the condenser.\n";
    ss << "A6 , \\field Evaporator Air Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note The node from which the DX coil draws its inlet air.\n";
    ss << "A7 , \\field Evaporator Air Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note The node to which the DX coil sends its outlet air.\n";
    ss << "A8 , \\field Condenser Water Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note The node from which the DX coil condenser draws its inlet water.\n";
    ss << "\\note This name should match the source side outlet node name in the associated\n";
    ss << "\\note water heater tank object.\n";
    ss << "A9 , \\field Condenser Water Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "\\note The node to which the DX coil condenser sends its outlet water.\n";
    ss << "\\note This name should match the source side inlet node name in the associated\n";
    ss << "\\note water heater tank object.\n";
    ss << "N11, \\field Crankcase Heater Capacity\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "\\units W\n";
    ss << "\\note The compressor crankcase heater only operates when the dry-bulb temperature of air\n";
    ss << "\\note surrounding the compressor is below the Maximum Ambient Temperature for Crankcase\n";
    ss << "\\note Heater Operation and the DX coil is off.  The ambient temperature surrounding the\n";
    ss << "\\note compressor is set by the WaterHeater:HeatPump parent object (field Compressor Location).\n";
    ss << "N12, \\field Maximum Ambient Temperature for Crankcase Heater Operation\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\required-field\n";
    ss << "\\units C\n";
    ss << "\\note The compressor crankcase heater only operates when the dry-bulb temperature of air\n";
    ss << "\\note surrounding the compressor is below the Maximum Outdoor Temperature for Crankcase\n";
    ss << "\\note Heater Operation and the unit is off. The ambient temperature surrounding the\n";
    ss << "\\note compressor is set by the WaterHeater:HeatPump parent object (field Compressor Location).\n";
    ss << "A10 , \\field Evaporator Air Temperature Type for Curve Objects\n";
    ss << "\\type choice\n";
    ss << "\\key DryBulbTemperature\n";
    ss << "\\key WetBulbTemperature\n";
    ss << "\\required-field\n";
    ss << "\\note Determines temperature type for heating capacity curves and\n";
    ss << "\\note heating COP curves. This input determines whether\n";
    ss << "\\note the inlet air dry-bulb or wet-bulb temperature is used to evaluate these curves.\n";
    ss << "A11, \\field Heating Capacity Function of Temperature Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCubicCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\required-field\n";
    ss << "\\note Heating capacity modifier curve (function of temperature) should be biquadratic or cubic.\n";
    ss << "\\note Biquadratic curve = a + b(ta) + c(ta)^2 + d(tw) + e(tw)^2 + f(ta)(tw).\n";
    ss << "\\note Cubic curve = a + b(ta) + c(ta)^2 + d(ta)^3.\n";
    ss << "\\note ta = evaporator inlet air [dry-bulb or wet-bulb] temperature (C).\n";
    ss << "\\note tw = condenser inlet water temperature (C).\n";
    ss << "\\note The field Evaporator Air Temperature Type for Curve Objects determines if dry-bulb or wet-bulb\n";
    ss << "\\note is used as the evaporator inlet air temperature (ta).\n";
    ss << "A12, \\field Heating Capacity Function of Air Flow Fraction Curve\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Heating capacity modifier curve (function of air flow fraction) should be quadratic or cubic.\n";
    ss << "\\note Quadratic curve = a + b(ff) + c(ff)^2.\n";
    ss << "\\note Cubic curve = a + b(ff) + c(ff)^2 + d(ff)^3.\n";
    ss << "\\note ff = fraction of the rated evaporator air flow rate.\n";
    ss << "\\note Use curve coefficients of 1,0,0 or leave this field blank when neglecting performance impacts\n";
    ss << "\\note due to variations in air flow rate fraction.\n";
    ss << "A13, \\field Heating Capacity Function of Water Flow Fraction Curve\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Heating capacity modifier curve (function of water flow fraction) should be quadratic or cubic.\n";
    ss << "\\note Quadratic curve = a + b(ff) + c(ff)^2.\n";
    ss << "\\note Cubic curve = a + b(ff) + c(ff)^2 + d(ff)^3.\n";
    ss << "\\note ff = fraction of the rated condenser water flow rate.\n";
    ss << "\\note Use curve coefficients of 1,0,0 or leave this field blank when neglecting performance impacts\n";
    ss << "\\note due to variations in water flow rate fraction.\n";
    ss << "A14, \\field Heating COP Function of Temperature Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list BiquadraticCubicCurves\n";
    ss << "\\object-list BiVariateTables\n";
    ss << "\\required-field\n";
    ss << "\\note Heating COP modifier curve (function of temperature) should be biquadratic or cubic.\n";
    ss << "\\note Biquadratic curve = a + b(ta) + c(ta)^2 + d(tw) + e(tw)^2 + f(ta)(tw).\n";
    ss << "\\note Cubic curve = a + b(ta) + c(ta)^2 + d(ta)^3.\n";
    ss << "\\note ta = evaporator inlet air [dry-bulb or wet-bulb] temperature (C).\n";
    ss << "\\note tw = condenser inlet water temperature (C).\n";
    ss << "\\note The field Evaporator Air Temperature Type for Curve Objects determines if dry-bulb or wet-bulb\n";
    ss << "\\note is used as the evaporator inlet air temperature (ta).\n";
    ss << "A15, \\field Heating COP Function of Air Flow Fraction Curve\n";
    ss << "\\type object-list\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\required-field\n";
    ss << "\\note Heating COP modifier curve (function of air flow fraction) should be quadratic or cubic.\n";
    ss << "\\note Quadratic curve = a + b(ff) + c(ff)^2.\n";
    ss << "\\note Cubic curve = a + b(ff) + c(ff)^2 + d(ff)^3.\n";
    ss << "\\note ff = fraction of the rated evaporator air flow rate.\n";
    ss << "\\note Use curve coefficients of 1,0,0 or leave this field blank when neglecting performance impacts\n";
    ss << "\\note due to variations in air flow rate fraction.\n";
    ss << "A16, \\field Heating COP Function of Water Flow Fraction Curve\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Heating COP modifier curve (function of water flow fraction) should be quadratic or cubic.\n";
    ss << "\\note Quadratic curve = a + b(ff) + c(ff)^2.\n";
    ss << "\\note Cubic curve = a + b(ff) + c(ff)^2 + d(ff)^3.\n";
    ss << "\\note ff = fraction of the rated condenser water flow rate.\n";
    ss << "\\note Use curve coefficients of 1,0,0 or leave this field blank when neglecting performance impacts\n";
    ss << "\\note due to variations in water flow rate fraction.\n";
    ss << "A17; \\field Part Load Fraction Correlation Curve\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticCubicCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "\\note Part Load Fraction Correlation (function of part load ratio) should be quadratic or cubic.\n";
    ss << "\\note Quadratic curve = a + b(PLR) + c(PLR)^2.\n";
    ss << "\\note Cubic curve = a + b(PLR) + c(PLR)^2 + d(PLR)^3.\n";
    ss << "\\note PLR = part load ratio (heating delivered/steady state heating capacity).\n";
    ss << "\\note Use curve coefficients of 1,0,0 or leave this field blank when neglecting performance impacts\n";
    ss << "\\note due to variations in part load ratio.\n";

    IddObjectType objType(IddObjectType::OS_Coil_WaterHeating_AirToWaterHeatPump);
    OptionalIddObject oObj = IddObject::load("OS:Coil:WaterHeating:AirToWaterHeatPump",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Coil_WaterHeating_AirToWaterHeatPump);
  return object;
}

IddObject createOS_WaterHeater_StratifiedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:WaterHeater:Stratified,\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WaterHeaterNames\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,  \\field End-Use Subcategory\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "N1,  \\field Tank Volume\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units gal\n";
    ss << "N2,  \\field Tank Height\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Height is measured in the axial direction for horizontal cylinders\n";
    ss << "A4,  \\field Tank Shape\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key VerticalCylinder\n";
    ss << "\\key HorizontalCylinder\n";
    ss << "\\key Other\n";
    ss << "N3,  \\field Tank Perimeter\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Only used if Tank Shape is Other\n";
    ss << "N4,  \\field Maximum Temperature Limit\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "A5,  \\field Heater Priority Control\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key MasterSlave\n";
    ss << "\\key Simultaneous\n";
    ss << "A6,  \\field Heater 1 Setpoint Temperature Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N5,  \\field Heater 1 Deadband Temperature Difference\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "N6,  \\field Heater 1 Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autosizable\n";
    ss << "N7,  \\field Heater 1 Height\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "A7,  \\field Heater 2 Setpoint Temperature Schedule Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N8,  \\field Heater 2 Deadband Temperature Difference\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "N9,  \\field Heater 2 Capacity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "N10, \\field Heater 2 Height\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "A8,  \\field Heater Fuel Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\key Steam\n";
    ss << "\\key DistrictHeating\n";
    ss << "N11, \\field Heater Thermal Efficiency\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N12, \\field Off Cycle Parasitic Fuel Consumption Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "A9,  \\field Off Cycle Parasitic Fuel Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\key Steam\n";
    ss << "\\key DistrictHeating\n";
    ss << "N13, \\field Off Cycle Parasitic Heat Fraction to Tank\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N14, \\field Off Cycle Parasitic Height\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "N15, \\field On Cycle Parasitic Fuel Consumption Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum 0.0\n";
    ss << "A10, \\field On Cycle Parasitic Fuel Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key PropaneGas\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Coal\n";
    ss << "\\key Diesel\n";
    ss << "\\key Gasoline\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "\\key Steam\n";
    ss << "\\key DistrictHeating\n";
    ss << "N16, \\field On Cycle Parasitic Heat Fraction to Tank\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N17, \\field On Cycle Parasitic Height\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "A11, \\field Ambient Temperature Indicator\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Schedule\n";
    ss << "\\key ThermalZone\n";
    ss << "\\key Outdoors\n";
    ss << "A12, \\field Ambient Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A13, \\field Ambient Temperature Thermal Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A14, \\field Ambient Temperature Outdoor Air Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\note required for Ambient Temperature Indicator=Outdoors\n";
    ss << "N18, \\field Uniform Skin Loss Coefficient per Unit Area to Ambient Temperature\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum 0.0\n";
    ss << "N19, \\field Skin Loss Fraction to Zone\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N20, \\field Off Cycle Flue Loss Coefficient to Ambient Temperature\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "N21, \\field Off Cycle Flue Loss Fraction to Zone\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N22, \\field Peak Use Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Only used if Use Side Node connections are blank\n";
    ss << "A15, \\field Use Flow Rate Fraction Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note If blank, defaults to 1.0 at all times\n";
    ss << "\\note Only used if use side node connections are blank\n";
    ss << "A16, \\field Cold Water Supply Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Only used if use side node connections are blank\n";
    ss << "\\note Defaults to water temperatures calculated by Site:WaterMainsTemperature object\n";
    ss << "A17, \\field Use Side Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A18, \\field Use Side Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N23, \\field Use Side Effectiveness\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note The use side effectiveness in the stratified tank model is a simplified analogy of\n";
    ss << "\\note a heat exchanger's effectiveness. This effectiveness is equal to the fraction of\n";
    ss << "\\note use mass flow rate that directly mixes with the tank fluid. And one minus the\n";
    ss << "\\note effectiveness is the fraction that bypasses the tank. The use side mass flow rate\n";
    ss << "\\note that bypasses the tank is mixed with the fluid or water leaving the stratified tank.\n";
    ss << "N24, \\field Use Side Inlet Height\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Defaults to bottom of tank\n";
    ss << "N25, \\field Use Side Outlet Height\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Defaults to top of tank\n";
    ss << "A19, \\field Source Side Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A20, \\field Source Side Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N26, \\field Source Side Effectiveness\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\note The source side effectiveness in the stratified tank model is a simplified analogy of\n";
    ss << "\\note a heat exchanger's effectiveness. This effectiveness is equal to the fraction of\n";
    ss << "\\note source mass flow rate that directly mixes with the tank fluid. And one minus the\n";
    ss << "\\note effectiveness is the fraction that bypasses the tank. The source side mass flow rate\n";
    ss << "\\note that bypasses the tank is mixed with the fluid or water leaving the stratified tank.\n";
    ss << "N27, \\field Source Side Inlet Height\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Defaults to top of tank\n";
    ss << "N28, \\field Source Side Outlet Height\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Defaults to bottom of tank\n";
    ss << "A21, \\field Inlet Mode\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fixed\n";
    ss << "\\key Seeking\n";
    ss << "N29, \\field Use Side Design Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "N30, \\field Source Side Design Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "N31, \\field Indirect Water Heating Recovery Time\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note Parameter for autosizing design flow rates for indirectly heated water tanks\n";
    ss << "\\note time required to raise temperature of entire tank from 14.4C to 57.2C\n";
    ss << "\\units hr\n";
    ss << "\\minimum> 0.0\n";
    ss << "N32, \\field Number of Nodes\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 10\n";
    ss << "N33, \\field Additional Destratification Conductivity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum 0.0\n";
    ss << "N34, \\field Node 1 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "N35, \\field Node 2 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "N36, \\field Node 3 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "N37, \\field Node 4 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "N38, \\field Node 5 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "N39, \\field Node 6 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "N40, \\field Node 7 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "N41, \\field Node 8 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "N42, \\field Node 9 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "N43, \\field Node 10 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "A22, \\field Source Side Flow Control Mode\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key StorageTank\n";
    ss << "\\key IndirectHeatPrimarySetpoint\n";
    ss << "\\key IndirectHeatAlternateSetpoint\n";
    ss << "\\note StorageTank mode always requests flow unless tank is at its Maximum Temperature Limit\n";
    ss << "\\note IndirectHeatPrimarySetpoint mode requests flow whenever primary setpoint for heater 1 calls for heat\n";
    ss << "\\note IndirectHeatAlternateSetpoint mode requests flow whenever alternate indirect setpoint calls for heat\n";
    ss << "A23; \\field Indirect Alternate Setpoint Temperature Schedule Name\n";
    ss << "\\note This field is only used if the previous is set to IndirectHeatAlternateSetpoint\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_WaterHeater_Stratified);
    OptionalIddObject oObj = IddObject::load("OS:WaterHeater:Stratified",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_WaterHeater_Stratified);
  return object;
}

IddObject createOS_WaterUse_EquipmentIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:WaterUse:Equipment,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference WaterUseEquipmentNames\n";
    ss << "A3, \\field Water Use Equipment Definition Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list WaterUseEquipmentDefinitionNames\n";
    ss << "A4, \\field Space Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list SpaceNames\n";
    ss << "A5; \\field Flow Rate Fraction Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defaults to 1.0 at all times\n";

    IddObjectType objType(IddObjectType::OS_WaterUse_Equipment);
    OptionalIddObject oObj = IddObject::load("OS:WaterUse:Equipment",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_WaterUse_Equipment);
  return object;
}

IddObject createOS_WaterUse_Equipment_DefinitionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:WaterUse:Equipment:Definition,\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference WaterUseEquipmentDefinitionNames\n";
    ss << "A3 , \\field End-Use Subcategory\n";
    ss << "\\type alpha\n";
    ss << "\\retaincase\n";
    ss << "\\default General\n";
    ss << "N1 , \\field Peak Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "A4 , \\field Target Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defaults to hot water supply temperature\n";
    ss << "A5 , \\field Sensible Fraction Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defaults to 0.0 at all times\n";
    ss << "A6 ; \\field Latent Fraction Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defaults to 0.0 at all times\n";

    IddObjectType objType(IddObjectType::OS_WaterUse_Equipment_Definition);
    OptionalIddObject oObj = IddObject::load("OS:WaterUse:Equipment:Definition",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_WaterUse_Equipment_Definition);
  return object;
}

IddObject createOS_WaterUse_ConnectionsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:WaterUse:Connections,\n";
    ss << "\\extensible:1 - repeat last field\n";
    ss << "\\min-fields 12\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4 , \\field Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5 , \\field Supply Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "\\note If blank, or tank is empty, defaults to fresh water from the mains\n";
    ss << "A6 , \\field Reclamation Water Storage Tank Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterStorageTankNames\n";
    ss << "A7 , \\field Hot Water Supply Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defaults to cold water supply temperature\n";
    ss << "A8 , \\field Cold Water Supply Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "\\note Defaults to water temperatures calculated by Site:WaterMainsTemperature object\n";
    ss << "A9 , \\field Drain Water Heat Exchanger Type\n";
    ss << "\\type choice\n";
    ss << "\\key None\n";
    ss << "\\key Ideal\n";
    ss << "\\key CounterFlow\n";
    ss << "\\key CrossFlow\n";
    ss << "\\default None\n";
    ss << "A10 , \\field Drain Water Heat Exchanger Destination\n";
    ss << "\\type choice\n";
    ss << "\\key Plant\n";
    ss << "\\key Equipment\n";
    ss << "\\key PlantAndEquipment\n";
    ss << "\\default Plant\n";
    ss << "N11 , \\field Drain Water Heat Exchanger U-Factor Times Area\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum 0.0\n";
    ss << "A12; \\field Water Use Equipment 1 Name\n";
    ss << "\\begin-extensible\n";
    ss << "\\note Enter the name of a WaterUse:Equipment object.\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list WaterUseEquipmentNames\n";

    IddObjectType objType(IddObjectType::OS_WaterUse_Connections);
    OptionalIddObject oObj = IddObject::load("OS:WaterUse:Connections",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_WaterUse_Connections);
  return object;
}

IddObject createOS_ThermalStorage_Ice_DetailedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ThermalStorage:Ice:Detailed,\n";
    ss << "\\memo This input syntax is intended to describe a thermal storage system that\n";
    ss << "\\memo includes smaller containers filled with water that are placed in a larger\n";
    ss << "\\memo tank or series of tanks.\n";
    ss << "\\memo The model uses polynomial equations to describe the system performance.\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Availability Schedule\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1 , \\field Capacity\n";
    ss << "\\note This includes only the latent storage capacity\n";
    ss << "\\units GJ\n";
    ss << "\\required-field\n";
    ss << "A4 , \\field Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5 , \\field Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6 , \\field Discharging Curve\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticLinearCurves\n";
    ss << "\\object-list CubicLinearCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "A7 , \\field Charging Curve\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list QuadraticLinearCurves\n";
    ss << "\\object-list CubicLinearCurves\n";
    ss << "\\object-list UniVariateTables\n";
    ss << "N2 , \\field Timestep of the Curve Data\n";
    ss << "\\units hr\n";
    ss << "\\required-field\n";
    ss << "N3 , \\field Parasitic Electric Load During Discharging\n";
    ss << "\\units dimensionless\n";
    ss << "\\required-field\n";
    ss << "N4 , \\field Parasitic Electric Load During Charging\n";
    ss << "\\units dimensionless\n";
    ss << "\\required-field\n";
    ss << "N5 , \\field Tank Loss Coefficient\n";
    ss << "\\note This is the fraction the total storage capacity that is lost or melts\n";
    ss << "\\note each hour\n";
    ss << "\\units dimensionless\n";
    ss << "\\required-field\n";
    ss << "N6 , \\field Freezing Temperature of Storage Medium\n";
    ss << "\\note This temperature is typically 0C for water.\n";
    ss << "\\note Simply changing this temperature without adjusting the performance\n";
    ss << "\\note parameters input above is inappropriate and not advised.\n";
    ss << "\\units C\n";
    ss << "\\required-field\n";
    ss << "A8 ; \\field Thaw Process Indicator\n";
    ss << "\\note This field determines whether the system uses internal or external melt\n";
    ss << "\\note during discharging.  This will then have an impact on charging performance.\n";
    ss << "\\type choice\n";
    ss << "\\key InsideMelt\n";
    ss << "\\key OutsideMelt\n";
    ss << "\\required-field\n";

    IddObjectType objType(IddObjectType::OS_ThermalStorage_Ice_Detailed);
    OptionalIddObject oObj = IddObject::load("OS:ThermalStorage:Ice:Detailed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ThermalStorage_Ice_Detailed);
  return object;
}

IddObject createOS_ThermalStorage_ChilledWater_StratifiedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ThermalStorage:ChilledWater:Stratified,\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "N1 , \\field Tank Volume\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units gal\n";
    ss << "N2 , \\field Tank Height\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\note Height is measured in the axial direction for horizontal cylinders\n";
    ss << "A3 , \\field Tank Shape\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key VerticalCylinder\n";
    ss << "\\key HorizontalCylinder\n";
    ss << "\\key Other\n";
    ss << "N3 , \\field Tank Perimeter\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Only used if Tank Shape is Other\n";
    ss << "A4 , \\field Setpoint Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N4 , \\field Deadband Temperature Difference\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\minimum 0.0\n";
    ss << "N5,  \\field Temperature Sensor Height\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "N6 , \\field Minimum Temperature Limit\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "N7 , \\field Nominal Cooling Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "A5 , \\field Ambient Temperature Indicator\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Schedule\n";
    ss << "\\key Zone\n";
    ss << "\\key Outdoors\n";
    ss << "A6 , \\field Ambient Temperature Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A7 , \\field Ambient Temperature Thermal Zone Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A8 , \\field Ambient Temperature Outdoor Air Node Name\n";
    ss << "\\type alpha\n";
    ss << "\\note required for Ambient Temperature Indicator=Outdoors\n";
    ss << "N8, \\field Uniform Skin Loss Coefficient per Unit Area to Ambient Temperature\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum 0.0\n";
    ss << "A9 , \\field Use Side Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A10, \\field Use Side Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N9 , \\field Use Side Heat Transfer Effectiveness\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A11, \\field Use Side Availability Schedule Name\n";
    ss << "\\note Availability schedule name for use side. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N10, \\field Use Side Inlet Height\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Defaults to top of tank\n";
    ss << "N11, \\field Use Side Outlet Height\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Defaults to bottom of tank\n";
    ss << "N12, \\field Use Side Design Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "A12, \\field Source Side Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A13, \\field Source Side Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N13, \\field Source Side Heat Transfer Effectiveness\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A14, \\field Source Side Availability Schedule Name\n";
    ss << "\\note Availability schedule name for use side. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N14, \\field Source Side Inlet Height\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\note Defaults to bottom of tank\n";
    ss << "N15, \\field Source Side Outlet Height\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum 0.0\n";
    ss << "\\autocalculatable\n";
    ss << "\\note Defaults to top of tank\n";
    ss << "N16, \\field Source Side Design Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\autosizable\n";
    ss << "\\units m3/s\n";
    ss << "\\ip-units gal/min\n";
    ss << "\\minimum 0.0\n";
    ss << "N17, \\field Tank Recovery Time\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note Parameter for autosizing design flow rates for indirectly cooled water tanks\n";
    ss << "\\note time required to lower temperature of entire tank from 14.4C to 9.0C\n";
    ss << "\\units hr\n";
    ss << "\\minimum> 0.0\n";
    ss << "A15, \\field Inlet Mode\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Fixed\n";
    ss << "\\key Seeking\n";
    ss << "N18, \\field Number of Nodes\n";
    ss << "\\required-field\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 10\n";
    ss << "N19, \\field Additional Destratification Conductivity\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m-K\n";
    ss << "\\minimum 0.0\n";
    ss << "N20, \\field Node 1 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "N21, \\field Node 2 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "N22, \\field Node 3 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "N23, \\field Node 4 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "N24, \\field Node 5 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "N25, \\field Node 6 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "N26, \\field Node 7 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "N27, \\field Node 8 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "N28, \\field Node 9 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "N29; \\field Node 10 Additional Loss Coefficient\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";

    IddObjectType objType(IddObjectType::OS_ThermalStorage_ChilledWater_Stratified);
    OptionalIddObject oObj = IddObject::load("OS:ThermalStorage:ChilledWater:Stratified",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ThermalStorage_ChilledWater_Stratified);
  return object;
}

IddObject createOS_DuctIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Duct,\n";
    ss << "\\memo Passes inlet node state variables to outlet node state variables\n";
    ss << "\\min-fields 4\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,  \\field Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4;  \\field Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";

    IddObjectType objType(IddObjectType::OS_Duct);
    OptionalIddObject oObj = IddObject::load("OS:Duct",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Duct);
  return object;
}

IddObject createOS_FluidCooler_SingleSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:FluidCooler:SingleSpeed,\n";
    ss << "\\memo The fluid cooler is modeled as a cross flow heat exchanger (both streams unmixed) with\n";
    ss << "\\memo single-speed fans (induced draft configuration).\n";
    ss << "\\min-fields 14\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "\\type alpha\n";
    ss << "\\note fluid cooler name\n";
    ss << "A3,  \\field Water Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4,  \\field Water Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5,  \\field Performance Input Method\n";
    ss << "\\type choice\n";
    ss << "\\key UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\key NominalCapacity\n";
    ss << "\\required-field\n";
    ss << "\\note User can define fluid cooler thermal performance by specifying the fluid cooler UA\n";
    ss << "\\note and the Design Water Flow Rate, or by specifying the fluid cooler nominal capacity\n";
    ss << "N1,  \\field Design Air Flow Rate U-factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 2100000.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\note Leave field blank if fluid cooler Performance Input Method is NominalCapacity\n";
    ss << "N2,  \\field Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\required-field\n";
    ss << "\\note Nominal fluid cooler capacity\n";
    ss << "N3,  \\field Design Entering Water Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Design Entering Water Temperature must be specified for both the performance input methods and\n";
    ss << "\\note its value must be greater than Design Entering Air Temperature.\n";
    ss << "N4,  \\field Design Entering Air Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Design Entering Air Temperature must be specified for both the performance input methods and\n";
    ss << "\\note its value must be greater than Design Entering Air Wet-bulb Temperature.\n";
    ss << "N5,  \\field Design Entering Air Wetbulb Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Design Entering Air Wet-bulb Temperature must be specified for both the performance input methods and\n";
    ss << "\\note its value must be less than Design Entering Air Temperature.\n";
    ss << "N6,  \\field Design Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N7,  \\field Design Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "N8,  \\field Design Air Flow Rate Fan Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\note This is the fan motor electric input power\n";
    ss << "A6 ; \\field Outdoor Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "\\note Enter the name of an outdoor air node\n";

    IddObjectType objType(IddObjectType::OS_FluidCooler_SingleSpeed);
    OptionalIddObject oObj = IddObject::load("OS:FluidCooler:SingleSpeed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_FluidCooler_SingleSpeed);
  return object;
}

IddObject createOS_FluidCooler_TwoSpeedIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:FluidCooler:TwoSpeed,\n";
    ss << "\\min-fields 22\n";
    ss << "\\memo The fluid cooler is modeled as a cross flow heat exchanger (both streams unmixed) with\n";
    ss << "\\memo two-speed fans (induced draft configuration).\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "\\type alpha\n";
    ss << "\\note fluid cooler name\n";
    ss << "A3,  \\field Water Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A4,  \\field Water Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5,  \\field Performance Input Method\n";
    ss << "\\type choice\n";
    ss << "\\key UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "\\key NominalCapacity\n";
    ss << "\\required-field\n";
    ss << "\\note User can define fluid cooler thermal performance by specifying the fluid cooler UA\n";
    ss << "\\note and the Design Water Flow Rate, or by specifying the fluid cooler nominal capacity\n";
    ss << "N1,  \\field High Fan Speed U-factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 2100000.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\note Leave field blank if fluid cooler Performance Input Method is NominalCapacity\n";
    ss << "N2,  \\field Low Fan Speed U-factor Times Area Value\n";
    ss << "\\type real\n";
    ss << "\\units W/K\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 300000.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\note Leave field blank if fluid cooler Performance Input Method is NominalCapacity\n";
    ss << "\\note Low speed fluid cooler UA must be less than high speed fluid cooler UA\n";
    ss << "\\note Low speed fluid cooler UA must be greater than free convection fluid cooler UA\n";
    ss << "N3,  \\field Low Fan Speed U-Factor Times Area Sizing Factor\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\note This field is only used if the previous field is set to autosize and\n";
    ss << "\\note the Performance Input Method is UFactorTimesAreaAndDesignWaterFlowRate\n";
    ss << "N4,  \\field High Speed Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\required-field\n";
    ss << "\\note Nominal fluid cooler capacity at high fan speed\n";
    ss << "N5,  \\field Low Speed Nominal Capacity\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\required-field\n";
    ss << "\\note Nominal fluid cooler capacity at low fan speed\n";
    ss << "N6,  \\field Low Speed Nominal Capacity Sizing Factor\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "\\note This field is only used if the previous field is set to autosize and\n";
    ss << "\\note the Performance Input Method is NominalCapacity\n";
    ss << "N7,  \\field Design Entering Water Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Design Entering Water Temperature must be specified for both the performance input methods and\n";
    ss << "\\note its value must be greater than Design Entering Air Temperature.\n";
    ss << "N8,  \\field Design Entering Air Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Design Entering Air Temperature must be specified for both the performance input methods and\n";
    ss << "\\note its value must be greater than Design Entering Air Wet-bulb Temperature.\n";
    ss << "N9,  \\field Design Entering Air Wet-bulb Temperature\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\ip-units F\n";
    ss << "\\note Design Entering Air Wet-bulb Temperature must be specified for both the performance input methods and\n";
    ss << "\\note its value must be less than Design Entering Air Temperature.\n";
    ss << "N10, \\field Design Water Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units gal/min\n";
    ss << "N11, \\field High Fan Speed Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Air Flow Rate at High Fan Speed must be greater than Air Flow Rate at Low Fan Speed\n";
    ss << "N12, \\field High Fan Speed Fan Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\note This is the fan motor electric input power at high speed\n";
    ss << "N13, \\field Low Fan Speed Air Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m3/s\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\note Air Flow Rate at Low Fan Speed must be less than Air Flow Rate at High Fan Speed\n";
    ss << "N14, \\field Low Fan Speed Air Flow Rate Sizing Factor\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note This field is only used if the previous field is set to autosize.\n";
    ss << "N15, \\field Low Fan Speed Fan Power\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\autosizable\n";
    ss << "\\ip-units W\n";
    ss << "\\note This is the fan motor electric input power at low speed\n";
    ss << "N16, \\field Low Fan Speed Fan Power Sizing Factor\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\note This field is only used if the previous field is set to autosize.\n";
    ss << "A6;  \\field Outdoor Air Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";

    IddObjectType objType(IddObjectType::OS_FluidCooler_TwoSpeed);
    OptionalIddObject oObj = IddObject::load("OS:FluidCooler:TwoSpeed",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_FluidCooler_TwoSpeed);
  return object;
}

IddObject createOS_Pipe_IndoorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Pipe:Indoor,\n";
    ss << "\\memo Pipe model with transport delay and heat transfer to the environment.\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,  \\field Construction\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A4,  \\field Fluid Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5,  \\field Fluid Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6,  \\field Environment Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Zone\n";
    ss << "\\key Schedule\n";
    ss << "A7,  \\field Ambient Temperature Zone\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "A8,  \\field Ambient Temperature Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A9,  \\field Ambient Air Velocity Schedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N1,  \\field Pipe Inside Diameter\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units in\n";
    ss << "N2;  \\field Pipe Length\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";

    IddObjectType objType(IddObjectType::OS_Pipe_Indoor);
    OptionalIddObject oObj = IddObject::load("OS:Pipe:Indoor",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Pipe_Indoor);
  return object;
}

IddObject createOS_Pipe_OutdoorIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Pipe:Outdoor,\n";
    ss << "\\memo Pipe model with transport delay and heat transfer to the environment.\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3,  \\field Construction\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConstructionNames\n";
    ss << "A4,  \\field Fluid Inlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A5,  \\field Fluid Outlet Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6,  \\field Ambient Temperature Outdoor Air Node\n";
    ss << "\\type object-list\n";
    ss << "\\object-list Node\n";
    ss << "N1,  \\field Pipe Inside Diameter\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0\n";
    ss << "\\ip-units in\n";
    ss << "N2;  \\field Pipe Length\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units m\n";
    ss << "\\minimum> 0.0\n";

    IddObjectType objType(IddObjectType::OS_Pipe_Outdoor);
    OptionalIddObject oObj = IddObject::load("OS:Pipe:Outdoor",
                                             "OpenStudio HVAC",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Pipe_Outdoor);
  return object;
}

IddObject createOS_SolarCollectorPerformance_FlatPlateIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SolarCollectorPerformance:FlatPlate,\n";
    ss << "\\memo Thermal and optical performance parameters for a single flat plate solar collector\n";
    ss << "\\memo module. These parameters are based on the testing methodologies described in ASHRAE\n";
    ss << "\\memo Standards 93 and 96 which are used Solar Rating and Certification Corporation (SRCC)\n";
    ss << "\\memo Directory of SRCC Certified Solar Collector Ratings. See EnergyPlus DataSets file\n";
    ss << "\\memo SolarCollectors.idf.\n";
    ss << "\\min-fields 11\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference FlatPlateSolarCollectorParameters\n";
    ss << "N1 , \\field Gross Area\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\units m2\n";
    ss << "A3,  \\field Test Fluid\n";
    ss << "\\type choice\n";
    ss << "\\key Water\n";
    ss << "\\default Water\n";
    ss << "N2,  \\field Test Flow Rate\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\units m3/s\n";
    ss << "A4 , \\field Test Correlation Type\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key Inlet\n";
    ss << "\\key Average\n";
    ss << "\\key Outlet\n";
    ss << "N3 , \\field Coefficient 1 of Efficiency Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Y-intercept term\n";
    ss << "N4 , \\field Coefficient 2 of Efficiency Equation\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\note 1st Order term\n";
    ss << "N5 , \\field Coefficient 3 of Efficiency Equation\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K2\n";
    ss << "\\note 2nd order term\n";
    ss << "N6 , \\field Coefficient 2 of Incident Angle Modifier\n";
    ss << "\\type real\n";
    ss << "\\note 1st order term\n";
    ss << "N7 ; \\field Coefficient 3 of Incident Angle Modifier\n";
    ss << "\\type real\n";
    ss << "\\note 2nd order term\n";

    IddObjectType objType(IddObjectType::OS_SolarCollectorPerformance_FlatPlate);
    OptionalIddObject oObj = IddObject::load("OS:SolarCollectorPerformance:FlatPlate",
                                             "Solar Collectors",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SolarCollectorPerformance_FlatPlate);
  return object;
}

IddObject createOS_SolarCollector_FlatPlate_WaterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SolarCollector:FlatPlate:Water,\n";
    ss << "\\memo Flat plate water solar collector (single glazed, unglazed, or evacuated tube).\n";
    ss << "\\memo Thermal and optical properties are taken from the referenced\n";
    ss << "\\memo SolarCollectorPerformance:FlatPlate object. Collector tilt, azimuth, and gross area\n";
    ss << "\\memo are taken from the referenced building surface or shading surface. The collector\n";
    ss << "\\memo surface participates normally in all shading calculations.\n";
    ss << "\\min-fields 7\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field SolarCollectorPerformance Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FlatPlateSolarCollectorParameters\n";
    ss << "A4 , \\field Surface Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllShadingAndHTSurfNames\n";
    ss << "A5 , \\field Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A6 , \\field Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 ; \\field Maximum Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\units m3/s\n";

    IddObjectType objType(IddObjectType::OS_SolarCollector_FlatPlate_Water);
    OptionalIddObject oObj = IddObject::load("OS:SolarCollector:FlatPlate:Water",
                                             "Solar Collectors",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SolarCollector_FlatPlate_Water);
  return object;
}

IddObject createOS_SolarCollectorPerformance_IntegralCollectorStorageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SolarCollectorPerformance:IntegralCollectorStorage,\n";
    ss << "\\memo Thermal and optical performance parameters for a single glazed solar collector with\n";
    ss << "\\memo integral storage unit.\n";
    ss << "\\min-fields 20\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2,  \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference CollectorStoragePerformance\n";
    ss << "A3,  \\field ICS Collector Type\n";
    ss << "\\type choice\n";
    ss << "\\key RectangularTank\n";
    ss << "\\default RectangularTank\n";
    ss << "\\note Currently only RectangularTank ICS collector type is available.\n";
    ss << "N1,  \\field Gross Area\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\units m2\n";
    ss << "N2,  \\field Collector Water Volume\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\units m3\n";
    ss << "N3,  \\field Bottom Heat Loss Conductance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.40\n";
    ss << "\\units W/m2-K\n";
    ss << "\\note Heat loss conductance of the collector bottom insulation\n";
    ss << "N4,  \\field Side Heat Loss Conductance\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\default 0.60\n";
    ss << "\\units W/m2-K\n";
    ss << "\\note heat loss conductance of the collector side insulation\n";
    ss << "N5,  \\field Aspect Ratio\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.5\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\default 0.8\n";
    ss << "\\units m\n";
    ss << "\\note This value is ratio of the width (short side) to length\n";
    ss << "\\note (long side of) of the collector.  Used to calculate the\n";
    ss << "\\note perimeter of the collector\n";
    ss << "N6,  \\field Collector Side Height\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum< 0.30\n";
    ss << "\\default 0.20\n";
    ss << "\\units m\n";
    ss << "\\note This value is used to estimate collector side area for the heat\n";
    ss << "\\note loss calculation through the collector side\n";
    ss << "N7,  \\field Thermal Mass of Absorber Plate\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "\\default 0\n";
    ss << "\\units J/m2-K\n";
    ss << "\\note Calculated from the specific heat, density and thickness\n";
    ss << "\\note of the absorber plate.\n";
    ss << "N8,  \\field Number of Covers\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 2\n";
    ss << "\\default 2\n";
    ss << "\\note Number of transparent covers. Common practice is to use low-iron\n";
    ss << "\\note glass as the outer cover and very thin transparent sheet such as\n";
    ss << "\\note Teflon as the inner cover.\n";
    ss << "N9,  \\field Cover Spacing\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\maximum 0.20\n";
    ss << "\\default 0.05\n";
    ss << "\\units m\n";
    ss << "\\note The gap between the transparent covers and between the inner cover\n";
    ss << "\\note and the absorber plate\n";
    ss << "N10, \\field Refractive Index of Outer Cover\n";
    ss << "\\type real\n";
    ss << "\\minimum 1.0\n";
    ss << "\\maximum 2.0\n";
    ss << "\\default 1.526\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Refractive index of outer cover. Typically low-iron glass is used\n";
    ss << "\\note as the outer cover material, and used as the default outer cover\n";
    ss << "\\note with a value of 1.526.\n";
    ss << "N11, \\field Extinction Coefficient Times Thickness of Outer Cover\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.\n";
    ss << "\\default 0.045\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Clear glass has extinction coefficient of about 15 [1/m]\n";
    ss << "\\note and with thickness of 3.0mm, the product of the extinction\n";
    ss << "\\note coefficient and thickness becomes 0.045 (=15 * 0.003)\n";
    ss << "N12, \\field Emissivity of Outer Cover\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\default 0.88\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Thermal emissivity of the outer cover, commonly glass is used as\n";
    ss << "\\note the out collector cover material.\n";
    ss << "N13, \\field Refractive Index of Inner Cover\n";
    ss << "\\type real\n";
    ss << "\\minimum 1.0\n";
    ss << "\\maximum 2.0\n";
    ss << "\\default 1.37\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Typical material is very thin sheet of Teflon (PTFE). The default\n";
    ss << "\\note value is refractive index of Teflon.\n";
    ss << "N14, \\field Extinction Coefficient Times Thickness of the inner Cover\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.\n";
    ss << "\\default 0.008\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Default inner cover is very thin sheet of Teflon with\n";
    ss << "\\note extinction coefficient of approximately 40.0 and a thickness\n";
    ss << "\\note 0.2mm yields a default value of 0.008.\n";
    ss << "N15, \\field Emissivity of Inner Cover\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\default 0.88\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Thermal emissivity of the inner cover material\n";
    ss << "N16, \\field Absorptance of Absorber Plate\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\default 0.96\n";
    ss << "\\units dimensionless\n";
    ss << "\\note The absorber plate solar absorptance.  Copper is assumed as\n";
    ss << "\\note the default absorber plate.\n";
    ss << "N17; \\field Emissivity of Absorber Plate\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0.\n";
    ss << "\\maximum< 1.0\n";
    ss << "\\default 0.30\n";
    ss << "\\units dimensionless\n";
    ss << "\\note Thermal emissivity of the absorber plate\n";

    IddObjectType objType(IddObjectType::OS_SolarCollectorPerformance_IntegralCollectorStorage);
    OptionalIddObject oObj = IddObject::load("OS:SolarCollectorPerformance:IntegralCollectorStorage",
                                             "Solar Collectors",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SolarCollectorPerformance_IntegralCollectorStorage);
  return object;
}

IddObject createOS_SolarCollector_IntegralCollectorStorageIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SolarCollector:IntegralCollectorStorage,\n";
    ss << "\\memo Glazed solar collector with integral storage unit. Thermal and optical properties are\n";
    ss << "\\memo taken from the referenced SolarCollectorPerformance:IntegralCollectorStorage object.\n";
    ss << "\\memo Collector tilt, azimuth, and gross area are taken from the referenced building surface\n";
    ss << "\\memo or shading surface. The collector surface participates normally in all shading\n";
    ss << "\\memo calculations.\n";
    ss << "\\min-fields 9\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field IntegralCollectorStorageParameters Name\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list CollectorStoragePerformance\n";
    ss << "A4 , \\field Surface Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllShadingAndHTSurfNames\n";
    ss << "A5 , \\field Bottom Surface Boundary Conditions Type\n";
    ss << "\\type choice\n";
    ss << "\\key OtherSideConditionsModel\n";
    ss << "\\key AmbientAir\n";
    ss << "\\default AmbientAir\n";
    ss << "A6 , \\field Boundary Condition Model Name\n";
    ss << "\\type alpha\n";
    ss << "\\note Enter the name of a SurfaceProperty:OtherSideConditionsModel\n";
    ss << "\\note object. Specified only if the boundary condition type is\n";
    ss << "\\note OtherSideConditionsModel, otherwise leave it blank\n";
    ss << "A7 , \\field Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A8 , \\field Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 ; \\field Maximum Flow Rate\n";
    ss << "\\type real\n";
    ss << "\\minimum> 0\n";
    ss << "\\units m3/s\n";

    IddObjectType objType(IddObjectType::OS_SolarCollector_IntegralCollectorStorage);
    OptionalIddObject oObj = IddObject::load("OS:SolarCollector:IntegralCollectorStorage",
                                             "Solar Collectors",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SolarCollector_IntegralCollectorStorage);
  return object;
}

IddObject createOS_SolarCollectorPerformance_PhotovoltaicThermal_SimpleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SolarCollectorPerformance:PhotovoltaicThermal:Simple,\n";
    ss << "\\memo Thermal performance parameters for a hybrid photovoltaic-thermal (PVT) solar collector.\n";
    ss << "\\min-fields 7\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference FlatPlatePVTParameters\n";
    ss << "N1 , \\field Fraction of Surface Area with Active Thermal Collector\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum> 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 1.0\n";
    ss << "A3 , \\field Thermal Conversion Efficiency Input Mode Type\n";
    ss << "\\type choice\n";
    ss << "\\key Fixed\n";
    ss << "\\key Scheduled\n";
    ss << "\\default Fixed\n";
    ss << "N2 , \\field Value for Thermal Conversion Efficiency if Fixed\n";
    ss << "\\note Efficiency = (thermal power generated [W])/(incident solar[W])\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A4 , \\field Thermal Conversion Efficiency Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "N3 ; \\field Front Surface Emittance\n";
    ss << "\\type real\n";
    ss << "\\default 0.84\n";
    ss << "\\minimum> 0.00\n";
    ss << "\\maximum< 1.00\n";

    IddObjectType objType(IddObjectType::OS_SolarCollectorPerformance_PhotovoltaicThermal_Simple);
    OptionalIddObject oObj = IddObject::load("OS:SolarCollectorPerformance:PhotovoltaicThermal:Simple",
                                             "Solar Collectors",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SolarCollectorPerformance_PhotovoltaicThermal_Simple);
  return object;
}

IddObject createOS_SolarCollector_FlatPlate_PhotovoltaicThermalIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:SolarCollector:FlatPlate:PhotovoltaicThermal,\n";
    ss << "\\memo Models hybrid photovoltaic-thermal (PVT) solar collectors that convert incident solar\n";
    ss << "\\memo energy into both electricity and useful thermal energy by heating air or water.\n";
    ss << "\\min-fields 8\n";
    ss << "A1,  \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\type alpha\n";
    ss << "\\reference ConnectionObject\n";
    ss << "A3 , \\field Surface Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllShadingAndHTSurfNames\n";
    ss << "A4 , \\field Photovoltaic-Thermal Model Performance Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list FlatPlatePVTParameters\n";
    ss << "A5 , \\field Photovoltaic Name\n";
    ss << "\\note Enter the name of a Generator:Photovoltaic object.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PVGeneratorNames\n";
    ss << "A6 , \\field Inlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "A7 , \\field Outlet Node Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ConnectionNames\n";
    ss << "N1 ; \\field Design Flow Rate\n";
    ss << "\\units m3/s\n";
    ss << "\\autosizable\n";

    IddObjectType objType(IddObjectType::OS_SolarCollector_FlatPlate_PhotovoltaicThermal);
    OptionalIddObject oObj = IddObject::load("OS:SolarCollector:FlatPlate:PhotovoltaicThermal",
                                             "Solar Collectors",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_SolarCollector_FlatPlate_PhotovoltaicThermal);
  return object;
}

IddObject createOS_Generator_PhotovoltaicIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Generator:Photovoltaic,\n";
    ss << "\\memo Describes an array of photovoltaic (PV) modules. PV performance is taken from the\n";
    ss << "\\memo referenced PhotovoltaicPerformance:* object. Array tilt, azimuth, and gross area\n";
    ss << "\\memo are taken from the referenced building surface or shading surface. The array\n";
    ss << "\\memo surface participates normally in all shading calculations.\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference GeneratorNames\n";
    ss << "\\reference PVGeneratorNames\n";
    ss << "A3 , \\field Surface Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list AllShadingAndHTSurfNames\n";
    ss << "A4 , \\field Module Performance Name\n";
    ss << "\\note PV array modeling details\n";
    ss << "\\required-field\n";
    ss << "\\type object-list\n";
    ss << "\\object-list PVModules\n";
    ss << "A5 , \\field Heat Transfer Integration Mode\n";
    ss << "\\type choice\n";
    ss << "\\key Decoupled\n";
    ss << "\\key DecoupledUllebergDynamic\n";
    ss << "\\key IntegratedSurfaceOutsideFace\n";
    ss << "\\key IntegratedTranspiredCollector\n";
    ss << "\\key IntegratedExteriorVentedCavity\n";
    ss << "\\key PhotovoltaicThermalSolarCollector\n";
    ss << "\\default Decoupled\n";
    ss << "N1 , \\field Number of Modules in Parallel\n";
    ss << "\\default 1\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 1\n";
    ss << "N2 , \\field Number of Modules in Series\n";
    ss << "\\default 1\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 1\n";
    ss << "N3 , \\field Rated Electric Power Output\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "A6 ; \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this generator. Schedule value > 0 means the generator is available.\n";
    ss << "\\note If this field is blank, the generator is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_Generator_Photovoltaic);
    OptionalIddObject oObj = IddObject::load("OS:Generator:Photovoltaic",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Generator_Photovoltaic);
  return object;
}

IddObject createOS_PhotovoltaicPerformance_SimpleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:PhotovoltaicPerformance:Simple,\n";
    ss << "\\memo Describes a simple model of photovoltaics that may be useful for early phase\n";
    ss << "\\memo design analysis. In this model the user has direct access to the efficiency with\n";
    ss << "\\memo which surfaces convert incident solar radiation to electricity and need not specify\n";
    ss << "\\memo arrays of specific modules.\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference PVModules\n";
    ss << "N1 , \\field Fraction of Surface Area with Active Solar Cells\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "\\default 0.89\n";
    ss << "A3 , \\field Conversion Efficiency Input Mode\n";
    ss << "\\type choice\n";
    ss << "\\key Fixed\n";
    ss << "\\key Scheduled\n";
    ss << "N2 , \\field Value for Cell Efficiency if Fixed\n";
    ss << "\\note Efficiency = (power generated [W])/(incident solar[W])\n";
    ss << "\\type real\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "A4 ; \\field Efficiency Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_PhotovoltaicPerformance_Simple);
    OptionalIddObject oObj = IddObject::load("OS:PhotovoltaicPerformance:Simple",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_PhotovoltaicPerformance_Simple);
  return object;
}

IddObject createOS_PhotovoltaicPerformance_EquivalentOneDiodeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:PhotovoltaicPerformance:EquivalentOne-Diode,\n";
    ss << "\\memo Describes the performance characteristics of Photovoltaic (PV) modules to be modeled\n";
    ss << "\\memo using an equivalent one-diode circuit.  This model is also known as\n";
    ss << "\\memo the 4- or 5-parameter TRNSYS model for photovoltaics.\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference PVModules\n";
    ss << "A3 , \\field Cell type\n";
    ss << "\\type choice\n";
    ss << "\\default CrystallineSilicon\n";
    ss << "\\key CrystallineSilicon\n";
    ss << "\\key AmorphousSilicon\n";
    ss << "N1 , \\field Number of Cells in Series\n";
    ss << "\\default 36\n";
    ss << "\\type integer\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0\n";
    ss << "N2 , \\field Active Area\n";
    ss << "\\note The total power output of the array is determined by the\n";
    ss << "\\note number of modules (see above).  The Active Area is only\n";
    ss << "\\note used to calculate the PV Array Efficiency output variable.\n";
    ss << "\\default 0.89\n";
    ss << "\\type real\n";
    ss << "\\units m2\n";
    ss << "\\minimum 0.1\n";
    ss << "N3 , \\field Transmittance Absorptance Product\n";
    ss << "\\default 0.95\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "\\minimum 0.0\n";
    ss << "\\maximum 1.0\n";
    ss << "N4 , \\field Semiconductor Bandgap\n";
    ss << "\\default 1.12\n";
    ss << "\\type real\n";
    ss << "\\units eV\n";
    ss << "\\minimum 0.0\n";
    ss << "N5 , \\field Shunt Resistance\n";
    ss << "\\default 1000000.0\n";
    ss << "\\type real\n";
    ss << "\\units ohms\n";
    ss << "\\minimum 0.0\n";
    ss << "N6 , \\field Short Circuit Current\n";
    ss << "\\default 6.5\n";
    ss << "\\type real\n";
    ss << "\\units A\n";
    ss << "\\minimum 0.0\n";
    ss << "N7, \\field Open Circuit Voltage\n";
    ss << "\\default 21.6\n";
    ss << "\\type real\n";
    ss << "\\units V\n";
    ss << "\\minimum 0.0\n";
    ss << "N8, \\field Reference Temperature\n";
    ss << "\\default 25\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "N9, \\field Reference Insolation\n";
    ss << "\\default 1000\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "N10, \\field Module Current at Maximum Power\n";
    ss << "\\note Single module current at the maximum power point\n";
    ss << "\\note and reference conditions.  Module Current, Module Voltage,\n";
    ss << "\\note Number of Modules in Parallel and Number of Modules in Series\n";
    ss << "\\note determine the maximum power output of the array.\n";
    ss << "\\default 5.9\n";
    ss << "\\type real\n";
    ss << "\\units A\n";
    ss << "\\minimum 0.0\n";
    ss << "N11, \\field Module Voltage at Maximum Power\n";
    ss << "\\note Single module voltage at the maximum power point\n";
    ss << "\\note and reference conditions.  Module Current, Module Voltage,\n";
    ss << "\\note Number of Modules in Parallel and Number of Modules in Series\n";
    ss << "\\note determine the maximum power output of the array.\n";
    ss << "\\default 17\n";
    ss << "\\type real\n";
    ss << "\\units V\n";
    ss << "\\minimum 0.0\n";
    ss << "N12, \\field Temperature Coefficient of Short Circuit Current\n";
    ss << "\\default 0.02\n";
    ss << "\\type real\n";
    ss << "\\units A/K\n";
    ss << "N13, \\field Temperature Coefficient of Open Circuit Voltage\n";
    ss << "\\default -0.079\n";
    ss << "\\type real\n";
    ss << "\\units V/K\n";
    ss << "N14, \\field Nominal Operating Cell Temperature Test Ambient Temperature\n";
    ss << "\\default 20\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "N15, \\field Nominal Operating Cell Temperature Test Cell Temperature\n";
    ss << "\\default 40\n";
    ss << "\\type real\n";
    ss << "\\units C\n";
    ss << "\\minimum 0.0\n";
    ss << "N16, \\field Nominal Operating Cell Temperature Test Insolation\n";
    ss << "\\default 800\n";
    ss << "\\type real\n";
    ss << "\\units W/m2\n";
    ss << "\\minimum 0.0\n";
    ss << "N17, \\field Module Heat Loss Coefficient\n";
    ss << "\\default 30\n";
    ss << "\\type real\n";
    ss << "\\units W/m2-K\n";
    ss << "\\minimum 0.0\n";
    ss << "N18; \\field Total Heat Capacity\n";
    ss << "\\default 50000\n";
    ss << "\\type real\n";
    ss << "\\units J/m2-K\n";
    ss << "\\minimum 0.0\n";

    IddObjectType objType(IddObjectType::OS_PhotovoltaicPerformance_EquivalentOneDiode);
    OptionalIddObject oObj = IddObject::load("OS:PhotovoltaicPerformance:EquivalentOne-Diode",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_PhotovoltaicPerformance_EquivalentOneDiode);
  return object;
}

IddObject createOS_ElectricLoadCenter_Inverter_SimpleIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ElectricLoadCenter:Inverter:Simple,\n";
    ss << "\\memo Electric power inverter to convert from direct current (DC) to alternating current\n";
    ss << "\\memo (AC) in an electric load center that contains photovoltaic modules. This input\n";
    ss << "\\memo object is for the simplest inverter model and uses a fixed efficiency.\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference InverterList\n";
    ss << "A3 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Zone Name\n";
    ss << "\\note enter name of zone to receive inverter losses as heat\n";
    ss << "\\note if blank then inverter is assumed to be outdoors\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "N1 , \\field Radiative Fraction\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "N2 ; \\field Inverter Efficiency\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";

    IddObjectType objType(IddObjectType::OS_ElectricLoadCenter_Inverter_Simple);
    OptionalIddObject oObj = IddObject::load("OS:ElectricLoadCenter:Inverter:Simple",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ElectricLoadCenter_Inverter_Simple);
  return object;
}

IddObject createOS_ElectricLoadCenter_Inverter_LookUpTableIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ElectricLoadCenter:Inverter:LookUpTable,\n";
    ss << "\\memo   California Energy Commission tests and publishes data on inverters\n";
    ss << "\\memo   This inverter model interpolates using CEC test data\n";
    ss << "\\memo   Input data are at http://www.gosolarcalifornia.org/equipment/inverter_tests/summaries\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "\\reference InverterList\n";
    ss << "A3 , \\field Availability Schedule Name\n";
    ss << "\\note Availability schedule name for this system. Schedule value > 0 means the system is available.\n";
    ss << "\\note If this field is blank, the system is always available.\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A4 , \\field Zone Name\n";
    ss << "\\note Enter name of zone to receive inverter losses as heat\n";
    ss << "\\note if blank then inverter is assumed to be outdoors\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ThermalZoneNames\n";
    ss << "N1 , \\field Radiative Fraction\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "N2 , \\field Rated Maximum Continuous Output Power\n";
    ss << "\\units W\n";
    ss << "N3 , \\field Night Tare Loss Power\n";
    ss << "\\units W\n";
    ss << "N4 , \\field Nominal Voltage Input\n";
    ss << "\\units V\n";
    ss << "N5 , \\field Efficiency at 10% Power and Nominal Voltage\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "N6 , \\field Efficiency at 20% Power and Nominal Voltage\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "N7 , \\field Efficiency at 30% Power and Nominal Voltage\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "N8 , \\field Efficiency at 50% Power and Nominal Voltage\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "N9 , \\field Efficiency at 75% Power and Nominal Voltage\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";
    ss << "N10; \\field Efficiency at 100% Power and Nominal Voltage\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1.0\n";

    IddObjectType objType(IddObjectType::OS_ElectricLoadCenter_Inverter_LookUpTable);
    OptionalIddObject oObj = IddObject::load("OS:ElectricLoadCenter:Inverter:LookUpTable",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ElectricLoadCenter_Inverter_LookUpTable);
  return object;
}

IddObject createOS_ElectricLoadCenter_DistributionIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ElectricLoadCenter:Distribution,\n";
    ss << "\\memo a list of meters that can be reported are available after a run on\n";
    ss << "\\memo the meter dictionary file (.mdd) if the Output:VariableDictionary has been requested.\n";
    ss << "A1 , \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2 , \\field Name\n";
    ss << "\\required-field\n";
    ss << "A3 , \\field Generator List Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list ModelObjectLists\n";
    ss << "A4 , \\field Generator Operation Scheme Type\n";
    ss << "\\note required if Generator List is entered.\n";
    ss << "\\memo Keys DemandLimit, TrackElectrical, TrackSchedule, TrackMeter, FollowThermal and FollowThermalLimitElectrical disabled for now\n";
    ss << "\\type choice\n";
    ss << "\\default Baseload\n";
    ss << "\\key Baseload\n";
    ss << "N1 , \\field Demand Limit Scheme Purchased Electric Demand Limit\n";
    ss << "\\type real\n";
    ss << "\\units W\n";
    ss << "A5 , \\field Track Schedule Name Scheme Schedule Name\n";
    ss << "\\note required when Generator Operation Scheme Type=TrackSchedule\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";
    ss << "A6 , \\field Track Meter Scheme Meter Name\n";
    ss << "\\note required when Generator Operation Scheme Type=TrackMeter\n";
    ss << "\\type external-list\n";
    ss << "\\external-list autoRDDmeter\n";
    ss << "A7 , \\field Electrical Buss Type\n";
    ss << "\\type choice\n";
    ss << "\\memo Keys AlternatingCurrent, AlternatingCurrentWithStorage, DirectCurrentWithInverterDCStorage, and DirectCurrentWithInverterACStorage disabled for now\n";
    ss << "\\key DirectCurrentWithInverter\n";
    ss << "\\default DirectCurrentWithInverter\n";
    ss << "A8 , \\field Inverter Object Name\n";
    ss << "\\note required when Electrical Buss Type=DirectCurrentWithInverter, DirectCurrentWithInverterDCStorage,\n";
    ss << "\\note or DirectCurrentWithInverterACStorage\n";
    ss << "\\type object-list\n";
    ss << "\\object-list InverterList\n";
    ss << "A9 , \\field Electrical Storage Object Name\n";
    ss << "\\note required when Electrical Buss Type=AlternatingCurrentWithStorage, DirectCurrentWithInverterDCStorage,\n";
    ss << "\\note or DirectCurrentWithInverterACStorage\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ElecStorageList\n";
    ss << "A10; \\field Transformer Object Name\n";
    ss << "\\note required when power needs to be output from on-site generation to the grid via transformer\n";
    ss << "\\type object-list\n";
    ss << "\\object-list TransformerNames\n";

    IddObjectType objType(IddObjectType::OS_ElectricLoadCenter_Distribution);
    OptionalIddObject oObj = IddObject::load("OS:ElectricLoadCenter:Distribution",
                                             "Electric Load Center-Generator Specifications",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ElectricLoadCenter_Distribution);
  return object;
}

IddObject createOS_ComponentCost_AdjustmentsIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:ComponentCost:Adjustments,\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "N1, \\field Miscellaneous Cost per Conditioned Area\n";
    ss << "\\note based on conditioned floor area\n";
    ss << "\\note for cost not accounted for in current line item cost model\n";
    ss << "\\type real\n";
    ss << "\\units $/m2\n";
    ss << "N2, \\field Design and Engineering Fees\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N3, \\field Contractor Fee\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N4, \\field Contingency\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N5, \\field Permits, Bonding and Insurance\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N6, \\field Commissioning Fee\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";
    ss << "N7; \\field Regional Adjustment Factor\n";
    ss << "\\note for use with average data in line item and Misc cost models\n";
    ss << "\\type real\n";
    ss << "\\units dimensionless\n";

    IddObjectType objType(IddObjectType::OS_ComponentCost_Adjustments);
    OptionalIddObject oObj = IddObject::load("OS:ComponentCost:Adjustments",
                                             "OpenStudio Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_ComponentCost_Adjustments);
  return object;
}

IddObject createOS_LifeCycleCostIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:LifeCycleCost,\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A3, \\field Category\n";
    ss << "\\note combination of fields from LifeCycleCost:NonrecurringCost and LifeCycleCost:RecurringCosts\n";
    ss << "\\type choice\n";
    ss << "\\default Construction\n";
    ss << "\\key Construction\n";
    ss << "\\key Salvage\n";
    ss << "\\key OtherCapital\n";
    ss << "\\key Maintenance\n";
    ss << "\\key Repair\n";
    ss << "\\key Operation\n";
    ss << "\\key Replacement\n";
    ss << "\\key MinorOverhaul\n";
    ss << "\\key MajorOverhaul\n";
    ss << "\\key OtherOperational\n";
    ss << "A4, \\field Item Type\n";
    ss << "\\note extend choice-keys as Cases are added to code\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Construction\n";
    ss << "\\key Building\n";
    ss << "\\key Space\n";
    ss << "\\key ThermalZone\n";
    ss << "\\key AirLoop\n";
    ss << "\\key PlantLoop\n";
    ss << "\\key ZoneHVAC\n";
    ss << "\\key Lights\n";
    ss << "\\key Luminaire\n";
    ss << "\\key Equipment\n";
    ss << "\\key HVACComponent\n";
    ss << "\\key ZoneHVACComponent\n";
    ss << "A5, \\field Item Name\n";
    ss << "\\type object-list\n";
    ss << "\\required-field\n";
    ss << "\\object-list AllObjects\n";
    ss << "N1, \\field Cost\n";
    ss << "\\required-field\n";
    ss << "\\type real\n";
    ss << "A6, \\field Cost Units\n";
    ss << "\\note extend choice-keys as Cases are added to code\n";
    ss << "\\required-field\n";
    ss << "\\type choice\n";
    ss << "\\key CostPerArea\n";
    ss << "\\key CostPerEach\n";
    ss << "\\key CostPerThermalZone\n";
    ss << "A7, \\field Start of Costs\n";
    ss << "\\note Enter when the costs start. The First Year of Cost is based on the number of years past the\n";
    ss << "\\note Start of Costs. For most maintenance costs the Start of Costs should be Service Period.\n";
    ss << "\\type choice\n";
    ss << "\\default BasePeriod\n";
    ss << "\\key BasePeriod\n";
    ss << "\\key ServicePeriod\n";
    ss << "N2, \\field Years from Start\n";
    ss << "\\note This field and the Months From Start field together represent the time from either the start\n";
    ss << "\\note of the Service Period on the service month and year or start of the Base Period on the base\n";
    ss << "\\note month and year (depending on the Start of Costs field) that the costs start to occur. Only\n";
    ss << "\\note integers should be entered representing whole years.\n";
    ss << "\\type integer\n";
    ss << "\\default 0\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 100\n";
    ss << "N3, \\field Months from Start\n";
    ss << "\\note This field and the Years From Start field together represent the time from either the start\n";
    ss << "\\note of the Service Period on the service month and year or start of the Base Period on the base\n";
    ss << "\\note month and year (depending on the Start of Costs field) that the costs start to occur. Only\n";
    ss << "\\note integers should be entered representing whole months. The Years From Start (times 12) and\n";
    ss << "\\note Months From Start are added together.\n";
    ss << "\\type integer\n";
    ss << "\\default 0\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1200\n";
    ss << "N4, \\field Repeat Period Years\n";
    ss << "\\note This field and the Repeat Period Months field indicate how much time elapses between\n";
    ss << "\\note reoccurrences of the cost. For costs that occur every year such the Repeat Period Years\n";
    ss << "\\note should be 1 and Repeat Period Months should be 0. Only integers should be entered\n";
    ss << "\\note representing whole years.  If both Repeat Period Years and Repeat Period Months are 0,\n";
    ss << "\\note then recurring costs are not applied.\n";
    ss << "\\type integer\n";
    ss << "\\default 0\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 100\n";
    ss << "N5; \\field Repeat Period Months\n";
    ss << "\\note This field and the Repeat Period Years field indicate how much time elapses between\n";
    ss << "\\note reoccurrences of the cost. Only integers should be entered representing whole months.\n";
    ss << "\\note The Repeat Period Years (times 12) and Repeat Period Months are added together.\n";
    ss << "\\note If both Repeat Period Years and Repeat Period Months are 0, then recurring costs are not applied.\n";
    ss << "\\type integer\n";
    ss << "\\default 0\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 1200\n";

    IddObjectType objType(IddObjectType::OS_LifeCycleCost);
    OptionalIddObject oObj = IddObject::load("OS:LifeCycleCost",
                                             "OpenStudio Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_LifeCycleCost);
  return object;
}

IddObject createOS_CurrencyTypeIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:CurrencyType,\n";
    ss << "\\memo If CurrencyType is not specified, it will default to USD and produce $ in the reports.\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2; \\field Monetary Unit\n";
    ss << "\\note The commonly used three letter currency code for the units of money for the country or region.\n";
    ss << "\\note Based on ISO 4217 currency codes.  Common currency codes are USD for $ and EUR for Euros.\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key USD\n";
    ss << "\\key AFN\n";
    ss << "\\key ALL\n";
    ss << "\\key ANG\n";
    ss << "\\key ARS\n";
    ss << "\\key AUD\n";
    ss << "\\key AWG\n";
    ss << "\\key AZN\n";
    ss << "\\key BAM\n";
    ss << "\\key BBD\n";
    ss << "\\key BGN\n";
    ss << "\\key BMD\n";
    ss << "\\key BND\n";
    ss << "\\key BOB\n";
    ss << "\\key BRL\n";
    ss << "\\key BSD\n";
    ss << "\\key BWP\n";
    ss << "\\key BYR\n";
    ss << "\\key BZD\n";
    ss << "\\key CAD\n";
    ss << "\\key CHF\n";
    ss << "\\key CLP\n";
    ss << "\\key CNY\n";
    ss << "\\key COP\n";
    ss << "\\key CRC\n";
    ss << "\\key CUP\n";
    ss << "\\key CZK\n";
    ss << "\\key DKK\n";
    ss << "\\key DOP\n";
    ss << "\\key EEK\n";
    ss << "\\key EGP\n";
    ss << "\\key EUR\n";
    ss << "\\key FJD\n";
    ss << "\\key GBP\n";
    ss << "\\key GHC\n";
    ss << "\\key GIP\n";
    ss << "\\key GTQ\n";
    ss << "\\key GYD\n";
    ss << "\\key HKD\n";
    ss << "\\key HNL\n";
    ss << "\\key HRK\n";
    ss << "\\key HUF\n";
    ss << "\\key IDR\n";
    ss << "\\key ILS\n";
    ss << "\\key IMP\n";
    ss << "\\key INR\n";
    ss << "\\key IRR\n";
    ss << "\\key ISK\n";
    ss << "\\key JEP\n";
    ss << "\\key JMD\n";
    ss << "\\key JPY\n";
    ss << "\\key KGS\n";
    ss << "\\key KHR\n";
    ss << "\\key KPW\n";
    ss << "\\key KRW\n";
    ss << "\\key KYD\n";
    ss << "\\key KZT\n";
    ss << "\\key LAK\n";
    ss << "\\key LBP\n";
    ss << "\\key LKR\n";
    ss << "\\key LRD\n";
    ss << "\\key LTL\n";
    ss << "\\key LVL\n";
    ss << "\\key MKD\n";
    ss << "\\key MNT\n";
    ss << "\\key MUR\n";
    ss << "\\key MXN\n";
    ss << "\\key MYR\n";
    ss << "\\key MZN\n";
    ss << "\\key NAD\n";
    ss << "\\key NGN\n";
    ss << "\\key NIO\n";
    ss << "\\key NOK\n";
    ss << "\\key NPR\n";
    ss << "\\key NZD\n";
    ss << "\\key OMR\n";
    ss << "\\key PAB\n";
    ss << "\\key PEN\n";
    ss << "\\key PHP\n";
    ss << "\\key PKR\n";
    ss << "\\key PLN\n";
    ss << "\\key PYG\n";
    ss << "\\key QAR\n";
    ss << "\\key RON\n";
    ss << "\\key RSD\n";
    ss << "\\key RUB\n";
    ss << "\\key SAR\n";
    ss << "\\key SBD\n";
    ss << "\\key SCR\n";
    ss << "\\key SEK\n";
    ss << "\\key SGD\n";
    ss << "\\key SHP\n";
    ss << "\\key SOS\n";
    ss << "\\key SRD\n";
    ss << "\\key SVC\n";
    ss << "\\key SYP\n";
    ss << "\\key THB\n";
    ss << "\\key TRL\n";
    ss << "\\key TRY\n";
    ss << "\\key TTD\n";
    ss << "\\key TVD\n";
    ss << "\\key TWD\n";
    ss << "\\key UAH\n";
    ss << "\\key UYU\n";
    ss << "\\key UZS\n";
    ss << "\\key VEF\n";
    ss << "\\key VND\n";
    ss << "\\key XCD\n";
    ss << "\\key YER\n";
    ss << "\\key ZAR\n";
    ss << "\\key ZWD\n";

    IddObjectType objType(IddObjectType::OS_CurrencyType);
    OptionalIddObject oObj = IddObject::load("OS:CurrencyType",
                                             "OpenStudio Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_CurrencyType);
  return object;
}

IddObject createOS_LifeCycleCost_ParametersIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:LifeCycleCost:Parameters,\n";
    ss << "\\unique-object\n";
    ss << "\\min-fields 12\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Analysis Type\n";
    ss << "\\type choice\n";
    ss << "\\default FEMP\n";
    ss << "\\key FEMP\n";
    ss << "\\key Custom\n";
    ss << "A3, \\field Discounting Convention\n";
    ss << "\\note The field specifies if the discounting of future costs should be computed as occurring at the end\n";
    ss << "\\note of each year or the middle of each year or the beginning of each year. The most common discounting\n";
    ss << "\\note convention uses the end of each year.\n";
    ss << "\\type choice\n";
    ss << "\\default EndOfYear\n";
    ss << "\\key EndOfYear\n";
    ss << "\\key MidYear\n";
    ss << "\\key BeginningOfYear\n";
    ss << "A4, \\field Inflation Approach\n";
    ss << "\\note This field is used to determine if the analysis should use constant dollars or current dollars\n";
    ss << "\\note which is related to how inflation is treated. If ConstantDollar is selected then the Real Discount\n";
    ss << "\\note Rate input is used and it excludes the rate of inflation. If CurrentDollar is selected then the\n";
    ss << "\\note Nominal Discount Rate input is used and it includes the rate of inflation.\n";
    ss << "\\type choice\n";
    ss << "\\default ConstantDollar\n";
    ss << "\\key ConstantDollar\n";
    ss << "\\key CurrentDollar\n";
    ss << "N1, \\field Real Discount Rate\n";
    ss << "\\note Enter the real discount rate as a decimal. For a 3% rate enter the value 0.03. This input is\n";
    ss << "\\note used when the Inflation Approach is ConstantDollar. The real discount rate reflects the interest\n";
    ss << "\\note rates needed to make current and future expenditures have comparable equivalent values when\n";
    ss << "\\note general inflation is ignored. When Inflation Approach is set to CurrentDollar this input is ignored.\n";
    ss << "\\type real\n";
    ss << "N2, \\field Nominal Discount Rate\n";
    ss << "\\note Enter the nominal discount rate as a decimal. For a 5% rate enter the value 0.05. This input\n";
    ss << "\\note is used when the Inflation Approach is CurrentDollar. The real discount rate reflects the interest\n";
    ss << "\\note rates needed to make current and future expenditures have comparable equivalent values when general\n";
    ss << "\\note inflation is included. When Inflation Approach is set to ConstantDollar this input is ignored.\n";
    ss << "\\type real\n";
    ss << "N3, \\field Inflation\n";
    ss << "\\note Enter the rate of inflation for general goods and services as a decimal. For a 2% rate enter\n";
    ss << "\\note the value 0.02.\n";
    ss << "\\type real\n";
    ss << "A5, \\field Base Date Month\n";
    ss << "\\note Enter the month that is the beginning of study period also known as the beginning of the base period.\n";
    ss << "\\type choice\n";
    ss << "\\default January\n";
    ss << "\\key January\n";
    ss << "\\key February\n";
    ss << "\\key March\n";
    ss << "\\key April\n";
    ss << "\\key May\n";
    ss << "\\key June\n";
    ss << "\\key July\n";
    ss << "\\key August\n";
    ss << "\\key September\n";
    ss << "\\key October\n";
    ss << "\\key November\n";
    ss << "\\key December\n";
    ss << "N4, \\field Base Date Year\n";
    ss << "\\note Enter the four digit year that is the beginning of study period such as 2010. The study period is\n";
    ss << "\\note also known as the base period.\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1900\n";
    ss << "\\maximum 2100\n";
    ss << "A6, \\field Service Date Month\n";
    ss << "\\note Enter the month that is the beginning of building occupancy. Energy costs computed by EnergyPlus\n";
    ss << "\\note are assumed to occur during the year following the service date. The service date must be the\n";
    ss << "\\note same or later than the Base Date. This field could also be referred to as part of beneficial\n";
    ss << "\\note occupancy date.\n";
    ss << "\\type choice\n";
    ss << "\\default January\n";
    ss << "\\key January\n";
    ss << "\\key February\n";
    ss << "\\key March\n";
    ss << "\\key April\n";
    ss << "\\key May\n";
    ss << "\\key June\n";
    ss << "\\key July\n";
    ss << "\\key August\n";
    ss << "\\key September\n";
    ss << "\\key October\n";
    ss << "\\key November\n";
    ss << "\\key December\n";
    ss << "N5, \\field Service Date Year\n";
    ss << "\\note Enter the four digit year that is the beginning of occupancy such as 2010.\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1900\n";
    ss << "\\maximum 2100\n";
    ss << "N6, \\field Length of Study Period in Years\n";
    ss << "\\note Enter the number of years of the study period. It is the number of years that the study continues\n";
    ss << "\\note based on the start at the base date. The default value is 25 years. Only integers may be used\n";
    ss << "\\note indicating whole years.\n";
    ss << "\\type integer\n";
    ss << "\\default 25\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 100\n";
    ss << "N7, \\field Tax Rate\n";
    ss << "\\note Enter the overall marginal tax rate for the project costs. This does not include energy or water\n";
    ss << "\\note taxes. The tax rate entered should be based on the marginal tax rate for the entity and not the\n";
    ss << "\\note average tax rate. Enter the tax rate results in present value calculations after taxes. Most\n";
    ss << "\\note analyses do not factor in the impact of taxes and assume that all options under consideration\n";
    ss << "\\note have roughly the same tax impact. Due to this many times the tax rate can be left to default\n";
    ss << "\\note to zero and the present value results before taxes are used to make decisions. The value\n";
    ss << "\\note should be entered as a decimal value. For 15% enter 0.15. For an analysis that does not include\n";
    ss << "\\note tax impacts enter 0.0.\n";
    ss << "\\type real\n";
    ss << "\\minimum 0\n";
    ss << "A7, \\field Depreciation Method\n";
    ss << "\\note For an analysis that includes income tax impacts this entry describes how capital costs are\n";
    ss << "\\note depreciated. Only one depreciation method may be used for an analysis and is applied to all\n";
    ss << "\\note capital expenditures.\n";
    ss << "\\type choice\n";
    ss << "\\default None\n";
    ss << "\\key ModifiedAcceleratedCostRecoverySystem-3year\n";
    ss << "\\key ModifiedAcceleratedCostRecoverySystem-5year\n";
    ss << "\\key ModifiedAcceleratedCostRecoverySystem-7year\n";
    ss << "\\key ModifiedAcceleratedCostRecoverySystem-10year\n";
    ss << "\\key ModifiedAcceleratedCostRecoverySystem-15year\n";
    ss << "\\key ModifiedAcceleratedCostRecoverySystem-20year\n";
    ss << "\\key StraightLine-27year\n";
    ss << "\\key StraightLine-31year\n";
    ss << "\\key StraightLine-39year\n";
    ss << "\\key StraightLine-40year\n";
    ss << "\\key None\n";
    ss << "A8, \\field Use NIST Fuel Escalation Rates\n";
    ss << "\\type choice\n";
    ss << "\\default Yes\n";
    ss << "\\key Yes\n";
    ss << "\\key No\n";
    ss << "A9, \\field NIST Region\n";
    ss << "\\note Applies only if Analysis Use NIST Fuel Escalation Rates is Yes\n";
    ss << "\\type choice\n";
    ss << "\\default U.S. Avg\n";
    ss << "\\key U.S. Avg\n";
    ss << "\\key NorthEast\n";
    ss << "\\key MidWest\n";
    ss << "\\key South\n";
    ss << "\\key West\n";
    ss << "A10, \\field NIST Sector\n";
    ss << "\\note Applies only if Analysis Use NIST Fuel Escalation Rates is Yes\n";
    ss << "\\type choice\n";
    ss << "\\default Commercial\n";
    ss << "\\key Commercial\n";
    ss << "\\key Residential\n";
    ss << "\\key Industrial\n";
    ss << "N8, \\field Electricity Inflation\n";
    ss << "\\note Applies only if Analysis Use NIST Fuel Escalation Rates is No\n";
    ss << "\\note Enter the rate of inflation for electricity as a decimal. For a 2% rate enter\n";
    ss << "\\note the value 0.02.\n";
    ss << "\\type real\n";
    ss << "N9, \\field NaturalGas Inflation\n";
    ss << "\\note Applies only if Analysis Use NIST Fuel Escalation Rates is No\n";
    ss << "\\note Enter the rate of inflation for natural gas as a decimal. For a 2% rate enter\n";
    ss << "\\note the value 0.02.\n";
    ss << "\\type real\n";
    ss << "N10, \\field Steam Inflation\n";
    ss << "\\note Applies only if Analysis Use NIST Fuel Escalation Rates is No\n";
    ss << "\\note Enter the rate of inflation for steam as a decimal. For a 2% rate enter\n";
    ss << "\\note the value 0.02.\n";
    ss << "\\type real\n";
    ss << "N11, \\field Gasoline Inflation\n";
    ss << "\\note Applies only if Analysis Use NIST Fuel Escalation Rates is No\n";
    ss << "\\note Enter the rate of inflation for gasoline as a decimal. For a 2% rate enter\n";
    ss << "\\note the value 0.02.\n";
    ss << "\\type real\n";
    ss << "N12, \\field Diesel Inflation\n";
    ss << "\\note Applies only if Analysis Use NIST Fuel Escalation Rates is No\n";
    ss << "\\note Enter the rate of inflation for diesel as a decimal. For a 2% rate enter\n";
    ss << "\\note the value 0.02.\n";
    ss << "\\type real\n";
    ss << "N13, \\field Coal Inflation\n";
    ss << "\\note Applies only if Analysis Use NIST Fuel Escalation Rates is No\n";
    ss << "\\note Enter the rate of inflation for coal as a decimal. For a 2% rate enter\n";
    ss << "\\note the value 0.02.\n";
    ss << "\\type real\n";
    ss << "N14, \\field FuelOil1 Inflation\n";
    ss << "\\note Applies only if Analysis Use NIST Fuel Escalation Rates is No\n";
    ss << "\\note Enter the rate of inflation for fuel oil #1 as a decimal. For a 2% rate enter\n";
    ss << "\\note the value 0.02.\n";
    ss << "\\type real\n";
    ss << "N15, \\field FuelOil2 Inflation\n";
    ss << "\\note Applies only if Analysis Use NIST Fuel Escalation Rates is No\n";
    ss << "\\note Enter the rate of inflation for fuel oil #2 as a decimal. For a 2% rate enter\n";
    ss << "\\note the value 0.02.\n";
    ss << "\\type real\n";
    ss << "N16, \\field Propane Inflation\n";
    ss << "\\note Applies only if Analysis Use NIST Fuel Escalation Rates is No\n";
    ss << "\\note Enter the rate of inflation for propane as a decimal. For a 2% rate enter\n";
    ss << "\\note the value 0.02.\n";
    ss << "\\type real\n";
    ss << "N17; \\field Water Inflation\n";
    ss << "\\note Applies only if Analysis Use NIST Fuel Escalation Rates is No\n";
    ss << "\\note Enter the rate of inflation for water as a decimal. For a 2% rate enter\n";
    ss << "\\note the value 0.02.\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::OS_LifeCycleCost_Parameters);
    OptionalIddObject oObj = IddObject::load("OS:LifeCycleCost:Parameters",
                                             "OpenStudio Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_LifeCycleCost_Parameters);
  return object;
}

IddObject createOS_LifeCycleCost_UsePriceEscalationIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:LifeCycleCost:UsePriceEscalation,\n";
    ss << "\\extensible:1\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note The identifier used for the object. The name usually identifies the location (such as the\n";
    ss << "\\note state or region or country or census area) that the escalations apply to. In addition the\n";
    ss << "\\note name should identify the building class such as residential or commercial or industrial\n";
    ss << "\\note and the use type such as electricity or natural gas or water.\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A3, \\field Resource\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Electricity\n";
    ss << "\\key NaturalGas\n";
    ss << "\\key Steam\n";
    ss << "\\key Gasoline\n";
    ss << "\\key Diesel\n";
    ss << "\\key Coal\n";
    ss << "\\key FuelOil#1\n";
    ss << "\\key FuelOil#2\n";
    ss << "\\key Propane\n";
    ss << "\\key Water\n";
    ss << "\\key OtherFuel1\n";
    ss << "\\key OtherFuel2\n";
    ss << "N1, \\field Escalation Start Year\n";
    ss << "\\note This field and the Escalation Start Month define the time that corresponds to Year 1 Escalation\n";
    ss << "\\note such as 2010 when the escalation rates are applied. This field and the Escalation Start Month\n";
    ss << "\\note define the time that escalation begins.\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1900\n";
    ss << "\\maximum 2100\n";
    ss << "A4, \\field Escalation Start Month\n";
    ss << "\\note This field and the Escalation Start Year define the time that corresponds to Year 1 Escalation\n";
    ss << "\\note such as 2010 when the escalation rates are applied. This field and the Escalation Start Year\n";
    ss << "\\note define the time that escalation begins.\n";
    ss << "\\type choice\n";
    ss << "\\default January\n";
    ss << "\\key January\n";
    ss << "\\key February\n";
    ss << "\\key March\n";
    ss << "\\key April\n";
    ss << "\\key May\n";
    ss << "\\key June\n";
    ss << "\\key July\n";
    ss << "\\key August\n";
    ss << "\\key September\n";
    ss << "\\key October\n";
    ss << "\\key November\n";
    ss << "\\key December\n";
    ss << "N2; \\field Year Escalation\n";
    ss << "\\note The escalation in price of the energy or water use for the first year expressed as a decimal.\n";
    ss << "\\type real\n";
    ss << "\\begin-extensible\n";

    IddObjectType objType(IddObjectType::OS_LifeCycleCost_UsePriceEscalation);
    OptionalIddObject oObj = IddObject::load("OS:LifeCycleCost:UsePriceEscalation",
                                             "OpenStudio Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_LifeCycleCost_UsePriceEscalation);
  return object;
}

IddObject createOS_UtilityBillIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:UtilityBill,\n";
    ss << "\\extensible:7\n";
    ss << "\\min-fields 10\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "A3, \\field Fuel Type\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key Electricity\n";
    ss << "\\key Gas\n";
    ss << "\\key Gasoline\n";
    ss << "\\key Diesel\n";
    ss << "\\key FuelOil_1\n";
    ss << "\\key FuelOil_2\n";
    ss << "\\key Propane\n";
    ss << "\\key Water\n";
    ss << "\\key Steam\n";
    ss << "\\key DistrictCooling\n";
    ss << "\\key DistrictHeating\n";
    ss << "\\key EnergyTransfer\n";
    ss << "A4, \\field Meter Install Location\n";
    ss << "\\note Location the meter associated with this utility bill object is installed.\n";
    ss << "\\type choice\n";
    ss << "\\key Facility\n";
    ss << "\\key Building\n";
    ss << "\\key HVAC\n";
    ss << "\\key Zone\n";
    ss << "\\key System\n";
    ss << "\\key Plant\n";
    ss << "\\default Facility\n";
    ss << "A5, \\field Meter Specific Install Location\n";
    ss << "\\note Specific location the meter associated with this utility bill object is installed.\n";
    ss << "\\note Empty field indicates no specific location.\n";
    ss << "A6, \\field Meter End Use Category\n";
    ss << "\\note Type of end use that meter is associated with.\n";
    ss << "\\note Empty field indicates all end uses are included.\n";
    ss << "\\type choice\n";
    ss << "\\key Heating\n";
    ss << "\\key Cooling\n";
    ss << "\\key InteriorLights\n";
    ss << "\\key ExteriorLights\n";
    ss << "\\key InteriorEquipment\n";
    ss << "\\key ExteriorEquipment\n";
    ss << "\\key Fans\n";
    ss << "\\key Pumps\n";
    ss << "\\key HeatRejection\n";
    ss << "\\key Humidifier\n";
    ss << "\\key HeatRecovery\n";
    ss << "\\key WaterSystems\n";
    ss << "\\key Refrigeration\n";
    ss << "\\key Generators\n";
    ss << "A7, \\field Meter Specific End Use\n";
    ss << "\\note Specific type of end use that meter is associated with.\n";
    ss << "\\note Empty field indicates all end uses are included.\n";
    ss << "A8, \\field Consumption Unit\n";
    ss << "\\note Units that fuel consumption is measured in.  Valid choices depend on Fuel Type.\n";
    ss << "\\type choice\n";
    ss << "\\required-field\n";
    ss << "\\key kBtu\n";
    ss << "\\key MBtu\n";
    ss << "\\key kWh\n";
    ss << "\\key MWh\n";
    ss << "\\key therms\n";
    ss << "\\key RTh\n";
    ss << "\\key tons\n";
    ss << "\\key lbs\n";
    ss << "\\key kLbs\n";
    ss << "\\key MLbs\n";
    ss << "\\key gal\n";
    ss << "\\key L\n";
    ss << "\\key cf\n";
    ss << "\\key m3\n";
    ss << "\\key Ccf\n";
    ss << "\\key Mcf\n";
    ss << "\\key MMcf\n";
    ss << "N1, \\field Consumption Unit Conversion Factor\n";
    ss << "\\note Number of J per unit of fuel consumption\n";
    ss << "\\note or number of m^3 per unit of water consumption.\n";
    ss << "\\type real\n";
    ss << "\\required-field\n";
    ss << "A9, \\field Peak Demand Unit\n";
    ss << "\\note Valid choices depend on Fuel Type.\n";
    ss << "\\note Currently Peak demand is only supported for Electricity.\n";
    ss << "\\type choice\n";
    ss << "\\key kW\n";
    ss << "\\key MW\n";
    ss << "\\key W\n";
    ss << "N2, \\field Timesteps in Peak Demand Window\n";
    ss << "\\type integer\n";
    ss << "\\minimum 1\n";
    ss << "\\default 1\n";
    ss << "N3, \\field Billing Period Begin Month\n";
    ss << "\\begin-extensible\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 12\n";
    ss << "N4, \\field Billing Period Begin Day of Month\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "\\maximum 31\n";
    ss << "N5, \\field Billing Period Begin Year\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "N6, \\field Number of Days in Billing Period\n";
    ss << "\\type integer\n";
    ss << "\\required-field\n";
    ss << "\\minimum 1\n";
    ss << "N7, \\field Billing Period Consumption\n";
    ss << "\\type real\n";
    ss << "N8, \\field Billing Period Peak Demand\n";
    ss << "\\type real\n";
    ss << "N9; \\field Billing Period Total Cost\n";
    ss << "\\type real\n";

    IddObjectType objType(IddObjectType::OS_UtilityBill);
    OptionalIddObject oObj = IddObject::load("OS:UtilityBill",
                                             "OpenStudio Economics",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_UtilityBill);
  return object;
}

IddObject createOS_OutputControl_ReportingTolerancesIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:OutputControl:ReportingTolerances,\n";
    ss << "\\memo Calculations of the time that setpoints are not met use a tolerance of 0.2C.\n";
    ss << "\\memo This object allows changing the tolerance used to determine when setpoints are being met.\n";
    ss << "\\unique-object\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "N1, \\field Tolerance for Time Heating Setpoint Not Met\n";
    ss << "\\note If the zone temperature is below the heating setpoint by more than\n";
    ss << "\\note this value, the following report variables will increment as appropriate\n";
    ss << "\\note Time Heating Setpoint Not Met\n";
    ss << "\\note Time Heating Setpoint Not Met While Occupied\n";
    ss << "\\note This also impacts table report \"Annual Building Utility Performance Summary\"\n";
    ss << "\\note subtable \"Comfort and Setpoint Not Met Summary\"\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default .2\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 10\n";
    ss << "N2; \\field Tolerance for Time Cooling Setpoint Not Met\n";
    ss << "\\note If the zone temperature is above the cooling setpoint by more than\n";
    ss << "\\note this value, the following report variables will increment as appropriate\n";
    ss << "\\note Time Cooling Setpoint Not Met\n";
    ss << "\\note Time Cooling Setpoint Not Met While Occupied\n";
    ss << "\\note This also impacts table report \"Annual Building Utility Performance Summary\"\n";
    ss << "\\note subtable \"Comfort and Setpoint Not Met Summary\"\n";
    ss << "\\type real\n";
    ss << "\\units deltaC\n";
    ss << "\\default .2\n";
    ss << "\\minimum 0\n";
    ss << "\\maximum 10\n";

    IddObjectType objType(IddObjectType::OS_OutputControl_ReportingTolerances);
    OptionalIddObject oObj = IddObject::load("OS:OutputControl:ReportingTolerances",
                                             "OpenStudio Output Requests",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_OutputControl_ReportingTolerances);
  return object;
}

IddObject createOS_MeterIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Meter,\n";
    ss << "\\memo each OS:Meter command picks meters to be put onto the standard output file (.eso) and\n";
    ss << "\\memo meter file (.mtr). Not all meters are reported in every simulation. A list of\n";
    ss << "\\memo a list of meters that can be reported are available after a run on\n";
    ss << "\\memo the meter dictionary file (.mdd).\n";
    ss << "\\format singleLine\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\note Form is EnergyUseType:..., e.g. Electricity:* for all Electricity meters\n";
    ss << "\\note or EndUse:..., e.g. GeneralLights:* for all General Lights\n";
    ss << "\\type external-list\n";
    ss << "\\required-field\n";
    ss << "\\external-list autoRDDmeter\n";
    ss << "A3, \\field Reporting Frequency\n";
    ss << "\\note Timestep refers to the zone Timestep/Number of Timesteps in hour value\n";
    ss << "\\note RunPeriod, Environment, and Annual are the same\n";
    ss << "\\note RunPeriod, Environment, and Annual are synonymous\n";
    ss << "\\type choice\n";
    ss << "\\default Hourly\n";
    ss << "\\key Timestep\n";
    ss << "\\key Hourly\n";
    ss << "\\key Daily\n";
    ss << "\\key Monthly\n";
    ss << "\\key RunPeriod\n";
    ss << "\\key Environment\n";
    ss << "\\key Annual\n";
    ss << "A4, \\field Meter File Only\n";
    ss << "\\type choice\n";
    ss << "\\default True\n";
    ss << "\\key True\n";
    ss << "\\key False\n";
    ss << "A5; \\field Cumulative\n";
    ss << "\\type choice\n";
    ss << "\\default False\n";
    ss << "\\key True\n";
    ss << "\\key False\n";

    IddObjectType objType(IddObjectType::OS_Meter);
    OptionalIddObject oObj = IddObject::load("OS:Meter",
                                             "OpenStudio Output Requests",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Meter);
  return object;
}

IddObject createOS_Output_VariableIddObject() {

  static IddObject object;

  if (object.type() == IddObjectType::Catchall) {
    std::stringstream ss;
    ss << "OS:Output:Variable,\n";
    ss << "\\memo each Output:Variable command picks variables to be put onto the standard output file (.eso)\n";
    ss << "\\memo some variables may not be reported for every simulation.\n";
    ss << "\\memo a list of variables that can be reported are available after a run on\n";
    ss << "\\memo the report dictionary file (.rdd).\n";
    ss << "\\format singleLine\n";
    ss << "\\min-fields 1\n";
    ss << "A1, \\field Handle\n";
    ss << "\\type handle\n";
    ss << "\\required-field\n";
    ss << "A2, \\field Name\n";
    ss << "\\type alpha\n";
    ss << "\\required-field\n";
    ss << "\\reference OutputVariableNames\n";
    ss << "A3, \\field Key Value\n";
    ss << "\\note use '*' (without quotes) to apply this variable to all keys\n";
    ss << "\\type alpha\n";
    ss << "\\default *\n";
    ss << "A4, \\field Variable Name\n";
    ss << "\\type external-list\n";
    ss << "\\required-field\n";
    ss << "\\external-list autoRDDvariable\n";
    ss << "A5, \\field Reporting Frequency\n";
    ss << "\\note Detailed lists every instance (i.e. HVAC variable timesteps)\n";
    ss << "\\note Timestep refers to the zone Timestep/Number of Timesteps in hour value\n";
    ss << "\\note RunPeriod, Environment, and Annual are the same\n";
    ss << "\\note RunPeriod, Environment, and Annual are synonymous\n";
    ss << "\\type choice\n";
    ss << "\\default Hourly\n";
    ss << "\\key Detailed\n";
    ss << "\\key Timestep\n";
    ss << "\\key Hourly\n";
    ss << "\\key Daily\n";
    ss << "\\key Monthly\n";
    ss << "\\key RunPeriod\n";
    ss << "\\key Environment\n";
    ss << "\\key Annual\n";
    ss << "A6; \\field Schedule Name\n";
    ss << "\\type object-list\n";
    ss << "\\object-list ScheduleNames\n";

    IddObjectType objType(IddObjectType::OS_Output_Variable);
    OptionalIddObject oObj = IddObject::load("OS:Output:Variable",
                                             "OpenStudio Output Requests",
                                             ss.str(),
                                             objType);
    OS_ASSERT(oObj);
    object = *oObj;
  }

  OS_ASSERT(object.type() == IddObjectType::OS_Output_Variable);
  return object;
}
void IddFactorySingleton::registerOpenStudioObjectsInCallbackMap() {
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Version,createOS_VersionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ComponentData,createOS_ComponentDataIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ConvergenceLimits,createOS_ConvergenceLimitsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ProgramControl,createOS_ProgramControlIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_HeatBalanceAlgorithm,createOS_HeatBalanceAlgorithmIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_RunPeriod,createOS_RunPeriodIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_RunPeriodControl_DaylightSavingTime,createOS_RunPeriodControl_DaylightSavingTimeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_RunPeriodControl_SpecialDays,createOS_RunPeriodControl_SpecialDaysIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ShadowCalculation,createOS_ShadowCalculationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SimulationControl,createOS_SimulationControlIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Sizing_Parameters,createOS_Sizing_ParametersIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SurfaceConvectionAlgorithm_Inside,createOS_SurfaceConvectionAlgorithm_InsideIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SurfaceConvectionAlgorithm_Outside,createOS_SurfaceConvectionAlgorithm_OutsideIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Timestep,createOS_TimestepIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_YearDescription,createOS_YearDescriptionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneAirContaminantBalance,createOS_ZoneAirContaminantBalanceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneAirHeatBalanceAlgorithm,createOS_ZoneAirHeatBalanceAlgorithmIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneAirMassFlowConservation,createOS_ZoneAirMassFlowConservationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneCapacitanceMultiplier_ResearchSpecial,createOS_ZoneCapacitanceMultiplier_ResearchSpecialIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_RadianceParameters,createOS_RadianceParametersIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ClimateZones,createOS_ClimateZonesIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Site,createOS_SiteIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Site_GroundTemperature_BuildingSurface,createOS_Site_GroundTemperature_BuildingSurfaceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Site_GroundTemperature_FCfactorMethod,createOS_Site_GroundTemperature_FCfactorMethodIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Site_GroundTemperature_Shallow,createOS_Site_GroundTemperature_ShallowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Site_GroundTemperature_Deep,createOS_Site_GroundTemperature_DeepIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Site_GroundReflectance,createOS_Site_GroundReflectanceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Site_WaterMainsTemperature,createOS_Site_WaterMainsTemperatureIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SizingPeriod_DesignDay,createOS_SizingPeriod_DesignDayIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SizingPeriod_WeatherFileConditionType,createOS_SizingPeriod_WeatherFileConditionTypeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SizingPeriod_WeatherFileDays,createOS_SizingPeriod_WeatherFileDaysIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_UtilityCost_Charge_Block,createOS_UtilityCost_Charge_BlockIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_UtilityCost_Charge_Simple,createOS_UtilityCost_Charge_SimpleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_UtilityCost_Computation,createOS_UtilityCost_ComputationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_UtilityCost_Qualify,createOS_UtilityCost_QualifyIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_UtilityCost_Ratchet,createOS_UtilityCost_RatchetIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_UtilityCost_Tariff,createOS_UtilityCost_TariffIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_UtilityCost_Variable,createOS_UtilityCost_VariableIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_WeatherFile,createOS_WeatherFileIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_WeatherProperty_SkyTemperature,createOS_WeatherProperty_SkyTemperatureIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_BuildingStory,createOS_BuildingStoryIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_DefaultConstructionSet,createOS_DefaultConstructionSetIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_DefaultScheduleSet,createOS_DefaultScheduleSetIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_DefaultSubSurfaceConstructions,createOS_DefaultSubSurfaceConstructionsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_DefaultSurfaceConstructions,createOS_DefaultSurfaceConstructionsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Rendering_Color,createOS_Rendering_ColorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SpaceType,createOS_SpaceTypeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ModelObjectList,createOS_ModelObjectListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Material,createOS_MaterialIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Material_AirGap,createOS_Material_AirGapIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Material_AirWall,createOS_Material_AirWallIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Material_InfraredTransparent,createOS_Material_InfraredTransparentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Material_NoMass,createOS_Material_NoMassIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Material_RoofVegetation,createOS_Material_RoofVegetationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_WindowMaterial_Blind,createOS_WindowMaterial_BlindIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_WindowMaterial_DaylightRedirectionDevice,createOS_WindowMaterial_DaylightRedirectionDeviceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_WindowMaterial_Gas,createOS_WindowMaterial_GasIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_WindowMaterial_GasMixture,createOS_WindowMaterial_GasMixtureIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_WindowMaterial_Glazing,createOS_WindowMaterial_GlazingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_WindowMaterial_GlazingGroup_Thermochromic,createOS_WindowMaterial_GlazingGroup_ThermochromicIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_WindowMaterial_Glazing_RefractionExtinctionMethod,createOS_WindowMaterial_Glazing_RefractionExtinctionMethodIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_WindowMaterial_Screen,createOS_WindowMaterial_ScreenIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_WindowMaterial_Shade,createOS_WindowMaterial_ShadeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_WindowMaterial_SimpleGlazingSystem,createOS_WindowMaterial_SimpleGlazingSystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_StandardsInformation_Material,createOS_StandardsInformation_MaterialIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Construction,createOS_ConstructionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Construction_CfactorUndergroundWall,createOS_Construction_CfactorUndergroundWallIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Construction_FfactorGroundFloor,createOS_Construction_FfactorGroundFloorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Construction_InternalSource,createOS_Construction_InternalSourceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Construction_WindowDataFile,createOS_Construction_WindowDataFileIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_StandardsInformation_Construction,createOS_StandardsInformation_ConstructionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_InternalMass_Definition,createOS_InternalMass_DefinitionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_People_Definition,createOS_People_DefinitionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Lights_Definition,createOS_Lights_DefinitionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Luminaire_Definition,createOS_Luminaire_DefinitionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ElectricEquipment_Definition,createOS_ElectricEquipment_DefinitionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_GasEquipment_Definition,createOS_GasEquipment_DefinitionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_HotWaterEquipment_Definition,createOS_HotWaterEquipment_DefinitionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SteamEquipment_Definition,createOS_SteamEquipment_DefinitionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_OtherEquipment_Definition,createOS_OtherEquipment_DefinitionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Exterior_Lights_Definition,createOS_Exterior_Lights_DefinitionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Schedule_Compact,createOS_Schedule_CompactIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Schedule_Day,createOS_Schedule_DayIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Schedule_Week,createOS_Schedule_WeekIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Schedule_Year,createOS_Schedule_YearIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Schedule_Rule,createOS_Schedule_RuleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Schedule_Ruleset,createOS_Schedule_RulesetIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Schedule_Constant,createOS_Schedule_ConstantIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Schedule_FixedInterval,createOS_Schedule_FixedIntervalIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Schedule_VariableInterval,createOS_Schedule_VariableIntervalIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ScheduleTypeLimits,createOS_ScheduleTypeLimitsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Building,createOS_BuildingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_DaylightingDevice_Shelf,createOS_DaylightingDevice_ShelfIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Facility,createOS_FacilityIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_InteriorPartitionSurface,createOS_InteriorPartitionSurfaceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_InteriorPartitionSurfaceGroup,createOS_InteriorPartitionSurfaceGroupIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ShadingSurface,createOS_ShadingSurfaceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ShadingSurfaceGroup,createOS_ShadingSurfaceGroupIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Space,createOS_SpaceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Surface,createOS_SurfaceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SubSurface,createOS_SubSurfaceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ShadingControl,createOS_ShadingControlIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_WindowProperty_FrameAndDivider,createOS_WindowProperty_FrameAndDividerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SurfaceProperty_ConvectionCoefficients,createOS_SurfaceProperty_ConvectionCoefficientsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SurfaceProperty_ConvectionCoefficients_MultipleSurface,createOS_SurfaceProperty_ConvectionCoefficients_MultipleSurfaceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SurfaceProperty_OtherSideCoefficients,createOS_SurfaceProperty_OtherSideCoefficientsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SurfaceProperty_OtherSideConditionsModel,createOS_SurfaceProperty_OtherSideConditionsModelIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_InternalMass,createOS_InternalMassIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_People,createOS_PeopleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Lights,createOS_LightsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Luminaire,createOS_LuminaireIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ElectricEquipment,createOS_ElectricEquipmentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_GasEquipment,createOS_GasEquipmentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_HotWaterEquipment,createOS_HotWaterEquipmentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SteamEquipment,createOS_SteamEquipmentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_OtherEquipment,createOS_OtherEquipmentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SpaceInfiltration_DesignFlowRate,createOS_SpaceInfiltration_DesignFlowRateIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SpaceInfiltration_EffectiveLeakageArea,createOS_SpaceInfiltration_EffectiveLeakageAreaIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Exterior_Lights,createOS_Exterior_LightsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Daylighting_Control,createOS_Daylighting_ControlIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Glare_Sensor,createOS_Glare_SensorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_IlluminanceMap,createOS_IlluminanceMapIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_LightingDesignDay,createOS_LightingDesignDayIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_LightingSimulationControl,createOS_LightingSimulationControlIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_LightingSimulationZone,createOS_LightingSimulationZoneIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Refrigeration_Case,createOS_Refrigeration_CaseIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Refrigeration_Condenser_AirCooled,createOS_Refrigeration_Condenser_AirCooledIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Refrigeration_Condenser_EvaporativeCooled,createOS_Refrigeration_Condenser_EvaporativeCooledIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Refrigeration_Condenser_WaterCooled,createOS_Refrigeration_Condenser_WaterCooledIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Refrigeration_Condenser_Cascade,createOS_Refrigeration_Condenser_CascadeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Refrigeration_Compressor,createOS_Refrigeration_CompressorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Refrigeration_DefrostCycleParameters,createOS_Refrigeration_DefrostCycleParametersIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Refrigeration_GasCooler_AirCooled,createOS_Refrigeration_GasCooler_AirCooledIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Refrigeration_Subcooler_Mechanical,createOS_Refrigeration_Subcooler_MechanicalIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Refrigeration_Subcooler_LiquidSuction,createOS_Refrigeration_Subcooler_LiquidSuctionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Refrigeration_System,createOS_Refrigeration_SystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Refrigeration_TranscriticalSystem,createOS_Refrigeration_TranscriticalSystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Refrigeration_SecondarySystem,createOS_Refrigeration_SecondarySystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Refrigeration_WalkIn,createOS_Refrigeration_WalkInIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Refrigeration_WalkIn_ZoneBoundary,createOS_Refrigeration_WalkIn_ZoneBoundaryIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Refrigeration_AirChiller,createOS_Refrigeration_AirChillerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirConditioner_VariableRefrigerantFlow,createOS_AirConditioner_VariableRefrigerantFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirLoopHVAC,createOS_AirLoopHVACIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirLoopHVAC_ControllerList,createOS_AirLoopHVAC_ControllerListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirLoopHVAC_OutdoorAirSystem,createOS_AirLoopHVAC_OutdoorAirSystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirLoopHVAC_ReturnPlenum,createOS_AirLoopHVAC_ReturnPlenumIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirLoopHVAC_SupplyPlenum,createOS_AirLoopHVAC_SupplyPlenumIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirLoopHVAC_UnitaryHeatPump_AirToAir_MultiSpeed,createOS_AirLoopHVAC_UnitaryHeatPump_AirToAir_MultiSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirLoopHVAC_UnitaryCoolOnly,createOS_AirLoopHVAC_UnitaryCoolOnlyIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirLoopHVAC_UnitaryHeatPump_AirToAir,createOS_AirLoopHVAC_UnitaryHeatPump_AirToAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirLoopHVAC_UnitaryHeatCool_VAVChangeoverBypass,createOS_AirLoopHVAC_UnitaryHeatCool_VAVChangeoverBypassIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirLoopHVAC_UnitarySystem,createOS_AirLoopHVAC_UnitarySystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirLoopHVAC_ZoneMixer,createOS_AirLoopHVAC_ZoneMixerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirLoopHVAC_ZoneSplitter,createOS_AirLoopHVAC_ZoneSplitterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirTerminal_SingleDuct_VAV_HeatAndCool_NoReheat,createOS_AirTerminal_SingleDuct_VAV_HeatAndCool_NoReheatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirTerminal_SingleDuct_VAV_HeatAndCool_Reheat,createOS_AirTerminal_SingleDuct_VAV_HeatAndCool_ReheatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirTerminal_SingleDuct_InletSideMixer,createOS_AirTerminal_SingleDuct_InletSideMixerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirTerminal_SingleDuct_ConstantVolume_Reheat,createOS_AirTerminal_SingleDuct_ConstantVolume_ReheatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirTerminal_SingleDuct_SeriesPIU_Reheat,createOS_AirTerminal_SingleDuct_SeriesPIU_ReheatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirTerminal_SingleDuct_ParallelPIU_Reheat,createOS_AirTerminal_SingleDuct_ParallelPIU_ReheatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirTerminal_SingleDuct_ConstantVolume_FourPipeInduction,createOS_AirTerminal_SingleDuct_ConstantVolume_FourPipeInductionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirTerminal_SingleDuct_ConstantVolume_CooledBeam,createOS_AirTerminal_SingleDuct_ConstantVolume_CooledBeamIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirTerminal_SingleDuct_Uncontrolled,createOS_AirTerminal_SingleDuct_UncontrolledIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirTerminal_SingleDuct_VAV_NoReheat,createOS_AirTerminal_SingleDuct_VAV_NoReheatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirTerminal_SingleDuct_VAV_Reheat,createOS_AirTerminal_SingleDuct_VAV_ReheatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirTerminal_DualDuct_VAV_OutdoorAir,createOS_AirTerminal_DualDuct_VAV_OutdoorAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirTerminal_DualDuct_ConstantVolume,createOS_AirTerminal_DualDuct_ConstantVolumeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AirTerminal_DualDuct_VAV,createOS_AirTerminal_DualDuct_VAVIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AvailabilityManagerAssignmentList,createOS_AvailabilityManagerAssignmentListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AvailabilityManager_Scheduled,createOS_AvailabilityManager_ScheduledIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AvailabilityManager_NightCycle,createOS_AvailabilityManager_NightCycleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AvailabilityManager_OptimumStart,createOS_AvailabilityManager_OptimumStartIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AvailabilityManager_DifferentialThermostat,createOS_AvailabilityManager_DifferentialThermostatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AvailabilityManager_NightVentilation,createOS_AvailabilityManager_NightVentilationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_AvailabilityManager_HybridVentilation,createOS_AvailabilityManager_HybridVentilationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Boiler_HotWater,createOS_Boiler_HotWaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Boiler_Steam,createOS_Boiler_SteamIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_HeatPump_WaterToWater_EquationFit_Heating,createOS_HeatPump_WaterToWater_EquationFit_HeatingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_HeatPump_WaterToWater_EquationFit_Cooling,createOS_HeatPump_WaterToWater_EquationFit_CoolingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Chiller_Electric_EIR,createOS_Chiller_Electric_EIRIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_CentralHeatPumpSystem,createOS_CentralHeatPumpSystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_CentralHeatPumpSystem_Module,createOS_CentralHeatPumpSystem_ModuleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ChillerHeaterPerformance_Electric_EIR,createOS_ChillerHeaterPerformance_Electric_EIRIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Chiller_Absorption_Indirect,createOS_Chiller_Absorption_IndirectIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Chiller_Absorption,createOS_Chiller_AbsorptionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_CoolingTower_SingleSpeed,createOS_CoolingTower_SingleSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_CoolingTower_TwoSpeed,createOS_CoolingTower_TwoSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_CoolingTower_VariableSpeed,createOS_CoolingTower_VariableSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_CoolingTowerPerformance_CoolTools,createOS_CoolingTowerPerformance_CoolToolsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_CoolingTowerPerformance_YorkCalc,createOS_CoolingTowerPerformance_YorkCalcIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_DistrictCooling,createOS_DistrictCoolingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_DistrictHeating,createOS_DistrictHeatingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_GroundHeatExchanger_Vertical,createOS_GroundHeatExchanger_VerticalIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_GroundHeatExchanger_HorizontalTrench,createOS_GroundHeatExchanger_HorizontalTrenchIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Cooling_CooledBeam,createOS_Coil_Cooling_CooledBeamIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Cooling_DX_SingleSpeed,createOS_Coil_Cooling_DX_SingleSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Cooling_DX_TwoStageWithHumidityControlMode,createOS_Coil_Cooling_DX_TwoStageWithHumidityControlModeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_CoilPerformance_DX_Cooling,createOS_CoilPerformance_DX_CoolingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Cooling_DX_MultiSpeed,createOS_Coil_Cooling_DX_MultiSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Cooling_DX_MultiSpeed_StageData,createOS_Coil_Cooling_DX_MultiSpeed_StageDataIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Cooling_DX_TwoSpeed,createOS_Coil_Cooling_DX_TwoSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_CoilSystem_Cooling_Water_HeatExchangerAssisted,createOS_CoilSystem_Cooling_Water_HeatExchangerAssistedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_CoilSystem_Cooling_DX_HeatExchangerAssisted,createOS_CoilSystem_Cooling_DX_HeatExchangerAssistedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Cooling_DX_VariableRefrigerantFlow,createOS_Coil_Cooling_DX_VariableRefrigerantFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Cooling_LowTemperatureRadiant_ConstantFlow,createOS_Coil_Cooling_LowTemperatureRadiant_ConstantFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Cooling_LowTemperatureRadiant_VariableFlow,createOS_Coil_Cooling_LowTemperatureRadiant_VariableFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Cooling_Water,createOS_Coil_Cooling_WaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Cooling_WaterToAirHeatPump_EquationFit,createOS_Coil_Cooling_WaterToAirHeatPump_EquationFitIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Heating_DX_SingleSpeed,createOS_Coil_Heating_DX_SingleSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Heating_DX_VariableRefrigerantFlow,createOS_Coil_Heating_DX_VariableRefrigerantFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Heating_Electric,createOS_Coil_Heating_ElectricIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Heating_Gas,createOS_Coil_Heating_GasIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Heating_Gas_MultiStage,createOS_Coil_Heating_Gas_MultiStageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Heating_Gas_MultiStage_StageData,createOS_Coil_Heating_Gas_MultiStage_StageDataIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Heating_Desuperheater,createOS_Coil_Heating_DesuperheaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_WaterHeating_Desuperheater,createOS_Coil_WaterHeating_DesuperheaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Heating_LowTemperatureRadiant_ConstantFlow,createOS_Coil_Heating_LowTemperatureRadiant_ConstantFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Heating_LowTemperatureRadiant_VariableFlow,createOS_Coil_Heating_LowTemperatureRadiant_VariableFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Heating_Water,createOS_Coil_Heating_WaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Heating_Water_Baseboard,createOS_Coil_Heating_Water_BaseboardIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Heating_Water_Baseboard_Radiant,createOS_Coil_Heating_Water_Baseboard_RadiantIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Heating_WaterToAirHeatPump_EquationFit,createOS_Coil_Heating_WaterToAirHeatPump_EquationFitIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Heating_DX_MultiSpeed,createOS_Coil_Heating_DX_MultiSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Heating_DX_MultiSpeed_StageData,createOS_Coil_Heating_DX_MultiSpeed_StageDataIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Heating_DX_VariableSpeed,createOS_Coil_Heating_DX_VariableSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Heating_DX_VariableSpeed_SpeedData,createOS_Coil_Heating_DX_VariableSpeed_SpeedDataIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Cooling_DX_VariableSpeed,createOS_Coil_Cooling_DX_VariableSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Cooling_DX_VariableSpeed_SpeedData,createOS_Coil_Cooling_DX_VariableSpeed_SpeedDataIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Heating_WaterToAirHeatPump_VariableSpeedEquationFit,createOS_Coil_Heating_WaterToAirHeatPump_VariableSpeedEquationFitIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Heating_WaterToAirHeatPump_VariableSpeedEquationFit_SpeedData,createOS_Coil_Heating_WaterToAirHeatPump_VariableSpeedEquationFit_SpeedDataIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Cooling_WaterToAirHeatPump_VariableSpeedEquationFit,createOS_Coil_Cooling_WaterToAirHeatPump_VariableSpeedEquationFitIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_Cooling_WaterToAirHeatPump_VariableSpeedEquationFit_SpeedData,createOS_Coil_Cooling_WaterToAirHeatPump_VariableSpeedEquationFit_SpeedDataIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Connection,createOS_ConnectionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Connector_Mixer,createOS_Connector_MixerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Connector_Splitter,createOS_Connector_SplitterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Controller_MechanicalVentilation,createOS_Controller_MechanicalVentilationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneControl_ContaminantController,createOS_ZoneControl_ContaminantControllerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Controller_OutdoorAir,createOS_Controller_OutdoorAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Controller_WaterCoil,createOS_Controller_WaterCoilIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Curve_Linear,createOS_Curve_LinearIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Curve_Quadratic,createOS_Curve_QuadraticIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Curve_Cubic,createOS_Curve_CubicIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Curve_Quartic,createOS_Curve_QuarticIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Curve_Exponent,createOS_Curve_ExponentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Curve_Bicubic,createOS_Curve_BicubicIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Curve_Biquadratic,createOS_Curve_BiquadraticIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Curve_QuadraticLinear,createOS_Curve_QuadraticLinearIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Curve_Triquadratic,createOS_Curve_TriquadraticIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Curve_Functional_PressureDrop,createOS_Curve_Functional_PressureDropIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Curve_FanPressureRise,createOS_Curve_FanPressureRiseIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Curve_ExponentialSkewNormal,createOS_Curve_ExponentialSkewNormalIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Curve_Sigmoid,createOS_Curve_SigmoidIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Curve_RectangularHyperbola1,createOS_Curve_RectangularHyperbola1IddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Curve_RectangularHyperbola2,createOS_Curve_RectangularHyperbola2IddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Curve_ExponentialDecay,createOS_Curve_ExponentialDecayIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Curve_DoubleExponentialDecay,createOS_Curve_DoubleExponentialDecayIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Table_MultiVariableLookup,createOS_Table_MultiVariableLookupIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_DesignSpecification_OutdoorAir,createOS_DesignSpecification_OutdoorAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_DesignSpecification_ZoneAirDistribution,createOS_DesignSpecification_ZoneAirDistributionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Humidifier_Steam_Electric,createOS_Humidifier_Steam_ElectricIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_EvaporativeCooler_Indirect_ResearchSpecial,createOS_EvaporativeCooler_Indirect_ResearchSpecialIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_EvaporativeCooler_Direct_ResearchSpecial,createOS_EvaporativeCooler_Direct_ResearchSpecialIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_EvaporativeFluidCooler_SingleSpeed,createOS_EvaporativeFluidCooler_SingleSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_EvaporativeFluidCooler_TwoSpeed,createOS_EvaporativeFluidCooler_TwoSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Fan_ConstantVolume,createOS_Fan_ConstantVolumeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Fan_VariableVolume,createOS_Fan_VariableVolumeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Fan_OnOff,createOS_Fan_OnOffIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Fan_ZoneExhaust,createOS_Fan_ZoneExhaustIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_HeatExchanger_AirToAir_SensibleAndLatent,createOS_HeatExchanger_AirToAir_SensibleAndLatentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_HeatExchanger_FluidToFluid,createOS_HeatExchanger_FluidToFluidIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_HVACComponentList,createOS_HVACComponentListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Node,createOS_NodeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_PortList,createOS_PortListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Pipe_Adiabatic,createOS_Pipe_AdiabaticIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_PlantLoop,createOS_PlantLoopIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_PlantEquipmentOperation_CoolingLoad,createOS_PlantEquipmentOperation_CoolingLoadIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_PlantEquipmentOperation_HeatingLoad,createOS_PlantEquipmentOperation_HeatingLoadIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_PlantEquipmentOperation_OutdoorDryBulb,createOS_PlantEquipmentOperation_OutdoorDryBulbIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_PlantEquipmentOperation_OutdoorWetBulb,createOS_PlantEquipmentOperation_OutdoorWetBulbIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_PlantEquipmentOperation_OutdoorRelativeHumidity,createOS_PlantEquipmentOperation_OutdoorRelativeHumidityIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_PlantEquipmentOperation_OutdoorDewpoint,createOS_PlantEquipmentOperation_OutdoorDewpointIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_PlantEquipmentOperation_OutdoorDryBulbDifference,createOS_PlantEquipmentOperation_OutdoorDryBulbDifferenceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_PlantEquipmentOperation_OutdoorDewpointDifference,createOS_PlantEquipmentOperation_OutdoorDewpointDifferenceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_PlantEquipmentOperation_OutdoorWetBulbDifference,createOS_PlantEquipmentOperation_OutdoorWetBulbDifferenceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_PlantComponent_TemperatureSource,createOS_PlantComponent_TemperatureSourceIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_LoadProfile_Plant,createOS_LoadProfile_PlantIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Pump_ConstantSpeed,createOS_Pump_ConstantSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Pump_VariableSpeed,createOS_Pump_VariableSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_HeaderedPumps_ConstantSpeed,createOS_HeaderedPumps_ConstantSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_HeaderedPumps_VariableSpeed,createOS_HeaderedPumps_VariableSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_TemperingValve,createOS_TemperingValveIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_FollowOutdoorAirTemperature,createOS_SetpointManager_FollowOutdoorAirTemperatureIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_MixedAir,createOS_SetpointManager_MixedAirIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_OutdoorAirReset,createOS_SetpointManager_OutdoorAirResetIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_OutdoorAirPretreat,createOS_SetpointManager_OutdoorAirPretreatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_SingleZone_Reheat,createOS_SetpointManager_SingleZone_ReheatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_SingleZone_Humidity_Minimum,createOS_SetpointManager_SingleZone_Humidity_MinimumIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_MultiZone_MinimumHumidity_Average,createOS_SetpointManager_MultiZone_MinimumHumidity_AverageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_MultiZone_Humidity_Minimum,createOS_SetpointManager_MultiZone_Humidity_MinimumIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_Scheduled,createOS_SetpointManager_ScheduledIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_Scheduled_DualSetpoint,createOS_SetpointManager_Scheduled_DualSetpointIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_Warmest,createOS_SetpointManager_WarmestIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_WarmestTemperatureFlow,createOS_SetpointManager_WarmestTemperatureFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_Coldest,createOS_SetpointManager_ColdestIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_FollowGroundTemperature,createOS_SetpointManager_FollowGroundTemperatureIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_FollowSystemNodeTemperature,createOS_SetpointManager_FollowSystemNodeTemperatureIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_MultiZone_Cooling_Average,createOS_SetpointManager_MultiZone_Cooling_AverageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_MultiZone_Heating_Average,createOS_SetpointManager_MultiZone_Heating_AverageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_MultiZone_Humidity_Maximum,createOS_SetpointManager_MultiZone_Humidity_MaximumIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_MultiZone_MaximumHumidity_Average,createOS_SetpointManager_MultiZone_MaximumHumidity_AverageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_SingleZone_OneStageCooling,createOS_SetpointManager_SingleZone_OneStageCoolingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_SingleZone_OneStageHeating,createOS_SetpointManager_SingleZone_OneStageHeatingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SetpointManager_SingleZone_Humidity_Maximum,createOS_SetpointManager_SingleZone_Humidity_MaximumIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Sizing_Plant,createOS_Sizing_PlantIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Sizing_System,createOS_Sizing_SystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Sizing_Zone,createOS_Sizing_ZoneIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Splitter,createOS_SplitterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ThermalZone,createOS_ThermalZoneIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneControl_Humidistat,createOS_ZoneControl_HumidistatIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ThermostatSetpoint_DualSetpoint,createOS_ThermostatSetpoint_DualSetpointIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneControl_Thermostat_StagedDualSetpoint,createOS_ZoneControl_Thermostat_StagedDualSetpointIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_EquipmentList,createOS_ZoneHVAC_EquipmentListIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneVentilation_DesignFlowRate,createOS_ZoneVentilation_DesignFlowRateIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_Baseboard_Convective_Electric,createOS_ZoneHVAC_Baseboard_Convective_ElectricIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_Baseboard_Convective_Water,createOS_ZoneHVAC_Baseboard_Convective_WaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_HighTemperatureRadiant,createOS_ZoneHVAC_HighTemperatureRadiantIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_LowTemperatureRadiant_Electric,createOS_ZoneHVAC_LowTemperatureRadiant_ElectricIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_IdealLoadsAirSystem,createOS_ZoneHVAC_IdealLoadsAirSystemIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_FourPipeFanCoil,createOS_ZoneHVAC_FourPipeFanCoilIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_LowTemperatureRadiant_ConstantFlow,createOS_ZoneHVAC_LowTemperatureRadiant_ConstantFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_LowTemperatureRadiant_VariableFlow,createOS_ZoneHVAC_LowTemperatureRadiant_VariableFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_PackagedTerminalHeatPump,createOS_ZoneHVAC_PackagedTerminalHeatPumpIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_PackagedTerminalAirConditioner,createOS_ZoneHVAC_PackagedTerminalAirConditionerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_TerminalUnit_VariableRefrigerantFlow,createOS_ZoneHVAC_TerminalUnit_VariableRefrigerantFlowIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_WaterToAirHeatPump,createOS_ZoneHVAC_WaterToAirHeatPumpIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_UnitHeater,createOS_ZoneHVAC_UnitHeaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_Dehumidifier_DX,createOS_ZoneHVAC_Dehumidifier_DXIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_EnergyRecoveryVentilator,createOS_ZoneHVAC_EnergyRecoveryVentilatorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_EnergyRecoveryVentilator_Controller,createOS_ZoneHVAC_EnergyRecoveryVentilator_ControllerIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_UnitVentilator,createOS_ZoneHVAC_UnitVentilatorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_Baseboard_RadiantConvective_Water,createOS_ZoneHVAC_Baseboard_RadiantConvective_WaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneHVAC_Baseboard_RadiantConvective_Electric,createOS_ZoneHVAC_Baseboard_RadiantConvective_ElectricIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ZoneMixing,createOS_ZoneMixingIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_WaterHeater_Mixed,createOS_WaterHeater_MixedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_WaterHeater_HeatPump,createOS_WaterHeater_HeatPumpIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Coil_WaterHeating_AirToWaterHeatPump,createOS_Coil_WaterHeating_AirToWaterHeatPumpIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_WaterHeater_Stratified,createOS_WaterHeater_StratifiedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_WaterUse_Equipment,createOS_WaterUse_EquipmentIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_WaterUse_Equipment_Definition,createOS_WaterUse_Equipment_DefinitionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_WaterUse_Connections,createOS_WaterUse_ConnectionsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ThermalStorage_Ice_Detailed,createOS_ThermalStorage_Ice_DetailedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ThermalStorage_ChilledWater_Stratified,createOS_ThermalStorage_ChilledWater_StratifiedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Duct,createOS_DuctIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_FluidCooler_SingleSpeed,createOS_FluidCooler_SingleSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_FluidCooler_TwoSpeed,createOS_FluidCooler_TwoSpeedIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Pipe_Indoor,createOS_Pipe_IndoorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Pipe_Outdoor,createOS_Pipe_OutdoorIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SolarCollectorPerformance_FlatPlate,createOS_SolarCollectorPerformance_FlatPlateIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SolarCollector_FlatPlate_Water,createOS_SolarCollector_FlatPlate_WaterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SolarCollectorPerformance_IntegralCollectorStorage,createOS_SolarCollectorPerformance_IntegralCollectorStorageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SolarCollector_IntegralCollectorStorage,createOS_SolarCollector_IntegralCollectorStorageIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SolarCollectorPerformance_PhotovoltaicThermal_Simple,createOS_SolarCollectorPerformance_PhotovoltaicThermal_SimpleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_SolarCollector_FlatPlate_PhotovoltaicThermal,createOS_SolarCollector_FlatPlate_PhotovoltaicThermalIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Generator_Photovoltaic,createOS_Generator_PhotovoltaicIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_PhotovoltaicPerformance_Simple,createOS_PhotovoltaicPerformance_SimpleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_PhotovoltaicPerformance_EquivalentOneDiode,createOS_PhotovoltaicPerformance_EquivalentOneDiodeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ElectricLoadCenter_Inverter_Simple,createOS_ElectricLoadCenter_Inverter_SimpleIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ElectricLoadCenter_Inverter_LookUpTable,createOS_ElectricLoadCenter_Inverter_LookUpTableIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ElectricLoadCenter_Distribution,createOS_ElectricLoadCenter_DistributionIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_ComponentCost_Adjustments,createOS_ComponentCost_AdjustmentsIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_LifeCycleCost,createOS_LifeCycleCostIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_CurrencyType,createOS_CurrencyTypeIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_LifeCycleCost_Parameters,createOS_LifeCycleCost_ParametersIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_LifeCycleCost_UsePriceEscalation,createOS_LifeCycleCost_UsePriceEscalationIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_UtilityBill,createOS_UtilityBillIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_OutputControl_ReportingTolerances,createOS_OutputControl_ReportingTolerancesIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Meter,createOS_MeterIddObject));
  m_callbackMap.insert(IddObjectCallbackMap::value_type(IddObjectType::OS_Output_Variable,createOS_Output_VariableIddObject));
}


} // openstudio
